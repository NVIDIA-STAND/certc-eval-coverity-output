[
  {
    "rule_id": "API00-C",
    "title": "Functions should validate their parameters",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/API00-C.+Functions+should+validate+their+parameters",
    "description": "Redundant testing by caller and by callee as a style of defensive programming is largely discredited in the C and C++ communities, the main problem being performance. The usual discipline in C and C++ is to require validation on only one side of each interface.\n\nRequiring the caller to validate arguments can result in faster code because the caller may understand certain invariants that prevent invalid values from being passed. Requiring the callee to validate arguments allows the validation code to be encapsulated in one location, reducing the size of the code and making it more likely that these checks are performed in a consistent and correct fashion.\n\nFor safety and security reasons, this standard recommends that the called function validate its parameters. Validity checks allow the function to survive at least some forms of improper usage, enabling an application using the function to likewise survive. Validity checks can also simplify the task of determining the condition that caused the invalid parameter.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, setfile() and usefile() do not validate their parameters. It is possible that an invalid file pointer can be used by the library, corrupting the library's internal state and exposing a vulnerability .",
          "code": "/* Sets some internal state in the library */\nextern int setfile(FILE *file);\n\n/* Performs some action using the file passed earlier */\nextern int usefile();\n\nstatic FILE *myFile;\n\nvoid setfile(FILE *file) {\n    myFile = file;\n}\n\nvoid usefile(void) {\n    /* Perform some action here */\n}\n",
          "explanation_after": "The vulnerability can be more severe if the internal state references sensitive or system-critical data."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Validating the function parameters and verifying the internal state leads to consistency of program execution and may eliminate potential vulnerabilities. In addition, implementing commit or rollback semantics (leaving program state unchanged on error) is a desirable practice for error safety.",
          "code": "/* Sets some internal state in the library */\nextern errno_t setfile(FILE *file);\n\n/* Performs some action using the file passed earlier */\nextern errno_t usefile(void);\n\nstatic FILE *myFile;\n\nerrno_t setfile(FILE *file) {\n if (file && !ferror(file) && !feof(file)) {\n    myFile = file;\n    return 0;\n  }\n\n  /* Error safety: leave myFile unchanged */\n  return -1;\n}\n\nerrno_t usefile(void) {\n  if (!myFile) return -1;\n\n    /*\n     * Perform other checks if needed; return \n     * error condition.\n     */\n\n    /* Perform some action here */\n    return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to validate the parameters in library functions may result in an access violation or a data integrity violation. Such a scenario indicates a flaw in how the library is used by the calling code. However, the library itself may still be the vector by which the calling code's vulnerability is exploited.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "API01-C",
    "title": "Avoid laying out strings in memory directly before sensitive data",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/API01-C.+Avoid+laying+out+strings+in+memory+directly+before+sensitive+data",
    "description": "Strings (both character and wide-character) are often subject to buffer overflows, which will overwrite the memory immediately past the string. Many rules warn against buffer overflows, including STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator . Sometimes the danger of buffer overflows can be minimized by ensuring that arranging memory such that data that might be corrupted by a buffer overflow is not sensitive.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example stores a set of strings using a linked list:",
          "code": "const size_t String_Size = 20;\nstruct node_s {\n  char name[String_Size];\n  struct node_s* next;\n}\n",
          "explanation_after": "A buffer overflow on name would overwrite the next pointer, which could then be used to read or write to arbitrary memory."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution creates a linked list of strings but stores the next pointer before the string:",
          "code": "const size_t String_Size = 20;\nstruct node_s {\n  struct node_s* next;\n  char name[String_Size];\n}\n",
          "explanation_after": "If buffer overflow occurs on name , the next pointer remains uncorrupted."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example stores a set of strings using a linked list:",
          "code": "const size_t String_Size = 20;\nstruct node_s {\n  char name[String_Size];\n  struct node_s* next;\n}\n",
          "explanation_after": "A buffer overflow on name would overwrite the next pointer, which could then be used to read or write to arbitrary memory."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the linked list stores pointers to strings that are stored elsewhere. Storing the strings elsewhere protects the next pointer from buffer overflows on the strings.",
          "code": "const size_t String_Size = 20;\nstruct node_s {\n  struct node_s* next;\n  char* name;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to follow this recommendation can result in memory corruption from buffer overflows, which can easily corrupt data or yield remote code execution.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "API02-C",
    "title": "Functions that read or write to or from an array should take an argument to specify the source or target size",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/API02-C.+Functions+that+read+or+write+to+or+from+an+array+should+take+an+argument+to+specify+the+source+or+target+size",
    "description": "Functions that have an array as a parameter should also have an additional parameter that indicates the maximum number of elements that can be stored in the array. That parameter is required to ensure that the function does not access memory outside the bounds of the array and adversely influence program execution. It should be present for each array parameter (in other words, the existence of each array parameter implies the existence of a complementary parameter that represents the maximum number of elements in the array).\n\nNote that array is used in this recommendation to mean array, string, or any other pointer to a contiguous block of memory in which one or more elements of a particular type are (potentially) stored. These terms are all effectively synonymous and represent the same potential for error.\n\nAlso note that this recommendation suggests the parameter accompanying array parameters indicates the maximum number of elements that can be stored in the array, not the maximum size, in bytes, of the array, because\n\nIt does not make sense to think of array sizes in bytes in all cases—for example, in the case of an array of integers. If the size in bytes of the array is required, it can be derived from the number of elements in the array. It is better not to add to the cognitive load of the function user by requiring the user to calculate the size in bytes of the array.\n\nIn most cases, the distinction between the number of elements and number of bytes is moot: there is a clear mapping between the two, and it is easier to think in terms of number of elements anyway. Unfortunately, this issue can become muddled when working with multibyte strings because the logical entity being manipulated differs from that of the type being used to implement it. Here, it is important to remember that the type of the array is a character, not a multibyte character. Accordingly, the number of elements in the array is represented as a number of characters.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "It is not necessary to go beyond the standard C library to find examples that violate this recommendation because the C language often prioritizes performance at the expense of robustness . The following are two examples from the C Standard, subclause 7.24 [ ISO/IEC 9899:2011 ]:",
          "code": "char *strncpy(char * restrict s1, const char * restrict s2, size_t n);\nchar *strncat(char * restrict s1, const char * restrict s2, size_t n);\n",
          "explanation_after": "These functions have two problems. First, there is no indication of the size of the first array, s1 . As a result, it is not possible to discern within the function how large s1 is and how many elements may be written into it. Second, it appears that a size is supplied for s2 , but the size_t parameter n actually gives the number of elements to copy. Consequently, there is no way for either function to determine the size of the array s2 ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The C strncpy() and strncat() functions could be improved by adding element count parameters as follows:",
          "code": "char *improved_strncpy(char * restrict s1, size_t s1count, const char * restrict s2, size_t s2count, size_t n);\nchar *improved_strncat(char * restrict s1, size_t s1count, const char * restrict s2, size_t s2count, size_t n);\n",
          "explanation_after": "The n parameter is used to specify a number of elements to copy that is less than the total number of elements in the source string."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to follow this recommendation can result in improper memory accesses and buffer overflows that are detrimental to the correct and continued execution of the program.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "API03-C",
    "title": "Create consistent interfaces and capabilities across related functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/API03-C.+Create+consistent+interfaces+and+capabilities+across+related+functions",
    "description": "Related functions, such as those that make up a library, should provide consistent and usable interfaces. Ralph Waldo Emerson said, \"A foolish consistency is the hobgoblin of little minds,\" but inconsistencies in functional interfaces or behavior can lead to erroneous use, so we understand this to be a \"wise consistency.\" One aspect of providing a consistent interface is to provide a consistent and usable error-checking mechanism. For more information, see API04-C. Provide a consistent and usable error-checking mechanism .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Interface)",
          "pre_code_commentary": "It is not necessary to go beyond the standard C library to find examples of inconsistent interfaces: the standard library is a fusion of multiple libraries with various styles and levels of rigor. For example, the fputs() defined in the C Standard, subclause 7.21.7.4, is closely related to the fprintf() defined in subclause 7.21.6.1. However, fputs() 's file handle is at the end, and fprintf() 's is at the beginning, as shown by their function declarations:",
          "code": "int fputs(const char * restrict s, FILE * restrict stream);\n\nint fprintf(FILE * restrict stream, const char * restrict format, ...);\n",
          "explanation_after": "The argument order can be easily rearranged using macros; for example:\n\nHowever, according to subclause 7.1.3 of the C Standard, the behavior of a program that defines a symbol, including a macro, with the same name as that of a standard library function, type, macro, or other reserved identifier is undefined .\n\nUsing inconsistent interfaces makes the code difficult to read, for example, by causing confusion when moving between code that follows this convention and code that does not. In effect, it becomes impossible to modify an interface once that interface has been broadly adopted. Consequently, it is important to get the interface design right the first time."
        },
        "compliant": {
          "heading": "Compliant Solution (Interface)",
          "pre_code_commentary": "The POSIX threads library [ Butenhof 1997 ] defines an interface that is both consistent and fits in with established conventions from the rest of the POSIX library. For example, all initialization functions follow the same consistent pattern of the first argument being a pointer to the object to initialize with the subsequent arguments, if any, optionally providing additional attributes for the initialization:",
          "code": "/* Initialization of pthread attribute objects */\nint pthread_condattr_init(pthread_condattr_t *);\nint pthread_mutexattr_init(pthread_mutexattr_t *);\nint pthread_rwlockattr_init(pthread_rwlockattr_t *);\n...\n/* Initialization of pthread objects using attributes */\nint pthread_cond_init(pthread_cond_t * restrict, const pthread_condattr_t * restrict);\nint pthread_mutex_init(pthread_mutex_t * restrict, const pthread_mutexattr_t * restrict);\nint pthread_rwlock_init(pthread_rwlock_t * restrict, const pthread_rwlockattr_t * restrict);\n...\n",
          "explanation_after": "Function arguments that refer to objects that are not modified are declared const . Because the object pointed to by the first argument is modified by the function, it is not const . For functions that implement a data abstraction, it is reasonable to define the handle for the data abstraction as the initial parameter. (See DCL12-C. Implement abstract data types using opaque types .) Finally, initialization functions that accept a pointer to an attribute object allow it to be NULL as an indication that a reasonable default should be used."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Behavior)",
          "pre_code_commentary": "The shared folder and file copy functions in the VMware virtual infrastructure (VIX) API are inconsistent in the set of characters they allow in folder names. As a result, you can create a shared folder that you subsequently cannot use in a file copy function such as VixVM_CopyFileFromHostToGuest() .",
          "code": null,
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Behavior)",
          "pre_code_commentary": "Try to be consistent in the behavior of related functions that perform operations on common objects so that an object created or modified by one function can be successfully processed by a downstream invocation of a related function.",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to maintain consistency in interfaces and capabilities across functions can result in type errors in the program.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "API04-C",
    "title": "Provide a consistent and usable error-checking mechanism",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/API04-C.+Provide+a+consistent+and+usable+error-checking+mechanism",
    "description": "Functions should provide consistent and usable error-checking mechanisms. Complex interfaces are sometimes ignored by programmers, resulting in code that is not error checked. Inconsistent interfaces are frequently misused and difficult to use, resulting in lower-quality code and higher development costs.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( strlcpy() )",
          "pre_code_commentary": "The strlcpy() function copies a null-terminated source string to a destination array. It is designed to be a safer, more consistent, and less error-prone replacement for strcpy() .\n\nThe strlcpy() function returns the total length of the string it tried to create (the length of the source string).\n\nTo detect truncation, perhaps while building a path name, code such as the following might be used:",
          "code": "char *dir, *file, pname[MAXPATHLEN];\n\n/* ... */\n\nif (strlcpy(pname, dir, sizeof(pname)) >= sizeof(pname)) {\n  /* Handle source-string-too long error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( strcpy_m() )",
          "pre_code_commentary": "The managed string library [ Burch 2006 ] handles errors by consistently returning the status code in the function return value. This approach encourages status checking because the user can insert the function call as the expression in an if statement and take appropriate action on failure.\n\nThe strcpy_m() function is an example of a managed string function that copies a source-managed string into a destination-managed string:",
          "code": "errno_t retValue; \nstring_m dest, source;  \n\n/* ... */\n\nif (retValue = strcpy_m(dest, source)) { \n  fprintf(stderr, \"Error %d from strcpy_m.\\n\", retValue);\n} \n",
          "explanation_after": "The greatest disadvantage of this approach is that it prevents functions from returning any other value. Consequently, all values (other than the status) returned by a function must be returned as a pass-by-reference parameter, preventing a programmer from nesting function calls. This trade-off is necessary because nesting function calls can conflict with a programmer's willingness to check status codes."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to provide a consistent and usable error-checking mechanism can result in type errors in the program.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "API05-C",
    "title": "Use conformant array parameters",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/API05-C.+Use+conformant+array+parameters",
    "description": "Traditionally, C arrays are declared with an index that is either a fixed constant or empty. An array with a fixed constant index indicates to the compiler how much space to reserve for the array. An array declaration with an empty index is an incomplete type and indicates that the variable references a pointer to an array of indeterminate size.\n\nThe term conformant array parameter comes from Pascal; it refers to a function argument that is an array whose size is specified in the function declaration. Since C99, C has supported conformant array parameters by permitting array parameter declarations to use extended syntax. Subclause 6.7.6.2, paragraph 1, of C11 [ ISO/IEC 9899:2011 ] summarizes the array index syntax extensions:\n\nThe [ and ] may delimit an expression or *. If they delimit an expression (which specifies the size of an array), the  expression shall have an integer type. If the expression is a constant expression, it shall  have a value greater than zero.\n\nConsequently, an array declaration that serves as a function argument may have an index that is a variable or an expression. The array argument is demoted to a pointer and is consequently not a variable length array (VLA). Conformant array parameters can be used by developers to indicate the expected bounds of the array. This information may be used by compilers, or it may be ignored. However, such declarations are useful to developers because they serve to document relationships between array sizes and pointers. This information can also be used by static analysis tools to diagnose potential defects.\n\nint f(size_t n, int a[n]);  /* Documents a relationship between n and a */\n\nint f(size_t n, int a[n]);  /* Documents a relationship between n and a */",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code example provides a function that wraps a call to the standard memset() function and has a similar set of arguments. However, although this function clearly intends that p point to an array of at least n chars, this invariant is not explicitly documented.",
          "code": "void my_memset(char* p, size_t n, char v)\n{\n  memset( p, v, n);\n}\n",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to document the relationship between the pointer and the size using conformant array parameters. However, the variable n is used as the index of the array declaration before n is itself declared. Consequently, this code example is not standards-compliant and will usually fail to compile.",
          "code": "void my_memset(char p[n], size_t n, char v)\n{\n  memset( p, v, n);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (GCC)",
          "pre_code_commentary": "This compliant solution uses a GNU extension to forward declare the size_t variable n before using it in the subsequent array declaration. Consequently, this code allows the existing parameter order to be retained and successfully documents the relationship between the array parameter and the size parameter.",
          "code": "void my_memset(size_t n; char p[n], size_t n, char v)\n{\n  memset(p, v, n);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to document the relationship between the pointer and the size using conformant array parameters. However, the variable n is used as the index of the array declaration before n is itself declared. Consequently, this code example is not standards-compliant and will usually fail to compile.",
          "code": "void my_memset(char p[n], size_t n, char v)\n{\n  memset( p, v, n);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (API change)",
          "pre_code_commentary": "This compliant solution changes the function's API by moving the size_t variable n to before the subsequent array declaration. Consequently, this code complies with the C99 standard and successfully documents the relationship between the array parameter and the size parameter, but requires all callers to be updated.",
          "code": "void my_memset(size_t n, char p[n], char v)\n{\n  memset(p, v, n);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to specify conformant array dimensions increases the likelihood that another developer will invoke the function with out-of-range integers, which could cause an out-of-bounds memory read or write.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "API07-C",
    "title": "Enforce type safety",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/API07-C.+Enforce+type+safety",
    "description": "Upon return, functions should guarantee that any object returned by the function, or any modified value referenced by a pointer argument, is a valid object of function return type or argument type. Otherwise, type errors can occur in the program.\n\nA good example is the null-terminated byte string type in C. If a string lacks the terminating null character, the program may be tricked into accessing storage after the string as legitimate data. A program may, as a result, process a string it should not process, which might be a security flaw in itself. It may also cause the program to abort, which might be a denial-of-service attack .\n\nThe emphasis of this recommendation is to avoid producing unterminated strings; it does not address processing of already existing unterminated strings. However, by preventing the creation of unterminated strings, the need to process them is greatly lessened.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The standard strncpy() function does not guarantee that the resulting string is null-terminated. If there is no null character in the first n characters of the source array, the result may not be null-terminated.",
          "code": "char *source;\nchar a[NTBS_SIZE];\n/* ... */\nif (source) {\n  char* b = strncpy(a, source, 5); // b == a\n}\nelse {\n  /* Handle null string condition */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( strncpy_s() , C11 Annex K)",
          "pre_code_commentary": "The C11 Annex K strncpy_s() function copies up to n characters from the source array to a destination array. If no null character was copied from the source array, the n th position in the destination array is set to a null character, guaranteeing that the resulting string is null-terminated.",
          "code": "char *source;\nchar a[NTBS_SIZE];\n/* ... */\nif (source) {\n  errno_t err = strncpy_s(a, sizeof(a), source, 5);\n  if (err != 0) {\n    /* Handle error */\n  }\n}\nelse {\n  /* Handle null string condition */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to enforce type safety can result in type errors in the program.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "API09-C",
    "title": "Compatible values should have the same type",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/API09-C.+Compatible+values+should+have+the+same+type",
    "description": "Make sure compatible values have the same type. For example, when the return value of one function is used as an argument to another function, make sure they are the same type. Ensuring compatible values have the same type allows the return value to be passed as an argument to the related function without conversion, reducing the potential for conversion errors.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "A source of potential errors may be traced to POSIX's tendency to overload return codes, using −1 to indicate an error condition but 0 for success and positive values as a result indicator (see ERR02-C. Avoid in-band error indicators ). A good example is the read() system call. This leads to a natural mixing of unsigned and signed quantities, potentially leading to conversion errors.\n\nOpenSSH performs most I/O calls through a \"retry on interrupt\" function, atomicio() . The following is a slightly simplified version of atomicio.c , v 1.12 2003/07/31. The function f() is either read() or vwrite() :",
          "code": "ssize_t atomicio(f, fd, _s, n)\n  ssize_t (*f) (int, void *, size_t);\n  int fd;\n  void *_s;\n  size_t n;\n{\n  char *s = _s;\n  ssize_t res, pos = 0;\n\n  while (n > pos) {\n    res = (f) (fd, s + pos, n - pos);\n    switch (res) {\n      case -1:\n         if (errno == EINTR || errno == EAGAIN)\n         continue;\n      case 0:\n        return (res);\n      default:\n        pos += res;\n     }\n   }\n   return (pos);\n}\n",
          "explanation_after": "This function has a large number of flaws. Pertinent to this recommendation, however, are the following:\n\nThe atomicio() function returns an ssize_t (which must be a signed type). The ssize_t type is a clear indication of poor interface design because a size should never be negative. Both res and pos are declared as ssize_t . The expression n - pos results in the conversion of pos from a signed to an unsigned type because of the usual arithmetic conversions (see INT02-C. Understand integer conversion rules )."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The atomicio() function from atomicio.c , v 1.25 2007/06/25, was modified to always return an unsigned quantity and to instead report its error via errno :",
          "code": "size_t atomicio(ssize_t (*f) (int, void *, size_t),\n                int fd, void *_s, size_t n) {\n  char *s = _s;\n  size_t pos = 0;\n  ssize_t res;\n  struct pollfd pfd;\n\n  pfd.fd = fd;\n  pfd.events = f == read ? POLLIN : POLLOUT;\n  while (n > pos) {\n    res = (f) (fd, s + pos, n - pos);\n    switch (res) {\n      case -1:\n        if (errno == EINTR)\n          continue;\n        if (errno == EAGAIN) {\n          (void)poll(&pfd, 1, -1);\n          continue;\n        }\n        return 0;\n      case 0:\n        errno = EPIPE;\n        return pos;\n      default:\n        pos += (size_t)res;\n      }\n    }\n  return (pos);\n}\n",
          "explanation_after": "Changes to this version of the atomicio() function include the following:\n\nThe atomicio() function now returns a value of type size_t . pos is now declared as size_t . The assignment pos += (size_t)res now requires an explicit cast to convert from the signed return value of f() to size_t . The expression n - pos no longer requires an implicit conversion.\n\nReducing the need to use signed types makes it easier to enable the compiler's signed/unsigned comparison warnings and fix all of the issues it reports (see MSC00-C. Compile cleanly at high warning levels )."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The risk in using in-band error indicators is difficult to quantify and is consequently given as low. However, if the use of in-band error indicators results in programmers' failing to check status codes or incorrectly checking them, the consequences can be more severe.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "API10-C",
    "title": "APIs should have security options enabled by default",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/API10-C.+APIs+should+have+security+options+enabled+by+default",
    "description": "APIS should have security options enabled by default– for example, having best practice cipher suites enabled by default (something that changes over time) while disabling out-of-favor cipher suites by default. When interface stability is also a design requirement, an interface can meet both goals by providing off-by-default options that produce stable behavior, such as TLS_ENABLE_Y2015_BEST_PRACTICE_CIPHERS_ONLY .\n\nTLS_ENABLE_Y2015_BEST_PRACTICE_CIPHERS_ONLY",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "If the caller of this API in this noncompliant example doesn't understand what the options mean, they will pass 0 or TLS_DEFAULT_OPTIONS and get a connection vulnerable to man-in-the-middle attacks and using old versions of TLS.",
          "code": "int tls_connect_by_name(const char *host, int port, int option_bitmask);\n#define TLS_DEFAULT_OPTIONS 0\n#define TLS_VALIDATE_HOST 0x0001\n#define TLS_DISABLE_V1_0 0x0002\n#define TLS_DISABLE_V1_1 0x0004\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "If the caller of this API doesn't understand the options and passes 0 or TLS_DEFAULT_OPTIONS they will get certificate validation with only the current version of TLS enabled.",
          "code": "int tls_connect_by_name(const char *host, int port, int option_bitmask);\n#define TLS_DEFAULT_OPTIONS 0\n#define TLS_DISABLE_HOST_VALIDATION 0x0001  // use rarely, subject to man-in-the-middle attack\n#define TLS_ENABLE_V1_0 0x0002\n#define TLS_ENABLE_V1_1 0x0004\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ARR00-C",
    "title": "Understand how arrays work",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ARR00-C.+Understand+how+arrays+work",
    "description": "The incorrect use of arrays has traditionally been a source of exploitable vulnerabilities . Elements referenced within an array using the subscript operator [] are not checked unless the programmer provides adequate bounds checking. As a result, the expression array [pos] = value can be used by an attacker to transfer control to arbitrary code.\n\n[]\n\narray [pos] = value\n\nAn attacker who can control the values of both pos and value in the expression array [pos] = value can perform an arbitrary write (which is when the attacker overwrites other storage locations with different content). The consequences range from changing a variable used to determine what permissions the program grants to executing arbitrary code with the permissions of the vulnerable process. Arrays are also a common source of buffer overflows when iterators exceed the bounds of the array.\n\npos\n\nvalue\n\narray [pos] = value\n\nAn array is a series of objects, all of which are the same size and type. Each object in an array is called an array element . The entire array is stored contiguously in memory (that is, there are no gaps between elements). Arrays are commonly used to represent a sequence of elements where random access is important but there is little or no need to insert new elements into the sequence (which can be an expensive operation with arrays).\n\nArrays containing a constant number of elements can be declared as follows:\n\nenum { ARRAY_SIZE = 12 };\nint array[ARRAY_SIZE];\n\nenum { ARRAY_SIZE = 12 };\nint array[ARRAY_SIZE];\n\nThese statements allocate storage for an array of 12 integers referenced by array . Arrays are indexed from 0..n-1 (where n represents an array bound). Arrays can also be declared as follows:\n\narray\n\n0..n-1\n\nn\n\nint array[];\n\nint array[];\n\nThis array is called an incomplete type because the size is unknown. If an array of unknown size is initialized, its size is determined by the largest indexed element with an explicit initializer. At the end of its initializer list, the array no longer has incomplete type.\n\nint array[] = { 1, 2 };\n\nint array[] = { 1, 2 };\n\nAlthough these declarations work fine when the size of the array is known at compile time, it is not possible to declare an array in this fashion when the size can be determined only at runtime. The C Standard adds support for variable length arrays or arrays whose size is determined at runtime. Before the introduction of variable length arrays in C99, however, these \"arrays\" were typically implemented as pointers to their respective element types allocated using malloc() , as shown in this example:\n\nmalloc()\n\nint *dis = (int *)malloc(ARRAY_SIZE * sizeof(int));\n\nint *dis = (int *)malloc(ARRAY_SIZE * sizeof(int));\n\nAlways check that malloc() returns a non-null pointer, as per ERR33-C. Detect and handle standard library errors .\n\nmalloc()\n\nIt is important to retain any pointer value returned by malloc() so that the referenced memory may eventually be deallocated. One possible way to preserve such a value is to use a constant pointer:\n\nmalloc()\n\nint * const dat = (int * const)malloc(\n  ARRAY_SIZE * sizeof(int)\n);\n/* ... */\nfree(dat);\n\nint * const dat = (int * const)malloc(\n  ARRAY_SIZE * sizeof(int)\n);\n/* ... */\nfree(dat);\n\nBelow we consider some techniques for array initialization.  Both dis and dat arrays can be initialized as follows:\n\ndis\n\ndat\n\nfor (i = 0; i < ARRAY_SIZE; i++) {\n   dis[i] = 42; /* Assigns 42 to each element of dis */ \n   dat[i] = 42; /* Assigns 42 to each element of dat */\n}\n\nfor (i = 0; i < ARRAY_SIZE; i++) {\n   dis[i] = 42; /* Assigns 42 to each element of dis */ \n   dat[i] = 42; /* Assigns 42 to each element of dat */\n}\n\nThe dis array can also be initialized as follows:\n\ndis\n\nfor (i = 0; i < ARRAY_SIZE; i++) {\n   *dis = 42;\n   dis++;\n}\ndis -= ARRAY_SIZE;\n\nfor (i = 0; i < ARRAY_SIZE; i++) {\n   *dis = 42;\n   dis++;\n}\ndis -= ARRAY_SIZE;\n\nThis technique, however, will not work for dat .  The dat identifier cannot be incremented (produces a fatal compilation error), as it was declared with type int * const .  This problem can be circumvented by copying dat into a separate pointer:\n\ndat\n\ndat\n\nint * const\n\ndat\n\nint *p = dat;\nfor (i = 0; i < ARRAY_SIZE; i++)  {\n  *p = 42; /* Assigns 42 to each element */\n  p++;\n}\n\nint *p = dat;\nfor (i = 0; i < ARRAY_SIZE; i++)  {\n  *p = 42; /* Assigns 42 to each element */\n  p++;\n}\n\nThe variable p is declared as a pointer to an integer, initialized with the value stored in dat , and then incremented in the loop. This technique can be used to initialize both arrays, and is a better style of programming than incrementing the original pointer to the array (e.g., dis++ , in the above example), as it avoids having to reset the pointer back to the start of the array after the loop completes.\n\np\n\ndat\n\ndis++\n\nObviously, there is a relationship between array subscripts [] and pointers. The expression dis[i] is equivalent to *(dis+i) for all integral values of i . In other words, if dis is an array object (equivalently, a pointer to the initial element of an array object) and i is an integer, dis[i] designates the i th element of dis . In fact, because *(dis+i) can be expressed as *(i+dis) , the expression dis[i] can be represented as i[dis] , although doing so is not encouraged. Because array indices are zero-based, the first element is designated as dis[0] , or equivalently as *(dis+0) or simply *dis .\n\n[]\n\ndis[i]\n\n*(dis+i)\n\ni\n\ndis\n\ni\n\ndis[i]\n\ni\n\ndis\n\n*(dis+i)\n\n*(i+dis)\n\ndis[i]\n\ni[dis]\n\ndis[0]\n\n*(dis+0)\n\n*dis",
    "examples": null,
    "risk_assessment": {
      "explanation": "Arrays are a common source of vulnerabilities in C language programs because they are frequently used but not always fully understood.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ARR01-C",
    "title": "Do not apply the sizeof operator to a pointer when taking the size of an array",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ARR01-C.+Do+not+apply+the+sizeof+operator+to+a+pointer+when+taking+the+size+of+an+array",
    "description": "The sizeof operator yields the size (in bytes) of its operand, which can be an expression or the parenthesized name of a type. However, using the sizeof operator to determine the size of arrays is error prone.\n\nsizeof\n\nsizeof\n\nThe sizeof operator is often used in determining how much memory to allocate via malloc() . However using an incorrect size is a violation of MEM35-C. Allocate sufficient memory for an object .\n\nsizeof\n\nmalloc()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the function clear() zeros the elements in an array. The function has one parameter declared as int array[] and is passed a static array consisting of 12 int as the argument. The function clear() uses the idiom sizeof(array) / sizeof(array[0]) to determine the number of elements in the array. However, array has a pointer type because it is a parameter. As a result, sizeof(array) is equal to the sizeof(int *) . For example, on an architecture (such as IA-32) where the sizeof(int) == 4 and the sizeof(int *) == 4 , the expression sizeof(array) / sizeof(array[0]) evaluates to 1, regardless of the length of the array passed, leaving the rest of the array unaffected.",
          "code": "void clear(int array[]) {\n  for (size_t i = 0; i < sizeof(array) / sizeof(array[0]); ++i) {\n     array[i] = 0;\n   }\n}\n\nvoid dowork(void) {\n  int dis[12];\n\n  clear(dis);\n  /* ... */\n}\n",
          "explanation_after": "Footnote 103 in subclause 6.5.3.4 of the C Standard [ ISO/IEC 9899:2011 ] applies to all array parameters:\n\nWhen applied to a parameter declared to have array or function type, the sizeof operator yields the size of the adjusted (pointer) type."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the size of the array is determined inside the block in which it is declared and passed as an argument to the function:",
          "code": "void clear(int array[], size_t len) {\n  for (size_t i = 0; i < len; i++) {\n    array[i] = 0;\n  }\n}\n\nvoid dowork(void) {\n  int dis[12];\n\n  clear(dis, sizeof(dis) / sizeof(dis[0]));\n  /* ... */\n}\n",
          "explanation_after": "This sizeof(array) / sizeof(array[0]) idiom will succeed provided the original definition of array is visible."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, sizeof(a) does not equal 100 * sizeof(int) , because the sizeof operator, when applied to a parameter declared to have array type, yields the size of the adjusted (pointer) type even if the parameter declaration specifies a length:",
          "code": "enum {ARR_LEN = 100};\n\nvoid clear(int a[ARR_LEN]) {\n  memset(a, 0, sizeof(a)); /* Error */\n}\n\nint main(void) {\n  int b[ARR_LEN];\n  clear(b);\n  assert(b[ARR_LEN / 2]==0); /* May fail */\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the size is specified using the expression len * sizeof(int) :",
          "code": "enum {ARR_LEN = 100};\n\nvoid clear(int a[], size_t len) {\n  memset(a, 0, len * sizeof(int));\n}\n\nint main(void) {\n  int b[ARR_LEN];\n  clear(b, ARR_LEN);\n  assert(b[ARR_LEN / 2]==0); /* Cannot fail */\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrectly using the sizeof operator to determine the size of an array can result in a buffer overflow, allowing the execution of arbitrary code.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "ARR02-C",
    "title": "Explicitly specify array bounds, even if implicitly defined by an initializer",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ARR02-C.+Explicitly+specify+array+bounds%2C+even+if+implicitly+defined+by+an+initializer",
    "description": "The C Standard allows an array variable to be declared both with a bound and with an initialization literal. The initialization literal also implies an array bound in the number of elements specified.\n\nThe size implied by an initialization literal is usually specified by the number of elements,\n\nint array[] = {1, 2, 3}; /* 3-element array */\n\nint array[] = {1, 2, 3}; /* 3-element array */\n\nbut it is also possible to use designators to initialize array elements in a noncontiguous fashion. Subclause 6.7.9, Example 12, of the C Standard [ ISO/IEC 9899:2011 ] states:\n\nSpace can be \"allocated\" from both ends of an array by using a single designator: int a[MAX] = {\n  1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0\n}; In the above, if MAX is greater than ten, there will be some zero-valued elements in the middle; if it is less than ten, some of the values provided by the first five initializers will be overridden by the second five.\n\nint a[MAX] = {\n  1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0\n};\n\nMAX\n\nThe C Standard also dictates how array initialization is handled when the number of initialization elements does not equal the explicit array bound. Subclause 6.7.9, paragraphs 21 and 22, state:\n\nIf there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration. If an array of unknown size is initialized, its size is determined by the largest indexed element with an explicit initializer. The array type is completed at the end of its initializer list.\n\nAlthough compilers can compute the size of an array on the basis of its initialization list, explicitly specifying the size of the array provides a redundancy check, ensuring that the array's size is correct. It also enables compilers to emit warnings if the array's size is less than the size implied by the initialization.\n\nNote that this recommendation does not apply (in all cases) to character arrays initialized with string literals. See STR11-C. Do not specify the bound of a character array initialized with a string literal for more information.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Incorrect Size)",
          "pre_code_commentary": "This noncompliant code example initializes an array of integers using an initialization with too many elements for the array:",
          "code": "int a[3] = {1, 2, 3, 4};\n",
          "explanation_after": "The size of the array a is 3, although the size of the initialization is 4. The last element of the initialization ( 4 ) is ignored. Most compilers will diagnose this error.\n\nThis noncompliant code example generates a warning in GCC. Microsoft Visual Studio generates a fatal diagnostic: error C2078: too many initializers ."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Implicit Size)",
          "pre_code_commentary": "In this example, the compiler allocates an array of four integer elements and, because an array bound is not explicitly specified by the programmer, sets the array bound to 4 . However, if the initializer changes, the array bound may also change, causing unexpected results.",
          "code": "int a[] = {1, 2, 3, 4};\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution explicitly specifies the array bound:",
          "code": "int a[4] = {1, 2, 3, 4};\n",
          "explanation_after": "Explicitly specifying the array bound, although it is implicitly defined by an initializer, allows a compiler or other static analysis tool to issue a diagnostic if these values do not agree."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ARR30-C",
    "title": "Do not form or use out-of-bounds pointers or array subscripts",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts",
    "description": "The C Standard identifies the following distinct situations in which undefined behavior (UB) can arise as a result of invalid pointer operations:\n\nUB Description Example Code 43 Addition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that does not point into, or just beyond, the same array object. Forming Out-of-Bounds Pointer , Null Pointer Arithmetic 44 Addition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that points just beyond the array object and is used as the operand of a unary * operator that is evaluated. Dereferencing Past the End Pointer , Using Past the End Index 46 An array subscript is out of range, even if an object is apparently accessible with the given subscript, for example, in the lvalue expression a[1][7] given the declaration int a[4][5] ). Apparently Accessible Out-of-Range Index 59 An attempt is made to access, or generate a pointer to just past, a flexible array member of a structure when the referenced object provides no elements for that array. Pointer Past Flexible Array Member\n\n*\n\na[1][7]\n\nint a[4][5]",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Forming Out-of-Bounds Pointer)",
          "pre_code_commentary": "In this noncompliant code example, the function f() attempts to validate the index before using it as an offset to the statically allocated table of integers. However, the function fails to reject negative index values. When index is less than zero, the behavior of the addition expression in the return statement of the function is undefined behavior 43 . On some implementations, the addition alone can trigger a hardware trap. On other implementations, the addition may produce a result that when dereferenced triggers a hardware trap. Other implementations still may produce a dereferenceable pointer that points to an object distinct from table . Using such a pointer to access the object may lead to information exposure or cause the wrong object to be modified.",
          "code": "enum { TABLESIZE = 100 };\n\nstatic int table[TABLESIZE];\n\nint *f(int index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "One compliant solution is to detect and reject invalid values of index if using them in pointer arithmetic would result in an invalid pointer:",
          "code": "enum { TABLESIZE = 100 };\n\nstatic int table[TABLESIZE];\n\nint *f(int index) {\n  if (index >= 0 && index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Forming Out-of-Bounds Pointer)",
          "pre_code_commentary": "In this noncompliant code example, the function f() attempts to validate the index before using it as an offset to the statically allocated table of integers. However, the function fails to reject negative index values. When index is less than zero, the behavior of the addition expression in the return statement of the function is undefined behavior 43 . On some implementations, the addition alone can trigger a hardware trap. On other implementations, the addition may produce a result that when dereferenced triggers a hardware trap. Other implementations still may produce a dereferenceable pointer that points to an object distinct from table . Using such a pointer to access the object may lead to information exposure or cause the wrong object to be modified.",
          "code": "enum { TABLESIZE = 100 };\n\nstatic int table[TABLESIZE];\n\nint *f(int index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Another slightly simpler and potentially more efficient compliant solution is to use an unsigned type to avoid having to check for negative values while still rejecting out-of-bounds positive values of index :",
          "code": "#include <stddef.h>\n \nenum { TABLESIZE = 100 };\n\nstatic int table[TABLESIZE];\n\nint *f(size_t index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Dereferencing Past-the-End Pointer)",
          "pre_code_commentary": "This noncompliant code example shows the flawed logic in the Windows Distributed Component Object Model (DCOM) Remote Procedure Call (RPC) interface that was exploited by the W32.Blaster.Worm. The error is that the while loop in the GetMachineName() function (used to extract the host name from a longer string) is not sufficiently bounded. When the character array pointed to by pwszTemp does not contain the backslash character among the first MAX_COMPUTERNAME_LENGTH_FQDN + 1 elements, the final valid iteration of the loop will dereference past the end pointer, resulting in exploitable undefined behavior 44 . In this case, the actual exploit allowed the attacker to inject executable code into a running program. Economic damage from the Blaster worm has been estimated to be at least $525 million [ Pethia 2003 ].\n\nFor a discussion of this programming error in the Common Weakness Enumeration database, see CWE-119 , \"Improper Restriction of Operations within the Bounds of a Memory Buffer,\" and CWE-121 , \"Stack-based Buffer Overflow\" [ MITRE 2013 ].",
          "code": "error_status_t _RemoteActivation(\n      /* ... */, WCHAR *pwszObjectName, ... ) {\n   *phr = GetServerPath(\n              pwszObjectName, &pwszObjectName);\n    /* ... */\n}\n\nHRESULT GetServerPath(\n  WCHAR *pwszPath, WCHAR **pwszServerPath ){\n  WCHAR *pwszFinalPath = pwszPath;\n  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1];\n  hr = GetMachineName(pwszPath, wszMachineName);\n  *pwszServerPath = pwszFinalPath;\n}\n\nHRESULT GetMachineName(\n  WCHAR *pwszPath,\n  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])\n{\n  pwszServerName = wszMachineName;\n  LPWSTR pwszTemp = pwszPath + 2;\n  while (*pwszTemp != L'\\\\')\n    *pwszServerName++ = *pwszTemp++;\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the while loop in the GetMachineName() function is bounded so that the loop terminates when a backslash character is found, the null-termination character ( L'\\0' ) is discovered, or the end of the buffer is reached. Or, as coded, the while loop continues as long as each character is neither a backslash nor a null character and is not at the end of the buffer. This code does not result in a buffer overflow even if no backslash character is found in wszMachineName .",
          "code": "HRESULT GetMachineName(\n  wchar_t *pwszPath,\n  wchar_t wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])\n{\n  wchar_t *pwszServerName = wszMachineName;\n  wchar_t *pwszTemp = pwszPath + 2;\n  wchar_t *end_addr\n    = pwszServerName + MAX_COMPUTERNAME_LENGTH_FQDN;\n  while ((*pwszTemp != L'\\\\') &&\n         (*pwszTemp != L'\\0') &&\n         (pwszServerName < end_addr))\n  {\n    *pwszServerName++ = *pwszTemp++;\n  }\n\n  /* ... */\n}\n",
          "explanation_after": "This compliant solution is for illustrative purposes and is not necessarily the solution implemented by Microsoft. This particular solution may not be correct because there is no guarantee that a backslash is found."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Using Past-the-End Index)",
          "pre_code_commentary": "Similar to the dereferencing-past-the-end-pointer error, the function insert_in_table() in this noncompliant code example uses an otherwise valid index to attempt to store a value in an element just past the end of an array.\n\nFirst, the function incorrectly validates the index pos against the size of the buffer. When pos is initially equal to size , the function attempts to store value in a memory location just past the end of the buffer.\n\nSecond, when the index is greater than size , the function modifies size before growing the size of the buffer. If the call to realloc() fails to increase the size of the buffer, the next call to the function with a value of pos equal to or greater than the original value of size will again attempt to store value in a memory location just past the end of the buffer or beyond.\n\nThird, the function violates INT30-C. Ensure that unsigned integer operations do not wrap , which could lead to wrapping when 1 is added to pos or when size is multiplied by the size of int .\n\nFor a discussion of this programming error in the Common Weakness Enumeration database, see CWE-122 , \"Heap-based Buffer Overflow,\" and CWE-129 , \"Improper Validation of Array Index\" [ MITRE 2013 ].",
          "code": "#include <stdlib.h>\n \nstatic int *table = NULL;\nstatic size_t size = 0;\n\nint insert_in_table(size_t pos, int value) {\n  if (size < pos) {\n    int *tmp;\n    size = pos + 1;\n    tmp = (int *)realloc(table, sizeof(*table) * size);\n    if (tmp == NULL) {\n      return -1;   /* Failure */\n    }\n    table = tmp;\n  }\n\n  table[pos] = value;\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution correctly validates the index pos by using the <= relational operator, ensures the multiplication will not overflow, and avoids modifying size until it has verified that the call to realloc() was successful:",
          "code": "#include <stdint.h>\n#include <stdlib.h>\n \nstatic int *table = NULL;\nstatic size_t size = 0;\n\nint insert_in_table(size_t pos, int value) {\n  if (size <= pos) {\n    if ((SIZE_MAX - 1 < pos) ||\n        ((pos + 1) > SIZE_MAX / sizeof(*table))) {\n      return -1;\n    }\n \n    int *tmp = (int *)realloc(table, sizeof(*table) * (pos + 1));\n    if (tmp == NULL) {\n      return -1;\n    }\n    /* Modify size only after realloc() succeeds */\n    size  = pos + 1;\n    table = tmp;\n  }\n\n  table[pos] = value;\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Apparently Accessible Out-of-Range Index)",
          "pre_code_commentary": "This noncompliant code example declares matrix to consist of 7 rows and 5 columns in row-major order. The function init_matrix iterates over all 35 elements in an attempt to initialize each to the value given by the function argument x . However, because multidimensional arrays are declared in C in row-major order, the function iterates over the elements in column-major order, and when the value of j reaches the value COLS during the first iteration of the outer loop, the function attempts to access element matrix[0][5] . Because the type of matrix is int[7][5] , the j subscript is out of range, and the access has undefined behavior 46 .",
          "code": "#include <stddef.h>\n#define COLS 5\n#define ROWS 7\nstatic int matrix[ROWS][COLS];\n\nvoid init_matrix(int x) {\n  for (size_t i = 0; i < COLS; i++) {\n    for (size_t j = 0; j < ROWS; j++) {\n      matrix[i][j] = x;\n    }\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution avoids using out-of-range indices by initializing matrix elements in the same row-major order as multidimensional objects are declared in C:",
          "code": "#include <stddef.h>\n#define COLS 5\n#define ROWS 7\nstatic int matrix[ROWS][COLS];\n\nvoid init_matrix(int x) {\n  for (size_t i = 0; i < ROWS; i++) {\n    for (size_t j = 0; j < COLS; j++) {\n      matrix[i][j] = x;\n    }\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Pointer Past Flexible Array Member)",
          "pre_code_commentary": "In this noncompliant code example, the function find() attempts to iterate over the elements of the flexible array member buf , starting with the second element. However, because function g() does not allocate any storage for the member, the expression first++ in find() attempts to form a pointer just past the end of buf when there are no elements. This attempt is undefined behavior 59 . (See MSC21-C. Use robust loop termination conditions for more information.)",
          "code": "#include <stdlib.h>\n \nstruct S {\n  size_t len;\n  char buf[];  /* Flexible array member */\n};\n\nconst char *find(const struct S *s, int c) {\n  const char *first = s->buf;\n  const char *last  = s->buf + s->len;\n\n  while (first++ != last) { /* Undefined behavior */\n    if (*first == c) {\n      return first;\n    }\n  }\n  return NULL;\n}\n \nvoid g(void) {\n  struct S *s = (struct S *)malloc(sizeof(struct S));\n  if (s == NULL) {\n    /* Handle error */\n  }\n  s->len = 0;\n  find(s, 'a');\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution avoids incrementing the pointer unless a value past the pointer's current value is known to exist:",
          "code": "#include <stdlib.h>\n \nstruct S {\n  size_t len;\n  char buf[];  /* Flexible array member */\n};\n\nconst char *find(const struct S *s, int c) {\n  const char *first = s->buf;\n  const char *last  = s->buf + s->len;\n\n  while (first != last) { /* Avoid incrementing here */\n    if (*++first == c) {\n      return first;\n    }\n  }\n  return NULL;\n}\n \nvoid g(void) {\n  struct S *s = (struct S *)malloc(sizeof(struct S));\n  if (s == NULL) {\n    /* Handle error */\n  }\n  s->len = 0;\n  find(s, 'a');\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Null Pointer Arithmetic)",
          "pre_code_commentary": "This noncompliant code example is similar to an Adobe Flash Player vulnerability that was first exploited in 2008. This code allocates a block of memory and initializes it with some data. The data does not belong at the beginning of the block, which is left uninitialized. Instead, it is placed offset bytes within the block. The function ensures that the data fits within the allocated block.",
          "code": "#include <string.h>\n#include <stdlib.h>\n\nchar *init_block(size_t block_size, size_t offset,\n                 char *data, size_t data_size) {\n  char *buffer = malloc(block_size);\n  if (data_size > block_size || block_size - data_size < offset) {\n    /* Data won't fit in buffer, handle error */\n  }\n  memcpy(buffer + offset, data, data_size);\n  return buffer;\n}",
          "explanation_after": "This function fails to check if the allocation succeeds, which is a violation of ERR33-C. Detect and handle standard library errors . If the allocation fails, then malloc() returns a null pointer. The null pointer is added to offset and passed as the destination argument to memcpy() . Because a null pointer does not point to a valid object, the result of the pointer arithmetic is undefined behavior 43 .\n\nAn attacker who can supply the arguments to this function can exploit it to execute arbitrary code. This can be accomplished by providing an overly large value for block_size , which causes malloc() to fail and return a null pointer. The offset argument will then serve as the destination address to the call to memcpy() . The attacker can specify the data and data_size arguments to provide the address and length of the address, respectively, that the attacker wishes to write into the memory referenced by offset . The overall result is that the call to memcpy() can be exploited by an attacker to overwrite an arbitrary memory location with an attacker-supplied address, typically resulting in arbitrary code execution."
        },
        "compliant": {
          "heading": "Compliant Solution  (Null Pointer Arithmetic)",
          "pre_code_commentary": "This compliant solution ensures that the call to malloc() succeeds:",
          "code": "#include <string.h>\n#include <stdlib.h>\n\nchar *init_block(size_t block_size, size_t offset,\n                 char *data, size_t data_size) {\n  char *buffer = malloc(block_size);\n  if (NULL == buffer) {\n    /* Handle error */\n  }\n  if (data_size > block_size || block_size - data_size < offset) {\n    /* Data won't fit in buffer, handle error */\n  }\n  memcpy(buffer + offset, data, data_size);\n  return buffer;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Writing to out-of-range pointers or array subscripts can result in a buffer overflow and the execution of arbitrary code with the permissions of the vulnerable process. Reading from out-of-range pointers or array subscripts can result in unintended information disclosure.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ARR32-C",
    "title": "Ensure size arguments for variable length arrays are in a valid range",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ARR32-C.+Ensure+size+arguments+for+variable+length+arrays+are+in+a+valid+range",
    "description": "Variable length arrays (VLAs), a conditionally supported language feature, are essentially the same as traditional C arrays except that they are declared with a size that is not a constant integer expression and can be declared only at block scope or function prototype scope and no linkage. When supported, a variable length array can be declared\n\n{ /* Block scope */\n  char vla[size];\n}\n\n{ /* Block scope */\n  char vla[size];\n}\n\nwhere the integer expression size and the declaration of vla are both evaluated at runtime. If the size argument supplied to a variable length array is not a positive integer value, the behavior is undefined. (See undefined behavior 72 .)  Additionally, if the magnitude of the argument is excessive, the program may behave in an unexpected way. An attacker may be able to leverage this behavior to overwrite critical program data [ Griffiths 2006 ]. The programmer must ensure that size arguments to variable length arrays, especially those derived from untrusted data, are in a valid range.\n\nsize\n\nvla\n\nBecause variable length arrays are a conditionally supported feature of C11, their use in portable code should be guarded by testing the value of the macro __STDC_NO_VLA__ . Implementations that do not support variable length arrays indicate it by setting __STDC_NO_VLA__ to the integer constant 1.\n\n__STDC_NO_VLA__\n\n__STDC_NO_VLA__",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a variable length array of size size is declared. The size is declared as size_t in compliance with INT01-C. Use size_t or rsize_t for all integer values representing the size of an object .",
          "code": "#include <stddef.h>\n\nextern void do_work(int *array, size_t size);\n \nvoid func(size_t size) {\n  int vla[size];\n  do_work(vla, size);\n}\n",
          "explanation_after": "However, the value of size may be zero or excessive, potentially giving rise to a security vulnerability ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution ensures the size argument used to allocate vla is in a valid range (between 1 and a programmer-defined maximum); otherwise, it uses an algorithm that relies on dynamic memory allocation. The solution also avoids unsigned integer wrapping that, given a sufficiently large value of size , would cause malloc to allocate insufficient storage for the array.",
          "code": "#include <stdint.h>\n#include <stdlib.h>\n \nenum { MAX_ARRAY = 1024 };\nextern void do_work(int *array, size_t size);\n \nvoid func(size_t size) {\n  if (0 == size || SIZE_MAX / sizeof(int) < size) {\n    /* Handle error */\n    return;\n  }\n  if (size < MAX_ARRAY) {\n    int vla[size];\n    do_work(vla, size);\n  } else {\n    int *array = (int *)malloc(size * sizeof(int));\n    if (array == NULL) {\n      /* Handle error */\n    }\n    do_work(array, size);\n    free(array);\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( sizeof )",
          "pre_code_commentary": "The following noncompliant code example defines A to be a variable length array and then uses the sizeof operator to compute its size at runtime. When the function is called with an argument greater than SIZE_MAX / (N1 * sizeof (int)) , the runtime sizeof expression may wrap around, yielding a result that is smaller than the mathematical product N1 * n2 * sizeof (int) . The call to malloc() , when successful, will then allocate storage for fewer than n2 elements of the array, causing one or more of the final memset() calls in the for loop to write past the end of that storage.",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nenum { N1 = 4096 };\n\nvoid *func(size_t n2) {\n  typedef int A[n2][N1];\n\n  A *array = malloc(sizeof(A));\n  if (!array) {\n    /* Handle error */\n    return NULL;\n  }\n\n  for (size_t i = 0; i != n2; ++i) {\n    memset(array[i], 0, N1 * sizeof(int));\n  }\n\n  return array;\n}\n",
          "explanation_after": "Furthermore, this code also violates ARR39-C. Do not add or subtract a scaled integer to a pointer , where array is a pointer to the two-dimensional array, where it should really be a pointer to the latter dimension instead. This means that the memset() call does out-of-bounds writes on all of its invocations except the first."
        },
        "compliant": {
          "heading": "Compliant Solution ( sizeof )",
          "pre_code_commentary": "This compliant solution prevents sizeof wrapping by detecting the condition before it occurs and avoiding the subsequent computation when the condition is detected. The code also uses an additional typedef to fix the type of array so that memset() never writes past the two-dimensional array.",
          "code": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n \nenum { N1 = 4096 };\n\nvoid *func(size_t n2) {\n  if (n2 > SIZE_MAX / (N1 * sizeof(int))) {\n    /* Prevent sizeof wrapping */\n    return NULL;\n  }\n\n  typedef int A1[N1];\n  typedef A1 A[n2];\n\n  A1 *array = (A1*) malloc(sizeof(A));\n\n  if (!array) {\n    /* Handle error */\n    return NULL;\n  } \n\n  for (size_t i = 0; i != n2; ++i) {\n    memset(array[i], 0, N1 * sizeof(int));\n  }\n  return array;\n}\n",
          "explanation_after": "Variable length arrays are not supported by Microsoft compilers."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to properly specify the size of a variable length array may allow arbitrary code execution or result in stack exhaustion.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ARR36-C",
    "title": "Do not subtract or compare two pointers that do not refer to the same array",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ARR36-C.+Do+not+subtract+or+compare+two+pointers+that+do+not+refer+to+the+same+array",
    "description": "When two pointers are subtracted, both must point to elements of the same array object or just one past the last element of the array object (C Standard, 6.5.7 [ ISO/IEC 9899:2024 ]); the result is the difference of the subscripts of the two array elements. Otherwise, the operation is undefined behavior . (See undefined behavior 45 .)\n\nSimilarly, comparing pointers using the relational operators < , <= , >= , and > gives the positions of the pointers relative to each other. Subtracting or comparing pointers that do not refer to the same array is undefined behavior. (See undefined behavior 45 and undefined behavior 50 .)\n\n<\n\n<=\n\n>=\n\n>\n\nComparing pointers using the equality operators == and != has well-defined semantics regardless of whether or not either of the pointers is null, points into the same object, or points one past the last element of an array object or function.\n\n==\n\n!=",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, pointer subtraction is used to determine how many free elements are left in the nums array:",
          "code": "#include <stddef.h>\n \nenum { SIZE = 32 };\n \nvoid func(void) {\n  int nums[SIZE];\n  int end;\n  int *next_num_ptr = nums;\n  size_t free_elements;\n\n  /* Increment next_num_ptr as array fills */\n\n  free_elements = &end - next_num_ptr;\n}",
          "explanation_after": "This program incorrectly assumes that the nums array is adjacent to the end variable in memory. A compiler is permitted to insert padding bits between these two variables or even reorder them in memory."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the number of free elements is computed by subtracting next_num_ptr from the address of the pointer past the nums array. While this pointer may not be dereferenced, it may be used in pointer arithmetic.",
          "code": "#include <stddef.h>\nenum { SIZE = 32 };\n \nvoid func(void) {\n  int nums[SIZE];\n  int *next_num_ptr = nums;\n  size_t free_elements;\n\n  /* Increment next_num_ptr as array fills */\n\n  free_elements = &(nums[SIZE]) - next_num_ptr;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ARR37-C",
    "title": "Do not add or subtract an integer to a pointer to a non-array object",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ARR37-C.+Do+not+add+or+subtract+an+integer+to+a+pointer+to+a+non-array+object",
    "description": "Pointer arithmetic must be performed only on pointers that reference elements of array objects.\n\nThe C Standard, 6.5.7 [ ISO/IEC 9899:2024 ], states the following about pointer arithmetic:\n\nWhen an expression that has integer type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to access structure members using pointer arithmetic. This practice is dangerous because structure members are not guaranteed to be contiguous.",
          "code": "struct numbers {\n  short num_a, num_b, num_c;\n};\n\nint sum_numbers(const struct numbers *numb){\n  int total = 0;\n  const short *numb_ptr;\n\n  for (numb_ptr = &numb->num_a;\n       numb_ptr <= &numb->num_c;\n       numb_ptr++) {\n    total += *(numb_ptr);\n  }\n\n  return total;\n}\n\nint main(void) {\n  struct numbers my_numbers = { 1, 2, 3 };\n  sum_numbers(&my_numbers);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "It is possible to use the -> operator to dereference each structure member:",
          "code": "total = numb->num_a + numb->num_b + numb->num_c;\n",
          "explanation_after": "However, this solution results in code that is hard to write and hard to maintain (especially if there are many more structure members), which is exactly what the author of the noncompliant code example was likely trying to avoid."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to access structure members using pointer arithmetic. This practice is dangerous because structure members are not guaranteed to be contiguous.",
          "code": "struct numbers {\n  short num_a, num_b, num_c;\n};\n\nint sum_numbers(const struct numbers *numb){\n  int total = 0;\n  const short *numb_ptr;\n\n  for (numb_ptr = &numb->num_a;\n       numb_ptr <= &numb->num_c;\n       numb_ptr++) {\n    total += *(numb_ptr);\n  }\n\n  return total;\n}\n\nint main(void) {\n  struct numbers my_numbers = { 1, 2, 3 };\n  sum_numbers(&my_numbers);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "A better solution is to define the structure to contain an array member to store the numbers in an array rather than a structure, as in this compliant solution:",
          "code": "#include <stddef.h>\n\nstruct numbers {\n  short a[3];\n};\n\nint sum_numbers(const short *numb, size_t dim) {\n  int total = 0;\n  for (size_t i = 0; i < dim; ++i) {\n    total += numb[i];\n  }\n\n  return total;\n}\n\nint main(void) {\n  struct numbers my_numbers = { .a[0]= 1, .a[1]= 2, .a[2]= 3};\n  sum_numbers(\n    my_numbers.a,\n    sizeof(my_numbers.a)/sizeof(my_numbers.a[0])\n  );\n  return 0;\n}\n",
          "explanation_after": "Array elements are guaranteed to be contiguous in memory, so this solution is completely portable."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ARR38-C",
    "title": "Guarantee that library functions do not form invalid pointers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ARR38-C.+Guarantee+that+library+functions+do+not+form+invalid+pointers",
    "description": "C library functions that make changes to arrays or objects take at least two arguments: a pointer to the array or object and an integer indicating the number of elements or bytes to be manipulated. For the purposes of this rule, the element count of a pointer is the size of the object to which it points, expressed by the number of elements that are valid to access. Supplying arguments to such a function might cause the function to form a pointer that does not point into or just past the end of the object, resulting in undefined behavior .\n\nAnnex J of the C Standard [ ISO/IEC 9899:2024 ] states that it is undefined behavior if the \"pointer passed to a library function array parameter does not have a value such that all address computations and object accesses are valid.\" (See undefined behavior 108 .)\n\nIn the following code,\n\nint arr[5];\nint *p = arr;\n\nunsigned char *p2 = (unsigned char *)arr;\nunsigned char *p3 = arr + 2;\nvoid *p4 = arr;\n\nint arr[5];\nint *p = arr;\n\nunsigned char *p2 = (unsigned char *)arr;\nunsigned char *p3 = arr + 2;\nvoid *p4 = arr;\n\nthe element count of the pointer p is sizeof(arr) / sizeof(arr[0]) , that is, 5 . The element count of the pointer p2 is sizeof(arr) , that is, 20 , on implementations where sizeof(int) == 4 . The element count of the pointer p3 is 12 on implementations where sizeof(int) == 4 , because p3 points two elements past the start of the array arr .  The element count of p4 is treated as though it were unsigned char * instead of void * , so it is the same as p2 .\n\np\n\nsizeof(arr) / sizeof(arr[0])\n\n5\n\np2\n\nsizeof(arr)\n\n20\n\nsizeof(int) == 4\n\np3\n\n12\n\nsizeof(int) == 4\n\np3\n\narr\n\np4\n\nunsigned char *\n\nvoid *\n\np2",
    "examples": null,
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ARR39-C",
    "title": "Do not add or subtract a scaled integer to a pointer",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ARR39-C.+Do+not+add+or+subtract+a+scaled+integer+to+a+pointer",
    "description": "Pointer arithmetic is appropriate only when the pointer argument refers to an array (see ARR37-C. Do not add or subtract an integer to a pointer to a non-array object ), including an array of bytes. When performing pointer arithmetic, the size of the value to add to or subtract from a pointer is automatically scaled to the size of the type of the referenced array object. Adding or subtracting a scaled integer value to or from a pointer is invalid because it may yield a pointer that does not point to an element within or one past the end of the array. (See ARR30-C. Do not form or use out-of-bounds pointers or array subscripts .)\n\nAdding a pointer to an array of a type other than character to the result of the sizeof operator or offsetof macro, which returns a size and an offset, respectively, violates this rule. However, adding an array pointer to the number of array elements, for example, by using the arr[sizeof(arr)/sizeof(arr[0])]) idiom, is allowed provided that arr refers to an array and not a pointer.\n\nsizeof\n\noffsetof\n\narr[sizeof(arr)/sizeof(arr[0])])\n\narr",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, sizeof(buf) is added to the array buf . This example is noncompliant because sizeof(buf) is scaled by int and then scaled again when added to buf .",
          "code": "enum { INTBUFSIZE = 80 };\n\nextern int getdata(void);\nint buf[INTBUFSIZE];\n \nvoid func(void) {\n  int *buf_ptr = buf;\n\n  while (buf_ptr < (buf + sizeof(buf))) {\n    *buf_ptr++ = getdata();\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses an unscaled integer to obtain a pointer to the end of the array:",
          "code": "enum { INTBUFSIZE = 80 };\n\nextern int getdata(void);\nint buf[INTBUFSIZE];\n\nvoid func(void) {\n  int *buf_ptr = buf;\n\n  while (buf_ptr < (buf + INTBUFSIZE)) {\n    *buf_ptr++ = getdata();\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, skip is added to the pointer s . However, skip represents the byte offset of ull_b in struct big . When added to s , skip is scaled by the size of struct big .",
          "code": "#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n \nstruct big {\n  unsigned long long ull_a;\n  unsigned long long ull_b;\n  unsigned long long ull_c;\n  int si_e;\n  int si_f;\n};\n\nvoid func(void) {\n  size_t skip = offsetof(struct big, ull_b);\n  struct big *s = (struct big *)malloc(sizeof(struct big));\n  if (s == NULL) {\n    /* Handle malloc() error */\n  }\n\n  memset(s + skip, 0, sizeof(struct big) - skip);\n  /* ... */\n  free(s);\n  s = NULL;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses an unsigned char * to calculate the offset instead of using a struct big * , which would result in scaled arithmetic:",
          "code": "#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n \nstruct big {\n  unsigned long long ull_a;\n  unsigned long long ull_b;\n  unsigned long long ull_c;\n  int si_d;\n  int si_e;\n};\n\nvoid func(void) {\n  size_t skip = offsetof(struct big, ull_b);\n  unsigned char *ptr = (unsigned char *)malloc(\n    sizeof(struct big)\n  );\n  if (ptr == NULL) {\n     /* Handle malloc() error */\n  }\n\n  memset(ptr + skip, 0, sizeof(struct big) - skip);\n  /* ... */\n  free(ptr);\n  ptr = NULL;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, wcslen(error_msg) * sizeof(wchar_t) bytes are scaled by the size of wchar_t when added to error_msg :",
          "code": "#include <wchar.h>\n#include <stdio.h>\n \nenum { WCHAR_BUF = 128 };\n \nvoid func(void) {\n  wchar_t error_msg[WCHAR_BUF];\n\n  wcscpy(error_msg, L\"Error: \");\n  fgetws(error_msg + wcslen(error_msg) * sizeof(wchar_t), \n         WCHAR_BUF - 7, stdin);\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not scale the length of the string; wcslen() returns the number of characters and the addition to error_msg is scaled:",
          "code": "#include <wchar.h>\n#include <stdio.h>\n\nenum { WCHAR_BUF = 128 };\nconst wchar_t ERROR_PREFIX[7] = L\"Error: \";\n\nvoid func(void) {\n  const size_t prefix_len = wcslen(ERROR_PREFIX);\n  wchar_t error_msg[WCHAR_BUF];\n\n  wcscpy(error_msg, ERROR_PREFIX);\n  fgetws(error_msg + prefix_len,\n        WCHAR_BUF - prefix_len, stdin);\n  /* ... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to understand and properly use pointer arithmetic can allow an attacker to execute arbitrary code.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "CON01-C",
    "title": "Acquire and release synchronization primitives in the same module, at the same level of abstraction",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON01-C.+Acquire+and+release+synchronization+primitives+in+the+same+module%2C+at+the+same+level+of+abstraction",
    "description": "All locking and unlocking of mutexes should be performed in the same module and at the same level of abstraction. Failure to follow this recommendation can lead to some lock or unlock operations not being executed by the multithreaded program as designed, eventually resulting in deadlock, race conditions, or other security vulnerabilities , depending on the mutex type.\n\nA common consequence of improper locking is for a mutex to be unlocked twice, via two calls to mtx_unlock() . This can cause the unlock operation to return errors. In the case of recursive mutexes, an error is returned only if the lock count is 0 (making the mutex available to other threads) and a call to mtx_unlock() is made.\n\n mtx_unlock()\n\nmtx_unlock()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example for a simplified multithreaded banking system, imagine an account with a required minimum balance. The code would need to verify that all debit transactions are allowable. Suppose a call is made to debit() asking to withdraw funds that would bring account_balance below MIN_BALANCE , which would result in two calls to mtx_unlock() . In this example, because the mutex is defined statically, the mutex type is implementation-defined .",
          "code": "#include <threads.h>\n\nenum { MIN_BALANCE = 50 };\n\nint account_balance;\nmtx_t mp;\n\n/* Initialize mp */\n\nint verify_balance(int amount) {\n  if (account_balance - amount < MIN_BALANCE) {\n    /* Handle error condition */\n    if (mtx_unlock(&mp) ==  thrd_error) {\n      /* Handle error */\n    }\n    return -1;\n  }\n  return 0;\n}\n\nvoid debit(int amount) {\n  if (mtx_lock(&mp) == thrd_error) {\n    /* Handle error */\n  }\n  if (verify_balance(amount) == -1) {\n    if (mtx_unlock(&mp) == thrd_error) {\n      /* Handle error */\n    }\n    return;\n  }\n  account_balance -= amount;\n  if (mtx_unlock(&mp) == thrd_error) {\n    /* Handle error */\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution unlocks the mutex only in the same module and at the same level of abstraction at which it is locked. This technique ensures that the code will not attempt to unlock the mutex twice.",
          "code": "#include <threads.h>\n\nenum { MIN_BALANCE = 50 };\n\nstatic int account_balance;\nstatic mtx_t mp;\n\n/* Initialize mp */\n\nstatic int verify_balance(int amount) {\n  if (account_balance - amount < MIN_BALANCE) {\n    return -1;   /* Indicate error to caller */\n  }\n\n  return 0;  /* Indicate success to caller */\n}\n\nint debit(int amount) {\n  if (mtx_lock(&mp) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n\n  if (verify_balance(amount)) {\n    mtx_unlock(&mp);\n    return -1;   /* Indicate error to caller */\n  }\n\n  account_balance -= amount;\n\n  if (mtx_unlock(&mp) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n\n  return 0;   /* Indicate success */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Improper use of mutexes can result in denial-of-service attacks or the unexpected termination of a multithreaded program.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON02-C",
    "title": "Do not use volatile as a synchronization primitive",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive",
    "description": "The C Standard, subclause 5.1.2.3, paragraph 2 [ ISO/IEC 9899:2011 ], says:\n\nAccessing a volatile object, modifying an object, modifying a file, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment. Evaluation of an expression in general includes both value computations and initiation of side effects. Value computation for an lvalue expression includes determining the identity of the designated object.\n\nThe volatile keyword informs the compiler that the qualified variable may change in ways that cannot be determined; consequently, compiler optimizations must be restricted for memory areas marked as volatile . For example, the compiler is forbidden to load the value into a register and subsequently reuse the loaded value rather than accessing memory directly. This concept relates to multithreading because incorrect caching of a shared variable may interfere with the propagation of modified values between threads, causing some threads to view stale data.\n\nvolatile\n\nvolatile\n\nThe volatile keyword is sometimes misunderstood to provide atomicity for variables that are shared between threads in a multithreaded program. Because the compiler is forbidden to either cache variables declared as volatile in registers or to reorder the sequence of reads and writes to any given volatile variable, many programmers mistakenly believe that volatile variables can correctly serve as synchronization primitives. Although the compiler is forbidden to reorder the sequence of reads and writes to a particular volatile variable, it may legally reorder these reads and writes with respect to reads and writes to other memory locations. This reordering alone is sufficient to make volatile variables unsuitable for use as synchronization primitives.\n\nvolatile\n\nvolatile\n\nFurther, the volatile qualifier lacks any guarantees regarding the following desired properties necessary for a multithreaded program:\n\nvolatile\n\nAtomicity: Indivisible memory operations. Visibility: The effects of a write action by a thread are visible to other threads. Ordering: Sequences of memory operations by a thread are guaranteed to be seen in the same order by other threads.\n\nThe volatile qualifier lacks guarantees for any of these properties, both by definition and by the way it is implemented in various platforms. For more information on how volatile is implemented, consult DCL17-C. Beware of miscompiled volatile-qualified variables .\n\nvolatile\n\nvolatile",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to use flag as a synchronization primitive:",
          "code": "bool flag = false;\n\nvoid test() {\n  while (!flag) {\n    sleep(1000);\n  }\n}\n\nvoid wakeup(){\n  flag = true;\n}\n\nvoid debit(unsigned int amount){\n  test();\n  account_balance -= amount;\n}\n",
          "explanation_after": "In this example, the value of flag is used to determine whether the critical section can be executed. Because the flag variable is not declared volatile , it may be cached in registers. Before the value in the register is written to memory, another thread might be scheduled to run, resulting in that thread reading stale data."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example uses flag as a synchronization primitive but qualifies flag as a volatile type:",
          "code": "volatile bool flag = false;\n\nvoid test() {\n  while (!flag){\n    sleep(1000);\n  }\n}\n\nvoid wakeup(){\n  flag = true;\n}\n\nvoid debit(unsigned int amount) {\n  test();\n  account_balance -= amount;\n}\n",
          "explanation_after": "Declaring flag as volatile solves the problem of values being cached, which causes stale data to be read. However, volatile flag still fails to provide the atomicity and visibility guarantees needed for synchronization primitives to work correctly. The volatile keyword does not promise to provide the guarantees needed for synchronization primitives."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This code uses a mutex to protect critical sections:",
          "code": "#include <threads.h>\n\nint account_balance;\nmtx_t flag;\n\n/* Initialize flag */\n\nint debit(unsigned int amount) {\n  if (mtx_lock(&flag) == thrd_error) {\n    return -1;  /* Indicate error */\n  }\n \n  account_balance -= amount; /* Inside critical section */\n\n  if (mtx_unlock(&flag) == thrd_error) {\n    return -1;  /* Indicate error */\n  }\n\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example uses flag as a synchronization primitive but qualifies flag as a volatile type:",
          "code": "volatile bool flag = false;\n\nvoid test() {\n  while (!flag){\n    sleep(1000);\n  }\n}\n\nvoid wakeup(){\n  flag = true;\n}\n\nvoid debit(unsigned int amount) {\n  test();\n  account_balance -= amount;\n}\n",
          "explanation_after": "Declaring flag as volatile solves the problem of values being cached, which causes stale data to be read. However, volatile flag still fails to provide the atomicity and visibility guarantees needed for synchronization primitives to work correctly. The volatile keyword does not promise to provide the guarantees needed for synchronization primitives."
        },
        "compliant": {
          "heading": "Compliant Solution (Critical Section, Windows)",
          "pre_code_commentary": "This compliant solution uses a Microsoft Windows critical section object to make operations involving account_balance atomic [ MSDN ].",
          "code": "#include <Windows.h>\n\nstatic volatile LONG account_balance;\nCRITICAL_SECTION flag;\n\n/* Initialize flag */\nInitializeCriticalSection(&flag);\n \nint debit(unsigned int amount) {\n  EnterCriticalSection(&flag); \n  account_balance -= amount; /* Inside critical section */\n  LeaveCriticalSection(&flag);\n \n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON03-C",
    "title": "Ensure visibility when accessing shared variables",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON03-C.+Ensure+visibility+when+accessing+shared+variables",
    "description": "Reading a shared primitive variable in one thread may not yield the value of the most recent write to the variable from another thread. Consequently, the thread may observe a stale value of the shared variable. To ensure the visibility of the most recent update, the write to the variable must happen before the read (C Standard, subclause 5.1.2.4, paragraph 18 [ ISO/IEC 9899:2011 ]). Atomic operations—other than relaxed atomic operations—trivially satisfy the happens before relationship. Where atomic operations are inappropriate, protecting both reads and writes with a mutex also satisfies the happens before relationship.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Non-volatile Flag)",
          "pre_code_commentary": "This noncompliant code example uses a shutdown() method to set the non-volatile done flag that is checked in the run() method.",
          "code": "final class ControlledStop implements Runnable {\n  private boolean done = false;\n \n  @Override public void run() {\n    while (!done) {\n      try {\n        // ...\n        Thread.currentThread().sleep(1000); // Do something\n      } catch(InterruptedException ie) { \n        Thread.currentThread().interrupt(); // Reset interrupted status\n      } \n    } \t \n  }\n\n  public void shutdown() {\n    done = true;\n  }\n}\n\n",
          "explanation_after": "If one thread invokes the shutdown() method to set the flag, a second thread might not observe that change. Consequently, the second thread might observe that done is still false and incorrectly invoke the sleep() method. Compilers and just-in-time compilers (JITs) are allowed to optimize the code when they determine that the value of done is never modified by the same thread, resulting in an infinite loop."
        },
        "compliant": {
          "heading": "Compliant Solution ( Volatile )",
          "pre_code_commentary": "In this compliant solution, the done flag is declared volatile to ensure that writes are visible to other threads.",
          "code": "final class ControlledStop implements Runnable {\n  private volatile boolean done = false;\n \n  @Override public void run() {\n    while (!done) {\n      try {\n        // ...\n        Thread.currentThread().sleep(1000); // Do something\n      } catch(InterruptedException ie) { \n        Thread.currentThread().interrupt(); // Reset interrupted status\n      } \n    } \t \n  }\n\n  public void shutdown() {\n    done = true;\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Non-volatile Flag)",
          "pre_code_commentary": "This noncompliant code example uses a shutdown() method to set the non-volatile done flag that is checked in the run() method.",
          "code": "final class ControlledStop implements Runnable {\n  private boolean done = false;\n \n  @Override public void run() {\n    while (!done) {\n      try {\n        // ...\n        Thread.currentThread().sleep(1000); // Do something\n      } catch(InterruptedException ie) { \n        Thread.currentThread().interrupt(); // Reset interrupted status\n      } \n    } \t \n  }\n\n  public void shutdown() {\n    done = true;\n  }\n}\n\n",
          "explanation_after": "If one thread invokes the shutdown() method to set the flag, a second thread might not observe that change. Consequently, the second thread might observe that done is still false and incorrectly invoke the sleep() method. Compilers and just-in-time compilers (JITs) are allowed to optimize the code when they determine that the value of done is never modified by the same thread, resulting in an infinite loop."
        },
        "compliant": {
          "heading": "Compliant Solution ( AtomicBoolean )",
          "pre_code_commentary": "In this compliant solution, the done flag is declared to be of type java.util.concurrent.atomic.AtomicBoolean . Atomic types also guarantee that writes are visible to other threads.",
          "code": "final class ControlledStop implements Runnable {\n  private final AtomicBoolean done = new AtomicBoolean(false);\n \n  @Override public void run() {\n    while (!done.get()) {\n      try {\n        // ...\n        Thread.currentThread().sleep(1000); // Do something\n      } catch(InterruptedException ie) { \n        Thread.currentThread().interrupt(); // Reset interrupted status\n      } \n    } \t \n  }\n\n  public void shutdown() {\n    done.set(true);\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Non-volatile Flag)",
          "pre_code_commentary": "This noncompliant code example uses a shutdown() method to set the non-volatile done flag that is checked in the run() method.",
          "code": "final class ControlledStop implements Runnable {\n  private boolean done = false;\n \n  @Override public void run() {\n    while (!done) {\n      try {\n        // ...\n        Thread.currentThread().sleep(1000); // Do something\n      } catch(InterruptedException ie) { \n        Thread.currentThread().interrupt(); // Reset interrupted status\n      } \n    } \t \n  }\n\n  public void shutdown() {\n    done = true;\n  }\n}\n\n",
          "explanation_after": "If one thread invokes the shutdown() method to set the flag, a second thread might not observe that change. Consequently, the second thread might observe that done is still false and incorrectly invoke the sleep() method. Compilers and just-in-time compilers (JITs) are allowed to optimize the code when they determine that the value of done is never modified by the same thread, resulting in an infinite loop."
        },
        "compliant": {
          "heading": "Compliant Solution ( synchronized )",
          "pre_code_commentary": "This compliant solution uses the intrinsic lock of the Class object to ensure that updates are visible to other threads.",
          "code": "final class ControlledStop implements Runnable {\n  private boolean done = false;\n \n  @Override public void run() {\n    while (!isDone()) {\n      try {\n        // ...\n        Thread.currentThread().sleep(1000); // Do something\n      } catch(InterruptedException ie) { \n        Thread.currentThread().interrupt(); // Reset interrupted status\n      } \n    } \t \n  }\n\n  public synchronized boolean isDone() {\n    return done;\n  }\n\n  public synchronized void shutdown() {\n    done = true;\n  }\n}\n",
          "explanation_after": "While this is an acceptable compliant solution, intrinsic locks cause threads to block and may introduce contention. On the other hand, volatile-qualified shared variables do not block. Excessive synchronization can also make the program prone to deadlock.\n\nSynchronization is a more secure alternative in situations where the volatile keyword or a java.util.concurrent.atomic.Atomic* field is inappropriate, such as when a variable's new value depends on its current value. See rule VNA02-J. Ensure that compound operations on shared variables are atomic for more information.\n\nCompliance with rule LCK00-J. Use private final lock objects to synchronize classes that may interact with untrusted code can reduce the likelihood of misuse by ensuring that untrusted callers cannot access the lock object."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON04-C",
    "title": "Join or detach threads even if their exit status is unimportant",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON04-C.+Join+or+detach+threads+even+if+their+exit+status+is+unimportant",
    "description": "The thrd_detach() function is used to tell the underlying system that resources allocated to a particular thread can be reclaimed once it terminates. This function should be used when a thread's exit status is not required by other threads (and no other thread needs to use thrd_join() to wait for it to complete).\n\n thrd_detach()\n\nthrd_join()\n\nWhenever a thread terminates without detaching, the thread's stack is deallocated, but some other resources, including the thread ID and exit status, are left until it is destroyed by either thrd_join() or thrd_detach() . These resources can be vital for systems with limited resources and can lead to various \"resource unavailable\" errors, depending on which critical resource gets used up first. For example, if the system has a limit (either per-process or system wide) on the number of thread IDs it can keep track of, failure to release the thread ID of a terminated thread may lead to thrd_create() being unable to create another thread.\n\nthrd_join()\n\nthrd_detach()\n\nthrd_create() being unable to",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example shows a pool of threads that are not exited correctly:",
          "code": "#include <stdio.h>\n#include <threads.h>\n \nconst size_t thread_no = 5;\nconst char mess[] = \"This is a test\";\n\nint message_print(void *ptr){\n  const char *msg = (const char *) ptr;\n  printf(\"THREAD: This is the Message %s\\n\", msg);\n  return 0;\n}\n\nint main(void){\n  /* Create a pool of threads */\n  thrd_t thr[thread_no];\n  for (size_t i = 0; i < thread_no; ++i) {\n    if (thrd_create(&(thr[i]), message_print,\n                    (void *)mess) != thrd_success) {\n      fprintf(stderr, \"Creation of thread %zu failed\\n\", i);\n      /* Handle error */\n    }\n  }\n  printf(\"MAIN: Thread Message: %s\\n\", mess);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the message_print() function is replaced by a similar function that correctly detaches the threads so that the associated resources can be reclaimed on exit:",
          "code": "#include <stdio.h>\n#include <threads.h>\n \nconst size_t thread_no = 5;\nconst char mess[] = \"This is a test\";\n\nint message_print(void *ptr){\n  const char *msg = (const char *)ptr;\n  printf(\"THREAD: This is the Message %s\\n\", msg);\n \n  /* Detach the thread, check the return code for errors */\n  if (thrd_detach(thrd_current()) != thrd_success) {\n    /* Handle error */\n  }\n  return 0;\n}\n\nint main(void) {\n  /* Create a pool of threads */\n  thrd_t thr[thread_no];\n  for(size_t i = 0; i < thread_no; ++i) {\n    if (thrd_create(&(thr[i]), message_print,\n                    (void *)mess) != thrd_success) {\n      fprintf(stderr, \"Creation of thread %zu failed\\n\", i);\n      /* Handle error */\n    }\n  }\n  printf(\"MAIN: Thread Message: %s\\n\", mess);\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON05-C",
    "title": "Do not perform operations that can block while holding a lock",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON05-C.+Do+not+perform+operations+that+can+block+while+holding+a+lock",
    "description": "If a lock is being held and an operation that can block is performed, any other thread that needs to acquire that lock may also block. This condition can degrade system performance or cause a deadlock to occur.  Blocking calls include, but are not limited to, network, file, and console I/O.\n\nUsing a blocking operation while holding a lock may be unavoidable for a portable solution. For instance, file access could be protected via a lock to prevent multiple threads from mutating the contents of the file. Or, a thread may be required to block while holding one or more locks and waiting to acquire another lock. In these cases, attempt to hold the lock for the least time required. Additionally, if acquiring multiple locks, the order of locking must avoid deadlock, as specified in CON35-C. Avoid deadlock by locking in a predefined order .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant example calls fopen() while a mutex is locked. The calls to fopen() and fclose() are blocking and may block for an extended period of time if the file resides on a network drive. While the call is blocked, other threads that are waiting for the lock are also blocked.",
          "code": "#include <stdio.h>\n#include <threads.h>\n \nmtx_t mutex;\n\nint thread_foo(void *ptr) {\n  int result;\n  FILE *fp;\n\n  if ((result = mtx_lock(&mutex)) != thrd_success) {\n    /* Handle error */\n  }\n \n  fp = fopen(\"SomeNetworkFile\", \"r\");\n  if (fp != NULL) {\n    /* Work with the file */\n    fclose(fp);\n  }\n \n  if ((result = mtx_unlock(&mutex)) != thrd_success) {\n    /* Handle error */\n  }\n\n  return 0;\n}\n\nint main(void) {\n  thrd_t thread;\n  int result;\n\n  if ((result = mtx_init(&mutex, mtx_plain)) != thrd_success) {\n    /* Handle error */\n  }\n\n  if (thrd_create(&thread, thread_foo, NULL) != thrd_success) {\n    /* Handle error */\n  }\n\n  /* ... */\n\n  if (thrd_join(thread, NULL) != thrd_success) {\n    /* Handle error */\n  }\n\n  mtx_destroy(&mutex);\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Block while Not Locked)",
          "pre_code_commentary": "This compliant solution performs the file operations when the lock has not been acquired. The blocking behavior consequently affects only the thread that called the blocking function.",
          "code": "#include <stdio.h>\n#include <threads.h>\n \nmtx_t mutex;\n \nint thread_foo(void *ptr) {\n  int result;\n  FILE *fp = fopen(\"SomeNetworkFile\", \"r\");\n \n  if (fp != NULL) {\n    /* Work with the file */\n    fclose(fp);\n  }\n\n  if ((result = mtx_lock(&mutex)) != thrd_success) {\n    /* Handle error */\n  }\n\n  /* ... */\n\n  if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle error */\n  }\n\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Blocking or lengthy operations performed within synchronized regions could result in a deadlocked or an unresponsive system.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON06-C",
    "title": "Ensure that every mutex outlives the data it protects",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON06-C.+Ensure+that+every+mutex+outlives+the+data+it+protects",
    "description": null,
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Nonstatic Lock Object for Static Data)",
          "pre_code_commentary": "This noncompliant code example attempts to guard access to the static counter field using a non-static lock object. When two Runnable tasks are started, they create two instances of the lock object and lock on each instance separately.\n\nThis example fails to prevent either thread from observing an inconsistent value of counter because the increment operation on volatile fields fails to be atomic in the absence of proper synchronization. (See rule VNA02-J. Ensure that compound operations on shared variables are atomic for more information.)",
          "code": null,
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Method Synchronization for Static Data)",
          "pre_code_commentary": "This noncompliant code example uses method synchronization to protect access to a static class counter field.\n\nIn this case, the method synchronization uses the intrinsic lock associated with each instance of the class rather than the intrinsic lock associated with the class itself. Consequently, threads constructed using different Runnable instances may observe inconsistent values of counter .",
          "code": null,
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Static Lock Object)",
          "pre_code_commentary": "This compliant solution ensures the atomicity of the increment operation by locking on a static object.\n\nIt is unnecessary to declare the counter variable volatile when using synchronization.",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using an instance lock to protect static shared data can result in nondeterministic behavior.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON07-C",
    "title": "Ensure that compound operations on shared variables are atomic",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON07-C.+Ensure+that+compound+operations+on+shared+variables+are+atomic",
    "description": "Compound operations are operations that consist of more than one discrete operation. Expressions that include postfix or prefix increment ( ++ ), postfix or prefix decrement ( -- ), or compound assignment operators always result in compound operations. Compound assignment expressions use operators such as *= , /= , %= , += , -= , <<= , >>= , ^= , and |= . Compound operations on shared variables must be performed atomically to prevent data races . Noncompliant Code Example (Logical Negation) This noncompliant code example declares a shared _Bool flag variable and provides a toggle_flag() method that negates the current value of flag : #include <stdbool.h>\n \nstatic bool flag = false;\n \nvoid toggle_flag(void) {\n  flag = !flag;\n}\n \nbool get_flag(void) {\n  return flag;\n} Execution of this code may result in a data race because the value of flag is read, negated, and written back. Consider, for example, two threads that call toggle_flag() . The expected effect of toggling flag twice is that it is restored to its original value. However, the following scenario leaves flag in the incorrect state: Time flag= Thread Action 1 true t 1 Reads the current value of flag , true , into a cache 2 true t 2 Reads the current value of flag , (still) true , into a different cache 3 true t 1 Toggles the temporary variable in the cache to false 4 true t 2 Toggles the temporary variable in the different cache to false 5 false t 1 Writes the cache variable's value to flag 6 false t 2 Writes the different cache variable's value to flag As a result, the effect of the call by t 2 is not reflected in flag ; the program behaves as if toggle_flag() was called only once, not twice. Compliant Solution (Mutex) This compliant solution restricts access to flag under a mutex lock: #include <threads.h>\n#include <stdbool.h>\n \nstatic bool flag = false;\nmtx_t flag_mutex;\n\n/* Initialize flag_mutex */\nbool init_mutex(int type) {\n  /* Check mutex type */\n  if (thrd_success != mtx_init(&flag_mutex, type)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n \nvoid toggle_flag(void) {\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  flag = !flag;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n}\n \nbool get_flag(void) {\n  bool temp_flag;\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  temp_flag = flag;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n  return temp_flag;\n} This solution guards reads and writes to the flag field with a lock on the flag_mutex . This lock ensures that changes to flag are visible to all threads. Now, only two execution orders are possible. In one execution order, t 1 obtains the mutex and completes the operation before t 2 can acquire the mutex, as shown here: Time flag= Thread Action 1 true t 1 Reads the current value of flag , true , into a cache variable 2 true t 1 Toggles the cache variable to false 3 false t 1 Writes the cache variable's value to flag 4 false t 2 Reads the current value of flag , false , into a different cache variable 5 false t 2 Toggles the different cache variable to true 6 true t 2 Writes the different cache variable's value to flag The other execution order is similar, except that t 2 starts and finishes before t 1 . Compliant Solution ( atomic_compare_exchange_weak() ) This compliant solution uses atomic variables and a compare-and-exchange operation to guarantee that the correct value is stored in flag . All updates are visible to other threads. #include <stdatomic.h>\n#include <stdbool.h>\n \nstatic atomic_bool flag;\n\nvoid init_flag(void) {\n  atomic_init(&flag, false);\n}\nvoid toggle_flag(void) {\n  bool old_flag = atomic_load(&flag);\n  bool new_flag;\n  do {\n    new_flag = !old_flag;\n  } while (!atomic_compare_exchange_weak(&flag, &old_flag, new_flag));\n}\n  \nbool get_flag(void) {\n  return atomic_load(&flag);\n} An alternative solution is to use the atomic_flag data type for managing Boolean values atomically. Noncompliant Code Example (Addition of Primitives) In this noncompliant code example, multiple threads can invoke the set_values() method to set the a and b fields. Because this code fails to test for integer overflow, users of this code must also ensure that the arguments to the set_values() method can be added without overflow (see INT32-C. Ensure that operations on signed integers do not result in overflow for more information). static int a;\nstatic int b;\n \nint get_sum(void) {\n  return a + b;\n}\n \nvoid set_values(int new_a, int new_b) {\n  a = new_a;\n  b = new_b;\n} The get_sum() method contains a race condition. For example, when a and b currently have the values 0 and INT_MAX , respectively, and one thread calls get_sum() while another calls set_values(INT_MAX, 0) , the get_sum() method might return either 0 or INT_MAX , or it might overflow. Overflow will occur when the first thread reads a and b after the second thread has set the value of a to INT_MAX but before it has set the value of b to 0 . Noncompliant Code Example (Addition of Atomic Integers) In this noncompliant code example, a and b are replaced with atomic integers. #include <stdatomic.h>\n\nstatic atomic_int a;\nstatic atomic_int b;\n\nvoid init_ab(void) {\n  atomic_init(&a, 0);\n  atomic_init(&b, 0);\n}\n\nint get_sum(void) {\n  return atomic_load(&a) + atomic_load(&b);\n}\n \nvoid set_values(int new_a, int new_b) {\n  atomic_store(&a, new_a);\n  atomic_store(&b, new_b);\n} The simple replacement of the two int fields with atomic integers fails to eliminate the race condition in the sum because the compound operation a.get() + b.get() is still non-atomic. While a sum of some value of a and some value of b will be returned, there is no guarantee that this value represents the sum of the values of a and b at any particular moment. Compliant Solution ( _Atomic struct ) This compliant solution uses an atomic struct, which guarantees that both numbers are read and written together. #include <stdatomic.h>\n  \nstatic _Atomic struct ab_s {\n  int a, b;\n} ab;\n \nvoid init_ab(void) {\n  struct ab_s new_ab = {0, 0};\n  atomic_init(&ab, new_ab);\n}\n \nint get_sum(void) {\n  struct ab_s new_ab = atomic_load(&ab);\n  return new_ab.a + new_ab.b;\n}\n \nvoid set_values(int new_a, int new_b) {\n  struct ab_s new_ab = {new_a, new_b};\n  atomic_store(&ab, new_ab);\n} On most modern platforms, this will compile to be lock-free. Compliant Solution (Mutex) This compliant solution protects the set_values() and get_sum() methods with a mutex to ensure atomicity: #include <threads.h>\n#include <stdbool.h>\n\nstatic int a;\nstatic int b;\nmtx_t flag_mutex;\n\n/* Initialize everything */\nbool init_all(int type) {\n  /* Check mutex type */\n  a = 0;\n  b = 0;\n  if (thrd_success != mtx_init(&flag_mutex, type)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n \nint get_sum(void) {\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  int sum = a + b;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n  return sum;\n}\n \nvoid set_values(int new_a, int new_b) {\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  a = new_a;\n  b = new_b;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n} Thanks to the mutex, it is now possible to add overflow checking to the get_sum() function without introducing the possibility of a race condition. Risk Assessment When operations on shared variables are not atomic, unexpected results can be produced. For example, information can be disclosed inadvertently because one user can receive information about other users. Rule Severity Likelihood Detectable Repairable Priority Level CON07-C Medium Probable Yes No P8 L2 Automated Detection Tool Version Checker Description CodeSonar 9.1p0 CONCURRENCY.DATARACE Data Race Helix QAC 2025.2 C1765 C1114 C1115 C1116 Related Guidelines CERT Oracle Secure Coding Standard for Java VNA02-J. Ensure that compound operations on shared variables are atomic MITRE CWE CWE-366 , Race condition within a thread CWE-413, Improper resource locking CWE-567, Unsynchronized access to shared data in a multithreaded context CWE-667 , Improper locking Bibliography [ ISO/IEC 14882:2011 ] Subclause 7.17, \"Atomics\"\n\n#include <stdbool.h>\n \nstatic bool flag = false;\n \nvoid toggle_flag(void) {\n  flag = !flag;\n}\n \nbool get_flag(void) {\n  return flag;\n}\n\n#include <threads.h>\n#include <stdbool.h>\n \nstatic bool flag = false;\nmtx_t flag_mutex;\n\n/* Initialize flag_mutex */\nbool init_mutex(int type) {\n  /* Check mutex type */\n  if (thrd_success != mtx_init(&flag_mutex, type)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n \nvoid toggle_flag(void) {\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  flag = !flag;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n}\n \nbool get_flag(void) {\n  bool temp_flag;\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  temp_flag = flag;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n  return temp_flag;\n}\n\n#include <stdatomic.h>\n#include <stdbool.h>\n \nstatic atomic_bool flag;\n\nvoid init_flag(void) {\n  atomic_init(&flag, false);\n}\nvoid toggle_flag(void) {\n  bool old_flag = atomic_load(&flag);\n  bool new_flag;\n  do {\n    new_flag = !old_flag;\n  } while (!atomic_compare_exchange_weak(&flag, &old_flag, new_flag));\n}\n  \nbool get_flag(void) {\n  return atomic_load(&flag);\n}\n\nstatic int a;\nstatic int b;\n \nint get_sum(void) {\n  return a + b;\n}\n \nvoid set_values(int new_a, int new_b) {\n  a = new_a;\n  b = new_b;\n}\n\n#include <stdatomic.h>\n\nstatic atomic_int a;\nstatic atomic_int b;\n\nvoid init_ab(void) {\n  atomic_init(&a, 0);\n  atomic_init(&b, 0);\n}\n\nint get_sum(void) {\n  return atomic_load(&a) + atomic_load(&b);\n}\n \nvoid set_values(int new_a, int new_b) {\n  atomic_store(&a, new_a);\n  atomic_store(&b, new_b);\n}\n\n#include <stdatomic.h>\n  \nstatic _Atomic struct ab_s {\n  int a, b;\n} ab;\n \nvoid init_ab(void) {\n  struct ab_s new_ab = {0, 0};\n  atomic_init(&ab, new_ab);\n}\n \nint get_sum(void) {\n  struct ab_s new_ab = atomic_load(&ab);\n  return new_ab.a + new_ab.b;\n}\n \nvoid set_values(int new_a, int new_b) {\n  struct ab_s new_ab = {new_a, new_b};\n  atomic_store(&ab, new_ab);\n}\n\n#include <threads.h>\n#include <stdbool.h>\n\nstatic int a;\nstatic int b;\nmtx_t flag_mutex;\n\n/* Initialize everything */\nbool init_all(int type) {\n  /* Check mutex type */\n  a = 0;\n  b = 0;\n  if (thrd_success != mtx_init(&flag_mutex, type)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n \nint get_sum(void) {\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  int sum = a + b;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n  return sum;\n}\n \nvoid set_values(int new_a, int new_b) {\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  a = new_a;\n  b = new_b;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n}\n\n++\n\n--\n\n*=\n\n/=\n\n %=\n\n+=\n\n-=\n\n<<=\n\n>>=\n\n^=\n\n|=\n\n_Bool\n\nflag\n\ntoggle_flag()\n\nflag\n\nflag\n\ntoggle_flag()\n\nflag\n\nflag\n\nflag=\n\ntrue\n\nflag\n\ntrue\n\ntrue\n\nflag\n\ntrue\n\ntrue\n\nfalse\n\ntrue\n\nfalse\n\nfalse\n\nflag\n\nfalse\n\nflag\n\nflag\n\ntoggle_flag()\n\nflag\n\nflag\n\nflag_mutex\n\nflag\n\nflag=\n\ntrue\n\nflag\n\ntrue\n\ntrue\n\nfalse\n\nfalse\n\nflag\n\nfalse\n\nflag\n\nfalse\n\nfalse\n\ntrue\n\ntrue\n\nflag\n\natomic_compare_exchange_weak()\n\nflag\n\natomic_flag\n\nset_values()\n\na\n\nb\n\nset_values()\n\nget_sum()\n\na\n\nb\n\n0\n\nINT_MAX\n\nget_sum()\n\nset_values(INT_MAX, 0)\n\nget_sum()\n\n0\n\nINT_MAX\n\na\n\nb\n\na\n\nINT_MAX\n\nb\n\n0\n\na\n\nb\n\nint\n\na.get() + b.get()\n\na\n\nb\n\na\n\nb\n\n_Atomic struct\n\nset_values()\n\nget_sum()\n\nget_sum()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Logical Negation)",
          "pre_code_commentary": "Execution of this code may result in a data race because the value of flag is read, negated, and written back.\n\nConsider, for example, two threads that call toggle_flag() . The expected effect of toggling flag twice is that it is restored to its original value. However, the following scenario leaves flag in the incorrect state:\n\nTime\n\nflag=\n\nThread\n\nAction\n\n1\n\ntrue\n\nt 1\n\nReads the current value of flag , true , into a cache\n\n2\n\nt 2\n\nReads the current value of flag , (still) true , into a different cache\n\n3\n\nToggles the temporary variable in the cache to false\n\n4\n\nToggles the temporary variable in the different cache to false\n\n5\n\nfalse\n\nWrites the cache variable's value to flag\n\n6\n\nWrites the different cache variable's value to flag\n\nAs a result, the effect of the call by t 2 is not reflected in flag ; the program behaves as if toggle_flag() was called only once, not twice.\n\nThis compliant solution restricts access to flag under a mutex lock:\n\nThis solution guards reads and writes to the flag field with a lock on the flag_mutex . This lock ensures that changes to flag are visible to all threads. Now, only two execution orders are possible. In one execution order, t 1 obtains the mutex and completes the operation before t 2 can acquire the mutex, as shown here:\n\nReads the current value of flag , true , into a cache variable\n\nToggles the cache variable to false\n\nReads the current value of flag , false , into a different cache variable\n\nToggles the different cache variable to true\n\nThe other execution order is similar, except that t 2 starts and finishes before t 1 .\n\nThis compliant solution uses atomic variables and a compare-and-exchange operation to guarantee that the correct value is stored in flag . All updates are visible to other threads.\n\nAn alternative solution is to use the atomic_flag data type for managing Boolean values atomically.\n\nIn this noncompliant code example, multiple threads can invoke the set_values() method to set the a and b fields. Because this code fails to test for integer overflow, users of this code must also ensure that the arguments to the set_values() method can be added without overflow (see INT32-C. Ensure that operations on signed integers do not result in overflow for more information).\n\nThe get_sum() method contains a race condition. For example, when a and b currently have the values 0 and INT_MAX , respectively, and one thread calls get_sum() while another calls set_values(INT_MAX, 0) , the get_sum() method might return either 0 or INT_MAX , or it might overflow. Overflow will occur when the first thread reads a and b after the second thread has set the value of a to INT_MAX but before it has set the value of b to 0 .\n\nNoncompliant Code Example (Addition of Atomic Integers)\n\nIn this noncompliant code example, a and b are replaced with atomic integers.\n\nThis compliant solution uses an atomic struct, which guarantees that both numbers are read and written together.\n\nOn most modern platforms, this will compile to be lock-free.\n\nThis compliant solution protects the set_values() and get_sum() methods with a mutex to ensure atomicity:\n\nThanks to the mutex, it is now possible to add overflow checking to the get_sum() function without introducing the possibility of a race condition.\n\nWhen operations on shared variables are not atomic, unexpected results can be produced. For example, information can be disclosed inadvertently because one user can receive information about other users.\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nCON07-C\n\nMedium\n\nProbable\n\nYes\n\nNo\n\nP8\n\nL2\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\nCONCURRENCY.DATARACE\n\n2025.2\n\nC1765 C1114 C1115 C1116\n\nMITRE CWE\n\nCWE-366 , Race condition within a thread CWE-413, Improper resource locking CWE-567, Unsynchronized access to shared data in a multithreaded context CWE-667 , Improper locking\n\n[ ISO/IEC 14882:2011 ]\n\nSubclause 7.17, \"Atomics\"",
          "code": null,
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Mutex)",
          "pre_code_commentary": "This compliant solution restricts access to flag under a mutex lock:",
          "code": "#include <threads.h>\n#include <stdbool.h>\n \nstatic bool flag = false;\nmtx_t flag_mutex;\n\n/* Initialize flag_mutex */\nbool init_mutex(int type) {\n  /* Check mutex type */\n  if (thrd_success != mtx_init(&flag_mutex, type)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n \nvoid toggle_flag(void) {\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  flag = !flag;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n}\n \nbool get_flag(void) {\n  bool temp_flag;\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  temp_flag = flag;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n  return temp_flag;\n}",
          "explanation_after": "This solution guards reads and writes to the flag field with a lock on the flag_mutex . This lock ensures that changes to flag are visible to all threads. Now, only two execution orders are possible. In one execution order, t 1 obtains the mutex and completes the operation before t 2 can acquire the mutex, as shown here:\n\nTime\n\nflag=\n\nThread\n\nAction\n\n1\n\ntrue\n\nt 1\n\nReads the current value of flag , true , into a cache variable\n\n2\n\nToggles the cache variable to false\n\n3\n\nfalse\n\nWrites the cache variable's value to flag\n\n4\n\nt 2\n\nReads the current value of flag , false , into a different cache variable\n\n5\n\nToggles the different cache variable to true\n\n6\n\nWrites the different cache variable's value to flag\n\nThe other execution order is similar, except that t 2 starts and finishes before t 1 ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Logical Negation)",
          "pre_code_commentary": "Execution of this code may result in a data race because the value of flag is read, negated, and written back.\n\nConsider, for example, two threads that call toggle_flag() . The expected effect of toggling flag twice is that it is restored to its original value. However, the following scenario leaves flag in the incorrect state:\n\nTime\n\nflag=\n\nThread\n\nAction\n\n1\n\ntrue\n\nt 1\n\nReads the current value of flag , true , into a cache\n\n2\n\nt 2\n\nReads the current value of flag , (still) true , into a different cache\n\n3\n\nToggles the temporary variable in the cache to false\n\n4\n\nToggles the temporary variable in the different cache to false\n\n5\n\nfalse\n\nWrites the cache variable's value to flag\n\n6\n\nWrites the different cache variable's value to flag\n\nAs a result, the effect of the call by t 2 is not reflected in flag ; the program behaves as if toggle_flag() was called only once, not twice.\n\nThis compliant solution restricts access to flag under a mutex lock:\n\nThis solution guards reads and writes to the flag field with a lock on the flag_mutex . This lock ensures that changes to flag are visible to all threads. Now, only two execution orders are possible. In one execution order, t 1 obtains the mutex and completes the operation before t 2 can acquire the mutex, as shown here:\n\nReads the current value of flag , true , into a cache variable\n\nToggles the cache variable to false\n\nReads the current value of flag , false , into a different cache variable\n\nToggles the different cache variable to true\n\nThe other execution order is similar, except that t 2 starts and finishes before t 1 .\n\nThis compliant solution uses atomic variables and a compare-and-exchange operation to guarantee that the correct value is stored in flag . All updates are visible to other threads.\n\nAn alternative solution is to use the atomic_flag data type for managing Boolean values atomically.\n\nIn this noncompliant code example, multiple threads can invoke the set_values() method to set the a and b fields. Because this code fails to test for integer overflow, users of this code must also ensure that the arguments to the set_values() method can be added without overflow (see INT32-C. Ensure that operations on signed integers do not result in overflow for more information).\n\nThe get_sum() method contains a race condition. For example, when a and b currently have the values 0 and INT_MAX , respectively, and one thread calls get_sum() while another calls set_values(INT_MAX, 0) , the get_sum() method might return either 0 or INT_MAX , or it might overflow. Overflow will occur when the first thread reads a and b after the second thread has set the value of a to INT_MAX but before it has set the value of b to 0 .\n\nNoncompliant Code Example (Addition of Atomic Integers)\n\nIn this noncompliant code example, a and b are replaced with atomic integers.\n\nThis compliant solution uses an atomic struct, which guarantees that both numbers are read and written together.\n\nOn most modern platforms, this will compile to be lock-free.\n\nThis compliant solution protects the set_values() and get_sum() methods with a mutex to ensure atomicity:\n\nThanks to the mutex, it is now possible to add overflow checking to the get_sum() function without introducing the possibility of a race condition.\n\nWhen operations on shared variables are not atomic, unexpected results can be produced. For example, information can be disclosed inadvertently because one user can receive information about other users.\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nCON07-C\n\nMedium\n\nProbable\n\nYes\n\nNo\n\nP8\n\nL2\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\nCONCURRENCY.DATARACE\n\n2025.2\n\nC1765 C1114 C1115 C1116\n\nMITRE CWE\n\nCWE-366 , Race condition within a thread CWE-413, Improper resource locking CWE-567, Unsynchronized access to shared data in a multithreaded context CWE-667 , Improper locking\n\n[ ISO/IEC 14882:2011 ]\n\nSubclause 7.17, \"Atomics\"",
          "code": null,
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( atomic_compare_exchange_weak() )",
          "pre_code_commentary": "This compliant solution uses atomic variables and a compare-and-exchange operation to guarantee that the correct value is stored in flag . All updates are visible to other threads.",
          "code": "#include <stdatomic.h>\n#include <stdbool.h>\n \nstatic atomic_bool flag;\n\nvoid init_flag(void) {\n  atomic_init(&flag, false);\n}\nvoid toggle_flag(void) {\n  bool old_flag = atomic_load(&flag);\n  bool new_flag;\n  do {\n    new_flag = !old_flag;\n  } while (!atomic_compare_exchange_weak(&flag, &old_flag, new_flag));\n}\n  \nbool get_flag(void) {\n  return atomic_load(&flag);\n}",
          "explanation_after": "An alternative solution is to use the atomic_flag data type for managing Boolean values atomically."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Addition of Primitives)",
          "pre_code_commentary": "In this noncompliant code example, multiple threads can invoke the set_values() method to set the a and b fields. Because this code fails to test for integer overflow, users of this code must also ensure that the arguments to the set_values() method can be added without overflow (see INT32-C. Ensure that operations on signed integers do not result in overflow for more information).",
          "code": "static int a;\nstatic int b;\n \nint get_sum(void) {\n  return a + b;\n}\n \nvoid set_values(int new_a, int new_b) {\n  a = new_a;\n  b = new_b;\n}",
          "explanation_after": "The get_sum() method contains a race condition. For example, when a and b currently have the values 0 and INT_MAX , respectively, and one thread calls get_sum() while another calls set_values(INT_MAX, 0) , the get_sum() method might return either 0 or INT_MAX , or it might overflow. Overflow will occur when the first thread reads a and b after the second thread has set the value of a to INT_MAX but before it has set the value of b to 0 .\n\nNoncompliant Code Example (Addition of Atomic Integers)\n\nIn this noncompliant code example, a and b are replaced with atomic integers."
        },
        "compliant": {
          "heading": "Compliant Solution ( _Atomic struct )",
          "pre_code_commentary": "This compliant solution uses an atomic struct, which guarantees that both numbers are read and written together.",
          "code": "#include <stdatomic.h>\n  \nstatic _Atomic struct ab_s {\n  int a, b;\n} ab;\n \nvoid init_ab(void) {\n  struct ab_s new_ab = {0, 0};\n  atomic_init(&ab, new_ab);\n}\n \nint get_sum(void) {\n  struct ab_s new_ab = atomic_load(&ab);\n  return new_ab.a + new_ab.b;\n}\n \nvoid set_values(int new_a, int new_b) {\n  struct ab_s new_ab = {new_a, new_b};\n  atomic_store(&ab, new_ab);\n}",
          "explanation_after": "On most modern platforms, this will compile to be lock-free."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Addition of Primitives)",
          "pre_code_commentary": "In this noncompliant code example, multiple threads can invoke the set_values() method to set the a and b fields. Because this code fails to test for integer overflow, users of this code must also ensure that the arguments to the set_values() method can be added without overflow (see INT32-C. Ensure that operations on signed integers do not result in overflow for more information).",
          "code": "static int a;\nstatic int b;\n \nint get_sum(void) {\n  return a + b;\n}\n \nvoid set_values(int new_a, int new_b) {\n  a = new_a;\n  b = new_b;\n}",
          "explanation_after": "The get_sum() method contains a race condition. For example, when a and b currently have the values 0 and INT_MAX , respectively, and one thread calls get_sum() while another calls set_values(INT_MAX, 0) , the get_sum() method might return either 0 or INT_MAX , or it might overflow. Overflow will occur when the first thread reads a and b after the second thread has set the value of a to INT_MAX but before it has set the value of b to 0 .\n\nNoncompliant Code Example (Addition of Atomic Integers)\n\nIn this noncompliant code example, a and b are replaced with atomic integers."
        },
        "compliant": {
          "heading": "Compliant Solution (Mutex)",
          "pre_code_commentary": "This compliant solution protects the set_values() and get_sum() methods with a mutex to ensure atomicity:",
          "code": "#include <threads.h>\n#include <stdbool.h>\n\nstatic int a;\nstatic int b;\nmtx_t flag_mutex;\n\n/* Initialize everything */\nbool init_all(int type) {\n  /* Check mutex type */\n  a = 0;\n  b = 0;\n  if (thrd_success != mtx_init(&flag_mutex, type)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n \nint get_sum(void) {\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  int sum = a + b;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n  return sum;\n}\n \nvoid set_values(int new_a, int new_b) {\n  if (thrd_success != mtx_lock(&flag_mutex)) {\n    /* Handle error */\n  }\n  a = new_a;\n  b = new_b;\n  if (thrd_success != mtx_unlock(&flag_mutex)) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "Thanks to the mutex, it is now possible to add overflow checking to the get_sum() function without introducing the possibility of a race condition."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "When operations on shared variables are not atomic, unexpected results can be produced. For example, information can be disclosed inadvertently because one user can receive information about other users.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "CON08-C",
    "title": "Do not assume that a group of calls to independently atomic methods is atomic",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON08-C.+Do+not+assume+that+a+group+of+calls+to+independently+atomic+methods+is+atomic",
    "description": "A consistent locking policy guarantees that multiple threads cannot simultaneously access or modify shared data. When two or more operations must be performed as a single atomic operation, a consistent locking policy must be implemented using some form of locking, such as a mutex. In the absence of such a policy, the code is susceptible to race conditions. When presented with a set of operations, where each is guaranteed to be atomic, it is tempting to assume that a single operation consisting of individually-atomic operations is guaranteed to be collectively atomic without additional locking. A grouping of calls to such methods requires additional synchronization for the group. Compound operations on shared variables are also non-atomic. See CON07-C. Ensure that compound operations on shared variables are atomic for more information. Noncompliant Code Example This noncompliant code example stores two integers atomically. It also provides atomic methods to obtain their sum and product. All methods are locked with the same mutex to provide their atomicity. #include <threads.h>\n#include <stdio.h>\n#include <stdbool.h>\n \nstatic int a = 0;\nstatic int b = 0;\nmtx_t lock;\n \nbool init_mutex(int type) {\n  /* Validate type */\n  if (thrd_success != mtx_init(&lock, type)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n\nvoid set_values(int new_a, int new_b) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  a = new_a;\n  b = new_b;\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}\n\nint get_sum(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  int sum = a + b;\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n  return sum;\n}\n  \nint get_product(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  int product = a * b;\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n  return product;\n}\n\n/* Can be called by multiple threads */\nvoid multiply_monomials(int x1, int x2) {\n  printf(\"(x + %d)(x + %d)\\n\", x1, x2);\n  set_values( x1, x2);\n  printf(\"= x^2 + %dx + %d\\n\", get_sum(), get_product());\n} Unfortunately, the multiply_monomials() function is still subject to race conditions, despite relying exclusively on atomic function calls. It is quite possible for get_sum() and get_product() to work with different numbers than the ones that were set by set_values() . It is even possible for get_sum() to operate with different numbers than get_product() . Compliant Solution This compliant solution locks the multiply_monomials() function with the same mutex lock that is used by the other functions. For this code to work, the mutex must be recursive. This is accomplished by making it recursive in the init_mutex() function. #include <threads.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nextern void set_values(int, int);\nextern int get_sum(void);\nextern int get_product(void);\n\nmtx_t lock;\n \nbool init_mutex(int type) {\n  /* Validate type */\n  if (thrd_success != mtx_init(&lock, type | mtx_recursive)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n\n/* Can be called by multiple threads */\nvoid multiply_monomials(int x1, int x2) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  set_values( x1, x2);\n  int sum = get_sum();\n  int product = get_product();\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n\n  printf(\"(x + %d)(x + %d)\\n\", x1, x2);\n  printf(\"= x^2 + %dx + %d\\n\", sum, product);\n} Noncompliant Code Example Function chaining is a useful design pattern for building an object and setting its optional fields. The output of one function serves as an argument (typically the last) in the next function. However, if accessed concurrently, a thread may observe shared fields to contain inconsistent values. This noncompliant code example demonstrates a race condition that can occur when multiple threads can variables with no thread protection. #include <threads.h>\n#include <stdio.h>\n\ntypedef struct currency_s {\n  int quarters;\n  int dimes;\n  int nickels;\n  int pennies;\n} currency_t;\n \ncurrency_t *set_quarters(int quantity, currency_t *currency) {\n  currency->quarters += quantity;\n  return currency;\n}\ncurrency_t *set_dimes(int quantity, currency_t *currency) {\n  currency->dimes += quantity;\n  return currency;\n} \ncurrency_t *set_nickels(int quantity, currency_t *currency) {\n  currency->nickels += quantity;\n  return currency;\n}\ncurrency_t *set_pennies(int quantity, currency_t *currency) {\n  currency->pennies += quantity;\n  return currency;\n}\n \nint init_45_cents(void *currency) {\n  currency_t *c = set_quarters(1, set_dimes(2, currency));\n  /* Validate values are correct */\n  return 0;\n}\nint init_60_cents(void* currency) {\n  currency_t *c = set_quarters(2, set_dimes(1, currency));\n  /* Validate values are correct */\n  return 0;\n}\n \nint main(void) {\n  thrd_t thrd1;\n  thrd_t thrd2;\n  currency_t currency = {0, 0, 0, 0};\n \n  if (thrd_success != thrd_create(&thrd1, init_45_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd2, init_60_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd1, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd2, NULL)) {\n    /* Handle error */\n  }\n \n  printf(\"%d quarters, %d dimes, %d nickels, %d pennies\\n\",\n         currency.quarters, currency.dimes, currency.nickels, currency.pennies);\n  return 0;\n} In this noncompliant code example, the program constructs a currency struct and starts two threads that use method chaining to set the optional values of the structure. This example code might result in the currency struct being left in an inconsistent state, for example, with two quarters and one dime or one quarter and two dimes. Noncompliant Code Example This code remains unsafe even if it uses a mutex on the set functions to guard modification of the currency: #include <threads.h>\n#include <stdio.h>\n\ntypedef struct currency_s {\n  int quarters;\n  int dimes;\n  int nickels;\n  int pennies;\n  mtx_t lock;\n} currency_t;\n \ncurrency_t *set_quarters(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->quarters += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\ncurrency_t *set_dimes(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->dimes += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\ncurrency_t *set_nickels(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->nickels += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\ncurrency_t *set_pennies(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->pennies += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\n \nint init_45_cents(void *currency) {\n  currency_t *c = set_quarters(1, set_dimes(2, currency));\n  /* Validate values are correct */\n  return 0;\n}\nint init_60_cents(void* currency) {\n  currency_t *c = set_quarters(2, set_dimes(1, currency));\n  /* Validate values are correct */\n  return 0;\n}\n \nint main(void) {\n  int result;\n  thrd_t thrd1;\n  thrd_t thrd2;\n  currency_t currency = {0, 0, 0, 0};\n \n  if (thrd_success != mtx_init(&currency.lock, mtx_plain)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd1, init_45_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd2, init_60_cents, &currency)) {\n    /* Handle error */\n  }\n  \n  if (thrd_success != thrd_join(thrd1, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd2, NULL)) {\n    /* Handle error */\n  }\n \n  printf(\"%d quarters, %d dimes, %d nickels, %d pennies\\n\",\n         currency.quarters, currency.dimes, currency.nickels, currency.pennies);\n \n  mtx_destroy( &currency.lock);\n  return 0;\n} Compliant Solution This compliant solution uses a mutex, but instead of guarding the set functions, it guards the init functions, which are invoked at thread creation. #include <threads.h>\n#include <stdio.h>\ntypedef struct currency_s {\n  int quarters;\n  int dimes;\n  int nickels;\n  int pennies;\n  mtx_t lock;\n} currency_t;\n \ncurrency_t *set_quarters(int quantity, currency_t *currency) {\n  currency->quarters += quantity;\n  return currency;\n}\ncurrency_t *set_dimes(int quantity, currency_t *currency) {\n  currency->dimes += quantity;\n  return currency;\n}\ncurrency_t *set_nickels(int quantity, currency_t *currency) {\n  currency->nickels += quantity;\n  return currency;\n} \ncurrency_t *set_pennies(int quantity, currency_t *currency) {\n  currency->pennies += quantity;\n  return currency;\n}\n \nint init_45_cents(void *currency) {\n  currency_t *c = (currency_t *)currency;\n  if (thrd_success != mtx_lock(&c->lock)) {\n    /* Handle error */\n  }\n  set_quarters(1, set_dimes(2, currency));\n  if (thrd_success != mtx_unlock(&c->lock)) {\n    /* Handle error */\n  }\n  return 0;\n}\nint init_60_cents(void *currency) {\n  currency_t *c = (currency_t *)currency;\n  if (thrd_success != mtx_lock(&c->lock)) {\n    /* Handle error */\n  }\n  set_quarters(2, set_dimes(1, currency));\n  if (thrd_success != mtx_unlock(&c->lock)) {\n    /* Handle error */\n  }\n  return 0;\n}\n \nint main(void) {\n  int result;\n  thrd_t thrd1;\n  thrd_t thrd2;\n  currency_t currency = {0, 0, 0, 0};\n \n  if (thrd_success != mtx_init(&currency.lock, mtx_plain)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd1, init_45_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd2, init_60_cents, &currency)) {\n    /* Handle error */\n  }\n \n  if (thrd_success != thrd_join(thrd1, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd2, NULL)) {\n    /* Handle error */\n  }\n \n  printf(\"%d quarters, %d dimes, %d nickels, %d pennies\\n\",\n         currency.quarters, currency.dimes, currency.nickels, currency.pennies);\n \n  mtx_destroy(&currency.lock);\n  return 0;\n} Consequently this compliant solution is thread-safe, and will always print out the same number of quarters as dimes. Risk Assessment Failure to ensure the atomicity of two or more operations that must be performed as a single atomic operation can result in race conditions in multithreaded applications. Rule Severity Likelihood Detectable Repairable Priority Level CON08-C Low Probable No No P2 L3 Related Guidelines CERT Oracle Secure Coding Standard for Java VNA03-J. Do not assume that a group of calls to independently atomic methods is atomic VNA04-J. Ensure that calls to chained methods are atomic MITRE CWE CWE-362 , Concurrent execution using shared resource with improper synchronization (\"race condition\") CWE-366, Race condition within a thread CWE-662 , Improper synchronization Bibliography [ ISO/IEC 9899:2011 ] Subclause 7.26, \"Threads <threads.h>\"\n\n#include <threads.h>\n#include <stdio.h>\n#include <stdbool.h>\n \nstatic int a = 0;\nstatic int b = 0;\nmtx_t lock;\n \nbool init_mutex(int type) {\n  /* Validate type */\n  if (thrd_success != mtx_init(&lock, type)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n\nvoid set_values(int new_a, int new_b) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  a = new_a;\n  b = new_b;\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}\n\nint get_sum(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  int sum = a + b;\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n  return sum;\n}\n  \nint get_product(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  int product = a * b;\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n  return product;\n}\n\n/* Can be called by multiple threads */\nvoid multiply_monomials(int x1, int x2) {\n  printf(\"(x + %d)(x + %d)\\n\", x1, x2);\n  set_values( x1, x2);\n  printf(\"= x^2 + %dx + %d\\n\", get_sum(), get_product());\n}\n\n#include <threads.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nextern void set_values(int, int);\nextern int get_sum(void);\nextern int get_product(void);\n\nmtx_t lock;\n \nbool init_mutex(int type) {\n  /* Validate type */\n  if (thrd_success != mtx_init(&lock, type | mtx_recursive)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n\n/* Can be called by multiple threads */\nvoid multiply_monomials(int x1, int x2) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  set_values( x1, x2);\n  int sum = get_sum();\n  int product = get_product();\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n\n  printf(\"(x + %d)(x + %d)\\n\", x1, x2);\n  printf(\"= x^2 + %dx + %d\\n\", sum, product);\n}\n\n#include <threads.h>\n#include <stdio.h>\n\ntypedef struct currency_s {\n  int quarters;\n  int dimes;\n  int nickels;\n  int pennies;\n} currency_t;\n \ncurrency_t *set_quarters(int quantity, currency_t *currency) {\n  currency->quarters += quantity;\n  return currency;\n}\ncurrency_t *set_dimes(int quantity, currency_t *currency) {\n  currency->dimes += quantity;\n  return currency;\n} \ncurrency_t *set_nickels(int quantity, currency_t *currency) {\n  currency->nickels += quantity;\n  return currency;\n}\ncurrency_t *set_pennies(int quantity, currency_t *currency) {\n  currency->pennies += quantity;\n  return currency;\n}\n \nint init_45_cents(void *currency) {\n  currency_t *c = set_quarters(1, set_dimes(2, currency));\n  /* Validate values are correct */\n  return 0;\n}\nint init_60_cents(void* currency) {\n  currency_t *c = set_quarters(2, set_dimes(1, currency));\n  /* Validate values are correct */\n  return 0;\n}\n \nint main(void) {\n  thrd_t thrd1;\n  thrd_t thrd2;\n  currency_t currency = {0, 0, 0, 0};\n \n  if (thrd_success != thrd_create(&thrd1, init_45_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd2, init_60_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd1, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd2, NULL)) {\n    /* Handle error */\n  }\n \n  printf(\"%d quarters, %d dimes, %d nickels, %d pennies\\n\",\n         currency.quarters, currency.dimes, currency.nickels, currency.pennies);\n  return 0;\n}\n\n#include <threads.h>\n#include <stdio.h>\n\ntypedef struct currency_s {\n  int quarters;\n  int dimes;\n  int nickels;\n  int pennies;\n  mtx_t lock;\n} currency_t;\n \ncurrency_t *set_quarters(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->quarters += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\ncurrency_t *set_dimes(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->dimes += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\ncurrency_t *set_nickels(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->nickels += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\ncurrency_t *set_pennies(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->pennies += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\n \nint init_45_cents(void *currency) {\n  currency_t *c = set_quarters(1, set_dimes(2, currency));\n  /* Validate values are correct */\n  return 0;\n}\nint init_60_cents(void* currency) {\n  currency_t *c = set_quarters(2, set_dimes(1, currency));\n  /* Validate values are correct */\n  return 0;\n}\n \nint main(void) {\n  int result;\n  thrd_t thrd1;\n  thrd_t thrd2;\n  currency_t currency = {0, 0, 0, 0};\n \n  if (thrd_success != mtx_init(&currency.lock, mtx_plain)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd1, init_45_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd2, init_60_cents, &currency)) {\n    /* Handle error */\n  }\n  \n  if (thrd_success != thrd_join(thrd1, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd2, NULL)) {\n    /* Handle error */\n  }\n \n  printf(\"%d quarters, %d dimes, %d nickels, %d pennies\\n\",\n         currency.quarters, currency.dimes, currency.nickels, currency.pennies);\n \n  mtx_destroy( &currency.lock);\n  return 0;\n}\n\n#include <threads.h>\n#include <stdio.h>\ntypedef struct currency_s {\n  int quarters;\n  int dimes;\n  int nickels;\n  int pennies;\n  mtx_t lock;\n} currency_t;\n \ncurrency_t *set_quarters(int quantity, currency_t *currency) {\n  currency->quarters += quantity;\n  return currency;\n}\ncurrency_t *set_dimes(int quantity, currency_t *currency) {\n  currency->dimes += quantity;\n  return currency;\n}\ncurrency_t *set_nickels(int quantity, currency_t *currency) {\n  currency->nickels += quantity;\n  return currency;\n} \ncurrency_t *set_pennies(int quantity, currency_t *currency) {\n  currency->pennies += quantity;\n  return currency;\n}\n \nint init_45_cents(void *currency) {\n  currency_t *c = (currency_t *)currency;\n  if (thrd_success != mtx_lock(&c->lock)) {\n    /* Handle error */\n  }\n  set_quarters(1, set_dimes(2, currency));\n  if (thrd_success != mtx_unlock(&c->lock)) {\n    /* Handle error */\n  }\n  return 0;\n}\nint init_60_cents(void *currency) {\n  currency_t *c = (currency_t *)currency;\n  if (thrd_success != mtx_lock(&c->lock)) {\n    /* Handle error */\n  }\n  set_quarters(2, set_dimes(1, currency));\n  if (thrd_success != mtx_unlock(&c->lock)) {\n    /* Handle error */\n  }\n  return 0;\n}\n \nint main(void) {\n  int result;\n  thrd_t thrd1;\n  thrd_t thrd2;\n  currency_t currency = {0, 0, 0, 0};\n \n  if (thrd_success != mtx_init(&currency.lock, mtx_plain)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd1, init_45_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd2, init_60_cents, &currency)) {\n    /* Handle error */\n  }\n \n  if (thrd_success != thrd_join(thrd1, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd2, NULL)) {\n    /* Handle error */\n  }\n \n  printf(\"%d quarters, %d dimes, %d nickels, %d pennies\\n\",\n         currency.quarters, currency.dimes, currency.nickels, currency.pennies);\n \n  mtx_destroy(&currency.lock);\n  return 0;\n}\n\nmultiply_monomials()\n\nget_sum()\n\nget_product()\n\nset_values()\n\nget_sum()\n\nget_product()\n\nmultiply_monomials()\n\ninit_mutex()\n\nstruct\n\nstruct\n\nset\n\nset\n\ninit",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example stores two integers atomically. It also provides atomic methods to obtain their sum and product. All methods are locked with the same mutex to provide their atomicity.",
          "code": "#include <threads.h>\n#include <stdio.h>\n#include <stdbool.h>\n \nstatic int a = 0;\nstatic int b = 0;\nmtx_t lock;\n \nbool init_mutex(int type) {\n  /* Validate type */\n  if (thrd_success != mtx_init(&lock, type)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n\nvoid set_values(int new_a, int new_b) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  a = new_a;\n  b = new_b;\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}\n\nint get_sum(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  int sum = a + b;\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n  return sum;\n}\n  \nint get_product(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  int product = a * b;\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n  return product;\n}\n\n/* Can be called by multiple threads */\nvoid multiply_monomials(int x1, int x2) {\n  printf(\"(x + %d)(x + %d)\\n\", x1, x2);\n  set_values( x1, x2);\n  printf(\"= x^2 + %dx + %d\\n\", get_sum(), get_product());\n}\n",
          "explanation_after": "Unfortunately, the multiply_monomials() function is still subject to race conditions, despite relying exclusively on atomic function calls. It is quite possible for get_sum() and get_product() to work with different numbers than the ones that were set by set_values() . It is even possible for get_sum() to operate with different numbers than get_product() ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution locks the multiply_monomials() function with the same mutex lock that is used by the other functions. For this code to work, the mutex must be recursive. This is accomplished by making it recursive in the init_mutex() function.",
          "code": "#include <threads.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nextern void set_values(int, int);\nextern int get_sum(void);\nextern int get_product(void);\n\nmtx_t lock;\n \nbool init_mutex(int type) {\n  /* Validate type */\n  if (thrd_success != mtx_init(&lock, type | mtx_recursive)) {\n    return false;  /* Report error */\n  }\n  return true;\n}\n\n/* Can be called by multiple threads */\nvoid multiply_monomials(int x1, int x2) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  set_values( x1, x2);\n  int sum = get_sum();\n  int product = get_product();\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n\n  printf(\"(x + %d)(x + %d)\\n\", x1, x2);\n  printf(\"= x^2 + %dx + %d\\n\", sum, product);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Function chaining is a useful design pattern for building an object and setting its optional fields. The output of one function serves as an argument (typically the last) in the next function. However, if accessed concurrently, a thread may observe shared fields to contain inconsistent values. This noncompliant code example demonstrates a race condition that can occur when multiple threads can variables with no thread protection.",
          "code": "#include <threads.h>\n#include <stdio.h>\n\ntypedef struct currency_s {\n  int quarters;\n  int dimes;\n  int nickels;\n  int pennies;\n} currency_t;\n \ncurrency_t *set_quarters(int quantity, currency_t *currency) {\n  currency->quarters += quantity;\n  return currency;\n}\ncurrency_t *set_dimes(int quantity, currency_t *currency) {\n  currency->dimes += quantity;\n  return currency;\n} \ncurrency_t *set_nickels(int quantity, currency_t *currency) {\n  currency->nickels += quantity;\n  return currency;\n}\ncurrency_t *set_pennies(int quantity, currency_t *currency) {\n  currency->pennies += quantity;\n  return currency;\n}\n \nint init_45_cents(void *currency) {\n  currency_t *c = set_quarters(1, set_dimes(2, currency));\n  /* Validate values are correct */\n  return 0;\n}\nint init_60_cents(void* currency) {\n  currency_t *c = set_quarters(2, set_dimes(1, currency));\n  /* Validate values are correct */\n  return 0;\n}\n \nint main(void) {\n  thrd_t thrd1;\n  thrd_t thrd2;\n  currency_t currency = {0, 0, 0, 0};\n \n  if (thrd_success != thrd_create(&thrd1, init_45_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd2, init_60_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd1, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd2, NULL)) {\n    /* Handle error */\n  }\n \n  printf(\"%d quarters, %d dimes, %d nickels, %d pennies\\n\",\n         currency.quarters, currency.dimes, currency.nickels, currency.pennies);\n  return 0;\n}",
          "explanation_after": "In this noncompliant code example, the program constructs a currency struct and starts two threads that use method chaining to set the optional values of the structure. This example code might result in the currency struct being left in an inconsistent state, for example, with two quarters and one dime or one quarter and two dimes.\n\nThis code remains unsafe even if it uses a mutex on the set functions to guard modification of the currency:\n\nThis compliant solution uses a mutex, but instead of guarding the set functions, it guards the init functions, which are invoked at thread creation.\n\nFailure to ensure the atomicity of two or more operations that must be performed as a single atomic operation can result in race conditions in multithreaded applications.\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nCON08-C\n\nLow\n\nProbable\n\nNo\n\nP2\n\nL3\n\nMITRE CWE\n\nCWE-362 , Concurrent execution using shared resource with improper synchronization (\"race condition\") CWE-366, Race condition within a thread CWE-662 , Improper synchronization\n\n[ ISO/IEC 9899:2011 ]"
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code remains unsafe even if it uses a mutex on the set functions to guard modification of the currency:",
          "code": "#include <threads.h>\n#include <stdio.h>\n\ntypedef struct currency_s {\n  int quarters;\n  int dimes;\n  int nickels;\n  int pennies;\n  mtx_t lock;\n} currency_t;\n \ncurrency_t *set_quarters(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->quarters += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\ncurrency_t *set_dimes(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->dimes += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\ncurrency_t *set_nickels(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->nickels += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\ncurrency_t *set_pennies(int quantity, currency_t *currency) {\n  if (thrd_success != mtx_lock(&currency->lock)) {\n    /* Handle error */\n  }\n  currency->pennies += quantity;\n  if (thrd_success != mtx_unlock(&currency->lock)) {\n    /* Handle error */\n  }\n  return currency;\n}\n \nint init_45_cents(void *currency) {\n  currency_t *c = set_quarters(1, set_dimes(2, currency));\n  /* Validate values are correct */\n  return 0;\n}\nint init_60_cents(void* currency) {\n  currency_t *c = set_quarters(2, set_dimes(1, currency));\n  /* Validate values are correct */\n  return 0;\n}\n \nint main(void) {\n  int result;\n  thrd_t thrd1;\n  thrd_t thrd2;\n  currency_t currency = {0, 0, 0, 0};\n \n  if (thrd_success != mtx_init(&currency.lock, mtx_plain)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd1, init_45_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd2, init_60_cents, &currency)) {\n    /* Handle error */\n  }\n  \n  if (thrd_success != thrd_join(thrd1, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd2, NULL)) {\n    /* Handle error */\n  }\n \n  printf(\"%d quarters, %d dimes, %d nickels, %d pennies\\n\",\n         currency.quarters, currency.dimes, currency.nickels, currency.pennies);\n \n  mtx_destroy( &currency.lock);\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses a mutex, but instead of guarding the set functions, it guards the init functions, which are invoked at thread creation.",
          "code": "#include <threads.h>\n#include <stdio.h>\ntypedef struct currency_s {\n  int quarters;\n  int dimes;\n  int nickels;\n  int pennies;\n  mtx_t lock;\n} currency_t;\n \ncurrency_t *set_quarters(int quantity, currency_t *currency) {\n  currency->quarters += quantity;\n  return currency;\n}\ncurrency_t *set_dimes(int quantity, currency_t *currency) {\n  currency->dimes += quantity;\n  return currency;\n}\ncurrency_t *set_nickels(int quantity, currency_t *currency) {\n  currency->nickels += quantity;\n  return currency;\n} \ncurrency_t *set_pennies(int quantity, currency_t *currency) {\n  currency->pennies += quantity;\n  return currency;\n}\n \nint init_45_cents(void *currency) {\n  currency_t *c = (currency_t *)currency;\n  if (thrd_success != mtx_lock(&c->lock)) {\n    /* Handle error */\n  }\n  set_quarters(1, set_dimes(2, currency));\n  if (thrd_success != mtx_unlock(&c->lock)) {\n    /* Handle error */\n  }\n  return 0;\n}\nint init_60_cents(void *currency) {\n  currency_t *c = (currency_t *)currency;\n  if (thrd_success != mtx_lock(&c->lock)) {\n    /* Handle error */\n  }\n  set_quarters(2, set_dimes(1, currency));\n  if (thrd_success != mtx_unlock(&c->lock)) {\n    /* Handle error */\n  }\n  return 0;\n}\n \nint main(void) {\n  int result;\n  thrd_t thrd1;\n  thrd_t thrd2;\n  currency_t currency = {0, 0, 0, 0};\n \n  if (thrd_success != mtx_init(&currency.lock, mtx_plain)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd1, init_45_cents, &currency)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&thrd2, init_60_cents, &currency)) {\n    /* Handle error */\n  }\n \n  if (thrd_success != thrd_join(thrd1, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(thrd2, NULL)) {\n    /* Handle error */\n  }\n \n  printf(\"%d quarters, %d dimes, %d nickels, %d pennies\\n\",\n         currency.quarters, currency.dimes, currency.nickels, currency.pennies);\n \n  mtx_destroy(&currency.lock);\n  return 0;\n}",
          "explanation_after": "Failure to ensure the atomicity of two or more operations that must be performed as a single atomic operation can result in race conditions in multithreaded applications.\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nCON08-C\n\nLow\n\nProbable\n\nNo\n\nP2\n\nL3\n\nMITRE CWE\n\nCWE-362 , Concurrent execution using shared resource with improper synchronization (\"race condition\") CWE-366, Race condition within a thread CWE-662 , Improper synchronization\n\n[ ISO/IEC 9899:2011 ]"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to ensure the atomicity of two or more operations that must be performed as a single atomic operation can result in race conditions in multithreaded applications.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON09-C",
    "title": "Avoid the ABA problem when using lock-free algorithms",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON09-C.+Avoid+the+ABA+problem+when+using+lock-free+algorithms",
    "description": "Lock-free programming is a technique that allows concurrent updates of shared data structures without using explicit locks. This method ensures that no threads block for arbitrarily long times, and it thereby boosts performance.\n\nLock-free programming has the following advantages:\n\nCan be used in places where locks must be avoided, such as interrupt handlers Efficiency benefits compared to lock-based algorithms for some workloads, including potential scalability benefits on multiprocessor machines Avoidance of priority inversion in real-time systems\n\nLock-free programming requires the use of special atomic processor instructions, such as CAS (compare and swap), LL/SC (load linked/store conditional), or the C Standard atomic_compare_exchange generic functions.\n\natomic_compare_exchange\n\nApplications for lock-free programming include\n\nRead-copy-update€ (RCU) in Linux 2.5 kernel Lock-free programming on AMD multicore systems\n\nThe ABA problem occurs during synchronization: a memory location is read twice and has the same value for both reads. However, another thread has modified the value, performed other work, then modified the value back between the two reads, thereby tricking the first thread into thinking that the value never changed.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to zero the maximum element of an array. The example is assumed to run in a multithreaded environment, where all variables are accessed by other threads.",
          "code": "#include <stdatomic.h>\n \n/*\n * Sets index to point to index of maximum element in array\n * and value to contain maximum array value.\n */\nvoid find_max_element(atomic_int array[], size_t *index, int *value);\n\nstatic atomic_int array[];\n\nvoid func(void) {\n  size_t index;\n  int value;\n  find_max_element(array, &index, &value);\n  /* ... */\n  if (!atomic_compare_exchange_strong(array[index], &value, 0)) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "The compare-and-swap operation sets array[index] to 0 if and only if it is currently set to value . However, this code does not necessarily zero out the maximum value of the array because\n\nindex may have changed. value may have changed (that is, the value of the value variable). value may no longer be the maximum value in the array."
        },
        "compliant": {
          "heading": "Compliant Solution (Mutex)",
          "pre_code_commentary": "This compliant solution uses a mutex to prevent the data from being modified during the operation. Although this code is thread-safe, it is no longer lock-free.",
          "code": "#include <stdatomic.h>\n#include <threads.h>\n \nstatic atomic_int array[];\nstatic mtx_t array_mutex;\n\nvoid func(void) {\n  size_t index;\n  int value;\n  if (thrd_success != mtx_lock(&array_mutex)) {\n    /* Handle error */\n  }\n  find_max_element(array, &index, &value);\n  /* ... */\n  if (!atomic_compare_exchange_strong(array[index], &value, 0)) {\n    /* Handle error */\n  }\n  if (thrd_success != mtx_unlock(&array_mutex)) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (GNU Glib)",
          "pre_code_commentary": "This code implements a queue data structure using lock-free programming. It is implemented using glib. The function CAS() internally uses g_atomic_pointer_compare_and_exchange() .",
          "code": "#include <glib.h>\n#include <glib-object.h>\n\ntypedef struct node_s {\n  void *data;\n  Node *next;\n} Node;\n\ntypedef struct queue_s {\n  Node *head;\n  Node *tail;\n} Queue;\n\nQueue* queue_new(void) {\n  Queue *q = g_slice_new(sizeof(Queue));\n  q->head = q->tail = g_slice_new(sizeof(Node));\n  return q;\n}\n\nvoid queue_enqueue(Queue *q, gpointer data) {\n  Node *node;\n  Node *tail;\n  Node *next;\n\n  node = g_slice_new(Node);\n  node->data = data;\n  node->next = NULL;\n  while (TRUE) {\n    tail = q->tail;\n    next = tail->next;\n    if (tail != q->tail) {\n      continue;\n    }\n    if (next != NULL) {\n      CAS(&q->tail, tail, next);\n      continue;\n    }\n    if (CAS(&tail->next, NULL, node)) {\n      break;\n    }\n  }\n  CAS(&q->tail, tail, node);\n}\n\ngpointer queue_dequeue(Queue *q) {\n  Node *node;\n  Node *head;\n  Node *tail;\n  Node *next;\n  gpointer data;\n\n  while (TRUE) {\n    head = q->head;\n    tail = q->tail;\n    next = head->next;\n    if (head != q->head) {\n      continue;\n    }\n    if (next == NULL) {\n      return NULL; /* Empty */\n    }\n    if (head == tail) {\n      CAS(&q->tail, tail, next);\n      continue;\n    }\n    data = next->data;\n    if (CAS(&q->head, head, next)) {\n      break;\n    }\n  }\n  g_slice_free(Node, head);\n  return data;\n}\n",
          "explanation_after": "Assume there are two threads ( T1 and T2 ) operating simultaneously on the queue. The queue looks like this:\n\nhead -> A -> B -> C -> tail\n\nThe following sequence of operations occurs:\n\nThread\n\nQueue Before\n\nOperation\n\nQueue After\n\nT1\n\nEnters queue_dequeue() function head = A, tail = C next = B after executing data = next->data; This thread gets preempted\n\nT2\n\nRemoves node A\n\nhead -> B -> C -> tail\n\nRemoves node B\n\nhead -> C -> tail\n\nEnqueues node A back into the queue\n\nhead -> C -> A -> tail\n\nRemoves node C\n\nhead -> A -> tail\n\nEnqueues a new node D After enqueue operation, thread 2 gets preempted\n\nhead -> A -> D -> tail\n\nThread 1 starts execution Compares the local head = q->head = A (true in this case) Updates q->head with node B (but node B is removed)\n\nundefined {}\n\nAccording to the sequence of events in this table, head will now point to memory that was freed. Also, if reclaimed memory is returned to the operating system (for example, using munmap() ), access to such memory locations can result in fatal access violation errors. The ABA problem occurred because of the internal reuse of nodes that have been popped off the list or the reclamation of memory occupied by removed nodes ."
        },
        "compliant": {
          "heading": "Compliant Solution (GNU Glib, Hazard Pointers)",
          "pre_code_commentary": "According to [ Michael 2004 ], t he core idea is to associate a number (typically one or two) of single-writer, multi-reader shared pointers, called hazard pointers, with each thread that intends to access lock-free dynamic objects. A hazard pointer either has a null value or points to a node that may be accessed later by that thread without further validation that the reference to the node is still valid. Each hazard pointer may be written only by its owner thread but may be read by other threads.\n\nIn this solution, communication with the associated algorithms is accomplished only through hazard pointers and a procedure RetireNode() that is called by threads to pass the addresses of retired nodes.",
          "code": "/* Hazard pointers types and structure */\nstructure HPRecType {\n  HP[K]:*Nodetype;\n  Next:*HPRecType;\n}\n \n/* The header of the HPRec list */\nHeadHPRec: *HPRecType;\n/* Per-thread private variables */\nrlist: listType; /* Initially empty */\nrcount: integer; /* Initially 0 */\n\n/* The retired node routine */\nRetiredNode(node:*NodeType) {\n  rlist.push(node);\n  rcount++;\n  if(rcount >= R)\n    Scan(HeadHPRec);\n}\n\n/* The scan routine */\nScan(head:*HPRecType) {\n  /* Stage 1: Scan HP list and insert non-null values in plist */\n  plist.init();\n  hprec<-head;\n  while (hprec != NULL) {\n    for (i<-0 to K-1) {\n      hptr<-hprec^HP[i];\n      if (hptr!= NULL)\n        plist.insert(hptr);\n    }\n    hprec<-hprec^Next;\n  }\n\n  /* Stage 2: search plist */\n  tmplist<-rlist.popAll();\n  rcount<-0;\n  node<-tmplist.pop();\n  while (node != NULL) {\n    if (plist.lookup(node)) {\n      rlist.push(node);\n      rcount++;\n    }\n    else {\n      PrepareForReuse(node);\n    }\n    node<-tmplist.pop();\n  }\n  plist.free();\n}\n",
          "explanation_after": "The scan consists of two stages. The first stage involves scanning the hazard pointer list for non-null values. Whenever a non-null value is encountered, it is inserted in a local list, plist , which can be implemented as a hash table. The second stage involves checking each node in rlist against the pointers in plist . If the lookup yields no match, the node is identified to be ready for arbitrary reuse. Otherwise, it is retained in rlist until the next scan by the current thread. Insertion and lookup in plist take constant expected time. The task of the memory reclamation method is to determine when a retired node is safely eligible for reuse while allowing memory reclamation.\n\nIn the implementation , the pointer being removed is stored in the hazard pointer, preventing other threads from reusing it and thereby avoiding the ABA problem."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (GNU Glib)",
          "pre_code_commentary": "This code implements a queue data structure using lock-free programming. It is implemented using glib. The function CAS() internally uses g_atomic_pointer_compare_and_exchange() .",
          "code": "#include <glib.h>\n#include <glib-object.h>\n\ntypedef struct node_s {\n  void *data;\n  Node *next;\n} Node;\n\ntypedef struct queue_s {\n  Node *head;\n  Node *tail;\n} Queue;\n\nQueue* queue_new(void) {\n  Queue *q = g_slice_new(sizeof(Queue));\n  q->head = q->tail = g_slice_new(sizeof(Node));\n  return q;\n}\n\nvoid queue_enqueue(Queue *q, gpointer data) {\n  Node *node;\n  Node *tail;\n  Node *next;\n\n  node = g_slice_new(Node);\n  node->data = data;\n  node->next = NULL;\n  while (TRUE) {\n    tail = q->tail;\n    next = tail->next;\n    if (tail != q->tail) {\n      continue;\n    }\n    if (next != NULL) {\n      CAS(&q->tail, tail, next);\n      continue;\n    }\n    if (CAS(&tail->next, NULL, node)) {\n      break;\n    }\n  }\n  CAS(&q->tail, tail, node);\n}\n\ngpointer queue_dequeue(Queue *q) {\n  Node *node;\n  Node *head;\n  Node *tail;\n  Node *next;\n  gpointer data;\n\n  while (TRUE) {\n    head = q->head;\n    tail = q->tail;\n    next = head->next;\n    if (head != q->head) {\n      continue;\n    }\n    if (next == NULL) {\n      return NULL; /* Empty */\n    }\n    if (head == tail) {\n      CAS(&q->tail, tail, next);\n      continue;\n    }\n    data = next->data;\n    if (CAS(&q->head, head, next)) {\n      break;\n    }\n  }\n  g_slice_free(Node, head);\n  return data;\n}\n",
          "explanation_after": "Assume there are two threads ( T1 and T2 ) operating simultaneously on the queue. The queue looks like this:\n\nhead -> A -> B -> C -> tail\n\nThe following sequence of operations occurs:\n\nThread\n\nQueue Before\n\nOperation\n\nQueue After\n\nT1\n\nEnters queue_dequeue() function head = A, tail = C next = B after executing data = next->data; This thread gets preempted\n\nT2\n\nRemoves node A\n\nhead -> B -> C -> tail\n\nRemoves node B\n\nhead -> C -> tail\n\nEnqueues node A back into the queue\n\nhead -> C -> A -> tail\n\nRemoves node C\n\nhead -> A -> tail\n\nEnqueues a new node D After enqueue operation, thread 2 gets preempted\n\nhead -> A -> D -> tail\n\nThread 1 starts execution Compares the local head = q->head = A (true in this case) Updates q->head with node B (but node B is removed)\n\nundefined {}\n\nAccording to the sequence of events in this table, head will now point to memory that was freed. Also, if reclaimed memory is returned to the operating system (for example, using munmap() ), access to such memory locations can result in fatal access violation errors. The ABA problem occurred because of the internal reuse of nodes that have been popped off the list or the reclamation of memory occupied by removed nodes ."
        },
        "compliant": {
          "heading": "Compliant Solution (GNU Glib, Mutex)",
          "pre_code_commentary": "In this compliant solution, mtx_lock() is used to lock the queue. When thread 1 locks on the queue to perform any operation, thread 2 cannot perform any operation on the queue, which prevents the ABA problem.",
          "code": "#include <threads.h>\n#include <glib-object.h>\n\ntypedef struct node_s {\n  void *data;\n  Node *next;\n} Node;\n\ntypedef struct queue_s {\n  Node *head;\n  Node *tail;\n  mtx_t mutex;\n} Queue;\n\nQueue* queue_new(void) {\n  Queue *q = g_slice_new(sizeof(Queue));\n  q->head = q->tail = g_slice_new(sizeof(Node));\n  return q;\n}\n\nint queue_enqueue(Queue *q, gpointer data) {\n  Node *node;\n  Node *tail;\n  Node *next;\n\n  /*\n   * Lock the queue before accessing the contents and\n   * check the return code for success.\n   */\n  if (thrd_success != mtx_lock(&(q->mutex))) {\n    return -1;  /* Indicate failure */\n  } else {\n    node = g_slice_new(Node);\n    node->data = data;\n    node->next = NULL;\n\n    if(q->head == NULL) {\n      q->head = node;\n      q->tail = node;\n    } else {\n      q->tail->next = node;\n      q->tail = node;\n    }\n    /* Unlock the mutex and check the return code */\n    if (thrd_success != mtx_unlock(&(queue->mutex))) {\n      return -1;  /* Indicate failure */\n    }\n  }\n  return 0;\n}\n\ngpointer queue_dequeue(Queue *q) {\n  Node *node;\n  Node *head;\n  Node *tail;\n  Node *next;\n  gpointer data;\n\n  if (thrd_success != mtx_lock(&(q->mutex)) {\n    return NULL;  /* Indicate failure */\n  } else {\n    head = q->head;\n    tail = q->tail;\n    next = head->next;\n    data = next->data;\n    q->head = next;\n    g_slice_free(Node, head);\n    if (thrd_success != mtx_unlock(&(queue->mutex))) {\n      return NULL;  /* Indicate failure */\n    }\n  }\n  return data;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The likelihood of having a race condition is low. Once the race condition occurs, the reading memory that has already been freed can lead to abnormal program termination or unintended information disclosure.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON30-C",
    "title": "Clean up thread-specific storage",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON30-C.+Clean+up+thread-specific+storage",
    "description": "The tss_create() function creates a thread-specific storage pointer identified by a key. Threads can allocate thread-specific storage and associate the storage with a key that uniquely identifies the storage by calling the tss_set() function. If not properly freed, this memory may be leaked. Ensure that thread-specific storage is freed.\n\ntss_create()\n\ntss_set()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, each thread dynamically allocates storage in the get_data() function, which is then associated with the global key by the call to tss_set() in the add_data() function. This memory is subsequently leaked when the threads terminate.",
          "code": "#include <threads.h>\n#include <stdlib.h>\n\n/* Global key to the thread-specific storage */\ntss_t key;\nenum { MAX_THREADS = 3 };\n\nint *get_data(void) {\n  int *arr = (int *)malloc(2 * sizeof(int));\n  if (arr == NULL) {\n    return arr;  /* Report error  */\n  }\n  arr[0] = 10;\n  arr[1] = 42;\n  return arr;\n}\n\nint add_data(void) {\n  int *data = get_data();\n  if (data == NULL) {\n    return -1;\t/* Report error */\n  }\n\n  if (thrd_success != tss_set(key, (void *)data)) {\n    /* Handle error */\n  }\n  return 0;\n}\n\nvoid print_data(void) {\n  /* Get this thread's global data from key */\n  int *data = tss_get(key);\n\n  if (data != NULL) {\n    /* Print data */\n  } \n}\n\nint function(void *dummy) {\n  if (add_data() != 0) {\n    return -1;\t/* Report error */\n  }\n  print_data();\n  return 0;\n}\n\nint main(void) {\n  thrd_t thread_id[MAX_THREADS];\n\n  /* Create the key before creating the threads */\n  if (thrd_success != tss_create(&key, NULL)) {\n    /* Handle error */\n  }\n\n  /* Create threads that would store specific storage */\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {\n      /* Handle error */\n    }\n  }\n\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_join(thread_id[i], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  tss_delete(key);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, each thread explicitly frees the thread-specific storage returned by the tss_get() function before terminating:",
          "code": "#include <threads.h>\n#include <stdlib.h>\n \n/* Global key to the thread-specific storage */\ntss_t key;\n \nint function(void *dummy) {\n  if (add_data() != 0) {\n    return -1;\t/* Report error */\n  }\n  print_data();\n  free(tss_get(key));\n  return 0;\n}\n\n/* ... Other functions are unchanged */\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, each thread dynamically allocates storage in the get_data() function, which is then associated with the global key by the call to tss_set() in the add_data() function. This memory is subsequently leaked when the threads terminate.",
          "code": "#include <threads.h>\n#include <stdlib.h>\n\n/* Global key to the thread-specific storage */\ntss_t key;\nenum { MAX_THREADS = 3 };\n\nint *get_data(void) {\n  int *arr = (int *)malloc(2 * sizeof(int));\n  if (arr == NULL) {\n    return arr;  /* Report error  */\n  }\n  arr[0] = 10;\n  arr[1] = 42;\n  return arr;\n}\n\nint add_data(void) {\n  int *data = get_data();\n  if (data == NULL) {\n    return -1;\t/* Report error */\n  }\n\n  if (thrd_success != tss_set(key, (void *)data)) {\n    /* Handle error */\n  }\n  return 0;\n}\n\nvoid print_data(void) {\n  /* Get this thread's global data from key */\n  int *data = tss_get(key);\n\n  if (data != NULL) {\n    /* Print data */\n  } \n}\n\nint function(void *dummy) {\n  if (add_data() != 0) {\n    return -1;\t/* Report error */\n  }\n  print_data();\n  return 0;\n}\n\nint main(void) {\n  thrd_t thread_id[MAX_THREADS];\n\n  /* Create the key before creating the threads */\n  if (thrd_success != tss_create(&key, NULL)) {\n    /* Handle error */\n  }\n\n  /* Create threads that would store specific storage */\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {\n      /* Handle error */\n    }\n  }\n\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_join(thread_id[i], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  tss_delete(key);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution invokes a destructor function registered during the call to tss_create() to automatically free any thread-specific storage:",
          "code": "#include <threads.h>\n#include <stdlib.h>\n\n/* Global key to the thread-specific storage */\ntss_t key;\nenum { MAX_THREADS = 3 };\n\n/* ... Other functions are unchanged */\n\nvoid destructor(void *data) {\n  free(data);\n}\n \nint main(void) {\n  thrd_t thread_id[MAX_THREADS];\n\n  /* Create the key before creating the threads */\n  if (thrd_success != tss_create(&key, destructor)) {\n    /* Handle error */\n  }\n\n  /* Create threads that would store specific storage */\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {\n      /* Handle error */\n    }\n  }\n\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_join(thread_id[i], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  tss_delete(key);\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to free thread-specific objects results in memory leaks and could result in a denial-of-service attack .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON31-C",
    "title": "Do not destroy a mutex while it is locked",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON31-C.+Do+not+destroy+a+mutex+while+it+is+locked",
    "description": "Mutexes are used to protect shared data structures being concurrently accessed. If a mutex is destroyed while a thread is blocked waiting for that mutex, critical sections and shared data are no longer protected.\n\nThe C Standard, 7.28.4.1, paragraph 2 [ ISO/IEC 9899:2024 ], states\n\nThe mtx_destroy function releases any resources used by the mutex pointed to by mtx . No threads can be blocked waiting for the mutex pointed to by mtx .\n\nmtx_destroy\n\nmtx\n\nmtx\n\nThis statement implies that destroying a mutex while a thread is waiting on it is undefined behavior .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example creates several threads that each invoke the do_work() function, passing a unique number as an ID. The do_work() function initializes the lock mutex if the argument is 0 and destroys the mutex if the argument is max_threads - 1 . In all other cases, the do_work() function provides normal processing. Each thread, except the final cleanup thread, increments the atomic completed variable when it is finished.\n\nUnfortunately, this code contains several race conditions, allowing the mutex to be destroyed before it is unlocked. Additionally, there is no guarantee that lock will be initialized before it is passed to mtx_lock() . Each of these behaviors is undefined .",
          "code": "#include <stdatomic.h>\n#include <stddef.h>\n#include <threads.h>\n \nmtx_t lock;\n/* Atomic so multiple threads can modify safely */\natomic_int completed = ATOMIC_VAR_INIT(0);\nenum { max_threads = 5 }; \n\nint do_work(void *arg) {\n  int *i = (int *)arg;\n\n  if (*i == 0) { /* Creation thread */\n    if (thrd_success != mtx_init(&lock, mtx_plain)) {\n      /* Handle error */\n    }\n    atomic_store(&completed, 1);\n  } else if (*i < max_threads - 1) { /* Worker thread */\n    if (thrd_success != mtx_lock(&lock)) {\n      /* Handle error */\n    }\n    /* Access data protected by the lock */\n    atomic_fetch_add(&completed, 1);\n    if (thrd_success != mtx_unlock(&lock)) {\n      /* Handle error */\n    }\n  } else { /* Destruction thread */\n    mtx_destroy(&lock);\n  }\n  return 0;\n}\n \nint main(void) {\n  thrd_t threads[max_threads];\n  \n  for (size_t i = 0; i < max_threads; i++) {\n    if (thrd_success != thrd_create(&threads[i], do_work, &i)) {\n      /* Handle error */\n    }\n  }\n  for (size_t i = 0; i < max_threads; i++) {\n    if (thrd_success != thrd_join(threads[i], 0)) {\n      /* Handle error */\n    }\n  }\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution eliminates the race conditions by initializing the mutex in main() before creating the threads and by destroying the mutex in main() after joining the threads:",
          "code": "#include <stdatomic.h>\n#include <stddef.h>\n#include <threads.h>\n \nmtx_t lock;\n/* Atomic so multiple threads can increment safely */\natomic_int completed = ATOMIC_VAR_INIT(0);\nenum { max_threads = 5 }; \n\nint do_work(void *dummy) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  /* Access data protected by the lock */\n  atomic_fetch_add(&completed, 1);\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n\n  return 0;\n}\n\nint main(void) {\n  thrd_t threads[max_threads];\n  \n  if (thrd_success != mtx_init(&lock, mtx_plain)) {\n    /* Handle error */\n  }\n  for (size_t i = 0; i < max_threads; i++) {\n    if (thrd_success != thrd_create(&threads[i], do_work, NULL)) {\n      /* Handle error */\n    }\n  }\n  for (size_t i = 0; i < max_threads; i++) {\n    if (thrd_success != thrd_join(threads[i], 0)) {\n      /* Handle error */\n    }\n  }\n\n  mtx_destroy(&lock);\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Destroying a mutex while it is locked may result in invalid control flow and data corruption.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON32-C",
    "title": "Prevent data races when accessing bit-fields from multiple threads",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON32-C.+Prevent+data+races+when+accessing+bit-fields+from+multiple+threads",
    "description": "When accessing a bit-field, a thread may inadvertently access a separate bit-field in adjacent memory. This is because compilers are required to store multiple adjacent bit-fields in one storage unit whenever they fit. Consequently, data races may exist not just on a bit-field accessed by multiple threads but also on other bit-fields sharing the same byte or word.  A similar problem is discussed in CON43-C. Do not allow data races in multithreaded code , but the issue described by this rule can be harder to diagnose because it may not be obvious that the same memory location is being modified by multiple threads.\n\nOne approach for preventing data races in concurrent programming is to use a mutex. When properly observed by all threads, a mutex can provide safe and secure access to a shared object. However, mutexes provide no guarantees with regard to other objects that might be accessed when the mutex is not controlled by the accessing thread. Unfortunately, there is no portable way to determine which adjacent bit-fields may be stored along with the desired bit-field.\n\nAnother approach is to insert a non-bit-field member between any two bit-fields to ensure that each bit-field is the only one accessed within its storage unit. This technique effectively guarantees that no two bit-fields are accessed simultaneously.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Bit-field)",
          "pre_code_commentary": "Adjacent bit-fields may be stored in a single memory location. Consequently, modifying adjacent bit-fields in different threads is undefined behavior 5 , as shown in this noncompliant code example:",
          "code": "struct multi_threaded_flags {\n  unsigned int flag1 : 2;\n  unsigned int flag2 : 2;\n};\n\nstruct multi_threaded_flags flags;\n\nint thread1(void *arg) {\n  flags.flag1 = 1;\n  return 0;\n}\n\nint thread2(void *arg) {\n  flags.flag2 = 2;\n  return 0;\n}\n",
          "explanation_after": "The C Standard, 3.17, paragraph 3 [ ISO/IEC 9899:2024 ], states\n\nNote 2 to entry: A bit-field and an adjacent non-bit-field member are in separate memory locations. The same applies to two bit-fields, if one is declared inside a nested structure declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field member declaration. It is not safe to concurrently update two non-atomic bit-fields in the same structure if all members declared between them are also (nonzero-length) bit-fields, no matter what the sizes of those intervening bit-fields happen to be.\n\nFor example, the following instruction sequence is possible:"
        },
        "compliant": {
          "heading": "Compliant Solution (Bit-field, C11, Mutex)",
          "pre_code_commentary": "This compliant solution protects all accesses of the flags with a mutex, thereby preventing any data races:",
          "code": "#include <threads.h>\n \nstruct multi_threaded_flags {\n  unsigned int flag1 : 2;\n  unsigned int flag2 : 2;\n};\n\nstruct mtf_mutex {\n  struct multi_threaded_flags s;\n  mtx_t mutex;\n};\n\nstruct mtf_mutex flags;\n\nint thread1(void *arg) {\n  if (thrd_success != mtx_lock(&flags.mutex)) {\n    /* Handle error */\n  }\n  flags.s.flag1 = 1;\n  if (thrd_success != mtx_unlock(&flags.mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\n \nint thread2(void *arg) {\n  if (thrd_success != mtx_lock(&flags.mutex)) {\n    /* Handle error */\n  }\n  flags.s.flag2 = 2;\n  if (thrd_success != mtx_unlock(&flags.mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Bit-field)",
          "pre_code_commentary": "Adjacent bit-fields may be stored in a single memory location. Consequently, modifying adjacent bit-fields in different threads is undefined behavior 5 , as shown in this noncompliant code example:",
          "code": "struct multi_threaded_flags {\n  unsigned int flag1 : 2;\n  unsigned int flag2 : 2;\n};\n\nstruct multi_threaded_flags flags;\n\nint thread1(void *arg) {\n  flags.flag1 = 1;\n  return 0;\n}\n\nint thread2(void *arg) {\n  flags.flag2 = 2;\n  return 0;\n}\n",
          "explanation_after": "The C Standard, 3.17, paragraph 3 [ ISO/IEC 9899:2024 ], states\n\nNote 2 to entry: A bit-field and an adjacent non-bit-field member are in separate memory locations. The same applies to two bit-fields, if one is declared inside a nested structure declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field member declaration. It is not safe to concurrently update two non-atomic bit-fields in the same structure if all members declared between them are also (nonzero-length) bit-fields, no matter what the sizes of those intervening bit-fields happen to be.\n\nFor example, the following instruction sequence is possible:"
        },
        "compliant": {
          "heading": "Compliant Solution (C11)",
          "pre_code_commentary": "In this compliant solution, two threads simultaneously modify two distinct non-bit-field members of a structure. Because the members occupy different bytes in memory, no concurrency protection is required.",
          "code": "struct multi_threaded_flags {\n  unsigned char flag1;\n  unsigned char flag2;\n};\n \nstruct multi_threaded_flags flags;\n \nint thread1(void *arg) {\n  flags.flag1 = 1;\n  return 0;\n}\n\nint thread2(void *arg) {\n  flags.flag2 = 2;\n  return 0;\n}",
          "explanation_after": "Unlike C99, C11 and C23 explicitly define a memory location and provides the following note in subclause 3.17 paragraph 2 [ ISO/IEC 9899:2024 ]:\n\nNote 1 to entry: Two threads of execution can update and access separate memory locations without interfering with each other.\n\nIt is almost certain that flag1 and flag2 are stored in the same word. Using a compiler that conforms to C99 or earlier, if both assignments occur on a thread-scheduling interleaving that ends with both stores occurring after one another, it is possible that only one of the flags will be set as intended. The other flag will contain its previous value because both members are represented by the same word, which is the smallest unit the processor can work on. Before the changes were made to the C Standard for C11, there were no guarantees that these flags could be modified concurrently."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Although the race window is narrow, an assignment or an expression can evaluate improperly because of misinterpreted data resulting in a corrupted running state or unintended information disclosure.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON33-C",
    "title": "Avoid race conditions when using library functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON33-C.+Avoid+race+conditions+when+using+library+functions",
    "description": "Some C standard library functions are not guaranteed to be reentrant with respect to threads. Functions such as strtok() and asctime() return a pointer to the result stored in function-allocated memory on a per-process basis. Other functions such as rand() store state information in function-allocated memory on a per-process basis. Multiple threads invoking the same function can cause concurrency problems, which often result in abnormal behavior and can cause more serious vulnerabilities , such as abnormal termination , denial-of-service attack , and data integrity violations.\n\nstrtok()\n\nasctime()\n\nrand()\n\nAccording to the C Standard, the library functions listed in the following table may contain data races when invoked by multiple threads.\n\nFunctions Remediation rand() , srand() MSC30-C. Do not use the rand() function for generating pseudorandom numbers getenv() ENV34-C. Do not store pointers returned by certain functions strtok() strtok_r() in POSIX strerror() strerror_r() in POSIX asctime() , ctime() , localtime() , gmtime() strftime() setlocale() Protect multithreaded access to locale-specific functions with a mutex ATOMIC_VAR_INIT , atomic_init() Do not attempt to initialize an atomic variable from multiple threads tmpnam() tmpnam_r() in POSIX mbrtoc16() , c16rtomb() , mbrtoc32() , c32rtomb() Do not call with a null mbstate_t * argument\n\nrand()\n\nsrand()\n\ngetenv()\n\nstrtok()\n\nstrtok_r()\n\nstrerror()\n\nstrerror_r()\n\nasctime()\n\nctime()\n\nlocaltime()\n\ngmtime()\n\nstrftime()\n\nsetlocale()\n\nATOMIC_VAR_INIT\n\natomic_init()\n\ntmpnam()\n\ntmpnam_r()\n\nmbrtoc16()\n\nc16rtomb()\n\nmbrtoc32()\n\nc32rtomb()\n\nmbstate_t *\n\nSection 2.9.1 of the Portable Operating System Interface (POSIX ® ), Base Specifications, Issue 7 [ IEEE Std 1003.1:2013 ] extends the list of functions that are not required to be thread-safe.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the function f() is called from within a multithreaded application but encounters an error while calling a system function. The strerror() function returns a human-readable error string given an error number.\n\nThe C Standard, 7.26.6.3 paragraph 3 [ ISO/IEC 9899:2024 ], specifically states that strerror() is not required to avoid data races.\n\nThe strerror function is not required to avoid data races with other calls to the strerror function.\n\nAn implementation could write the error string into a static array and return a pointer to it, and that array might be accessible and modifiable by other threads.",
          "code": "#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n \nvoid f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n\n  if (0 != fgetpos(fp, &pos)) {\n    char *errmsg = strerror(errno);\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}",
          "explanation_after": "This code first sets errno to 0 to comply with ERR30-C. Take care when reading errno ."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX, strerror_r() )",
          "pre_code_commentary": "This compliant solution uses the POSIX strerror_r() function, which has the same functionality as strerror() but guarantees thread safety:",
          "code": "#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n\nenum { BUFFERSIZE = 64 };\n \nvoid f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n\n  if (0 != fgetpos(fp, &pos)) {\n    char errmsg[BUFFERSIZE];\n    if (strerror_r(errno, errmsg, BUFFERSIZE) != 0) {\n      /* Handle error */\n    }\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}",
          "explanation_after": "Linux provides two versions of strerror_r() , known as the XSI-compliant version and the GNU-specific version . This compliant solution assumes the XSI-compliant version, which is the default when an application is compiled as required by POSIX (that is, by defining _POSIX_C_SOURCE or _XOPEN_SOURCE appropriately). The strerror_r() manual page lists versions that are available on a particular system."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Race conditions caused by multiple threads invoking the same library function can lead to abnormal termination of the application, data integrity violations, or a denial-of-service attack .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON34-C",
    "title": "Declare objects shared between threads with appropriate storage durations",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON34-C.+Declare+objects+shared+between+threads+with+appropriate+storage+durations",
    "description": "Accessing the automatic or thread-local variables of one thread from another thread is implementation-defined behavior and can cause invalid memory accesses because the execution of threads can be interwoven within the constraints of the synchronization model. As a result, the referenced stack frame or thread-local variable may no longer be valid when another thread tries to access it. Shared static variables can be protected by thread synchronization mechanisms.\n\nHowever, automatic (local) variables cannot be shared in the same manner because the referenced stack frame's thread would need to stop executing, or some other mechanism must be employed to ensure that the referenced stack frame is still valid. Do not access automatic or thread-local objects from a thread other than the one with which the object is associated. See DCL30-C. Declare objects with appropriate storage durations for information on how to declare objects with appropriate storage durations when data is not being shared between threads.\n\nNoncompliant Code Example (Automatic Storage Duration)\n\nThis noncompliant code example passes the address of a variable to a child thread, which prints it out. The variable has automatic storage duration. Depending on the execution order, the child thread might reference the variable after the variable's lifetime in the parent thread. This would cause the child thread to access an invalid memory location.\n\n#include <threads.h>\n#include <stdio.h>\n\nint child_thread(void *val) {\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return 0;\n}\n\nvoid create_thread(thrd_t *tid) {\n  int val = 1;\n  if (thrd_success != thrd_create(tid, child_thread, &val)) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  thrd_t tid;\n  create_thread(&tid);\n  \n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}\n\n#include <threads.h>\n#include <stdio.h>\n\nint child_thread(void *val) {\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return 0;\n}\n\nvoid create_thread(thrd_t *tid) {\n  int val = 1;\n  if (thrd_success != thrd_create(tid, child_thread, &val)) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  thrd_t tid;\n  create_thread(&tid);\n  \n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Automatic Storage Duration)",
          "pre_code_commentary": "One practice is to ensure that all objects with automatic storage duration shared between threads are declared such that their lifetime extends past the lifetime of the threads. This can be accomplished using a thread synchronization mechanism, such as thrd_join() . In this code example, val is declared in main() , where thrd_join() is called. Because the parent thread waits until the child thread completes before continuing its execution, the shared objects have a lifetime at least as great as the thread.",
          "code": "#include <threads.h>\n#include <stdio.h>\n\nint child_thread(void *val) {\n  int *result = (int *)val;\n  printf(\"Result: %d\\n\", *result);  /* Correctly prints 1 */\n  return 0;\n}\n \nvoid create_thread(thrd_t *tid, int *val) {\n  if (thrd_success != thrd_create(tid, child_thread, val)) {\n    /* Handle error */\n  }\n}\n \nint main(void) {\n  int val = 1;\n  thrd_t tid;\n  create_thread(&tid, &val);\n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution (Static Storage Duration)",
          "pre_code_commentary": "This compliant solution stores the value in an object having static storage duration. The lifetime of this object is the entire execution of the program; consequently, it can be safely accessed by any thread.",
          "code": "#include <threads.h>\n#include <stdio.h>\n\nint child_thread(void *v) {\n  int *result = (int *)v;\n  printf(\"Result: %d\\n\", *result);  /* Correctly prints 1 */\n  return 0;\n}\n \nvoid create_thread(thrd_t *tid) {\n  static int val = 1;\n  if (thrd_success != thrd_create(tid, child_thread, &val)) {\n    /* Handle error */\n  }\n}\n \nint main(void) {\n  thrd_t tid;\n  create_thread(&tid);\n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution (Allocated Storage Duration)",
          "pre_code_commentary": "This compliant solution stores the value passed to the child thread in a dynamically allocated object. Because this object will persist until explicitly freed, the child thread can safely access its value.",
          "code": "#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint child_thread(void *val) {\n  int *result = (int *)val;\n  printf(\"Result: %d\\n\", *result); /* Correctly prints 1 */\n  return 0;\n}\n \nvoid create_thread(thrd_t *tid, int *value) {\n  *value = 1;\n  if (thrd_success != thrd_create(tid, child_thread,\n                                  value)) {\n    /* Handle error */\n  }\n}\n \nint main(void) {\n  thrd_t tid;\n  int *value = (int *)malloc(sizeof(int));\n  if (!value) {\n    /* Handle error */\n  }\n  create_thread(&tid, value);\n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  free(value);\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Thread-Specific Storage)",
          "pre_code_commentary": "In this noncompliant code example, the value is stored in thread-specific storage of the parent thread. However, because thread-specific data is available only to the thread that stores it, the child_thread() function will set result to a null value.",
          "code": "#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nstatic tss_t key; \n \nint child_thread(void *v) {\n  void *result = tss_get(*(tss_t *)v);\n  printf(\"Result: %d\\n\", *(int *)result);\n  return 0;\n}\n \nint create_thread(void *thrd) {\n  int *val = (int *)malloc(sizeof(int));\n  if (val == NULL) {\n    /* Handle error */\n  }\n  *val = 1;\n  if (thrd_success != tss_set(key, val)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create((thrd_t *)thrd,\n                                  child_thread, &key)) {\n    /* Handle error */\n  }\n  return 0;\n}\n\nint main(void) {\n  thrd_t parent_tid, child_tid;\n\n  if (thrd_success != tss_create(&key, free)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&parent_tid, create_thread,\n                                  &child_tid)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(parent_tid, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(child_tid, NULL)) {\n    /* Handle error */\n  }\n  tss_delete(key);\n  return 0;\n} ",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Thread-Specific Storage)",
          "pre_code_commentary": "This compliant solution illustrates how thread-specific storage can be combined with a call to a thread synchronization mechanism, such as thrd_join() . Because the parent thread waits until the child thread completes before continuing its execution, the child thread is guaranteed to access a valid live object.",
          "code": "#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nstatic tss_t key;\n\nint child_thread(void *v) {\n  int *result = v;\n  printf(\"Result: %d\\n\", *result); /* Correctly prints 1 */\n  return 0;\n}\n\nint create_thread(void *thrd) {\n  int *val = (int *)malloc(sizeof(int));\n  if (val == NULL) {\n    /* Handle error */\n  }\n  *val = 1;\n  if (thrd_success != tss_set(key, val)) {\n    /* Handle error */\n  }\n  /* ... */\n  void *v = tss_get(key);\n  if (thrd_success != thrd_create((thrd_t *)thrd,\n                                   child_thread, v)) {\n    /* Handle error */\n  }\n  return 0;\n}\n\nint main(void) {\n  thrd_t parent_tid, child_tid;\n\n  if (thrd_success != tss_create(&key, free)) {\n  /* Handle error */\n  }\n  if (thrd_success != thrd_create(&parent_tid, create_thread,\n                                  &child_tid)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(parent_tid, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(child_tid, NULL)) {\n    /* Handle error */\n  }\n  tss_delete(key);\nreturn 0;\n} ",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Thread-Specific Storage)",
          "pre_code_commentary": "In this noncompliant code example, the value is stored in thread-specific storage of the parent thread. However, because thread-specific data is available only to the thread that stores it, the child_thread() function will set result to a null value.",
          "code": "#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nstatic tss_t key; \n \nint child_thread(void *v) {\n  void *result = tss_get(*(tss_t *)v);\n  printf(\"Result: %d\\n\", *(int *)result);\n  return 0;\n}\n \nint create_thread(void *thrd) {\n  int *val = (int *)malloc(sizeof(int));\n  if (val == NULL) {\n    /* Handle error */\n  }\n  *val = 1;\n  if (thrd_success != tss_set(key, val)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create((thrd_t *)thrd,\n                                  child_thread, &key)) {\n    /* Handle error */\n  }\n  return 0;\n}\n\nint main(void) {\n  thrd_t parent_tid, child_tid;\n\n  if (thrd_success != tss_create(&key, free)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&parent_tid, create_thread,\n                                  &child_tid)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(parent_tid, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(child_tid, NULL)) {\n    /* Handle error */\n  }\n  tss_delete(key);\n  return 0;\n} ",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Thread-Local Storage, Windows, Visual Studio)",
          "pre_code_commentary": "Similar to the preceding compliant solution, this compliant solution uses thread-local storage combined with thread synchronization to ensure the child thread is accessing a valid live object. It uses the Visual Studio–specific __declspec(thread) language extension to provide the thread-local storage and the WaitForSingleObject() API to provide the synchronization.",
          "code": "#include <Windows.h>\n#include <stdio.h>\n\nDWORD WINAPI child_thread(LPVOID v) {\n  int *result = (int *)v;\n  printf(\"Result: %d\\n\", *result);  /* Correctly prints 1 */\n  return NULL;\n}\n\nint create_thread(HANDLE *tid) {\n  /* Declare val as a thread-local value */\n  __declspec(thread) int val = 1;\n  *tid = create_thread(NULL, 0, child_thread, &val, 0, NULL);\n  return *tid == NULL;\n}\n\nint main(void) {\n  HANDLE tid;\n \n  if (create_thread(&tid)) {\n    /* Handle error */\n  }\n \n  if (WAIT_OBJECT_0 != WaitForSingleObject(tid, INFINITE)) {\n    /* Handle error */\n  }\n  CloseHandle(tid);\n \n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (OpenMP, parallel )",
          "pre_code_commentary": "It is important to note that local data can be used securely with threads when using other thread interfaces, so the programmer need not always copy data into nonlocal memory when sharing data with threads. For example, the shared keyword in The OpenMP ® API Specification for Parallel Programming [ OpenMP ] can be used in combination with OpenMP's threading interface to share local memory without having to worry about whether local automatic variables remain valid.\n\nIn this noncompliant code example, a variable j is declared outside a parallel #pragma and not listed as a private variable. In OpenMP, variables outside a parallel #pragma are shared unless designated as private .",
          "code": "#include <omp.h>\n#include <stdio.h>\n \nint main(void) {\n  int j = 0;\n  #pragma omp parallel\n  {\n    int t = omp_get_thread_num();\n    printf(\"Running thread - %d\\n\", t);\n    for (int i = 0; i < 5050; i++) {\n    j++; /* j not private; could be a race condition */\n    }\n    printf(\"Just ran thread - %d\\n\", t);\n    printf(\"loop count %d\\n\", j);\n  }\nreturn 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (OpenMP, parallel , private )",
          "pre_code_commentary": "In this compliant solution, the variable j is declared outside of the parallel #pragma but is explicitly labeled as private :",
          "code": "#include <omp.h>\n#include <stdio.h>\n\nint main(void) {\n  int j = 0;\n  #pragma omp parallel private(j)\n  {\n    int t = omp_get_thread_num();\n    printf(\"Running thread - %d\\n\", t);\n    for (int i = 0; i < 5050; i++) {\n    j++;\n    }\n    printf(\"Just ran thread - %d\\n\", t);\n    printf(\"loop count %d\\n\", j);\n  }\nreturn 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Threads that reference the stack of other threads can potentially overwrite important information on the stack, such as function pointers and return addresses. The compiler may not generate warnings if the programmer allows one thread to access another thread's local variables, so a programmer may not catch a potential error at compile time. The remediation cost for this error is high because analysis tools have difficulty diagnosing problems with concurrency and race conditions.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON35-C",
    "title": "Avoid deadlock by locking in a predefined order",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON35-C.+Avoid+deadlock+by+locking+in+a+predefined+order",
    "description": "Mutexes are used to prevent multiple threads from causing a data race by accessing shared resources at the same time. Sometimes, when locking mutexes, multiple threads hold each other's lock, and the program consequently deadlocks. Four conditions are required for deadlock to occur:\n\nMutual exclusion Hold and wait No preemption Circular wait\n\nDeadlock needs all four conditions, so preventing deadlock requires preventing any one of the four conditions. One simple solution is to lock the mutexes in a predefined order, which prevents circular wait.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The behavior of this noncompliant code example depends on the runtime environment and the platform's scheduler. The program is susceptible to deadlock if thread thr1 attempts to lock ba2 's mutex at the same time thread thr2 attempts to lock ba1 's mutex in the deposit() function.",
          "code": "#include <stdlib.h>\n#include <threads.h>\n \ntypedef struct {\n  int balance;\n  mtx_t balance_mutex;\n} bank_account;\n\ntypedef struct {\n  bank_account *from;\n  bank_account *to;\n  int amount;\n} transaction;\n\nvoid create_bank_account(bank_account **ba,\n                         int initial_amount) {\n  bank_account *nba = (bank_account *)malloc(\n    sizeof(bank_account)\n  );\n  if (nba == NULL) {\n    /* Handle error */\n  }\n\n  nba->balance = initial_amount;\n  if (thrd_success\n      != mtx_init(&nba->balance_mutex, mtx_plain)) {\n    /* Handle error */\n  }\n\n  *ba = nba;\n}\n\nint deposit(void *ptr) {\n  transaction *args = (transaction *)ptr;\n\n  if (thrd_success != mtx_lock(&args->from->balance_mutex)) {\n    /* Handle error */\n  }\n\n  /* Not enough balance to transfer */\n  if (args->from->balance < args->amount) {\n    if (thrd_success\n        != mtx_unlock(&args->from->balance_mutex)) {\n      /* Handle error */\n    }\n    return -1; /* Indicate error */\n  }\n  if (thrd_success != mtx_lock(&args->to->balance_mutex)) {\n    /* Handle error */\n  }\n\n  args->from->balance -= args->amount;\n  args->to->balance += args->amount;\n\n  if (thrd_success\n      != mtx_unlock(&args->from->balance_mutex)) {\n    /* Handle error */\n  }\n\n  if (thrd_success\n      != mtx_unlock(&args->to->balance_mutex)) {\n    /* Handle error */\n  }\n\n  free(ptr);\n  return 0;\n}\n\nint main(void) {\n  thrd_t thr1, thr2;\n  transaction *arg1;\n  transaction *arg2;\n  bank_account *ba1;\n  bank_account *ba2;\n\n  create_bank_account(&ba1, 1000);\n  create_bank_account(&ba2, 1000);\n\n  arg1 = (transaction *)malloc(sizeof(transaction));\n  if (arg1 == NULL) {\n    /* Handle error */\n  }\n  arg2 = (transaction *)malloc(sizeof(transaction));\n  if (arg2 == NULL) {\n    /* Handle error */\n  }\n  arg1->from = ba1;\n  arg1->to = ba2;\n  arg1->amount = 100;\n\n  arg2->from = ba2;\n  arg2->to = ba1;\n  arg2->amount = 100;\n\n  /* Perform the deposits */\n  if (thrd_success\n     != thrd_create(&thr1, deposit, (void *)arg1)) {\n    /* Handle error */\n  }\n  if (thrd_success\n      != thrd_create(&thr2, deposit, (void *)arg2)) {\n    /* Handle error */\n  }\n  return 0;\n} ",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution eliminates the circular wait condition by establishing a predefined order for locking in the deposit() function. Each thread will lock on the basis of the bank_account ID, which is set when the bank_account struct is initialized.",
          "code": "#include <stdlib.h>\n#include <threads.h>\n \ntypedef struct {\n  int balance;\n  mtx_t balance_mutex;\n \n  /* Should not change after initialization */\n  unsigned int id;\n} bank_account;\n\ntypedef struct {\n  bank_account *from;\n  bank_account *to;\n  int amount;\n} transaction;\n\nunsigned int global_id = 1;\n\nvoid create_bank_account(bank_account **ba,\n                         int initial_amount) {\n  bank_account *nba = (bank_account *)malloc(\n    sizeof(bank_account)\n  );\n  if (nba == NULL) {\n    /* Handle error */\n  }\n\n  nba->balance = initial_amount;\n  if (thrd_success\n      != mtx_init(&nba->balance_mutex, mtx_plain)) {\n    /* Handle error */\n  }\n\n  nba->id = global_id++;\n  *ba = nba;\n}\n\nint deposit(void *ptr) {\n  transaction *args = (transaction *)ptr;\n  int result = -1;\n  mtx_t *first;\n  mtx_t *second;\n\n  if (args->from->id == args->to->id) {\n    return -1; /* Indicate error */\n  }\n\n  /* Ensure proper ordering for locking */\n  if (args->from->id < args->to->id) {\n    first = &args->from->balance_mutex;\n    second = &args->to->balance_mutex;\n  } else {\n    first = &args->to->balance_mutex;\n    second = &args->from->balance_mutex;\n  }\n  if (thrd_success != mtx_lock(first)) {\n    /* Handle error */\n  }\n  if (thrd_success != mtx_lock(second)) {\n    /* Handle error */\n  }\n\n  /* Not enough balance to transfer */\n  if (args->from->balance >= args->amount) {\n    args->from->balance -= args->amount;\n    args->to->balance += args->amount;\n    result = 0;\n  }\n\n  if (thrd_success != mtx_unlock(second)) {\n    /* Handle error */\n  }\n  if (thrd_success != mtx_unlock(first)) {\n    /* Handle error */\n  }\n  free(ptr);\n  return result;\n} ",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Deadlock prevents multiple threads from progressing, halting program execution. A denial-of-service attack is possible if the attacker can create the conditions for deadlock.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON36-C",
    "title": "Wrap functions that can spuriously wake up in a loop",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON36-C.+Wrap+functions+that+can+spuriously+wake+up+in+a+loop",
    "description": "The cnd_wait() and cnd_timedwait() functions temporarily cede possession of a mutex so that other threads that may be requesting the mutex can proceed. These functions must always be called from code that is protected by locking a mutex. The waiting thread resumes execution only after it has been notified, generally as the result of the invocation of the cnd_signal() or cnd_broadcast() function invoked by another thread. The cnd_wait() function must be invoked from a loop that checks whether a condition predicate holds. A condition predicate is an expression constructed from the variables of a function that must be true for a thread to be allowed to continue execution. The thread pauses execution, via cnd_wait() , cnd_timedwait() , or some other mechanism, and is resumed later, presumably when the condition predicate is true and the thread is notified.\n\ncnd_wait()\n\ncnd_timedwait()\n\ncnd_signal()\n\ncnd_broadcast()\n\ncnd_wait()\n\ncnd_wait()\n\ncnd_timedwait()\n\n#include <threads.h>\n#include <stdbool.h>\n \nextern bool until_finish(void);\nextern mtx_t lock;\nextern cnd_t condition;\n \nvoid func(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n\n  while (until_finish()) {  /* Predicate does not hold */\n    if (thrd_success != cnd_wait(&condition, &lock)) {\n      /* Handle error */\n    }\n  }\n \n  /* Resume when condition holds */\n\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}\n\n#include <threads.h>\n#include <stdbool.h>\n \nextern bool until_finish(void);\nextern mtx_t lock;\nextern cnd_t condition;\n \nvoid func(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n\n  while (until_finish()) {  /* Predicate does not hold */\n    if (thrd_success != cnd_wait(&condition, &lock)) {\n      /* Handle error */\n    }\n  }\n \n  /* Resume when condition holds */\n\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}\n\nThe notification mechanism notifies the waiting thread and allows it to check its condition predicate. The invocation of cnd_broadcast() in another thread cannot precisely determine which waiting thread will be resumed. Condition predicate statements allow notified threads to determine whether they should resume upon receiving the notification.\n\ncnd_broadcast()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example monitors a linked list and assigns one thread to consume list elements when the list is nonempty.\n\nThis thread pauses execution using cnd_wait() and resumes when notified, presumably when the list has elements to be consumed. It is possible for the thread to be notified even if the list is still empty, perhaps because the notifying thread used cnd_broadcast() , which notifies all threads. Notification using cnd_broadcast() is frequently preferred over using cnd_signal(). (See CON38-C. Preserve thread safety and liveness when using condition variables for more information.)\n\nA condition predicate is typically the negation of the condition expression in the loop. In this noncompliant code example, the condition predicate for removing an element from a linked list is (list->next != NULL) , whereas the condition expression for the while loop condition is (list->next == NULL) .\n\nThis noncompliant code example nests the cnd_wait() function inside an if block and consequently fails to check the condition predicate after the notification is received. If the notification was spurious or malicious, the thread would wake up prematurely.",
          "code": "#include <stddef.h>\n#include <threads.h>\n \nstruct node_t {\n  void *node;\n  struct node_t *next;\n};\n \nstruct node_t list;\nstatic mtx_t lock;\nstatic cnd_t condition;\n \nvoid consume_list_element(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n \n  if (list.next == NULL) {\n    if (thrd_success != cnd_wait(&condition, &lock)) {\n      /* Handle error */\n    }\n  }\n\n  /* Proceed when condition holds */\n\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution calls the cnd_wait() function from within a while loop to check the condition both before and after the call to cnd_wait() :",
          "code": "#include <stddef.h>\n#include <threads.h>\n \nstruct node_t {\n  void *node;\n  struct node_t *next;\n};\n \nstruct node_t list;\nstatic mtx_t lock;\nstatic cnd_t condition;\n \nvoid consume_list_element(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n \n  while (list.next == NULL) {\n    if (thrd_success != cnd_wait(&condition, &lock)) {\n      /* Handle error */\n    }\n  }\n\n  /* Proceed when condition holds */\n\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "Failure to enclose calls to the cnd_wait() or cnd_timedwait() functions inside a while loop can lead to indefinite blocking and denial of service (DoS).\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nCON36-C\n\nLow\n\nUnlikely\n\nYes\n\nNo\n\nP2\n\nL3\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\nLANG.STRUCT.ICOL CONCURRENCY.BADFUNC.CNDWAIT\n\nInappropriate Call Outside Loop Use of Condition Variable Wait\n\n24.11.0\n\n2025.2\n\nCERT.CONC.WAKE_IN_LOOP_C\n\n2024.2\n\nCERT_C-CON36-a\n\nWrap functions that can spuriously wake up in a loop\n\nR2024b\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON37-C",
    "title": "Do not call signal() in a multithreaded program",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON37-C.+Do+not+call+signal%28%29+in+a+multithreaded+program",
    "description": "Calling the signal() function in a multithreaded program is undefined behavior . (See undefined behavior 135 .)\n\nsignal()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example invokes the signal() function from a multithreaded program:",
          "code": "#include <signal.h>\n#include <stddef.h>\n#include <threads.h>\n \nvolatile sig_atomic_t flag = 0;\n\nvoid handler(int signum) {\n  flag = 1;\n}\n\n/* Runs until user sends SIGUSR1 */\nint func(void *data) {\n  while (!flag) {\n    /* ... */\n  }\n  return 0;\n}\n\nint main(void) {\n  signal(SIGUSR1, handler); /* Undefined behavior */\n  thrd_t tid;\n  \n  if (thrd_success != thrd_create(&tid, func, NULL)) {\n    /* Handle error */\n  }\n  /* ... */\n  return 0;\n}",
          "explanation_after": "NOTE: The SIGUSR1 signal value is not defined in the C Standard; consequently, this is not a C-compliant code example."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses an object of type atomic_bool to indicate when the child thread should terminate its loop:",
          "code": "#include <stdatomic.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <threads.h>\n \natomic_bool flag = ATOMIC_VAR_INIT(false);\n\nint func(void *data) {\n  while (!flag) {\n    /* ... */\n  }\n  return 0;\n}\n\nint main(void) {\n  thrd_t tid;\n  \n  if (thrd_success != thrd_create(&tid, func, NULL)) {\n    /* Handle error */\n  }\n  /* ... */\n  /* Set flag when done */\n  flag = true;\n\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Mixing signals and threads causes undefined behavior 135 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON38-C",
    "title": "Preserve thread safety and liveness when using condition variables",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON38-C.+Preserve+thread+safety+and+liveness+when+using+condition+variables",
    "description": "Both thread safety and liveness are concerns when using condition variables. The thread-safety property requires that all objects maintain consistent states in a multithreaded environment [ Lea 2000 ]. The liveness property requires that every operation or function invocation execute to completion without interruption; for example, there is no deadlock.\n\nCondition variables must be used inside a while loop. (See CON36-C. Wrap functions that can spuriously wake up in a loop for more information.) To guarantee liveness, programs must test the while loop condition before invoking the cnd_wait() function. This early test checks whether another thread has already satisfied the condition predicate and has sent a notification. Invoking the cnd_wait() function after the notification has been sent results in indefinite blocking.\n\nwhile\n\nwhile\n\ncnd_wait()\n\ncnd_wait()\n\nTo guarantee thread safety, programs must test the while loop condition after returning from the cnd_wait() function. When a given thread invokes the cnd_wait() function, it will attempt to block until its condition variable is signaled by a call to cnd_broadcast() or to cnd_signal() .\n\nwhile\n\ncnd_wait()\n\ncnd_wait()\n\ncnd_broadcast()\n\ncnd_signal()\n\nThe cnd_signal() function unblocks one of the threads that are blocked on the specified condition variable at the time of the call. If multiple threads are waiting on the same condition variable, the scheduler can select any of those threads to be awakened (assuming that all threads have the same priority level). The cnd_broadcast() function unblocks all of the threads that are blocked on the specified condition variable at the time of the call. The order in which threads execute following a call to cnd_broadcast() is unspecified. Consequently, an unrelated thread could start executing, discover that its condition predicate is satisfied, and resume execution even though it was supposed to remain dormant. For these reasons, threads must check the condition predicate after the cnd_wait() function returns. A while loop is the best choice for checking the condition predicate both before and after invoking cnd_wait() .\n\ncnd_signal()\n\ncnd_broadcast()\n\ncnd_broadcast()\n\ncnd_wait()\n\nwhile\n\ncnd_wait()\n\nThe use of cnd_signal() is safe if each thread uses a unique condition variable. If multiple threads share a condition variable, the use of cnd_signal() is safe only if the following conditions are met:\n\ncnd_signal()\n\ncnd_signal()\n\nAll threads must perform the same set of operations after waking up, which means that any thread can be selected to wake up and resume for a single invocation of cnd_signal() . Only one thread is required to wake upon receiving the signal.\n\ncnd_signal()\n\nThe cnd_broadcast() function can be used to unblock all of the threads that are blocked on the specified condition variable if the use of cnd_signal() is unsafe.\n\ncnd_broadcast()\n\ncnd_signal()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( cnd_signal() )",
          "pre_code_commentary": "This noncompliant code example uses five threads that are intended to execute sequentially according to the step level assigned to each thread when it is created (serialized processing). The current_step variable holds the current step level and is incremented when the respective thread completes. Finally, another thread is signaled so that the next step can be executed. Each thread waits until its step level is ready, and the cnd_wait() function call is wrapped inside a while loop, in compliance with CON36-C. Wrap functions that can spuriously wake up in a loop .",
          "code": "#include <stdio.h>\n#include <threads.h>\n\nenum { NTHREADS = 5 };\n\nmtx_t mutex;\ncnd_t cond;\n\nint run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n\n  if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n\n  printf(\"Thread %zu has the lock\\n\", my_step);\n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n\n    if (thrd_success != cnd_wait(&cond, &mutex)) {\n      /* Handle error */\n    }\n\n    printf(\"Thread %zu woke up\\n\", my_step);\n  }\n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n  current_step++;\n\n  /* Signal awaiting task */\n  if (thrd_success != cnd_signal(&cond)) {\n    /* Handle error */\n  }\n\n  printf(\"Thread %zu is exiting...\\n\", my_step);\n\n  if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\nint main(void) {\n  thrd_t threads[NTHREADS];\n  size_t step[NTHREADS];\n\n  if (thrd_success != mtx_init(&mutex, mtx_plain)) {\n    /* Handle error */\n  }\n\n  if (thrd_success != cnd_init(&cond)) {\n    /* Handle error */\n  }\n\n  /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    step[i] = i;\n\n    if (thrd_success != thrd_create(&threads[i], run_step,\n                                    &step[i])) {\n      /* Handle error */\n    }\n  }\n\n  /* Wait for all threads to complete */\n  for (size_t i = NTHREADS; i != 0; --i) {\n    if (thrd_success != thrd_join(threads[i-1], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  mtx_destroy(&mutex);\n  cnd_destroy(&cond);\n  return 0;\n} ",
          "explanation_after": "In this example, all threads share a condition variable. Each thread has its own distinct condition predicate because each thread requires current_step to have a different value before proceeding. When the condition variable is signaled, any of the waiting threads can wake up.\n\nThe following table illustrates a possible scenario in which the liveness property is violated. If, by chance, the notified thread is not the thread with the next step value, that thread will wait again. No additional notifications can occur, and eventually the pool of available threads will be exhausted.\n\nDeadlock: Out-of-Sequence Step Value\n\nTime\n\nThread # ( my_step )\n\ncurrent_step\n\nAction\n\n0\n\n3\n\nThread 3 executes first time: predicate is FALSE -> wait()\n\n1\n\n2\n\nThread 2 executes first time: predicate is FALSE -> wait()\n\n4\n\nThread 4 executes first time: predicate is FALSE -> wait()\n\nThread 0 executes first time: predicate is TRUE -> current_step++; cnd_signal()\n\nThread 1 executes first time: predicate is TRUE -> current_step++; cnd_signal()\n\n5\n\nThread 3 wakes up (scheduler choice): predicate is FALSE -> wait()\n\n6\n\n—\n\nThread exhaustion! No more threads to run, and a conditional variable signal is needed to wake up the others\n\nThis noncompliant code example violates the liveness property."
        },
        "compliant": {
          "heading": "Compliant Solution ( cnd_broadcast() )",
          "pre_code_commentary": "This compliant solution uses the cnd_broadcast() function to signal all waiting threads instead of a single random thread. Only the run_step() thread code from the noncompliant code example is modified, as follows:",
          "code": "#include <stdio.h>\n#include <threads.h>\n\nmtx_t mutex;\ncnd_t cond;\nint run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n\n  if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n\n  printf(\"Thread %zu has the lock\\n\", my_step);\n\n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n\n    if (thrd_success != cnd_wait(&cond, &mutex)) {\n      /* Handle error */\n    }\n\n  printf(\"Thread %zu woke up\\n\", my_step);\n  }\n\n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n\n  current_step++;\n\n  /* Signal ALL waiting tasks */\n  if (thrd_success != cnd_broadcast(&cond)) {\n    /* Handle error */\n  }\n\n  printf(\"Thread %zu is exiting...\\n\", my_step);\n\n  if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}",
          "explanation_after": "Awakening all threads guarantees the liveness property because each thread will execute its condition predicate test, and exactly one will succeed and continue execution."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( cnd_signal() )",
          "pre_code_commentary": "This noncompliant code example uses five threads that are intended to execute sequentially according to the step level assigned to each thread when it is created (serialized processing). The current_step variable holds the current step level and is incremented when the respective thread completes. Finally, another thread is signaled so that the next step can be executed. Each thread waits until its step level is ready, and the cnd_wait() function call is wrapped inside a while loop, in compliance with CON36-C. Wrap functions that can spuriously wake up in a loop .",
          "code": "#include <stdio.h>\n#include <threads.h>\n\nenum { NTHREADS = 5 };\n\nmtx_t mutex;\ncnd_t cond;\n\nint run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n\n  if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n\n  printf(\"Thread %zu has the lock\\n\", my_step);\n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n\n    if (thrd_success != cnd_wait(&cond, &mutex)) {\n      /* Handle error */\n    }\n\n    printf(\"Thread %zu woke up\\n\", my_step);\n  }\n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n  current_step++;\n\n  /* Signal awaiting task */\n  if (thrd_success != cnd_signal(&cond)) {\n    /* Handle error */\n  }\n\n  printf(\"Thread %zu is exiting...\\n\", my_step);\n\n  if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\nint main(void) {\n  thrd_t threads[NTHREADS];\n  size_t step[NTHREADS];\n\n  if (thrd_success != mtx_init(&mutex, mtx_plain)) {\n    /* Handle error */\n  }\n\n  if (thrd_success != cnd_init(&cond)) {\n    /* Handle error */\n  }\n\n  /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    step[i] = i;\n\n    if (thrd_success != thrd_create(&threads[i], run_step,\n                                    &step[i])) {\n      /* Handle error */\n    }\n  }\n\n  /* Wait for all threads to complete */\n  for (size_t i = NTHREADS; i != 0; --i) {\n    if (thrd_success != thrd_join(threads[i-1], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  mtx_destroy(&mutex);\n  cnd_destroy(&cond);\n  return 0;\n} ",
          "explanation_after": "In this example, all threads share a condition variable. Each thread has its own distinct condition predicate because each thread requires current_step to have a different value before proceeding. When the condition variable is signaled, any of the waiting threads can wake up.\n\nThe following table illustrates a possible scenario in which the liveness property is violated. If, by chance, the notified thread is not the thread with the next step value, that thread will wait again. No additional notifications can occur, and eventually the pool of available threads will be exhausted.\n\nDeadlock: Out-of-Sequence Step Value\n\nTime\n\nThread # ( my_step )\n\ncurrent_step\n\nAction\n\n0\n\n3\n\nThread 3 executes first time: predicate is FALSE -> wait()\n\n1\n\n2\n\nThread 2 executes first time: predicate is FALSE -> wait()\n\n4\n\nThread 4 executes first time: predicate is FALSE -> wait()\n\nThread 0 executes first time: predicate is TRUE -> current_step++; cnd_signal()\n\nThread 1 executes first time: predicate is TRUE -> current_step++; cnd_signal()\n\n5\n\nThread 3 wakes up (scheduler choice): predicate is FALSE -> wait()\n\n6\n\n—\n\nThread exhaustion! No more threads to run, and a conditional variable signal is needed to wake up the others\n\nThis noncompliant code example violates the liveness property."
        },
        "compliant": {
          "heading": "Compliant Solution (Using cnd_signal() with a Unique Condition Variable per Thread)",
          "pre_code_commentary": "Another compliant solution is to use a unique condition variable for each thread (all associated with the same mutex). In this case, cnd_signal() wakes up only the thread that is waiting on it. This solution is more efficient than using cnd_broadcast() because only the desired thread is awakened.\n\nThe condition predicate of the signaled thread must be true; otherwise, a deadlock will occur.",
          "code": "#include <stdio.h>\n#include <threads.h>\n\nenum { NTHREADS = 5 };\n\nmtx_t mutex;\ncnd_t cond[NTHREADS];\n\nint run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n\n  if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n\n  printf(\"Thread %zu has the lock\\n\", my_step);\n\n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n\n    if (thrd_success != cnd_wait(&cond[my_step], &mutex)) {\n      /* Handle error */\n    }\n\n    printf(\"Thread %zu woke up\\n\", my_step);\n  }\n\n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n\n  current_step++;\n\n  /* Signal next step thread */\n  if ((my_step + 1) < NTHREADS) {\n    if (thrd_success != cnd_signal(&cond[my_step + 1])) {\n      /* Handle error */\n    }\n  }\n\n  printf(\"Thread %zu is exiting...\\n\", my_step);\n\n  if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\n\nint main(void) {\n  thrd_t threads[NTHREADS];\n  size_t step[NTHREADS];\n\n  if (thrd_success != mtx_init(&mutex, mtx_plain)) {\n    /* Handle error */\n  }\n\n  for (size_t i = 0; i< NTHREADS; ++i) {\n    if (thrd_success != cnd_init(&cond[i])) {\n      /* Handle error */\n    }\n  }\n\n  /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    step[i] = i;\n    if (thrd_success != thrd_create(&threads[i], run_step,\n                                    &step[i])) {\n      /* Handle error */\n    }\n  }\n\n  /* Wait for all threads to complete */\n  for (size_t i = NTHREADS; i != 0; --i) {\n    if (thrd_success != thrd_join(threads[i-1], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  mtx_destroy(&mutex);\n\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    cnd_destroy(&cond[i]);\n  }\n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( cnd_signal() )",
          "pre_code_commentary": "This noncompliant code example uses five threads that are intended to execute sequentially according to the step level assigned to each thread when it is created (serialized processing). The current_step variable holds the current step level and is incremented when the respective thread completes. Finally, another thread is signaled so that the next step can be executed. Each thread waits until its step level is ready, and the cnd_wait() function call is wrapped inside a while loop, in compliance with CON36-C. Wrap functions that can spuriously wake up in a loop .",
          "code": "#include <stdio.h>\n#include <threads.h>\n\nenum { NTHREADS = 5 };\n\nmtx_t mutex;\ncnd_t cond;\n\nint run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n\n  if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n\n  printf(\"Thread %zu has the lock\\n\", my_step);\n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n\n    if (thrd_success != cnd_wait(&cond, &mutex)) {\n      /* Handle error */\n    }\n\n    printf(\"Thread %zu woke up\\n\", my_step);\n  }\n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n  current_step++;\n\n  /* Signal awaiting task */\n  if (thrd_success != cnd_signal(&cond)) {\n    /* Handle error */\n  }\n\n  printf(\"Thread %zu is exiting...\\n\", my_step);\n\n  if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\nint main(void) {\n  thrd_t threads[NTHREADS];\n  size_t step[NTHREADS];\n\n  if (thrd_success != mtx_init(&mutex, mtx_plain)) {\n    /* Handle error */\n  }\n\n  if (thrd_success != cnd_init(&cond)) {\n    /* Handle error */\n  }\n\n  /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    step[i] = i;\n\n    if (thrd_success != thrd_create(&threads[i], run_step,\n                                    &step[i])) {\n      /* Handle error */\n    }\n  }\n\n  /* Wait for all threads to complete */\n  for (size_t i = NTHREADS; i != 0; --i) {\n    if (thrd_success != thrd_join(threads[i-1], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  mtx_destroy(&mutex);\n  cnd_destroy(&cond);\n  return 0;\n} ",
          "explanation_after": "In this example, all threads share a condition variable. Each thread has its own distinct condition predicate because each thread requires current_step to have a different value before proceeding. When the condition variable is signaled, any of the waiting threads can wake up.\n\nThe following table illustrates a possible scenario in which the liveness property is violated. If, by chance, the notified thread is not the thread with the next step value, that thread will wait again. No additional notifications can occur, and eventually the pool of available threads will be exhausted.\n\nDeadlock: Out-of-Sequence Step Value\n\nTime\n\nThread # ( my_step )\n\ncurrent_step\n\nAction\n\n0\n\n3\n\nThread 3 executes first time: predicate is FALSE -> wait()\n\n1\n\n2\n\nThread 2 executes first time: predicate is FALSE -> wait()\n\n4\n\nThread 4 executes first time: predicate is FALSE -> wait()\n\nThread 0 executes first time: predicate is TRUE -> current_step++; cnd_signal()\n\nThread 1 executes first time: predicate is TRUE -> current_step++; cnd_signal()\n\n5\n\nThread 3 wakes up (scheduler choice): predicate is FALSE -> wait()\n\n6\n\n—\n\nThread exhaustion! No more threads to run, and a conditional variable signal is needed to wake up the others\n\nThis noncompliant code example violates the liveness property."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows, Condition Variables)",
          "pre_code_commentary": "This compliant solution uses  a CONDITION_VARIABLE object, available on Microsoft Windows (Vista and later):",
          "code": "#include <Windows.h>\n#include <stdio.h>\n \nCRITICAL_SECTION lock;\nCONDITION_VARIABLE cond;\n \nDWORD WINAPI run_step(LPVOID t) {\n  static size_t current_step = 0;\n  size_t my_step = (size_t)t;\n\n  EnterCriticalSection(&lock);  \n  printf(\"Thread %zu has the lock\\n\", my_step);\n\n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n \n    if (!SleepConditionVariableCS(&cond, &lock, INFINITE)) {\n      /* Handle error */\n    }\n\n    printf(\"Thread %zu woke up\\n\", my_step);\n  }\n\n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n\n  current_step++;\n \n  LeaveCriticalSection(&lock);\n \n  /* Signal ALL waiting tasks */\n  WakeAllConditionVariable(&cond);\n \n  printf(\"Thread %zu is exiting...\\n\", my_step);\n  return 0;\n}\n \nenum { NTHREADS = 5 };\n \nint main(void) {\n  HANDLE threads[NTHREADS];\n  \n  InitializeCriticalSection(&lock);\n  InitializeConditionVariable(&cond);\n \n  /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    threads[i] = CreateThread(NULL, 0, run_step, (LPVOID)i, 0, NULL);\n  }\n \n  /* Wait for all threads to complete */\n  WaitForMultipleObjects(NTHREADS, threads, TRUE, INFINITE);\n \n  DeleteCriticalSection(&lock);\n \n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to preserve the thread safety and liveness of a program when using condition variables can lead to indefinite blocking and denial of service (DoS).",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON39-C",
    "title": "Do not join or detach a thread that was previously joined or detached",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON39-C.+Do+not+join+or+detach+a+thread+that+was+previously+joined+or+detached",
    "description": "The C Standard, 7.28.5.6 paragraph 2 [ ISO/IEC 9899:2024 ], states that a thread shall not be joined once it was previously joined or detached.\n\nThe termination of the other thread synchronizes with the completion of the thrd_join function. The thread identified by thr shall not have been previously detached or joined with another thread.\n\nSimilarly, subclause 7.28.5.3 paragraph 2 [ ISO/IEC 9899:2024 ], states that a thread shall not be detached once it was previously joined or detached.\n\nThe thrd_detach function tells the operating system to dispose of any resources allocated to the thread identified by thr when that thread terminates. The thread identified by thr shall not have been previously detached or joined with another thread.\n\nViolating either of these subclauses results in undefined behavior 211 .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example detaches a thread that is later joined.",
          "code": "#include <stddef.h>\n#include <threads.h>\n \nint thread_func(void *arg) {\n  /* Do work */\n  thrd_detach(thrd_current());\n  return 0;\n}\n\nint main(void) {\n  thrd_t t;\n\n  if (thrd_success != thrd_create(&t, thread_func, NULL)) {\n    /* Handle error */\n    return 0;\n  }\n\n  if (thrd_success != thrd_join(t, 0)) {\n    /* Handle error */\n    return 0;\n  }\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not detach the thread. Its resources are released upon successfully joining with the main thread:",
          "code": "#include <stddef.h>\n#include <threads.h>\n  \nint thread_func(void *arg) {\n  /* Do work */\n  return 0;\n}\n\nint main(void) {\n  thrd_t t;\n\n  if (thrd_success != thrd_create(&t, thread_func, NULL)) {\n    /* Handle error */\n    return 0;\n  }\n\n  if (thrd_success != thrd_join(t, 0)) {\n    /* Handle error */\n    return 0;\n  }\n  return 0;\n} ",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Joining or detaching a previously joined or detached thread is undefined behavior 211 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON40-C",
    "title": "Do not refer to an atomic variable twice in an expression",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON40-C.+Do+not+refer+to+an+atomic+variable+twice+in+an+expression",
    "description": "A consistent locking policy guarantees that multiple threads cannot simultaneously access or modify shared data. Atomic variables eliminate the need for locks by guaranteeing thread safety when certain operations are performed on them. The thread-safe operations on atomic variables are specified in the C Standard, subclauses 7.17.7 and 7.17.8 [ ISO/IEC 9899:2024 ]. While atomic operations can be combined, combined operations do not provide the thread safety provided by individual atomic operations.\n\nEvery time an atomic variable appears on the left side of an assignment operator, including a compound assignment operator such as *= , an atomic write is performed on the variable. The use of the increment (++ ) or decrement (--) operators on an atomic variable constitutes an atomic read-and-write operation and is consequently thread-safe. Any reference of an atomic variable anywhere else in an expression indicates a distinct atomic read on the variable.\n\n*=\n\n)\n\n(--)\n\nIf the same atomic variable appears twice in an expression, then two atomic reads, or an atomic read and an atomic write, are required. Such a pair of atomic operations is not thread-safe, as another thread can modify the atomic variable between the two operations. Consequently, an atomic variable must not be referenced twice in the same expression.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( atomic_bool )",
          "pre_code_commentary": "This noncompliant code example declares a shared atomic_bool flag variable and provides a toggle_flag() method that negates the current value of flag :",
          "code": "#include <stdatomic.h>\n#include <stdbool.h>\n  \nstatic atomic_bool flag = ATOMIC_VAR_INIT(false);\n  \nvoid init_flag(void) {\n  atomic_init(&flag, false);\n}\n  \nvoid toggle_flag(void) {\n  bool temp_flag = atomic_load(&flag);\n  temp_flag = !temp_flag;\n  atomic_store(&flag, temp_flag);\n}\n    \nbool get_flag(void) {\n  return atomic_load(&flag);\n}\n",
          "explanation_after": "Execution of this code may result in unexpected behavior because the value of flag is read, negated, and written back. This occurs even though the read and write are both atomic.\n\nConsider, for example, two threads that call toggle_flag() . The expected effect of toggling flag twice is that it is restored to its original value. However, the scenario in the following table leaves flag in the incorrect state.\n\nTime\n\nflag\n\nThread\n\nAction\n\n1\n\ntrue\n\nt 1\n\nReads the current value of flag , which is true, into a cache\n\n2\n\nt 2\n\nReads the current value of flag , which is still true, into a different cache\n\n3\n\nToggles the temporary variable in the cache to false\n\n4\n\nToggles the temporary variable in the different cache to false\n\n5\n\nfalse\n\nWrites the cache variable's value to flag\n\n6\n\nWrites the different cache variable's value to flag\n\nAs a result, the effect of the call by t 2 is not reflected in flag ; the program behaves as if toggle_flag() was called only once, not twice.\n\nThis compliant solution uses a compare-and-exchange to guarantee that the correct value is stored in flag . All updates are visible to other threads. The call to atomic_compare_exchange_weak() is in a loop in conformance with CON41-C. Wrap functions that can fail spuriously in a loop .\n\nAn alternative solution is to use the atomic_flag data type for managing Boolean values atomically. However, atomic_flag does not support a toggle operation.\n\nThis compliant solution uses the ^= assignment operation to toggle flag . This operation is guaranteed to be atomic, according to the C Standard, 6.5.17.5, paragraph 3 [ ISO/IEC 9899:2024 ]. This operation performs a bitwise-exclusive-or between its arguments, but for Boolean arguments, this is equivalent to negation.\n\nAn alternative solution is to use a mutex to protect the atomic operation, but this solution loses the performance benefits of atomic variables.\n\nThis noncompliant code example takes an atomic global variable n and computes n + (n - 1) + (n - 2) + ... + 1 , using the formula n * (n + 1) / 2 :\n\nThe value of n may change between the two atomic reads of n in the expression, yielding an incorrect result.\n\nThis compliant solution passes the atomic variable as a function argument, forcing the variable to be copied and guaranteeing a correct result. Note that the function's formal parameter need not be atomic, and the atomic variable can still be passed as an actual argument.\n\nWhen operations on atomic variables are assumed to be atomic, but are not atomic, surprising data races can occur, leading to corrupted data and invalid control flow.\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nCON40-C\n\nMedium\n\nProbable\n\nYes\n\nNo\n\nP8\n\nL2\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\n7.2.0\n\nCONCURRENCY.MAA\n\nEVALUATION_ORDER (partial)\n\nMISRA 2012 Rule 13.2\n\nVOLATILE_ATOICITY (possible)\n\n24.11.0\n\n2025.2\n\nC1114, C1115, C1116\n\nC++3171, C++4150\n\nCERT.CONC.ATOMIC_TWICE_EXPR\n\n2024.2\n\nCERT_C-CON40-a\n\nDo not refer to an atomic variable twice in an expression\n\nR2024b\n\nChecks for:\n\nAtomic variable accessed twice in an expression Atomic load and store sequence not atomic\n\nRule fully covered.\n\n24.04\n\n6.02\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website .\n\nKey here (explains table format and definitions)\n\nTaxonomy\n\nTaxonomy item\n\nRelationship\n\nKey here for mapping notes\n\nCON40-C = Subset( CON43-C) Intersection( CON32-C, CON40-C) = Ø\n\nCWE-366 = Union( CON40-C, list) where list =\n\nC data races that do not involve an atomic variable used twice within an expression\n\n[ ISO/IEC 9899:2024 ]\n\n6.5.17.3, \"Compound Assignment\" 7.17, \"Atomics\""
        },
        "compliant": {
          "heading": "Compliant Solution ( atomic_compare_exchange_weak() )",
          "pre_code_commentary": null,
          "code": null,
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( atomic_bool )",
          "pre_code_commentary": "This noncompliant code example declares a shared atomic_bool flag variable and provides a toggle_flag() method that negates the current value of flag :",
          "code": "#include <stdatomic.h>\n#include <stdbool.h>\n  \nstatic atomic_bool flag = ATOMIC_VAR_INIT(false);\n  \nvoid init_flag(void) {\n  atomic_init(&flag, false);\n}\n  \nvoid toggle_flag(void) {\n  bool temp_flag = atomic_load(&flag);\n  temp_flag = !temp_flag;\n  atomic_store(&flag, temp_flag);\n}\n    \nbool get_flag(void) {\n  return atomic_load(&flag);\n}\n",
          "explanation_after": "Execution of this code may result in unexpected behavior because the value of flag is read, negated, and written back. This occurs even though the read and write are both atomic.\n\nConsider, for example, two threads that call toggle_flag() . The expected effect of toggling flag twice is that it is restored to its original value. However, the scenario in the following table leaves flag in the incorrect state.\n\nTime\n\nflag\n\nThread\n\nAction\n\n1\n\ntrue\n\nt 1\n\nReads the current value of flag , which is true, into a cache\n\n2\n\nt 2\n\nReads the current value of flag , which is still true, into a different cache\n\n3\n\nToggles the temporary variable in the cache to false\n\n4\n\nToggles the temporary variable in the different cache to false\n\n5\n\nfalse\n\nWrites the cache variable's value to flag\n\n6\n\nWrites the different cache variable's value to flag\n\nAs a result, the effect of the call by t 2 is not reflected in flag ; the program behaves as if toggle_flag() was called only once, not twice.\n\nThis compliant solution uses a compare-and-exchange to guarantee that the correct value is stored in flag . All updates are visible to other threads. The call to atomic_compare_exchange_weak() is in a loop in conformance with CON41-C. Wrap functions that can fail spuriously in a loop .\n\nAn alternative solution is to use the atomic_flag data type for managing Boolean values atomically. However, atomic_flag does not support a toggle operation.\n\nThis compliant solution uses the ^= assignment operation to toggle flag . This operation is guaranteed to be atomic, according to the C Standard, 6.5.17.5, paragraph 3 [ ISO/IEC 9899:2024 ]. This operation performs a bitwise-exclusive-or between its arguments, but for Boolean arguments, this is equivalent to negation.\n\nAn alternative solution is to use a mutex to protect the atomic operation, but this solution loses the performance benefits of atomic variables.\n\nThis noncompliant code example takes an atomic global variable n and computes n + (n - 1) + (n - 2) + ... + 1 , using the formula n * (n + 1) / 2 :\n\nThe value of n may change between the two atomic reads of n in the expression, yielding an incorrect result.\n\nThis compliant solution passes the atomic variable as a function argument, forcing the variable to be copied and guaranteeing a correct result. Note that the function's formal parameter need not be atomic, and the atomic variable can still be passed as an actual argument.\n\nWhen operations on atomic variables are assumed to be atomic, but are not atomic, surprising data races can occur, leading to corrupted data and invalid control flow.\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nCON40-C\n\nMedium\n\nProbable\n\nYes\n\nNo\n\nP8\n\nL2\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\n7.2.0\n\nCONCURRENCY.MAA\n\nEVALUATION_ORDER (partial)\n\nMISRA 2012 Rule 13.2\n\nVOLATILE_ATOICITY (possible)\n\n24.11.0\n\n2025.2\n\nC1114, C1115, C1116\n\nC++3171, C++4150\n\nCERT.CONC.ATOMIC_TWICE_EXPR\n\n2024.2\n\nCERT_C-CON40-a\n\nDo not refer to an atomic variable twice in an expression\n\nR2024b\n\nChecks for:\n\nAtomic variable accessed twice in an expression Atomic load and store sequence not atomic\n\nRule fully covered.\n\n24.04\n\n6.02\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website .\n\nKey here (explains table format and definitions)\n\nTaxonomy\n\nTaxonomy item\n\nRelationship\n\nKey here for mapping notes\n\nCON40-C = Subset( CON43-C) Intersection( CON32-C, CON40-C) = Ø\n\nCWE-366 = Union( CON40-C, list) where list =\n\nC data races that do not involve an atomic variable used twice within an expression\n\n[ ISO/IEC 9899:2024 ]\n\n6.5.17.3, \"Compound Assignment\" 7.17, \"Atomics\""
        },
        "compliant": {
          "heading": "Compliant Solution (Compound Assignment)",
          "pre_code_commentary": "This compliant solution uses the ^= assignment operation to toggle flag . This operation is guaranteed to be atomic, according to the C Standard, 6.5.17.5, paragraph 3 [ ISO/IEC 9899:2024 ]. This operation performs a bitwise-exclusive-or between its arguments, but for Boolean arguments, this is equivalent to negation.",
          "code": "#include <stdatomic.h>\n#include <stdbool.h>\n  \nstatic atomic_bool flag = ATOMIC_VAR_INIT(false);\n  \nvoid toggle_flag(void) {\n  flag ^= 1;\n}\n    \nbool get_flag(void) {\n  return flag;\n}",
          "explanation_after": "An alternative solution is to use a mutex to protect the atomic operation, but this solution loses the performance benefits of atomic variables."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example takes an atomic global variable n and computes n + (n - 1) + (n - 2) + ... + 1 , using the formula n * (n + 1) / 2 :",
          "code": "#include <stdatomic.h>\n\natomic_int n = ATOMIC_VAR_INIT(0);\n  \nint compute_sum(void) {\n  return n * (n + 1) / 2;\n}",
          "explanation_after": "The value of n may change between the two atomic reads of n in the expression, yielding an incorrect result."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution passes the atomic variable as a function argument, forcing the variable to be copied and guaranteeing a correct result. Note that the function's formal parameter need not be atomic, and the atomic variable can still be passed as an actual argument.",
          "code": "#include <stdatomic.h>\n \nint compute_sum(int n) {\n  return n * (n + 1) / 2;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "When operations on atomic variables are assumed to be atomic, but are not atomic, surprising data races can occur, leading to corrupted data and invalid control flow.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "CON41-C",
    "title": "Wrap functions that can fail spuriously in a loop",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON41-C.+Wrap+functions+that+can+fail+spuriously+in+a+loop",
    "description": "Functions that can fail spuriously should be wrapped in a loop.  The atomic_compare_exchange_weak() and atomic_compare_exchange_weak_explicit() functions both attempt to set an atomic variable to a new value but only if it currently possesses a known old value. Unlike the related functions atomic_compare_exchange_strong() and atomic_compare_exchange_strong_explicit() , these functions are permitted to fail spuriously . This makes these functions faster on some platforms—for example, on architectures that implement compare-and-exchange using load-linked/store-conditional instructions, such as Alpha, ARM, MIPS, and PowerPC. The C Standard, 7.17.7.4, paragraph 5 [ ISO/IEC 9899:2024 ], describes this behavior: A weak compare-and-exchange operation may fail spuriously. That is, even when the contents of memory referred to by expected and object are equal, it may return zero and store back to expected the same memory contents that were originally there. Noncompliant Code Example In this noncompliant code example, reorganize_data_structure() is to be used as an argument to thrd_create() .  After reorganizing, the function attempts to replace the head pointer so that it points to the new version.  If no other thread has changed the head pointer since it was originally loaded, reorganize_data_structure() is intended to exit the thread with a result of true , indicating success.  Otherwise, the new reorganization attempt is discarded and the thread is exited with a result of false .  However, atomic_compare_exchange_weak() may fail even when the head pointer has not changed. Therefore, reorganize_data_structure() may perform the work and then discard it unnecessarily. #include <stdatomic.h>\n#include <stdbool.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head;\n  bool success;\n\n  /* ... Reorganize the data structure ... */\n\n  success = atomic_compare_exchange_weak(ptr_to_head,\n                                         &old_head, new_head);\n  if (!success) {\n    cleanup_data_structure(new_head);\n  }\n  return success; /* Exit the thread */\n} Compliant Solution ( atomic_compare_exchange_weak() ) To recover from spurious failures, a loop must be used.  However, atomic_compare_exchange_weak() might fail because the head pointer changed, or the failure may be spurious. In either case, the thread must perform the work repeatedly until the compare-and-exchange succeeds, as shown in this compliant solution: #include <stdatomic.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head = NULL;\n  struct data *saved_old_head;\n  bool success;\n\n  do {\n    if (new_head != NULL) {\n      cleanup_data_structure(new_head);\n    }\n    saved_old_head = old_head;\n\n  /* ... Reorganize the data structure ... */\n\n  } while (!(success = atomic_compare_exchange_weak(\n               ptr_to_head, &old_head, new_head\n             )) && old_head == saved_old_head);\n  return success; /* Exit the thread */\n} This loop could also be part of a larger control flow; for example, the thread from the noncompliant code example could be retried if it returns false . Compliant Solution ( atomic_compare_exchange_strong() ) When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable, as in this compliant solution: #include <stdatomic.h>\n#include <stdbool.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head;\n  bool success;\n\n  /* ... Reorganize the data structure ... */\n\n  success = atomic_compare_exchange_strong(\n    ptr_to_head, &old_head, new_head\n  );\n  if (!success) {\n    cleanup_data_structure(new_head);\n  }\n  return success; /* Exit the thread */\n} Risk Assessment Failing to wrap the atomic_compare_exchange_weak() and atomic_compare_exchange_weak_explicit() functions in a loop can result in incorrect values and control flow. Rule Severity Likelihood Detectable Repairable Priority Level CON41-C Low Unlikely Yes No P2 L3 Automated Detection Tool Version Checker Description CodeSonar 9.1p0 LANG.STRUCT.ICOL Inappropriate Call Outside Loop Coverity 2017.07 BAD_CHECK_OF_WAIT_COND Implemented Cppcheck Premium 24.11.0 premium-cert-con41-c Helix QAC 2025.2 C2026 C++5023 Klocwork 2025.2 CERT.CONC.ATOMIC_COMP_FAIL_IN_LOOP Parasoft C/C++test 2024.2 CERT_C-CON41-a Wrap functions that can fail spuriously in a loop Polyspace Bug Finder R2024b CERT C: Rule CON41-C Checks for situations where functions that can spuriously fail are not wrapped in loop (rule fully covered) Related Vulnerabilities Search for vulnerabilities resulting from the violation of this rule on the CERT website . Related Guidelines Key here (explains table format and definitions) Taxonomy Taxonomy item Relationship CERT Oracle Secure Coding Standard for Java THI03-J. Always invoke wait() and await() methods inside a loop Prior to 2018-01-12: CERT: Unspecified Relationship Bibliography [ ISO/IEC 9899:2024 ] 7.17.7.4, \"The atomic_compare_exchange Generic Functions\" [ Lea 2000 ] 1.3.2, \"Liveness\" 3.2.2, \"Monitor Mechanics\"\n\n#include <stdatomic.h>\n#include <stdbool.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head;\n  bool success;\n\n  /* ... Reorganize the data structure ... */\n\n  success = atomic_compare_exchange_weak(ptr_to_head,\n                                         &old_head, new_head);\n  if (!success) {\n    cleanup_data_structure(new_head);\n  }\n  return success; /* Exit the thread */\n}\n\n#include <stdatomic.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head = NULL;\n  struct data *saved_old_head;\n  bool success;\n\n  do {\n    if (new_head != NULL) {\n      cleanup_data_structure(new_head);\n    }\n    saved_old_head = old_head;\n\n  /* ... Reorganize the data structure ... */\n\n  } while (!(success = atomic_compare_exchange_weak(\n               ptr_to_head, &old_head, new_head\n             )) && old_head == saved_old_head);\n  return success; /* Exit the thread */\n}\n\n#include <stdatomic.h>\n#include <stdbool.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head;\n  bool success;\n\n  /* ... Reorganize the data structure ... */\n\n  success = atomic_compare_exchange_strong(\n    ptr_to_head, &old_head, new_head\n  );\n  if (!success) {\n    cleanup_data_structure(new_head);\n  }\n  return success; /* Exit the thread */\n}\n\natomic_compare_exchange_weak()\n\natomic_compare_exchange_weak_explicit()\n\natomic_compare_exchange_strong()\n\natomic_compare_exchange_strong_explicit()\n\nexpected\n\nobject\n\nexpected\n\nreorganize_data_structure()\n\nthrd_create()\n\nreorganize_data_structure()\n\ntrue\n\nfalse\n\natomic_compare_exchange_weak()\n\nreorganize_data_structure()\n\natomic_compare_exchange_weak()\n\natomic_compare_exchange_weak()\n\nfalse\n\natomic_compare_exchange_strong()\n\natomic_compare_exchange_weak()\n\natomic_compare_exchange_weak_explicit()\n\natomic_compare_exchange",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, reorganize_data_structure() is to be used as an argument to thrd_create() .  After reorganizing, the function attempts to replace the head pointer so that it points to the new version.  If no other thread has changed the head pointer since it was originally loaded, reorganize_data_structure() is intended to exit the thread with a result of true , indicating success.  Otherwise, the new reorganization attempt is discarded and the thread is exited with a result of false .  However, atomic_compare_exchange_weak() may fail even when the head pointer has not changed. Therefore, reorganize_data_structure() may perform the work and then discard it unnecessarily.",
          "code": "#include <stdatomic.h>\n#include <stdbool.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head;\n  bool success;\n\n  /* ... Reorganize the data structure ... */\n\n  success = atomic_compare_exchange_weak(ptr_to_head,\n                                         &old_head, new_head);\n  if (!success) {\n    cleanup_data_structure(new_head);\n  }\n  return success; /* Exit the thread */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( atomic_compare_exchange_weak() )",
          "pre_code_commentary": "To recover from spurious failures, a loop must be used.  However, atomic_compare_exchange_weak() might fail because the head pointer changed, or the failure may be spurious. In either case, the thread must perform the work repeatedly until the compare-and-exchange succeeds, as shown in this compliant solution:",
          "code": "#include <stdatomic.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head = NULL;\n  struct data *saved_old_head;\n  bool success;\n\n  do {\n    if (new_head != NULL) {\n      cleanup_data_structure(new_head);\n    }\n    saved_old_head = old_head;\n\n  /* ... Reorganize the data structure ... */\n\n  } while (!(success = atomic_compare_exchange_weak(\n               ptr_to_head, &old_head, new_head\n             )) && old_head == saved_old_head);\n  return success; /* Exit the thread */\n}\n",
          "explanation_after": "This loop could also be part of a larger control flow; for example, the thread from the noncompliant code example could be retried if it returns false ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, reorganize_data_structure() is to be used as an argument to thrd_create() .  After reorganizing, the function attempts to replace the head pointer so that it points to the new version.  If no other thread has changed the head pointer since it was originally loaded, reorganize_data_structure() is intended to exit the thread with a result of true , indicating success.  Otherwise, the new reorganization attempt is discarded and the thread is exited with a result of false .  However, atomic_compare_exchange_weak() may fail even when the head pointer has not changed. Therefore, reorganize_data_structure() may perform the work and then discard it unnecessarily.",
          "code": "#include <stdatomic.h>\n#include <stdbool.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head;\n  bool success;\n\n  /* ... Reorganize the data structure ... */\n\n  success = atomic_compare_exchange_weak(ptr_to_head,\n                                         &old_head, new_head);\n  if (!success) {\n    cleanup_data_structure(new_head);\n  }\n  return success; /* Exit the thread */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( atomic_compare_exchange_strong() )",
          "pre_code_commentary": "When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable, as in this compliant solution:",
          "code": "#include <stdatomic.h>\n#include <stdbool.h>\n\nstruct data {\n  struct data *next;\n  /* ... */\n};\n\nextern void cleanup_data_structure(struct data *head);\n\nint reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head;\n  bool success;\n\n  /* ... Reorganize the data structure ... */\n\n  success = atomic_compare_exchange_strong(\n    ptr_to_head, &old_head, new_head\n  );\n  if (!success) {\n    cleanup_data_structure(new_head);\n  }\n  return success; /* Exit the thread */\n}\n",
          "explanation_after": "Failing to wrap the atomic_compare_exchange_weak() and atomic_compare_exchange_weak_explicit() functions in a loop can result in incorrect values and control flow.\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nCON41-C\n\nLow\n\nUnlikely\n\nYes\n\nNo\n\nP2\n\nL3\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\nLANG.STRUCT.ICOL\n\nInappropriate Call Outside Loop\n\n24.11.0\n\n2025.2\n\nC2026\n\nC++5023\n\nCERT.CONC.ATOMIC_COMP_FAIL_IN_LOOP\n\n2024.2\n\nWrap functions that can fail spuriously in a loop\n\nR2024b\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website .\n\nKey here (explains table format and definitions)\n\nTaxonomy\n\nTaxonomy item\n\nRelationship\n\n[ Lea 2000 ]\n\n1.3.2, \"Liveness\" 3.2.2, \"Monitor Mechanics\""
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to wrap the atomic_compare_exchange_weak() and atomic_compare_exchange_weak_explicit() functions in a loop can result in incorrect values and control flow.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON43-C",
    "title": "Do not allow data races in multithreaded code",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/CON43-C.+Do+not+allow+data+races+in+multithreaded+code",
    "description": "When multiple threads can read or modify the same data, use synchronization techniques to avoid software flaws that can lead to security vulnerabilities . Data races can often result in abnormal termination or denial of service , but it is possible for them to result in more serious vulnerabilities. The C Standard, section 5.1.2.5, paragraph 35 [ ISO/IEC 9899:2024 ], says:\n\nThe execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Assume this simplified code is part of a multithreaded bank system. Threads call credit() and debit() as money is deposited into and withdrawn from the single account. Because the addition and subtraction operations are not atomic, it is possible that two operations can occur concurrently, but only the result of one would be saved—despite declaring the account_balance volatile . For example, an attacker can credit the account with a sum of money and make a large number of small debits concurrently. Some of the debits might not affect the account balance because of the race condition, so the attacker is effectively creating money.",
          "code": "static volatile int account_balance;\n\nvoid debit(int amount) {\n  account_balance -= amount;\n}\n\nvoid credit(int amount) {\n  account_balance += amount;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Mutex)",
          "pre_code_commentary": "This compliant solution uses a mutex to make credits and debits atomic operations. All credits and debits will now affect the account balance, so an attacker cannot exploit the race condition to steal money from the bank. The mutex is created with the mtx_init() function. The presence of the mutex makes declaring account_balance volatile unnecessary.",
          "code": "#include <threads.h>\n\nstatic int account_balance;\nstatic mtx_t account_lock;\n \nint debit(int amount) {\n  if (mtx_lock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  account_balance -= amount;\n  if (mtx_unlock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  return 0;   /* Indicate success */\n}\n\nint credit(int amount) {\n  if (mtx_lock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  account_balance += amount;\n  if (mtx_unlock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  return 0;   /* Indicate success */\n}\n \nint main(void) {\n  if(mtx_init(&account_lock, mtx_plain) == thrd_error) {\n    /* Handle error */\n  }\n  /* ... */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Assume this simplified code is part of a multithreaded bank system. Threads call credit() and debit() as money is deposited into and withdrawn from the single account. Because the addition and subtraction operations are not atomic, it is possible that two operations can occur concurrently, but only the result of one would be saved—despite declaring the account_balance volatile . For example, an attacker can credit the account with a sum of money and make a large number of small debits concurrently. Some of the debits might not affect the account balance because of the race condition, so the attacker is effectively creating money.",
          "code": "static volatile int account_balance;\n\nvoid debit(int amount) {\n  account_balance -= amount;\n}\n\nvoid credit(int amount) {\n  account_balance += amount;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Atomic)",
          "pre_code_commentary": "This compliant solution uses an atomic variable to synchronize credit and debit operations. All credits and debits will now affect the account balance, so an attacker cannot exploit the race condition to steal money from the bank. The atomic integer does not need to be initialized because default (zero) initialization of an atomic object with static or thread-local storage is guaranteed to produce a valid state. The += and -= operators behave atomically when used with an atomic variable.",
          "code": "#include <stdatomic.h>\n\natomic_int account_balance;\n\nvoid debit(int amount) {\n  account_balance -= amount;\n}\n\nvoid credit(int amount) {\n  account_balance += amount;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Double-Fetch)",
          "pre_code_commentary": "This noncompliant code example illustrates Xen Security Advisory CVE-2015-8550 / XSA-155 In this example, the following code is vulnerable to a data race where the integer referenced by ps could be modified by a second thread that ran between the two reads of the variable.",
          "code": "#include <stdio.h>\n \nvoid doStuff(int *ps) {\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\n",
          "explanation_after": "Even though there is only one read of the *ps variable in the source code, the compiler is permitted to produce object code that performs multiple reads of the memory location. This is permitted by the \"as-if\" principle, as explained by section 5.1 of the [C99 Rationale 2003] :\n\nThe /as if/ principle is invoked repeatedly in this Rationale. The C89 Committee found that describing various aspects of the C language, library, and environment in terms of concrete models best serves discussion and presentation. Every attempt has been made to craft these models so that implementations are constrained only insofar as they must bring about the same result, /as if/ they had implemented the presentation model; often enough the clearest model would make for the worst implementation.\n\nThis code produces two reads of the *ps value using GCC 4.8.4 on x86, as well as GCC 5.3.0 on x86-64 ( Compiler-Introduced Double-Fetch Vulnerabilities – Understanding XSA-155 )."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Volatile)",
          "pre_code_commentary": "The data race can be disabled by declaring the data to be volatile, because the volatile keyword forces the compiler to not produce two reads of the data. However, this violates CON02-C. Do not use volatile as a synchronization primitive .",
          "code": "#include <stdio.h>\n \nvoid doStuff(volatile int *ps) {\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (C11, Atomic)",
          "pre_code_commentary": "Declaring the data to be atomic also forces the compiler to produce only one read of the data.",
          "code": "#include <stdio.h>\n#include <stdatomic.h>\n \nvoid doStuff(atomic_int *ps) {\n  switch (atomic_load(ps)) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Volatile)",
          "pre_code_commentary": "The data race can be disabled by declaring the data to be volatile, because the volatile keyword forces the compiler to not produce two reads of the data. However, this violates CON02-C. Do not use volatile as a synchronization primitive .",
          "code": "#include <stdio.h>\n \nvoid doStuff(volatile int *ps) {\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (C11, Fences)",
          "pre_code_commentary": "The bug was actually resolved by erecting fences around the switch statement.",
          "code": "#include <stdio.h>\n#include <stdatomic.h>\n \nvoid doStuff(int *ps) {\n  atomic_thread_fence(memory_order_acquire);\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n  atomic_thread_fence(memory_order_release);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Race conditions caused by multiple threads concurrently accessing and modifying the same data can lead to abnormal termination and denial-of-service attacks or data integrity violations.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL00-C",
    "title": "Const-qualify immutable objects",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL00-C.+Const-qualify+immutable+objects",
    "description": "Immutable objects should be const -qualified. Enforcing object immutability using const qualification helps ensure the correctness and security of applications. ISO/IEC TR 24772, for example, recommends labeling parameters as constant to avoid the unintentional modification of function arguments [ ISO/IEC TR 24772 ]. STR05-C. Use pointers to const when referring to string literals describes a specialized case of this recommendation.\n\nconst\n\nconst\n\nAdding const qualification may propagate through a program; as you add const , qualifiers become still more necessary. This phenomenon is sometimes called const poisoning , which can frequently lead to violations of EXP05-C. Do not cast away a const qualification . Although const qualification is a good idea, the costs may outweigh the value in the remediation of existing code.\n\nconst\n\nconst\n\nconst\n\nconst\n\nA macro or an enumeration constant may also be used instead of a const -qualified object. DCL06-C. Use meaningful symbolic constants to represent literal values describes the relative merits of using const -qualified objects, enumeration constants, and object-like macros. However, adding a const qualifier to an existing variable is a better first step than replacing the variable with an enumeration constant or macro because the compiler will issue warnings on any code that changes your const -qualified variable. Once you have verified that a const -qualified variable is not changed by any code, you may consider changing it to an enumeration constant or macro, as best fits your design.\n\nconst\n\nconst\n\nconst\n\nconst\n\nconst",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code, pi is declared as a float . Although pi is a mathematical constant, its value is not protected from accidental modification.",
          "code": "float pi = 3.14159f;\nfloat degrees;\nfloat radians;\n/* ... */\nradians = degrees * pi / 180;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, pi is declared as a const -qualified object:",
          "code": "const float pi = 3.14159f;\nfloat degrees;\nfloat radians;\n/* ... */\nradians = degrees * pi / 180;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to const -qualify immutable objects can result in a constant being modified at runtime.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL01-C",
    "title": "Do not reuse variable names in subscopes",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL01-C.+Do+not+reuse+variable+names+in+subscopes",
    "description": "Do not use the same variable name in two scopes where one scope is contained in another. For example,\n\nNo other variable should share the name of a global variable if the other variable is in a subscope of the global variable. A block should not declare a variable with the same name as a variable declared in any block that contains it.\n\nReusing variable names leads to programmer confusion about which variable is being modified. Additionally, if variable names are reused, generally one or both of the variable names are too generic.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example declares the msg identifier at file scope and reuses the same identifier to declare a character array local to the report_error() function. The programmer may unintentionally copy the function argument to the locally declared msg array within the report_error() function. Depending on the programmer's intention, it either fails to initialize the global variable msg or allows the local msg buffer to overflow by using the global value msgsize as a bounds for the local buffer.",
          "code": "#include <stdio.h>\n \nstatic char msg[100];\nstatic const size_t msgsize = sizeof( msg);\n\nvoid report_error(const char *str) {\n  char msg[80];\n  snprintf(msg, msgsize, \"Error: %s\\n\", str);\n  /* ... */\n}\n\nint main(void) {\n  /* ... */\n  report_error(\"some error\");\n \n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses different, more descriptive variable names:",
          "code": "#include <stdio.h>\n \nstatic char message[100];\nstatic const size_t message_size = sizeof( message);\n\nvoid report_error(const char *str) {\n  char msg[80];\n  snprintf(msg, sizeof( msg), \"Error: %s\\n\", str);\n  /* ... */\n}\n\nint main(void) {\n  /* ... */\n  report_error(\"some error\");\n \n  return 0;\n}\n",
          "explanation_after": "When the block is small, the danger of reusing variable names is mitigated by the visibility of the immediate declaration. Even in this case, however, variable name reuse is not desirable. In general, the larger the declarative region of an identifier, the more descriptive and verbose should be the name of the identifier.\n\nBy using different variable names globally and locally, the compiler forces the developer to be more precise and descriptive with variable names."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example declares two variables with the same identifier, but in slightly different scopes. The scope of the identifier i declared in the for loop's initial clause terminates after the closing curly brace of the for loop. The scope of the identifier i declared in the for loop's compound statement terminates before the closing curly brace. Thus, the inner declaration of i hides the outer declaration of i , which can lead to unintentionally referencing the wrong object.",
          "code": "void f(void) {\n  for (int i = 0; i < 10; i++) {\n    long i;\n    /* ... */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses a unique identifier for the variable declared within the for loop.",
          "code": "void f(void) {\n  for (int i = 0; i < 10; i++) {\n    long j;\n    /* ... */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Reusing a variable name in a subscope can lead to unintentionally referencing an incorrect variable.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL02-C",
    "title": "Use visually distinct identifiers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL02-C.+Use+visually+distinct+identifiers",
    "description": "Use visually distinct identifiers with meaningful names to eliminate errors resulting from misreading the spelling of an identifier during the development and review of code. An identifier can denote an object; a function; a tag or a member of a structure, union, or enumeration; a typedef name; a label name; a macro name; or a macro parameter.\n\nDepending on the fonts used, certain characters appear visually similar or even identical:\n\nCharacter Similar Characters 0 (zero) O (capital o ), Q (capital q ), D (capital d ) 1 (one) I (capital i ), l (lowercase L ) 2 (two) Z (capital z ) 5 (five) S (capital s ) 8 (eight) B (capital b ) n (lowercase N ) h (lowercase H ) m (lowercase M ) rn (lowercase R , lowercase N )\n\n0\n\nO\n\no\n\nQ\n\nq\n\nD\n\nd\n\n1\n\nI\n\ni\n\nl\n\nL\n\n2\n\nZ\n\nz\n\n5\n\nS\n\ns\n\n8\n\nB\n\nb\n\nn\n\nN\n\nh\n\nH\n\nm\n (lowercase \nM\n)\n\nm\n\nM\n\nrn\n (lowercase \nR\n, lowercase \nN\n)\n\nrn\n\nR\n\nN\n\nDo not define multiple identifiers that vary only with respect to one or more visually similar characters.\n\nMake the initial portions of long identifiers unique for easier recognition and to help prevent errors resulting from nonunique identifiers. (See DCL23-C. Guarantee that mutually visible identifiers are unique .)\n\nIn addition, the larger the scope of an identifier, the more descriptive its name should be. It may be perfectly appropriate to name a loop control variable i , but the same name would likely be confusing if it named a file scope object or a variable local to a function more than a few lines long. See also DCL01-C. Do not reuse variable names in subscopes and DCL19-C. Use as minimal a scope as possible for all variables and functions .\n\ni",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Source Character Set)",
          "pre_code_commentary": "DCL02-C implicitly assumes global scope , which can be confused with scope within the same file . Although it may not generate any errors, a possible violation of the rule may occur, as in the following example. Note this example does not violate DCL23-C. Guarantee that mutually visible identifiers are unique .\n\nIn file foo.h :",
          "code": "int id_O; /* (Capital letter O) */\n",
          "explanation_after": "In file bar.h :\n\nIf a file foobar.c includes both foo.h and bar.h , then both id_0 and id_0 come in the same scope, violating this rule."
        },
        "compliant": {
          "heading": "Compliant Solution (Source Character Set)",
          "pre_code_commentary": "In a compliant solution, use of visually similar identifiers should be avoided in the same project scope.\n\nIn file foo.h :",
          "code": "int id_a;\n",
          "explanation_after": "In file bar.h :"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to use visually distinct identifiers can result in referencing the wrong object or function, causing unintended program behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL03-C",
    "title": "Use a static assertion to test the value of a constant expression",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL03-C.+Use+a+static+assertion+to+test+the+value+of+a+constant+expression",
    "description": "Assertions are a valuable diagnostic tool for finding and eliminating software defects that may result in vulnerabilities (see MSC11-C. Incorporate diagnostic tests using assertions ). The runtime assert() macro has some limitations, however, in that it incurs a runtime overhead and because it calls abort() . Consequently, the runtime assert() macro is useful only for identifying incorrect assumptions and not for runtime error checking. As a result, runtime assertions are generally unsuitable for server programs or embedded systems.\n\nassert()\n\nabort()\n\nassert()\n\nStatic assertion is a new facility in the C Standard. It takes the form\n\nstatic_assert(constant-expression, string-literal);\n\nstatic_assert(constant-expression, string-literal);\n\nSubclause 6.7.10 of the C Standard [ ISO/IEC 9899:2011 ] states:\n\nThe constant expression shall be an integer constant expression. If the value of the constant expression compares unequal to 0, the declaration has no effect. Otherwise, the constraint is violated and the implementation shall produce a diagnostic message that includes the text of the string literal, except that characters not in the basic source character set are not required to appear in the message.\n\nIt means that if constant-expression is true, nothing will happen. However, if constant-expression is false, an error message containing string-literal will be output at compile time.\n\nconstant-expression\n\nconstant-expression\n\nstring-literal\n\n/* Passes */\nstatic_assert(\n  sizeof(int) <= sizeof(void*), \n  \"sizeof(int) <= sizeof(void*)\"\n); \n\n/* Fails */\nstatic_assert(\n  sizeof(double) <= sizeof(int), \n  \"sizeof(double) <= sizeof(int)\"\n);\n\n/* Passes */\nstatic_assert(\n  sizeof(int) <= sizeof(void*), \n  \"sizeof(int) <= sizeof(void*)\"\n); \n\n/* Fails */\nstatic_assert(\n  sizeof(double) <= sizeof(int), \n  \"sizeof(double) <= sizeof(int)\"\n);\n\nStatic assertion is not available in C99.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code uses the assert() macro to assert a property concerning a memory-mapped structure that is essential for the code to behave correctly:",
          "code": "#include <assert.h>\n \nstruct timer {\n  unsigned char MODE;\n  unsigned int DATA;\n  unsigned int COUNT;\n};\n \nint func(void) {\n  assert(sizeof(struct timer) == sizeof(unsigned char) + sizeof(unsigned int) + sizeof(unsigned int));\n}\n",
          "explanation_after": "Although the use of the runtime assertion is better than nothing, it needs to be placed in a function and executed. This means that it is usually far away from the definition of the actual structure to which it refers. The diagnostic occurs only at runtime and only if the code path containing the assertion is executed."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "For assertions involving only constant expressions, a preprocessor conditional statement may be used, as in this compliant solution:",
          "code": "struct timer {\n  unsigned char MODE;\n  unsigned int DATA;\n  unsigned int COUNT;\n};\n\n#if (sizeof(struct timer) != (sizeof(unsigned char) + sizeof(unsigned int) + sizeof(unsigned int)))\n  #error \"Structure must not have any padding\"\n#endif\n",
          "explanation_after": "Using #error directives allows for clear diagnostic messages. Because this approach evaluates assertions at compile time, there is no runtime penalty."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code uses the assert() macro to assert a property concerning a memory-mapped structure that is essential for the code to behave correctly:",
          "code": "#include <assert.h>\n \nstruct timer {\n  unsigned char MODE;\n  unsigned int DATA;\n  unsigned int COUNT;\n};\n \nint func(void) {\n  assert(sizeof(struct timer) == sizeof(unsigned char) + sizeof(unsigned int) + sizeof(unsigned int));\n}\n",
          "explanation_after": "Although the use of the runtime assertion is better than nothing, it needs to be placed in a function and executed. This means that it is usually far away from the definition of the actual structure to which it refers. The diagnostic occurs only at runtime and only if the code path containing the assertion is executed."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This portable compliant solution uses static_assert :",
          "code": "#include <assert.h>\n \nstruct timer {\n  unsigned char MODE;\n  unsigned int DATA;\n  unsigned int COUNT;\n};\n\nstatic_assert(sizeof(struct timer) == sizeof(unsigned char) + sizeof(unsigned int) + sizeof(unsigned int),\n              \"Structure must not have any padding\");\n",
          "explanation_after": "Static assertions allow incorrect assumptions to be diagnosed at compile time instead of resulting in a silent malfunction or runtime error. Because the assertion is performed at compile time, no runtime cost in space or time is incurred. An assertion can be used at file or block scope, and failure results in a meaningful and informative diagnostic error message.\n\nOther uses of static assertion are shown in VOID STR07-C. Use the bounds-checking interfaces for string manipulation and FIO34-C. Distinguish between characters read from a file and EOF or WEOF ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Static assertion is a valuable diagnostic tool for finding and eliminating software defects that may result in vulnerabilities at compile time. The absence of static assertions, however, does not mean that code is incorrect.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL04-C",
    "title": "Do not declare more than one variable per declaration",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL04-C.+Do+not+declare+more+than+one+variable+per+declaration",
    "description": "Every declaration should be for a single variable, on its own line, with an explanatory comment about the role of the variable. Declaring multiple variables in a single declaration can cause confusion regarding the types of the variables and their initial values. If more than one variable is declared in a declaration, care must be taken that the type and initialized value of the variable are handled correctly.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a programmer or code reviewer might mistakenly believe that the two variables src and c are declared as char * . In fact, src has a type of char * , whereas c has a type of char .",
          "code": "char *src = 0, c = 0;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, each variable is declared on a separate line:",
          "code": "char *src;    /* Source string */\nchar c;       /* Character being tested */\n",
          "explanation_after": "Although this change has no effect on compilation, the programmer's intent is clearer."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a programmer or code reviewer might mistakenly believe that both i and j have been initialized to 1. In fact, only j has been initialized, and i remains uninitialized.",
          "code": "int i, j = 1;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, it is readily apparent that both i and j have been initialized to 1:",
          "code": "int i = 1;\nint j = 1;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Declaring no more than one variable per declaration can make code easier to read and eliminate confusion.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL05-C",
    "title": "Use typedefs of non-pointer types only",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL05-C.+Use+typedefs+of+non-pointer+types+only",
    "description": "Using type definitions ( typedef ) can often improve code readability. However, type definitions to pointer types can make it more difficult to write const -correct code because the const qualifier will be applied to the pointer type, not to the underlying declared type.\n\ntypedef\n\nconst\n\nconst",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The following type definition improves readability at the expense of introducing a const -correctness issue. In this example, the const qualifier applies to the typedef instead of to the underlying object type. Consequently, func does not take a pointer to a const struct obj but instead takes a const pointer to a struct obj .",
          "code": "struct obj {\n  int i;\n  float f;\n};\ntypedef struct obj *ObjectPtr;\n \nvoid func(const ObjectPtr o) {\n  /* Can actually modify o's contents, against expectations */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution makes use of type definitions but does not declare a pointer type and so cannot be used in a const -incorrect manner:",
          "code": "struct obj {\n  int i;\n  float f;\n};\ntypedef struct obj Object;\n \nvoid func(const Object *o) {\n  /* Cannot modify o's contents */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "The Win32 SDK headers make use of type definitions for most of the types involved in Win32 APIs, but this noncompliant code example demonstrates a const -correctness bug:",
          "code": "#include <Windows.h>\n/* typedef char *LPSTR; */\n \nvoid func(const LPSTR str) {\n  /* Can mutate str's contents, against expectations */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "This compliant solution demonstrates a common naming convention found in the Win32 APIs, using the proper const type:",
          "code": "#include <Windows.h>\n/* typedef const char *LPCSTR; */\n \nvoid func(LPCSTR str) {\n  /* Cannot modify str's contents */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "Note that many structures in the Win32 API are declared with pointer type definitions but not pointer-to- const type definitions ( LPPOINT , LPSIZE , and others). In these cases, it is suggested that you create your own type definition from the base structure type.",
          "code": "#include <Windows.h>\n/*\n  typedef struct tagPOINT {\n    long x, y;\n  } POINT, *LPPOINT;\n*/\n \nvoid func(const LPPOINT pt) {\n  /* Can modify pt's contents, against expectations */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": null,
          "code": "#include <Windows.h>\n/*\n  typedef struct tagPOINT {\n    long x, y;\n  } POINT, *LPPOINT;\n*/\n \ntypedef const POINT *LPCPOINT;\nvoid func(LPCPOINT pt) {\n  /* Cannot modify pt's contents */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the declaration of the signal() function is difficult to read and comprehend:",
          "code": "void (*signal(int, void (*)(int)))(int);\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution makes use of type definitions to specify the same type as in the noncompliant code example:",
          "code": "typedef void SighandlerType(int signum);\nextern SighandlerType *signal(\n  int signum,\n  SighandlerType *handler\n);\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Code readability is important for discovering and eliminating vulnerabilities .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL06-C",
    "title": "Use meaningful symbolic constants to represent literal values",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL06-C.+Use+meaningful+symbolic+constants+to+represent+literal+values",
    "description": "The C language provides several different kinds of constants: integer constants, such as 10 and 0x1C ; floating constants, such as 1.0 and 6.022e+23 ; and character constants, such as 'a' and '\\x10' . C also provides string literals, such as \"hello, world\" and \"\\n\" . These constants can all be referred to as literals .\n\n10\n\n0x1C\n\n1.0\n\n6.022e+23\n\n'a'\n\n'\\x10'\n\n\"hello, world\"\n\n\"\\n\"\n\nWhen used in program logic, literals can reduce the readability of source code. As a result, literals, in general, and integer constants, in particular, are frequently called magic numbers because their purpose is often obscured. Magic numbers can be constant values that represent either an arbitrary value (such as a determined appropriate buffer size) or a malleable concept (such as the age at which a person is considered an adult, which can change between geopolitical boundaries). Rather than embed literals in program logic, use appropriately named symbolic constants to clarify the intent of the code. In addition, if a specific value needs to be changed, reassigning a symbolic constant once is more efficient and less error prone than replacing every instance of the value [ Saks 2002 ].\n\nThe C programming language has several mechanisms for creating named, symbolic constants: const -qualified objects, enumeration constants, and object-like macro definitions. Each of these mechanisms has associated advantages and disadvantages.\n\nconst",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The meaning of the integer literal 18 is not clear in this example:",
          "code": "/* ... */\nif (age >= 18) {\n   /* Take action */\n}\nelse {\n  /* Take a different action */\n}\n/* ... */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution replaces the integer literal 18 with the symbolic constant ADULT_AGE to clarify the meaning of the code:",
          "code": "enum { ADULT_AGE=18 };\n/* ... */\nif (age >= ADULT_AGE) {\n   /* Take action */\n}\nelse {\n  /* Take a different action */\n}\n/* ... */\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Integer literals are frequently used when referring to array dimensions, as shown in this noncompliant code example:",
          "code": "char buffer[256];\n/* ... */\nfgets(buffer, 256, stdin);\n",
          "explanation_after": "This use of integer literals can easily result in buffer overflows if, for example, the buffer size is reduced but the integer literal used in the call to fgets() is not."
        },
        "compliant": {
          "heading": "Compliant Solution ( enum )",
          "pre_code_commentary": "In this compliant solution, the integer literal is replaced with an enumeration constant. (See DCL00-C. Const-qualify immutable objects .)",
          "code": "enum { BUFFER_SIZE=256 };\n\nchar buffer[BUFFER_SIZE];\n/* ... */\nfgets(buffer, BUFFER_SIZE, stdin);\n",
          "explanation_after": "Enumeration constants can safely be used anywhere a constant expression is required."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Integer literals are frequently used when referring to array dimensions, as shown in this noncompliant code example:",
          "code": "char buffer[256];\n/* ... */\nfgets(buffer, 256, stdin);\n",
          "explanation_after": "This use of integer literals can easily result in buffer overflows if, for example, the buffer size is reduced but the integer literal used in the call to fgets() is not."
        },
        "compliant": {
          "heading": "Compliant Solution ( sizeof )",
          "pre_code_commentary": "Frequently, it is possible to obtain the desired readability by using a symbolic expression composed of existing symbols rather than by defining a new symbol. For example, a sizeof expression can work just as well as an enumeration constant. (See EXP09-C. Use sizeof to determine the size of a type or variable .)",
          "code": "char buffer[256];\n/* ... */\nfgets(buffer, sizeof(buffer), stdin);\n",
          "explanation_after": "Using the sizeof expression in this example reduces the total number of names declared in the program, which is generally a good idea [ Saks 2002 ]. The sizeof operator is almost always evaluated at compile time (except in the case of variable-length arrays).\n\nWhen working with sizeof() , keep in mind ARR01-C. Do not apply the sizeof operator to a pointer when taking the size of an array ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the string literal \"localhost\" and integer constant 1234 are embedded directly in program logic and are consequently difficult to change:",
          "code": "LDAP *ld = ldap_init(\"localhost\", 1234);\nif (ld == NULL) {\n  perror(\"ldap_init\");\n  return(1);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the host name and port number are both defined as object-like macros , so they can be passed as compile-time arguments:",
          "code": "#ifndef PORTNUMBER     /* Might be passed on compile line */\n#  define PORTNUMBER 1234\n#endif\n\n#ifndef HOSTNAME       /* Might be passed on compile line */\n#  define HOSTNAME \"localhost\"\n#endif\n\n/* ... */\n\nLDAP *ld = ldap_init(HOSTNAME, PORTNUMBER);\nif (ld == NULL) {\n  perror(\"ldap_init\");\n  return(1);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using numeric literals makes code more difficult to read and understand. Buffer overruns are frequently a consequence of a magic number being changed in one place (such as in an array declaration) but not elsewhere (such as in a loop through an array).",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL07-C",
    "title": "Include the appropriate type information in function declarators",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL07-C.+Include+the+appropriate+type+information+in+function+declarators",
    "description": "Function declarators must be declared with the appropriate type information, including a return type and parameter list. If type information is not properly specified in a function declarator, the compiler cannot properly check function type information. When using standard library calls, the easiest (and preferred) way to obtain function declarators with appropriate type information is to include the appropriate header file.\n\nAttempting to compile a program with a function declarator that does not include the appropriate type information typically generates a warning but does not prevent program compilation. These warnings should be resolved. (See MSC00-C. Compile cleanly at high warning levels .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Non-Prototype-Format Declarators)",
          "pre_code_commentary": "This noncompliant code example uses the identifier-list form for parameter declarations:",
          "code": "int max(a, b)\nint a, b;\n{\n  return a > b ? a : b;\n}\n",
          "explanation_after": "Subclause 6.11.7 of the C Standard [ ISO/IEC 9899:2011 ] states that \"the use of function definitions with separate parameter identifier and declaration lists (not prototype-format parameter type and identifier declarators) is an obsolescent feature.\""
        },
        "compliant": {
          "heading": "Compliant Solution (Non-Prototype-Format Declarators)",
          "pre_code_commentary": "In this compliant solution, int is the type specifier, max(int a, int b) is the function declarator, and the block within the curly braces is the function body:",
          "code": "int max(int a, int b) {\n  return a > b ? a : b;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Function Prototypes)",
          "pre_code_commentary": "Declaring a function without any prototype forces the compiler to assume that the correct number and type of parameters have been supplied to a function. This practice can result in unintended and undefined behavior .\n\nIn this noncompliant code example, the definition of func() in file_a.c expects three parameters but is supplied only two:",
          "code": "/* file_a.c source file */\nint func(int one, int two, int three){\n  printf(\"%d %d %d\", one, two, three);\n  return 1;\n}\n",
          "explanation_after": "However, because there is no prototype for func() in file_b.c , the compiler assumes that the correct number of arguments has been supplied and uses the next value on the program stack as the missing third argument:\n\nC99 eliminated implicit function declarations from the C language. However, many compilers still allow the compilation of programs containing implicitly declared functions, although they may issue a warning message. These warnings should be resolved. (See MSC00-C. Compile cleanly at high warning levels .)"
        },
        "compliant": {
          "heading": "Compliant Solution (Function Prototypes)",
          "pre_code_commentary": "This compliant solution correctly includes the function prototype for func() in the compilation unit in which it is invoked, and the function invocation has been corrected to pass the right number of arguments:",
          "code": "/* file_b.c source file */\nint func(int, int, int);\n\nfunc(1, 2, 3);\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Function Pointers)",
          "pre_code_commentary": "If a function pointer refers to an incompatible function, invoking that function via the pointer may corrupt the process stack. As a result, unexpected data may be accessed by the called function.\n\nIn this noncompliant code example, the function pointer fn_ptr refers to the function add() , which accepts three integer arguments. However, fn_ptr is specified to accept two integer arguments. Setting fn_ptr to refer to add() results in unexpected program behavior. This example also violates EXP37-C. Call functions with the correct number and type of arguments :",
          "code": "int add(int x, int y, int z) {\n  return x + y + z;\n}\n\nint main(int argc, char *argv[]) {\n  int (*fn_ptr) (int, int);\n  int res;\n  fn_ptr = add;\n  res = fn_ptr(2, 3);  /* Incorrect */\n  /* ... */\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Function Pointers)",
          "pre_code_commentary": "To correct this example, the declaration of fn_ptr is changed to accept three arguments:",
          "code": "int add(int x, int y, int z) {\n  return x + y + z;\n}\n\nint main(int argc, char *argv[]) {\n  int (*fn_ptr) (int, int, int) ;\n  int res;\n  fn_ptr = add;\n  res = fn_ptr(2, 3, 4);\n  /* ... */\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to include type information for function declarators can result in unexpected or unintended program behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL08-C",
    "title": "Properly encode relationships in constant definitions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL08-C.+Properly+encode+relationships+in+constant+definitions",
    "description": "If a relation exists between constants, you should encode the relationship in the definitions. Do not give two independent definitions, because a maintainer may fail to preserve that relationship when modifying the code. As a corollary, do not encode an impermanent or false relationship between constants, because future modifications may result in an incorrect definition for the dependent constant.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the definition for OUT_STR_LEN must always be two greater than the definition of IN_STR_LEN . The following definitions fail to embody this relationship:",
          "code": "enum { IN_STR_LEN=18, OUT_STR_LEN=20 };\n",
          "explanation_after": "A programmer performing maintenance on this program would need to identify the relationship and modify both definitions accordingly. Although this sort of error appears relatively benign, it can easily lead to serious security vulnerabilities , such as buffer overflows."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The declaration in this compliant solution embodies the relationship between the two definitions:",
          "code": "enum { IN_STR_LEN=18, OUT_STR_LEN=IN_STR_LEN+2 };\n",
          "explanation_after": "As a result, a programmer can reliably modify the program by changing the definition of IN_STR_LEN ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a relationship is established between two constants where none exists:",
          "code": "enum { ADULT_AGE=18 };\n\n/* Misleading; relationship established when none exists */\nenum { ALCOHOL_AGE=ADULT_AGE+3 };\n",
          "explanation_after": "A programmer performing maintenance on this program may modify the definition for ADULT_AGE but fail to recognize that the definition for ALCOHOL_AGE has also been changed as a consequence."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not assume a relationship where none exists:",
          "code": "enum { ADULT_AGE=18 };\nenum { ALCOHOL_AGE=21 };\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to properly encode relationships in constant definitions may lead to the introduction of defects during maintenance. These defects could potentially result in vulnerabilities , for example, if the affected constants were used for allocating or accessing memory.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL09-C",
    "title": "Declare functions that return errno with a return type of errno_t",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL09-C.+Declare+functions+that+return+errno+with+a+return+type+of+errno_t",
    "description": "When developing new code, declare functions that return errno with a return type of errno_t .  Many existing functions that return errno are declared as returning a value of type int . It is semantically unclear by inspecting the function declaration or prototype if these functions return an error status or a value or, worse, some combination of the two. (See ERR02-C. Avoid in-band error indicators .)\n\nerrno\n\nerrno_t\n\nerrno\n\nint\n\nC11 Annex K  introduced the new type errno_t that is defined to be type int in errno.h and elsewhere. Many of the functions defined in C11 Annex K return values of this type. The errno_t type should be used as the type of an object that may contain only values that might be found in errno . For example, a function that returns the value of errno should be declared as having the return type errno_t .\n\nerrno_t\n\nint\n\nerrno.h\n\nerrno_t\n\nerrno\n\nerrno\n\nerrno_t\n\nThis recommendation depends on C11 Annex K being implemented. The following code can be added to remove this dependency:\n\n#ifndef __STDC_LIB_EXT1__\n  typedef int errno_t;\n#endif\n\n#ifndef __STDC_LIB_EXT1__\n  typedef int errno_t;\n#endif\n\nNoncompliant Code Example\n\nThis noncompliant code example shows a function called opener() that returns errno error codes. However, the function is declared as returning an int . Consequently, the meaning of the return value is not readily apparent.\n\nopener()\n\nerrno\n\nint\n\n#include <errno.h>\n#include <stdio.h>\n \nenum { NO_FILE_POS_VALUES = 3 };\n\nint opener(\n  FILE *file,\n  size_t *width,\n  size_t *height,\n  size_t *data_offset\n) {\n  size_t file_w;\n  size_t file_h;\n  size_t file_o;\n  fpos_t offset;\n\n  if (file == NULL) { return EINVAL; }\n  errno = 0;\n  if (fgetpos(file, &offset) != 0) { return errno; }\n  if (fscanf(file, \"%zu %zu %zu\", &file_w, &file_h, &file_o)\n        != NO_FILE_POS_VALUES) {\n    return -1;\n  }\n\n  errno = 0;\n  if (fsetpos(file, &offset) != 0) { return errno; }\n\n  if (width != NULL) { *width = file_w; }\n  if (height != NULL) { *height = file_h; }\n  if (data_offset != NULL) { *data_offset = file_o; }\n\n  return 0;\n}\n\n#include <errno.h>\n#include <stdio.h>\n \nenum { NO_FILE_POS_VALUES = 3 };\n\nint opener(\n  FILE *file,\n  size_t *width,\n  size_t *height,\n  size_t *data_offset\n) {\n  size_t file_w;\n  size_t file_h;\n  size_t file_o;\n  fpos_t offset;\n\n  if (file == NULL) { return EINVAL; }\n  errno = 0;\n  if (fgetpos(file, &offset) != 0) { return errno; }\n  if (fscanf(file, \"%zu %zu %zu\", &file_w, &file_h, &file_o)\n        != NO_FILE_POS_VALUES) {\n    return -1;\n  }\n\n  errno = 0;\n  if (fsetpos(file, &offset) != 0) { return errno; }\n\n  if (width != NULL) { *width = file_w; }\n  if (height != NULL) { *height = file_h; }\n  if (data_offset != NULL) { *data_offset = file_o; }\n\n  return 0;\n}\n\nThis noncompliant code example nevertheless complies with ERR30-C. Take care when reading errno .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": null,
          "code": null,
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "In this compliant solution, the opener() function returns a value of type errno_t , providing a clear indication that this function returns an error code:",
          "code": "#define __STDC_WANT_LIB_EXT1__ 1\n \n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n    \nenum { NO_FILE_POS_VALUES = 3 };\n\nerrno_t opener(\n  FILE *file,\n  size_t *width,\n  size_t *height,\n  size_t *data_offset\n) {\n  size_t file_w;\n  size_t file_h;\n  size_t file_o;\n  fpos_t offset;\n\n  if (NULL == file) { return EINVAL; }\n  errno = 0;\n  if (fgetpos(file, &offset) != 0 ) { return errno; }\n  if (fscanf(file, \"%zu %zu %zu\", &file_w, &file_h, &file_o)\n        != NO_FILE_POS_VALUES) {\n    return EIO;\n  }\n\n  errno = 0;\n  if (fsetpos(file, &offset) != 0 ) { return errno; }\n\n  if (width != NULL) { *width = file_w; }\n  if (height != NULL) { *height = file_h; }\n  if (data_offset != NULL) { *data_offset = file_o; }\n\n  return 0;\n}\n",
          "explanation_after": "This compliant solution is categorized as a POSIX solution because it returns EINVAL and EIO , which are defined by POSIX (IEEE Std 1003.1, 2013 Edition) but not by the C Standard."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to test for error conditions can lead to vulnerabilities of varying severity. Declaring functions that return an errno with a return type of errno_t will not eliminate this problem but may reduce errors caused by programmers' misunderstanding the purpose of a return value.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL10-C",
    "title": "Maintain the contract between the writer and caller of variadic functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL10-C.+Maintain+the+contract+between+the+writer+and+caller+of+variadic+functions",
    "description": "Variadic functions accept a variable number of arguments but are problematic. Variadic functions define an implicit contract between the function writer and the function user that allows the function to determine the number of arguments passed in any particular invocation. Failure to enforce this contract may result in undefined behavior . See undefined behavior 141 of Appendix J of the C Standard.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the average() function is called as follows:",
          "code": "int avg = average(1, 4, 6, 4, 1);\n",
          "explanation_after": "The omission of the va_eol terminating value means that the function will continue to process values from the stack until it encounters a va_eol by coincidence or an error occurs."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution enforces the contract by adding va_eol as the final argument:",
          "code": "int avg = average(1, 4, 6, 4, 1, va_eol);\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Another common mistake is to use more conversion specifiers than supplied arguments, as shown in this noncompliant code example:",
          "code": "const char *error_msg = \"Resource not available to user.\";\n/* ... */\nprintf(\"Error (%s): %s\", error_msg);\n",
          "explanation_after": "This code results in nonexistent arguments being processed by the function, potentially leaking information about the process."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution matches the number of format specifiers with the number of variable arguments:",
          "code": "const char *error_msg = \"Resource not available to user.\";\n/* ... */\nprintf(\"Error: %s\", error_msg);\n",
          "explanation_after": "C functions that accept the variadic primitive va_list as an argument pose an additional risk. Calls to vfprintf() , vfscanf() , vprintf() , vscanf() , vsnprintf() , vsprintf() , and vsscanf() use the va_arg() macro, invalidating the parameterized va_list . Consequently, once a va_list is passed as an argument to any of these functions, it cannot be used again without a call to va_end() followed by a call to va_start() ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrectly using a variadic function can result in abnormal program termination or unintended information disclosure.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "DCL11-C",
    "title": "Understand the type issues associated with variadic functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL11-C.+Understand+the+type+issues+associated+with+variadic+functions",
    "description": "The variable parameters of a variadic function—that is, those that correspond with the position of the ellipsis—are interpreted by the va_arg() macro. The va_arg() macro is used to extract the next argument from an initialized argument list within the body of a variadic function implementation. The size of each parameter is determined by the specified type. If the type is inconsistent with the corresponding argument, the behavior is undefined and may result in misinterpreted data or an alignment error (see EXP36-C. Do not cast pointers into more strictly aligned pointer types ).\n\nva_arg()\n\nva_arg()\n\nThe variable arguments to a variadic function are not checked for type by the compiler. As a result, the programmer is responsible for ensuring that they are compatible with the corresponding parameter after the default argument promotions:\n\nInteger arguments of types ranked lower than int are promoted to int if int can hold all the values of that type; otherwise, they are promoted to unsigned int (the integer promotions ). Arguments of type float are promoted to double .\n\nint\n\nint\n\nint\n\nunsigned int\n\nfloat\n\ndouble",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Type Interpretation Error)",
          "pre_code_commentary": "The C printf() function is implemented as a variadic function. This noncompliant code example swaps its null-terminated byte string and integer parameters with respect to how they are specified in the format string. Consequently, the integer is interpreted as a pointer to a null-terminated byte string and dereferenced, which will likely cause the program to abnormally terminate . Note that the error_message pointer is likewise interpreted as an integer.",
          "code": "const char *error_msg = \"Error occurred\";\n/* ... */\nprintf(\"%s:%d\", 15, error_msg);\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Type Interpretation Error)",
          "pre_code_commentary": "This compliant solution modifies the format string so that the conversion specifiers correspond to the arguments:",
          "code": "const char *error_msg = \"Error occurred\";\n/* ... */\nprintf(\"%d:%s\", 15, error_msg);\n",
          "explanation_after": "As shown, care must be taken to ensure that the arguments passed to a format string function match up with the supplied format string."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Type Alignment Error)",
          "pre_code_commentary": "In this noncompliant code example, a type long long integer is incorrectly parsed by the printf() function with a %d specifier. This code may result in data truncation or misrepresentation when the value is extracted from the argument list.",
          "code": "long long a = 1;\nconst char msg[] = \"Default message\";\n/* ... */\nprintf(\"%d %s\", a, msg);\n",
          "explanation_after": "Because a long long was not interpreted, if the long long uses more bytes for storage, the subsequent format specifier %s is unexpectedly offset, causing unknown data to be used instead of the pointer to the message."
        },
        "compliant": {
          "heading": "Compliant Solution (Type Alignment Error)",
          "pre_code_commentary": "This compliant solution adds the length modifier ll to the %d format specifier so that the variadic function parser for printf() extracts the correct number of bytes from the variable argument list for the long long argument:",
          "code": "long long a = 1;\nconst char msg[] = \"Default message\";\n/* ... */\nprintf(\"%lld %s\", a, msg);\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( NULL )",
          "pre_code_commentary": "The C Standard allows NULL to be either an integer constant or a pointer constant. While passing NULL as an argument to a function with a fixed number of arguments will cause NULL to be cast to the appropriate pointer type, when it is passed as a variadic argument, this will not happen if sizeof(NULL) != sizeof(void *). This is possible for several reasons:\n\nPointers and ints may have different sizes on a platform where NULL is an integer constant The platform may have different pointer types with different sizes on a platform. In that case, if NULL is a void pointer, it is the same size as a pointer to char (C11 section 6.2.5, paragraph 28), which might be sized differently than the required pointer type.\n\nOn either such platform, the following code will have undefined behavior :",
          "code": "char* string = NULL;\nprintf(\"%s %d\\n\", string, 1);\n",
          "explanation_after": "On a system with 32-bit int and 64-bit pointers, printf() may interpret the NULL as high-order bits of the pointer and the third argument 1 as the low-order bits of the pointer. In this case, printf() will print a pointer with the value 0x00000001 and then attempt to read an additional argument for the %d conversion specifier, which was not provided."
        },
        "compliant": {
          "heading": "Compliant Solution ( NULL )",
          "pre_code_commentary": "This compliant solution avoids sending NULL to printf() :",
          "code": "char* string = NULL;\nprintf(\"%s %d\\n\", (string ? string : \"null\"), 1);\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Inconsistent typing in variadic functions can result in abnormal program termination or unintended information disclosure.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "DCL12-C",
    "title": "Implement abstract data types using opaque types",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL12-C.+Implement+abstract+data+types+using+opaque+types",
    "description": "Abstract data types are not restricted to object-oriented languages such as C++ and Java. They should be created and used in C language programs as well. Abstract data types are most effective when used with private (opaque) data types and information hiding.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example is based on the managed string library developed by CERT [ Burch 2006 ]. In this example, the managed string type and the functions that operate on this type are defined in the string_m.h header file as follows:",
          "code": "struct string_mx {\n  size_t size;\n  size_t maxsize;\n  unsigned char strtype;\n  char *cstr;\n};\n\ntypedef struct string_mx string_mx;\n\n/* Function declarations */\nextern errno_t strcpy_m(string_mx *s1, const string_mx *s2);\nextern errno_t strcat_m(string_mx *s1, const string_mx *s2);\n/* ... */\n",
          "explanation_after": "The implementation of the string_mx type is fully visible to the user of the data type after including the string_m.h file. Programmers are consequently more likely to directly manipulate the fields within the structure, violating the software engineering principles of information hiding and data encapsulation and increasing the probability of developing incorrect or nonportable code."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution reimplements the string_mx type as a private type, hiding the implementation of the data type from the user of the managed string library. To accomplish this, the developer of the private data type creates two header files: an external string_m.h header file that is included by the user of the data type and an internal file that is included only in files that implement the managed string abstract data type.\n\nIn the external string_m.h file, the string_mx type is defined to be an instance of struct string_mx , which in turn is declared as an incomplete type :",
          "code": "struct string_mx;\ntypedef struct string_mx string_mx;\n\n/* Function declarations */\nextern errno_t strcpy_m(string_mx *s1, const string_mx *s2);\nextern errno_t strcat_m(string_mx *s1, const string_mx *s2);\n/* ... */\n",
          "explanation_after": "In the internal header file, struct string_mx is fully defined but not visible to a user of the data abstraction:\n\nModules that implement the abstract data type include both the external and internal definitions, whereas users of the data abstraction include only the external string_m.h file. This allows the implementation of the string_mx data type to remain private."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The use of opaque abstract data types, though not essential to secure programming, can significantly reduce the number of defects and vulnerabilities introduced in code, particularly during ongoing maintenance.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL13-C",
    "title": "Declare function parameters that are pointers to values not changed by the function as const",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL13-C.+Declare+function+parameters+that+are+pointers+to+values+not+changed+by+the+function+as+const",
    "description": "Declaring function parameters const indicates that the function promises not to change these values.\n\nconst\n\nIn C, function arguments are passed by value rather than by reference. Although a function may change the values passed in, these changed values are discarded once the function returns. For this reason, many programmers assume a function will not change its arguments and that declaring the function's parameters as const is unnecessary.\n\nconst\n\nvoid foo(int x) {\n  x = 3; /* Visible only in the function */\n  /* ... */\n}\n\nvoid foo(int x) {\n  x = 3; /* Visible only in the function */\n  /* ... */\n}\n\nPointers behave in a similar fashion. A function may change a pointer to reference a different object, or NULL , yet that change is discarded once the function exits. Consequently, declaring a pointer as const is unnecessary.\n\nNULL\n\nconst\n\nvoid foo(int *x) {\n  x = NULL; /* Visible only in the function */\n  /* ... */\n}\n\nvoid foo(int *x) {\n  x = NULL; /* Visible only in the function */\n  /* ... */\n}",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Unlike passed-by-value arguments and pointers, pointed-to values are a concern. A function may modify a value referenced by a pointer argument, leading to a side effect that persists even after the function exits. Modification of the pointed-to value is not diagnosed by the compiler, which assumes this behavior was intended.",
          "code": "void foo(int *x) {\n  if (x != NULL) {\n    *x = 3; /* Visible outside function */\n  }\n  /* ... */\n}\n",
          "explanation_after": "If the function parameter is const -qualified, any attempt to modify the pointed-to value should cause the compiler to issue a diagnostic message.\n\nAs a result, the const violation must be resolved before the code can be compiled without a diagnostic message being issued."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution addresses the const violation by not modifying the constant argument:",
          "code": "void foo(const int * x) {\n  if (x != NULL) {\n    printf(\"Value is %d\\n\", *x);\n  }\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example defines a fictional version of the standard strcat() function called strcat_nc() . This function differs from strcat() in that the second argument is not const -qualified.",
          "code": "char *strcat_nc(char *s1, char *s2);\n\nchar *c_str1 = \"c_str1\";\nconst char *c_str2 = \"c_str2\";\nchar c_str3[9] = \"c_str3\";\nconst char c_str4[9] = \"c_str4\";\n\nstrcat_nc(c_str3, c_str2);  /* Compiler warns that c_str2 is const */\nstrcat_nc(c_str1, c_str3);  /* Attempts to overwrite string literal! */\nstrcat_nc(c_str4, c_str3);  /* Compiler warns that c_str4 is const */\n",
          "explanation_after": "The function behaves the same as strcat() , but the compiler generates warnings in incorrect locations and fails to generate them in correct locations.\n\nIn the first strcat_nc() call, the compiler generates a warning about attempting to cast away const on c_str2 because strcat_nc() does not modify its second argument yet fails to declare it const .\n\nIn the second strcat_nc() call, the compiler compiles the code with no warnings, but the resulting code will attempt to modify the \"c_str1\" literal. This violates STR05-C. Use pointers to const when referring to string literals and STR30-C. Do not attempt to modify string literals .\n\nIn the final strcat_nc() call, the compiler generates a warning about attempting to cast away const on c_str4 , which is a valid warning."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses the prototype for the strcat() from C90. Although the restrict type qualifier did not exist in C90, const did. In general, function parameters should be declared in a manner consistent with the semantics of the function. In the case of strcat() , the initial argument can be changed by the function, but the second argument cannot.",
          "code": "char *strcat(char *s1, const char *s2); \n\nchar *c_str1 = \"c_str1\";\nconst char *c_str2 = \"c_str2\";\nchar c_str3[9] = \"c_str3\";\nconst char c_str4[9] = \"c_str4\";\n\nstrcat(c_str3, c_str2); \n\n/* Args reversed to prevent overwriting string literal */ \nstrcat(c_str3, c_str1);  \nstrcat(c_str4, c_str3);  /* Compiler warns that c_str4 is const */\n",
          "explanation_after": "The const -qualification of the second argument, s2 , eliminates the spurious warning in the initial invocation but maintains the valid warning on the final invocation in which a const -qualified object is passed as the first argument (which can change). Finally, the middle strcat() invocation is now valid because c_str3 is a valid destination string and may be safely modified."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to declare an unchanging value const prohibits the function from working with values already cast as const . This problem can be sidestepped by type casting away the const , but doing so violates EXP05-C. Do not cast away a const qualification .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL15-C",
    "title": "Declare file-scope objects or functions that do not need external linkage as static",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL15-C.+Declare+file-scope+objects+or+functions+that+do+not+need+external+linkage+as+static",
    "description": "If a file-scope object or a function does not need to be visible outside of the file, it should be hidden by being declared as static . This practice creates more modular code and limits pollution of the global name space.\n\nstatic\n\nSubclause 6.2.2 of the C Standard [ ISO/IEC 9899:2011 ] states:\n\nIf the declaration of a file scope identifier for an object or a function contains the storage-class specifier static , the identifier has internal linkage.\n\nstatic\n\nand\n\nIf the declaration of an identifier for an object has file scope and no storage-class specifier, its linkage is external.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example includes a helper() function that is implicitly declared to have external linkage:",
          "code": "enum { MAX = 100 };\n\nint helper(int i) {\n  /* Perform some computation based on i */\n}\n\nint main(void) {\n  size_t i;\n  int out[MAX];\n\n  for (i = 0; i < MAX; i++) {\n    out[i] = helper(i);\n  }\n\n  /* ... */\n\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution declares helper() to have internal linkage, thereby preventing external functions from using it:",
          "code": "enum {MAX = 100};\n\nstatic int helper(int i) {\n  /* Perform some computation based on i */\n}\n\nint main(void) {\n  size_t i;\n  int out[MAX];\n\n  for (i = 0; i < MAX; i++) {\n    out[i] = helper(i);\n  }\n\n  /* ... */\n\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Allowing too many objects to have external linkage can use up descriptive identifiers, leading to more complicated identifiers, violations of abstraction models, and possible name conflicts with libraries. If the compilation unit implements a data abstraction, it may also expose invocations of private functions from outside the abstraction.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL17-C",
    "title": "Beware of miscompiled volatile-qualified variables",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL17-C.+Beware+of+miscompiled+volatile-qualified+variables",
    "description": "As described in depth in rule DCL22-C. Use volatile for data that cannot be cached , a volatile -qualified variable \"shall be evaluated strictly according to the rules of the abstract machine\" [ ISO/IEC 9899:2011 ]. In other words, the volatile qualifier is used to instruct the compiler to not make caching optimizations about a variable.\n\nvolatile\n\nvolatile\n\nHowever, as demonstrated in \"Volatiles Are Miscompiled, and What to Do about It\" [ Eide and Regehr ], all tested compilers generated some percentage of incorrect compiled code with regard to volatile accesses. Therefore, it is necessary to know how your compiler behaves when the standard volatile behavior is required. The authors also provide a workaround that eliminates some or all of these errors.\n\nvolatile\n\nvolatile",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "As demonstrated in Eide and Regehr's work, the following code example compiles incorrectly using GCC 4.3.0 for IA32 and the -Os optimization flag:",
          "code": "const volatile int x;\nvolatile int y;\nvoid foo(void) {\n  for(y = 0; y < 10; y++) {\n    int z = x;\n  }\n}\n",
          "explanation_after": "Because the variable x is volatile -qualified, it should be accessed 10 times in this program. However, as shown in the compiled object code, it is accessed only once due to a loop-hoisting optimization [ Eide and Regehr ]:\n\nShould x represent a hardware register or some other memory-mapped device that has side effects when accessed, the previous miscompiled code example may produce unexpected behavior ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Eide and Regehr tested a workaround by wrapping volatile accesses with function calls. They describe it with the intuition that \"we can replace an action that compilers empirically get wrong by a different action—a function call—that compilers can get right\" [ Eide and Regehr ]. For example, the workaround for the noncompliant code example would be",
          "code": "int vol_read_int(volatile int *vp) {\n  return *vp;\n}\nvolatile int *vol_id_int(volatile int *vp) {\n  return vp;\n}\n\nconst volatile int x;\nvolatile int y;\nvoid foo(void) {\n  for(*vol_id_int(&y) = 0; vol_read_int(&y) < 10; *vol_id_int(&y) = vol_read_int(&y) + 1) {\n    int z = vol_read_int(&x);\n  }\n}\n",
          "explanation_after": "The workarounds proposed by Eide and Regehr fix many of the volatile -access bugs in the tested compilers. However, compilers are always changing, so critical sections of code should be compiled as if for deployment, and the compiled object code should be inspected for the correct behavior."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The volatile qualifier should be used with caution in mission-critical situations. Always make sure code that assumes certain behavior when using the volatile qualifier is inspected at the object code level for compiler bugs.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL18-C",
    "title": "Do not begin integer constants with 0 when specifying a decimal value",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL18-C.+Do+not+begin+integer+constants+with+0+when+specifying+a+decimal+value",
    "description": "The C Standard defines octal constants as a 0 followed by octal digits (0 1 2 3 4 5 6 7). Programming errors can occur when decimal values are mistakenly specified as octal constants.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a decimal constant is mistakenly prefaced with zeros so that all the constants are a fixed length:",
          "code": "i_array[0] = 2719;\ni_array[1] = 4435;\ni_array[2] = 0042;\n",
          "explanation_after": "Although it may appear that i_array[2] is assigned the decimal value 42, it is actually assigned the decimal value 34."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "To avoid using wrong values and to make the code more readable, do not preface constants with zeroes if the value is meant to be decimal:",
          "code": "i_array[0] = 2719;\ni_array[1] = 4435;\ni_array[2] =   42;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Misrepresenting decimal values as octal can lead to incorrect comparisons and assignments.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL19-C",
    "title": "Minimize the scope of variables and functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL19-C.+Minimize+the+scope+of+variables+and+functions",
    "description": "Variables and functions should be declared in the minimum scope from which all references to the identifier are still possible.\n\nWhen a larger scope than necessary is used, code becomes less readable, harder to maintain, and more likely to reference unintended variables (see DCL01-C. Do not reuse variable names in subscopes ).",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the function counter() increments the global variable count and then returns immediately if this variable exceeds a maximum value:",
          "code": "unsigned int count = 0;\n\nvoid counter() {\n  if (count++ > MAX_COUNT) return;\n  /* ... */\n\n}\n",
          "explanation_after": "Assuming that the variable count is only accessed from this function, this example is noncompliant because it does not define count within the minimum possible scope."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the variable count is declared within the scope of the counter() function as a static variable. The static modifier, when applied to a local variable (one inside of a function), modifies the lifetime (duration) of the variable so that it persists for as long as the program does and does not disappear between invocations of the function.",
          "code": "void counter() {\n  static unsigned int count = 0;\n  if (count++ > MAX_COUNT) return;\n  /* ... */\n\n}\n",
          "explanation_after": "The keyword static also prevents reinitialization of the variable."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The counter variable i is declared outside of the for loop, which goes against this recommendation because it is not declared in the block in which it is used. If this code were reused with another index variable j , but there was a previously declared variable i , the loop could iterate over the wrong variable.",
          "code": "size_t i = 0;\n\nfor (i=0; i < 10; i++){\n  /* Perform operations */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Complying with this recommendation requires that you declare variables where they are used, which improves readability and reusability. In this example, you would declare the loop's index variable i within the initialization of the for loop. This requirement was recently relaxed in the C Standard.",
          "code": "for (size_t i=0; i < 10; i++) {\n  /* Perform operations */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Function Declaration)",
          "pre_code_commentary": "In this noncompliant code example, the function f() is called only from within the function g() , which is defined in the same compilation unit. By default, function declarations are extern , meaning that these functions are placed in the global symbol table and are available from other compilation units.",
          "code": "int f(int i) {\n  /* Function definition */\n}\n\nint g(int i) {\n  int j = f(i);\n  /* ... */\n} ",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the function f() is declared with internal linkage. This practice limits the scope of the function declaration to the current compilation unit and prevents the function from being included in the external symbol table. It also limits cluttering in the global name space and prevents the function from being accidentally or intentionally invoked from another compilation unit. See DCL15-C. Declare file-scope objects or functions that do not need external linkage as static for more information.",
          "code": "static int f(int i) {\n  /* Function definition */\n}\n\nint g(int i) {\n  int j = f(i);\n  /* ... */\n} \n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to minimize scope could result in less reliable, readable, and reusable code.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL20-C",
    "title": "Explicitly specify void when a function accepts no arguments",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL20-C.+Explicitly+specify+void+when+a+function+accepts+no+arguments",
    "description": "According to the C Standard, subclause 6.7.6.3, paragraph 14 [ ISO/IEC 9899:2011 ],\n\nAn identifier list declares only the identifiers of the parameters of the function. An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of the parameters is supplied.\n\nSubclause 6.11.6 states that\n\nThe use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.\n\nConsequently, functions that accept no arguments should explicitly declare a void parameter in their parameter list. This holds true in both the declaration and definition sections (which should match).\n\nvoid\n\nDefining a function with a void argument list differs from declaring it with no arguments because, in the latter case, the compiler will not check whether the function is called with parameters at all [ TIGCC, void usage ]. Consequently, function calling with arbitrary parameters will be accepted without a warning at compile time.\n\nvoid\n\nFailure to declare a void parameter will result in\n\nvoid\n\nAn ambiguous functional interface between the caller and callee. Sensitive information outflow.\n\nA similar recommendation deals with parameter type in a more general sense: DCL07-C. Include the appropriate type information in function declarators .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Ambiguous Interface)",
          "pre_code_commentary": "In this noncompliant code example, the caller calls foo() with an argument of 3. The caller expects foo() to accept a single int argument and to output the argument as part of a longer message. Because foo() is declared without the void parameter, the compiler will not perform any caller check. It is therefore possible that the caller may not detect the error. In this example, for instance, foo() might output the value 3 as expected.\n\nBecause no function parameter has the same meaning as an arbitrary parameter, the caller can provide an arbitrary number of arguments to the function.",
          "code": "/* In foo.h */\nvoid foo();\n\n/* In foo.c */\nvoid foo() {\n  int i = 3;\n  printf(\"i value: %d\\n\", i);\n}\n\n/* In caller.c */\n#include \"foo.h\"\n\nfoo(3);\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Ambiguous Interface)",
          "pre_code_commentary": "In this compliant solution, void is specified explicitly as a parameter in the declaration of foo 's prototype:",
          "code": "/* In foo.h */\nvoid foo(void);\n\n/* In foo.c */\nvoid foo(void) {\n  int i = 3;\n  printf(\"i value: %d\\n\", i);\n}\n\n/* In caller.c */\n#include \"foo.h\"\n\nfoo(3);\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Information Outflow)",
          "pre_code_commentary": "Another possible vulnerability is the leak of privileged information. In this noncompliant code example, a user with high privileges feeds some secret input to the caller that the caller then passes to foo() . Because of the way foo() is defined, we might assume there is no way for foo() to retrieve information from the caller. However, because the value of i is really passed into a stack (before the return address of the caller), a malicious programmer can change the internal implementation and copy the value manually into a less privileged file.",
          "code": "/* Compile using gcc4.3.3 */\nvoid foo() {\n  /* \n   * Use assembly code to retrieve i\n   * implicitly from caller\n   * and transfer it to a less privileged file.\n   */\n}\n\n...\n\n/* Caller */\nfoo(i); /* i is fed from user input */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Information Outflow)",
          "pre_code_commentary": null,
          "code": "void foo(void) {\n  int i = 3;\n  printf(\"i value: %d\\n\", i);\n}\n",
          "explanation_after": "Again, the simplest solution is to explicitly specify void as the only parameter."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "DCL21-C",
    "title": "Understand the storage of compound literals",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL21-C.+Understand+the+storage+of+compound+literals",
    "description": "Subclause 6.5.2.5 of the C Standard [ ISO/IEC 9899:2011 ] defines a compound literal as\n\nA postfix expression that consists of a parenthesized type name followed by a brace-enclosed list of initializers. . . . The value of the compound literal is that of an unnamed object initiated by the initializer list.\n\nThe storage for this object is either static (if the compound literal occurs at file scope) or automatic (if the compound literal occurs at block scope), and the storage duration is associated with its immediate enclosing block. For example, in the function\n\nvoid func(void) {\n  int *ip = (int[4]){1,2,3,4};\n  /* ... */\n}\n\nvoid func(void) {\n  int *ip = (int[4]){1,2,3,4};\n  /* ... */\n}\n\nfollowing initialization, the int pointer ip contains the address of an unnamed object of type int[4] , allocated on the stack. Once func returns, any attempts to access this object will produce undefined behavior .\n\nint\n\nip\n\nint[4]\n\nfunc\n\nNote that only one object is created per compound literal—even if the compound literal appears in a loop and has dynamic initializers.\n\nThis recommendation is a specific instance of DCL30-C. Declare objects with appropriate storage durations .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the programmer mistakenly assumes that the elements of the ints array of the pointer to int_struct are assigned the addresses of distinct int_struct objects, one for each integer in the range [0, MAX_INTS - 1] :",
          "code": "#include <stdio.h>\n\ntypedef struct int_struct {\n  int x;\n} int_struct;\n\n#define MAX_INTS 10\n\nint main(void){\n  size_t i;\n  int_struct *ints[MAX_INTS];\n\n  for (i = 0; i < MAX_INTS; i++) {\n    ints[i] = &(int_struct){i};\n  }\n\n  for (i = 0; i < MAX_INTS; i++) {\n    printf(\"%d\\n\", ints[i]->x);\n  }\n \n  return 0;\n}\n",
          "explanation_after": "However, only one int_struct object is created. At each iteration of the first loop, the x member of this object is set equal to the current value of the loop counter i . Therefore, just before the first loop terminates, the value of the x member is MAX_INTS - 1 .\n\nBecause the storage duration of the compound literal is associated with the for loop that contains it, dereferencing ints in the second loop results in undefined behavior 9 (Annex J of the C Standard).\n\nEven if the region of memory that contained the compound literal is not written to between loops, the print loop will display the value MAX_INTS - 1 for MAX_INTS lines. This is contrary to the intuitive expected result, which is that the integers 0 through MAX_INTS - 1 would be printed in order."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses an array of structures rather than an array of pointers. That way, an actual copy of each int_struct (rather than a pointer to the object) is stored.",
          "code": "#include <stdio.h>\n\ntypedef struct int_struct {\n  int x;\n} int_struct;\n\n#define MAX_INTS 10\n\nint main(void){\n  size_t i;\n  int_struct ints[MAX_INTS];\n\n  for (i = 0; i < MAX_INTS; i++) {\n    ints[i] = (int_struct){i};\n  }\n\n  for (i = 0; i < MAX_INTS; i++) {\n    printf(\"%d\\n\", ints[i].x);\n  }\n \n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL22-C",
    "title": "Use volatile for data that cannot be cached",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL22-C.+Use+volatile+for+data+that+cannot+be+cached",
    "description": "An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects. Asynchronous signal handling, for example, may cause objects to be modified in a manner unknown to the compiler. Without this type qualifier, unintended optimizations may occur. These optimizations may cause race conditions because a programmer may write code that prevents a race condition, yet the compiler is not aware of the programmer's data model and may modify the code during compilation to permit race conditions.\n\nThe volatile keyword eliminates this confusion by imposing restrictions on access and caching. According to the C99 Rationale [ C99 Rationale 2003 ],\n\nvolatile\n\nNo caching through this lvalue : each operation in the abstract semantics must be performed (that is, no caching assumptions may be made, because the location is not guaranteed to contain any previous value). In the absence of this qualifier, the contents of the designated location may be assumed to be unchanged except for possible aliasing.\n\nType qualifying objects as volatile does not guarantee synchronization between multiple threads, protect against simultaneous memory accesses, or, unless used to declare objects of type sig_atomic_t , guarantee atomicity of accesses to the object. For restrictions specific to signal handlers, see SIG31-C. Do not access shared objects in signal handlers . However, type qualifying objects as volatile does ensure that a conforming compiler will not elide or reorder access to the object.\n\nsig_atomic_t",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the programmer is targeting a custom piece of hardware that controls an LED by writing values into a register bank. The register bank is memory mapped into the process such that writing to a specific memory location will actually place a value into a hardware register to be read by the LED controller. The programmer intends to turn the LED on by placing value 1 into the first register, and then turn the LED off later by placing the value 0 into the first register.",
          "code": "#include <stddef.h>\n#include <stdint.h>\n\nextern void get_register_bank(int32_t **bank,\n                              size_t *num_registers);\nextern void external_wait(void);\n\nvoid func(void) {\n  int32_t bank[3];\n  size_t num_regs = 3;\n\n  get_register_bank((int32_t **)&bank, &num_regs);\n  if (num_regs < 3) {\n    /* Handle error */\n   }\n\n  bank[0] = 1;\n  external_wait();\n  bank[0] = 0;\n}",
          "explanation_after": "The compiler is free to optimize what it perceives as being a dead store to bank[0] by removing the first assignment to the variable. This would cause the LED to never be turned on in an optimized build."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the register bank's memory is qualified with the volatile keyword, ensuring the compiler does not optimize access to the memory.",
          "code": "#include <stddef.h>\n#include <stdint.h>\n\nextern void get_register_bank(volatile int32_t **bank,\n                              size_t *num_registers);\nextern void external_wait(void);\n\nvoid func(void) {\n  volatile int32_t bank[3];\n  size_t num_regs = 3;\n\n  get_register_bank((volatile int32_t **)&bank, &num_regs);\n  if (num_regs < 3) {\n    /* Handle error */\n   }\n\n  bank[0] = 1;\n  external_wait();\n  bank[0] = 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to declare variables containing data that cannot be cached as volatile can result in unexpected runtime behavior resulting from compiler optimizations.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL23-C",
    "title": "Guarantee that mutually visible identifiers are unique",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL23-C.+Guarantee+that+mutually+visible+identifiers+are+unique",
    "description": "According to subclause 6.2.7 of the C Standard [ ISO/IEC 9899:2011 ],\n\nAll declarations that refer to the same object or function shall have compatible type; otherwise, the behavior is undefined.\n\n(See also undefined behavior 14 of Annex J.)\n\nFurther, according to subclause 6.4.2.1,\n\nAny identifiers that differ in a significant character are different identifiers. If two identifiers differ only in nonsignificant characters, the behavior is undefined.\n\n(See also undefined behavior 30 of Annex J.)\n\nIdentifiers in mutually visible scopes must be deemed unique by the compiler to prevent confusion about which variable or function is being referenced. Implementations can allow additional nonunique characters to be appended to the end of identifiers, making the identifiers appear unique while actually being indistinguishable.\n\nIt is reasonable for scopes that are not visible to each other to have duplicate identifiers. For example, two functions can each have a local variable with the same name because their scopes cannot access each other. But a function's local variable names should be distinct from each other as well as from all static variables declared within the function's file (and from all included header files.)\n\nTo guarantee that identifiers are unique, the number of significant characters recognized by the most restrictive compiler used must be determined. This assumption must be documented in the code.\n\nThe standard defines the following minimum requirements:\n\n63 significant initial characters in an internal identifier or a macro name. (Each universal character name or extended source character is considered a single character.) 31 significant initial characters in an external identifier. (Each universal character name specifying a short identifier of 0000FFFF or less is considered 6 characters; each universal character name specifying a short identifier of 00010000 or more is considered 10 characters; and each extended source character, if any exist, is considered the same number of characters as the corresponding universal character name.)\n\nRestriction of the significance of an external name to fewer than 255 characters in the standard (considering each universal character name or extended source character as a single character) is an obsolescent feature that is a concession to existing implementations. As a result, it is not necessary to comply with this restriction as long as the identifiers are unique and the assumptions concerning the number of significant characters are documented.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Source Character Set)",
          "pre_code_commentary": "On implementations that support only the minimum requirements for significant characters required by the standard, this code example is noncompliant because the first 31 characters of the external identifiers are identical:",
          "code": "extern int *global_symbol_definition_lookup_table_a;\nextern int *global_symbol_definition_lookup_table_b;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Source Character Set)",
          "pre_code_commentary": "In a compliant solution, the significant characters in each identifier must differ:",
          "code": "extern int *a_global_symbol_definition_lookup_table;\nextern int *b_global_symbol_definition_lookup_table;\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Universal Character Names)",
          "pre_code_commentary": "In this noncompliant code example, both external identifiers consist of four universal character names. Because the first three universal character names of each identifier are identical, both identify the same integer array on implementations that support only the minimum requirements for significant characters required by the standard:",
          "code": "extern int *\\U00010401\\U00010401\\U00010401\\U00010401;\nextern int *\\U00010401\\U00010401\\U00010401\\U00010402;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Universal Character Names)",
          "pre_code_commentary": "For portability, the first three universal character name combinations used in an identifier must be unique:",
          "code": "extern int *\\U00010401\\U00010401\\U00010401\\U00010401;\nextern int *\\U00010402\\U00010401\\U00010401\\U00010401;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Nonunique identifiers can lead to abnormal program termination, denial-of-service attacks, or unintended information disclosure.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "DCL30-C",
    "title": "Declare objects with appropriate storage durations",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL30-C.+Declare+objects+with+appropriate+storage+durations",
    "description": "Every object has a storage duration that determines its lifetime: static , thread , automatic , or allocated .\n\nAccording to the C Standard, 6.2.4, paragraph 2 [ ISO/IEC 9899:2024 ],\n\nThe lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address, and retains its last-stored value throughout its lifetime. If an object is referred to outside of its lifetime, the behavior is undefined. If a pointer value is used in an evaluation after the object the pointer points to (or just past) reaches the end of its lifetime, the behavior is undefined.\n\nDo not attempt to access an object outside of its lifetime. Attempting to do so is undefined behavior and can lead to an exploitable vulnerability . (See also undefined behavior 9 in the C Standard, Annex J.)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Differing Storage Durations)",
          "pre_code_commentary": "In this noncompliant code example, the address of the variable c_str with automatic storage duration is assigned to the variable p , which has static storage duration. The assignment itself is valid, but it is invalid for c_str to go out of scope while p holds its address, as happens at the end of dont_do_this () .",
          "code": "#include <stdio.h>\n \nconst char *p;\nvoid dont_do_this(void) {\n  const char c_str[] = \"This will change\";\n  p = c_str; /* Dangerous */\n}\n\nvoid innocuous(void) {\n  printf(\"%s\\n\", p);\n}\n\nint main(void) {\n  dont_do_this();\n  innocuous();\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Same Storage Durations)",
          "pre_code_commentary": "In this compliant solution, p is declared with the same storage duration as c_str , preventing p from taking on an indeterminate value outside of this_is_OK() :",
          "code": "void this_is_OK(void) {\n  const char c_str[] = \"Everything OK\";\n  const char *p = c_str;\n  /* ... */\n}\n/* p is inaccessible outside the scope of string c_str */\n",
          "explanation_after": "Alternatively, both p and c_str could be declared with static storage duration."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Differing Storage Durations)",
          "pre_code_commentary": "In this noncompliant code example, the address of the variable c_str with automatic storage duration is assigned to the variable p , which has static storage duration. The assignment itself is valid, but it is invalid for c_str to go out of scope while p holds its address, as happens at the end of dont_do_this () .",
          "code": "#include <stdio.h>\n \nconst char *p;\nvoid dont_do_this(void) {\n  const char c_str[] = \"This will change\";\n  p = c_str; /* Dangerous */\n}\n\nvoid innocuous(void) {\n  printf(\"%s\\n\", p);\n}\n\nint main(void) {\n  dont_do_this();\n  innocuous();\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Differing Storage Durations)",
          "pre_code_commentary": "If it is necessary for p to be defined with static storage duration but c_str with a more limited duration, then p can be set to NULL before c_str is destroyed. This practice prevents p from taking on an indeterminate value , although any references to p must check for NULL .",
          "code": "const char *p;\nvoid is_this_OK(void) {\n  const char c_str[] = \"Everything OK?\";\n  p = c_str;\n  /* ... */\n  p = NULL;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Return Values)",
          "pre_code_commentary": "In this noncompliant code sample, the function init_array () returns a pointer to a character array with automatic storage duration, which is accessible to the caller:",
          "code": "char *init_array(void) {\n  char array[10];\n  /* Initialize array */\n  return array;\n}\n",
          "explanation_after": "Some compilers generate a diagnostic message when a pointer to an object with automatic storage duration is returned from a function, as in this example. Programmers should compile code at high warning levels and resolve any diagnostic messages. (See MSC00-C. Compile cleanly at high warning levels .)"
        },
        "compliant": {
          "heading": "Compliant Solution (Return Values)",
          "pre_code_commentary": "The solution, in this case, depends on the intent of the programmer. If the intent is to modify the value of array and have that modification persist outside the scope of init_array() , the desired behavior can be achieved by declaring array elsewhere and passing it as an argument to init_array() :",
          "code": "#include <stddef.h>\nvoid init_array(char *array, size_t len) {\n  /* Initialize array */\n  return;\n}\n\nint main(void) {\n  char array[10];\n  init_array(array, sizeof(array) / sizeof(array[0]));\n  /* ... */\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Output Parameter)",
          "pre_code_commentary": "In this noncompliant code example, the function squirrel_away() stores a pointer to local variable local into a location pointed to by function parameter ptr_param . Upon the return of squirrel_away() , the pointer ptr_param points to a variable that has an expired lifetime.",
          "code": "void squirrel_away(char **ptr_param) {\n  char local[10];\n  /* Initialize array */\n  *ptr_param = local;\n}\n\nvoid rodent(void) {\n  char *ptr;\n  squirrel_away(&ptr);\n  /* ptr is live but invalid here */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Output Parameter)",
          "pre_code_commentary": "In this compliant solution, the variable local has static storage duration; consequently, ptr can be used to reference the local array within the rodent() function:",
          "code": "char local[10];\n \nvoid squirrel_away(char **ptr_param) {\n  /* Initialize array */\n  *ptr_param = local;\n}\n\nvoid rodent(void) {\n  char *ptr;\n  squirrel_away(&ptr);\n  /* ptr is valid in this scope */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Referencing an object outside of its lifetime can result in an attacker being able to execute arbitrary code.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "DCL31-C",
    "title": "Declare identifiers before using them",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL31-C.+Declare+identifiers+before+using+them",
    "description": "The C23 Standard requires type specifiers and forbids implicit function declarations. The C90 Standard allows implicit typing of variables and functions. Consequently, some existing legacy code uses implicit typing. Some C compilers still support legacy code by allowing implicit typing, but it should not be used for new code. Such an implementation may choose to assume an implicit declaration and continue translation to support existing programs that used this feature.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Implicit int )",
          "pre_code_commentary": "C no longer allows the absence of type specifiers in a declaration. The C Standard, 6.7.3 paragraph 2 [ ISO/IEC 9899:2024 ], states\n\nExcept where the type is inferred (6.7.10), at least one type specifier shall be given in the declaration specifiers in each declaration, and in the specifier-qualifier list in each member declaration and type name.\n\nThis noncompliant code example omits the type specifier:",
          "code": "extern foo;\n",
          "explanation_after": "Some C implementations do not issue a diagnostic for the violation of this constraint. These nonconforming C translators continue to treat such declarations as implying the type int ."
        },
        "compliant": {
          "heading": "Compliant Solution (Implicit int )",
          "pre_code_commentary": "This compliant solution explicitly includes a type specifier:",
          "code": "extern int foo;\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Implicit Function Declaration)",
          "pre_code_commentary": "Implicit declaration of functions is not allowed; every function must be explicitly declared before it can be called. In C90, if a function is called without an explicit prototype, the compiler provides an implicit declaration.\n\nThe C90 Standard [ ISO/IEC 9899:1990 ] includes this requirement:\n\nIf the expression that precedes the parenthesized argument list in a function call consists solely of an identifier, and if no declaration is visible for this identifier, the identifier is implicitly declared exactly as if, in the innermost block containing the function call, the declaration extern int identifier(); appeared.\n\nIf a function declaration is not visible at the point at which a call to the function is made, C90-compliant platforms assume an implicit declaration of extern int identifier(); .\n\nThis declaration implies that the function may take any number and type of arguments and return an int . However, to conform to the current C Standard, programmers must explicitly prototype every function before invoking it. An implementation that conforms to the C Standard may or may not perform implicit function declarations, but C does require a conforming implementation to issue a diagnostic if it encounters an undeclared function being used.\n\nIn this noncompliant code example, if malloc() is not declared, either explicitly or by including stdlib.h , a compiler that conforms only to C90 may implicitly declare malloc() as int malloc() . If the platform's size of int is 32 bits, but the size of pointers is 64 bits, the resulting pointer would likely be truncated as a result of the implicit declaration of malloc() , returning a 32-bit integer.",
          "code": "#include <stddef.h>\n/* #include <stdlib.h> is missing */\n \nint main(void) {\n  for (size_t i = 0; i < 100; ++i) {\n    /* int malloc() assumed */\n    char *ptr = (char *)malloc(0x10000000);\n    *ptr = 'a';\n  }\n  return 0;\n}",
          "explanation_after": "When compiled with Microsoft Visual Studio 2013 for a 64-bit platform, this noncompliant code example will eventually cause an access violation when dereferencing ptr in the loop."
        },
        "compliant": {
          "heading": "Compliant Solution (Implicit Function Declaration)",
          "pre_code_commentary": "This compliant solution declares malloc() by including the appropriate header file:",
          "code": "#include <stdlib.h>\n \nint main(void) {\n  for (size_t i = 0; i < 100; ++i) {\n    char *ptr = (char *)malloc(0x10000000);\n    *ptr = 'a';\n  }\n  return 0;\n}",
          "explanation_after": "For more information on function declarations, see DCL07-C. Include the appropriate type information in function declarators ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Implicit Return Type)",
          "pre_code_commentary": "Do not declare a function with an implicit return type. For example, if a function returns a meaningful integer value, declare it as returning int . If it returns no meaningful value, declare it as returning void .",
          "code": "#include <limits.h>\n#include <stdio.h>\n \nfoo(void) {\n  return UINT_MAX;\n}\n\nint main(void) {\n  long long int c = foo();\n  printf(\"%lld\\n\", c);\n  return 0;\n}\n",
          "explanation_after": "Because the compiler assumes that foo() returns a value of type int for this noncompliant code example, UINT_MAX is incorrectly converted to −1 ."
        },
        "compliant": {
          "heading": "Compliant Solution (Implicit Return Type)",
          "pre_code_commentary": "This compliant solution explicitly defines the return type of foo() as unsigned int . As a result, the function correctly returns UINT_MAX .",
          "code": "#include <limits.h>\n#include <stdio.h>\n\nunsigned int foo(void) {\n  return UINT_MAX;\n}\n\nint main(void) {\n  long long int c = foo();\n  printf(\"%lld\\n\", c);\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Because implicit declarations lead to less stringent type checking, they can introduce unexpected and erroneous behavior. Occurrences of an omitted type specifier in existing code are rare, and the consequences are generally minor, perhaps resulting in abnormal program termination .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL36-C",
    "title": "Do not declare an identifier with conflicting linkage classifications",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL36-C.+Do+not+declare+an+identifier+with+conflicting+linkage+classifications",
    "description": "Linkage can make an identifier declared in different scopes or declared multiple times within the same scope refer to the same object or function. Identifiers are classified as externally linked , internally linked , or not linked . These three kinds of linkage have the following characteristics [ Kirch-Prinz 2002 ]:\n\nExternal linkage: An identifier with external linkage represents the same object or function throughout the entire program, that is, in all compilation units and libraries belonging to the program. The identifier is available to the linker. When a second declaration of the same identifier with external linkage occurs, the linker associates the identifier with the same object or function.\n\nInternal linkage: An identifier with internal linkage represents the same object or function within a given translation unit. The linker has no information about identifiers with internal linkage. Consequently, these identifiers are internal to the translation unit.\n\nNo linkage: If an identifier has no linkage, then any further declaration using the identifier declares something new, such as a new variable or a new type.\n\nAccording to the C Standard, 6.2.2 paragraph 3 [ ISO/IEC 9899:2024 ], linkage is determined as follows:\n\nIf the declaration of a file scope identifier for: - an object contains any of the storage-class specifiers static or contexpr; - or, a function contains the storage-class specifier static , then the identifier has internal linkage. For an identifier declared with the storage-class specifier extern in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the linkage of the identifier at the later declaration is the same as the linkage specified at the prior declaration . If no prior declaration is visible, or if the prior declaration specifies no linkage, then the identifier has external linkage. If the declaration of an identifier for a function has no storage-class specifier, its linkage is determined exactly as if it were declared with the storage-class specifier extern . If the declaration of an identifier for an object has file scope and does not contain the storage-class specifier static or contexpr , its linkage is external. The following identifiers have no linkage: an identifier declared to be anything other than an object or a function; an identifier declared to be a function parameter; a block scope identifier for an object declared without the storage-class specifier extern .\n\nstatic\n\ncontexpr;\n\nstatic\n\nextern\n\nextern\n\nstatic\n\ncontexpr\n\nextern\n\nUse of an identifier (within one translation unit) classified as both internally and externally linked is undefined behavior . (See also undefined behavior 8 .) A translation unit includes the source file together with its headers and all source files included via the preprocessing directive #include .\n\n#include\n\nThe following table identifies the linkage assigned to an object that is declared twice in a single translation unit. The column designates the first declaration, and the row designates the redeclaration.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, i2 and i5 are defined as having both internal and external linkage. Future use of either identifier results in undefined behavior 8 .",
          "code": "int i1 = 10;         /* Definition, external linkage */\nstatic int i2 = 20;  /* Definition, internal linkage */\nextern int i3 = 30;  /* Definition, external linkage */\nint i4;              /* Tentative definition, external linkage */\nstatic int i5;       /* Tentative definition, internal linkage */\n\nint i1;  /* Valid tentative definition */\nint i2;  /* Undefined, linkage disagreement with previous */\nint i3;  /* Valid tentative definition */\nint i4;  /* Valid tentative definition */\nint i5;  /* Undefined, linkage disagreement with previous */\n\nint main(void) {\n  /* ... */\n  return 0;\n}\n",
          "explanation_after": "Microsoft Visual Studio 2013 issues no warnings about this code, even at the highest diagnostic levels.\n\nGCC and Clang 14 both generate fatal diagnostics for the conflicting definitions of i2 and i5 ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not include conflicting definitions:",
          "code": "int i1 = 10;         /* Definition, external linkage */\nstatic int i2 = 20;  /* Definition, internal linkage */\nextern int i3 = 30;  /* Definition, external linkage */\nint i4;              /* Tentative definition, external linkage */\nstatic int i5;       /* Tentative definition, internal linkage */\n\nint main(void) {\n  /* ... */\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Use of an identifier classified as both internally and externally linked is undefined behavior 8 .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "DCL37-C",
    "title": "Do not declare or define a reserved identifier",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL37-C.+Do+not+declare+or+define+a+reserved+identifier",
    "description": "According to the C Standard, 6.4.2.1 paragraph 7 [ ISO/IEC 9899:2024 ],\n\nSome identifiers are reserved. —  All identifiers that begin with a double underscore ( __ ) or begin with an underscore ( _ ) followed by an uppercase letter are reserved for any use, except those identifiers which are lexically identical to keywords. —  All identifiers that begin with an underscore are reserved for use as identifiers with file scope in both the ordinary and tag name spaces. Other identifiers may be reserved, see 7.1.3.\n\nC Standard, 7.1.3 paragraph 1 [ ISO/IEC 9899:2024 ],\n\nEach header declares or defines all identifiers listed in its associated subclause, and optionally declares or defines identifiers listed in its associated future library directions subclause and identifiers which are always reserved either for any use or for use as file scope identifiers. — All potentially reserved identifiers (including ones listed in the future library directions) that are provided by an implementation with an external definition are reserved for any use. An implementation shall not provide an external definition of a potentially reserved identifier unless that identifier is reserved for a use where it would have external linkage. All other potentially reserved identifiers that are provided by an implementation (including in the form of a macro) are reserved for any use when the associated header is included. No other potentially reserved identifiers are reserved. — Each macro name in any of the following subclauses (including the future library directions) is reserved for use as specified if any of its associated headers is included; unless explicitly stated otherwise (see 7.1.4). — All identifiers with external linkage in any of the following subclauses (including the future library directions) and errno are always reserved for use as identifiers with external linkage. — Each identifier with file scope listed in any of the following subclauses (including the future library directions) is reserved for use as a macro name and as an identifier with file scope in the same name space if any of its associated headers is included.\n\nerrno\n\nAdditionally, subclause 7.33 defines many other reserved identifiers for future library directions.\n\nNo other identifiers are reserved. (The POSIX standard extends the set of identifiers reserved by the C Standard to include an open-ended set of its own. See Portable Operating System Interface [POSIX ® ], Base Specifications, Issue 7 , Section 2.2 , \"The Compilation Environment\" [ IEEE Std 1003.1-2013 ].) The behavior of a program that declares or defines an identifier in a context in which it is reserved or that defines a reserved identifier as a macro name is undefined. (See undefined behavior 105 .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Include Guard)",
          "pre_code_commentary": "A common, but noncompliant, practice is to choose a reserved name for a macro used in a preprocessor conditional guarding against multiple inclusions of a header file. (See also PRE06-C. Enclose header files in an include guard .) The name may clash with reserved names defined by the implementation of the C standard library in its headers or with reserved names implicitly predefined by the compiler even when no C standard library header is included.",
          "code": "#ifndef _MY_HEADER_H_\n#define _MY_HEADER_H_\n\n/* Contents of <my_header.h> */\n\n#endif /* _MY_HEADER_H_ */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Include Guard)",
          "pre_code_commentary": "This compliant solution avoids using leading underscores in the macro name of the include guard:",
          "code": "#ifndef MY_HEADER_H\n#define MY_HEADER_H\n\n/* Contents of <my_header.h> */\n\n#endif /* MY_HEADER_H */\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (File Scope Objects)",
          "pre_code_commentary": "In this noncompliant code example, the names of the file scope objects _max_limit and _limit both begin with an underscore. Because _max_limit is static, this declaration might seem to be impervious to clashes with names defined by the implementation. However, because the header <stddef.h> is included to define size_t , a potential for a name clash exists. (Note, however, that a conforming compiler may implicitly declare reserved names regardless of whether any C standard library header is explicitly included.)\n\nIn addition, because _limit has external linkage, it may clash with a symbol of the same name defined in the language runtime library even if such a symbol is not declared in any header. Consequently, it is not safe to start the name of any file scope identifier with an underscore even if its linkage limits its visibility to a single translation unit.",
          "code": "#include <stddef.h>\n\nstatic const size_t _max_limit = 1024;\nsize_t _limit = 100;\n\nunsigned int getValue(unsigned int count) {\n  return count < _limit ? count : _limit;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (File Scope Objects)",
          "pre_code_commentary": "In this compliant solution, names of file scope objects do not begin with an underscore:",
          "code": "#include <stddef.h>\n\nstatic const size_t max_limit = 1024;\nsize_t limit = 100;\n\nunsigned int getValue(unsigned int count) {\n  return count < limit ? count : limit;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Reserved Macros)",
          "pre_code_commentary": "In this noncompliant code example, because the C standard library header <inttypes.h> is specified to include <stdint.h> , the name SIZE_MAX conflicts with a standard macro of the same name, which is used to denote the upper limit of size_t . In addition, although the name INTFAST16_LIMIT_MAX is not defined by the C standard library, it is a reserved identifier because it begins with the INT prefix and ends with the _MAX suffix. (See the C Standard, 7.33.14 .)",
          "code": "#include <inttypes.h>\n#include <stdio.h>\n\nstatic const int_fast16_t INTFAST16_LIMIT_MAX = 12000;\n\nvoid print_fast16(int_fast16_t val) {\n  enum { SIZE_MAX = 80 };\n  char buf[SIZE_MAX];\n  if (INTFAST16_LIMIT_MAX < val) {\n    sprintf(buf, \"The value is too large\");\n  } else {\n    snprintf(buf, SIZE_MAX, \"The value is %\" PRIdFAST16, val);\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Reserved Macros)",
          "pre_code_commentary": "This compliant solution avoids redefining reserved names or using reserved prefixes and suffixes:",
          "code": "#include <inttypes.h>\n#include <stdio.h>\n \nstatic const int_fast16_t MY_INTFAST16_UPPER_LIMIT = 12000;\n\nvoid print_fast16(int_fast16_t val) {\n  enum { BUFSIZE = 80 };\n  char buf[BUFSIZE];\n  if (MY_INTFAST16_UPPER_LIMIT < val) {\n    sprintf(buf, \"The value is too large\");\n  } else {\n    snprintf(buf, BUFSIZE, \"The value is %\" PRIdFAST16, val);\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Identifiers with External Linkage)",
          "pre_code_commentary": "This noncompliant example provides definitions for the C standard library functions malloc() and free() . Although this practice is permitted by many traditional implementations of UNIX (for example, the Dmalloc library), it is undefined behavior 84 according to the C Standard. Even on systems that allow replacing malloc() , doing so without also replacing aligned_alloc() , calloc() , and realloc() is likely to cause problems.",
          "code": "#include <stddef.h>\n \nvoid *malloc(size_t nbytes) {\n  void *ptr;\n  /* Allocate storage from own pool and set ptr */\n  return ptr;\n}\n\nvoid free(void *ptr) {\n  /* Return storage to own pool */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Identifiers with External Linkage)",
          "pre_code_commentary": "The compliant, portable solution avoids redefining any C standard library identifiers with external linkage. In addition, it provides definitions for all memory allocation functions:",
          "code": "#include <stddef.h>\n\nvoid *my_malloc(size_t nbytes) {\n  void *ptr;\n  /* Allocate storage from own pool and set ptr */\n  return ptr;\n}\n\nvoid *my_aligned_alloc(size_t alignment, size_t size) {\n  void *ptr;\n  /* Allocate storage from own pool, align properly, set ptr */\n  return ptr;\n}\n\nvoid *my_calloc(size_t nelems, size_t elsize) {\n  void *ptr;\n  /* Allocate storage from own pool, zero memory, and set ptr */\n  return ptr;\n}\n\nvoid *my_realloc(void *ptr, size_t nbytes) {\n  /* Reallocate storage from own pool and set ptr */\n  return ptr;\n}\n\nvoid my_free(void *ptr) {\n  /* Return storage to own pool */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( errno )",
          "pre_code_commentary": "In addition to symbols defined as functions in each C standard library header, identifiers with external linkage include errno and math_errhandling .  According to the C Standard, 7.5, paragraph 2 [ ISO/IEC 9899:2011 ], the behavior of a program is undefined when\n\nA macro definition of errno is suppressed in order to access an actual object, or the program defines an identifier with the name errno .\n\nSee undefined behavior 111 .\n\nThe errno identifier expands to a modifiable lvalue that has type int but is not necessarily the identifier of an object. It might expand to a modifiable lvalue resulting from a function call, such as *errno() . It is unspecified whether errno is a macro or an identifier declared with external linkage. If a macro definition is suppressed to access an actual object, or if a program defines an identifier with the name errno , the behavior is undefined .\n\nLegacy code is apt to include an incorrect declaration, such as the following:",
          "code": "extern int errno;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( errno )",
          "pre_code_commentary": "The correct way to declare errno is to include the header <errno.h> :",
          "code": "#include <errno.h>\n",
          "explanation_after": "Implementations conforming to C are required to declare errno in <errno.h> , although some historic implementations failed to do so."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using reserved identifiers can lead to incorrect program operation.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL38-C",
    "title": "Use the correct syntax when declaring a flexible array member",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL38-C.+Use+the+correct+syntax+when+declaring+a+flexible+array+member",
    "description": "Flexible array members are a special type of array in which the last element of a structure with more than one named member has an incomplete array type; that is, the size of the array is not specified explicitly within the structure. This \"struct hack\" was widely used in practice and supported by a variety of compilers. Consequently, a variety of different syntaxes have been used for declaring flexible array members. For conforming C implementations, use the syntax guaranteed to be valid by the C Standard.\n\nFlexible array members are defined in the C Standard, 6.7.3.2, paragraph 20 [ ISO/IEC 9899:2024 ], as follows:\n\nAs a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member . In most situations, the flexible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply. However, when a . (or -> ) operator has a left operand that is (a pointer to) a structure with a flexible array member and the right operand names that member, it behaves as if that member were replaced with the longest array (with the same element type) that would not make the structure larger than the object being accessed; the offset of the array shall remain that of the flexible array member, even if this would differ from that of the replacement array. If this array would have no elements, it behaves as if it had one element but the behavior is undefined if any attempt is made to access that element or to generate a pointer one past it.\n\n. \n\n->\n\nStructures with a flexible array member can be used to produce code with defined behavior. However, some restrictions apply:\n\nThe incomplete array type must be the last element within the structure. There cannot be an array of structures that contain a flexible array member. Structures that contain a flexible array member cannot be used as a member of another structure. The structure must contain at least one named member in addition to the flexible array member.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Before the introduction of flexible array members in the C Standard, structures with a one-element array as the final member were used to achieve similar functionality. This noncompliant code example illustrates how struct flexArrayStruct is declared in this case.\n\nThis noncompliant code example attempts to allocate a flexible array-like member with a one-element array as the final member. When the structure is instantiated, the size computed for malloc() is modified to account for the actual size of the dynamic array.",
          "code": "#include <stdlib.h>\n \nstruct flexArrayStruct {\n  int num;\n  int data[1];\n};\n\nvoid func(size_t array_size) {\n  /* Space is allocated for the struct */\n  struct flexArrayStruct *structP\n    = (struct flexArrayStruct *)\n     malloc(sizeof(struct flexArrayStruct)\n          + sizeof(int) * (array_size - 1));\n  if (structP == NULL) {\n    /* Handle malloc failure */\n  }\n  \n  structP->num = array_size;\n\n  /*\n   * Access data[] as if it had been allocated\n   * as data[array_size].\n   */\n  for (size_t i = 0; i < array_size; ++i) {\n    structP->data[i] = 1;\n  }\n}",
          "explanation_after": "This example has undefined behavior 59 when accessing any element other than the first element of the data array. (See the C Standard, 6.5.7.) Consequently, the compiler can generate code that does not return the expected value when accessing the second element of data.\n\nThis approach may be the only alternative for compilers that do not yet implement the standard C syntax."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses a flexible array member to achieve a dynamically sized structure:",
          "code": "#include <stdlib.h>\n \nstruct flexArrayStruct{\n  int num;\n  int data[];\n};\n\nvoid func(size_t array_size) {\n  /* Space is allocated for the struct */\n  struct flexArrayStruct *structP \n    = (struct flexArrayStruct *)\n    malloc(sizeof(struct flexArrayStruct) \n         + sizeof(int) * array_size);\n  if (structP == NULL) {\n    /* Handle malloc failure */\n  }\n\n  structP->num = array_size;\n\n  /*\n   * Access data[] as if it had been allocated\n   * as data[array_size].\n   */\n  for (size_t i = 0; i < array_size; ++i) {\n    structP->data[i] = 1;\n  }\n}",
          "explanation_after": "This compliant solution allows the structure to be treated as if its member data[] was declared to be data[array_size] in a manner that conforms to the C Standard."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to use the correct syntax when declaring a flexible array member can result in undefined behavior 59 , although the incorrect syntax will work on most implementations.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL39-C",
    "title": "Avoid information leakage when passing a structure across a trust boundary",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL39-C.+Avoid+information+leakage+when+passing+a+structure+across+a+trust+boundary",
    "description": "The C Standard, 6.7.3.2, discusses the layout of structure fields. It specifies that non-bit-field members are aligned in an implementation-defined manner and that there may be padding within or at the end of a structure. Furthermore, initializing the members of the structure does not guarantee initialization of the padding bytes. The C Standard, 6.2.6.1, paragraph 6 [ ISO/IEC 9899:2024 ], states\n\nWhen a value is stored in an object of structure or union type, including in a member object, the bytes of the object representation that correspond to any padding bytes take unspecified values (e.g. structure and union assignment may or may not copy any padding bits).\n\nAdditionally, the storage units in which a bit-field resides may also have padding bits. For an object with automatic storage duration, these padding bits do not take on specific values and can contribute to leaking sensitive information.\n\nWhen passing a pointer to a structure across a trust boundary to a different trusted domain, the programmer must ensure that the padding bytes and bit-field storage unit padding bits of such a structure do not contain sensitive information.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example runs in kernel space and copies data from arg to user space. However, padding bytes may be used within the structure, for example, to ensure the proper alignment of the structure members. These padding bytes may contain sensitive information, which may then be leaked when the data is copied to user space.",
          "code": "#include <stddef.h>\n\nstruct test {\n  int a;\n  char b;\n  int c;\n};\n\n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  struct test arg = {.a = 1, .b = 2, .c = 3};\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\n",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( memset() )",
          "pre_code_commentary": "The padding bytes can be explicitly initialized by calling memset() :",
          "code": "#include <string.h>\n\nstruct test {\n  int a;\n  char b;\n  int c;\n};\n\n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  struct test arg;\n\n  /* Set all bytes (including padding bytes) to zero */\n  memset(&arg, 0, sizeof(arg));\n\n  arg.a = 1;\n  arg.b = 2;\n  arg.c = 3;\n\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\n",
          "explanation_after": "However, a conforming compiler is free to implement arg.b = 2 by setting the low-order bits of a register to 2, leaving the high-order bits unchanged and containing sensitive information. Then the platform copies all register bits into memory, leaving sensitive information in the padding bits. Consequently, this implementation could leak the high-order bits from the register to a user."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution serializes the structure data before copying it to an untrusted context:",
          "code": "#include <stddef.h>\n#include <string.h>\n \nstruct test {\n  int a;\n  char b;\n  int c;\n};\n \n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n \nvoid do_stuff(void *usr_buf) {\n  struct test arg = {.a = 1, .b = 2, .c = 3};\n  /* May be larger than strictly needed */\n  unsigned char buf[sizeof(arg)];\n  size_t offset = 0;\n  \n  memcpy(buf + offset, &arg.a, sizeof(arg.a));\n  offset += sizeof(arg.a);\n  memcpy(buf + offset, &arg.b, sizeof(arg.b));\n  offset += sizeof(arg.b);\n  memcpy(buf + offset, &arg.c, sizeof(arg.c));\n  offset += sizeof(arg.c);\n  /* Set all remaining bytes to zero */\n  memset(buf + offset, 0, sizeof(arg) - offset);\n\n  copy_to_user(usr_buf, buf, offset /* size of info copied */);\n} ",
          "explanation_after": "This code ensures that no uninitialized padding bytes are copied to unprivileged users. Important: The structure copied to user space is now a packed structure and the copy_to_user() function (or other eventual user) would need to unpack it to recreate the original padded structure."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( memset() )",
          "pre_code_commentary": "The padding bytes can be explicitly initialized by calling memset() :",
          "code": "#include <string.h>\n\nstruct test {\n  int a;\n  char b;\n  int c;\n};\n\n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  struct test arg;\n\n  /* Set all bytes (including padding bytes) to zero */\n  memset(&arg, 0, sizeof(arg));\n\n  arg.a = 1;\n  arg.b = 2;\n  arg.c = 3;\n\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\n",
          "explanation_after": "However, a conforming compiler is free to implement arg.b = 2 by setting the low-order bits of a register to 2, leaving the high-order bits unchanged and containing sensitive information. Then the platform copies all register bits into memory, leaving sensitive information in the padding bits. Consequently, this implementation could leak the high-order bits from the register to a user."
        },
        "compliant": {
          "heading": "Compliant Solution (Padding Bytes)",
          "pre_code_commentary": "Padding bytes can be explicitly declared as fields within the structure. This solution is not portable, however, because it depends on the implementation and target memory architecture. The following solution is specific to the x86-32 architecture:",
          "code": "#include <assert.h>\n#include <stddef.h>\n\nstruct test {\n  int a;\n  char b;\n  char padding_1, padding_2, padding_3;\n  int c;\n};\n\n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  /* Ensure c is the next byte after the last padding byte */\n  static_assert(offsetof(struct test, c) ==\n                offsetof(struct test, padding_3) + 1,\n                \"Structure contains intermediate padding\");\n  /* Ensure there is no trailing padding */\n  static_assert(sizeof(struct test) ==\n                offsetof(struct test, c) + sizeof(int),\n                \"Structure contains trailing padding\");\n  struct test arg = {.a = 1, .b = 2, .c = 3};\n  arg.padding_1 = 0;\n  arg.padding_2 = 0;\n  arg.padding_3 = 0;\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\n",
          "explanation_after": "The C Standard static_assert() macro accepts a constant expression and an error message . The expression is evaluated at compile time and, if false, the compilation is terminated and the error message is output. (See DCL03-C. Use a static assertion to test the value of a constant expression for more details.) The explicit insertion of the padding bytes into the struct should ensure that no additional padding bytes are added by the compiler and consequently both static assertions should be true. However, it is necessary to validate these assumptions to ensure that the solution is correct for a particular implementation."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( memset() )",
          "pre_code_commentary": "The padding bytes can be explicitly initialized by calling memset() :",
          "code": "#include <string.h>\n\nstruct test {\n  int a;\n  char b;\n  int c;\n};\n\n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  struct test arg;\n\n  /* Set all bytes (including padding bytes) to zero */\n  memset(&arg, 0, sizeof(arg));\n\n  arg.a = 1;\n  arg.b = 2;\n  arg.c = 3;\n\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\n",
          "explanation_after": "However, a conforming compiler is free to implement arg.b = 2 by setting the low-order bits of a register to 2, leaving the high-order bits unchanged and containing sensitive information. Then the platform copies all register bits into memory, leaving sensitive information in the padding bits. Consequently, this implementation could leak the high-order bits from the register to a user."
        },
        "compliant": {
          "heading": "Compliant Solution (Structure Packing—GCC)",
          "pre_code_commentary": "GCC allows specifying declaration attributes using the keyword __attribute__((__packed__)) . When this attribute is present, the compiler will not add padding bytes for memory alignment unless an explicit alignment specifier for a structure member requires the introduction of padding bytes.",
          "code": "#include <stddef.h>\n\nstruct test {\n  int a;\n  char b;\n  int c;\n} __attribute__((__packed__));\n\n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  struct test arg = {.a = 1, .b = 2, .c = 3};\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( memset() )",
          "pre_code_commentary": "The padding bytes can be explicitly initialized by calling memset() :",
          "code": "#include <string.h>\n\nstruct test {\n  int a;\n  char b;\n  int c;\n};\n\n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  struct test arg;\n\n  /* Set all bytes (including padding bytes) to zero */\n  memset(&arg, 0, sizeof(arg));\n\n  arg.a = 1;\n  arg.b = 2;\n  arg.c = 3;\n\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\n",
          "explanation_after": "However, a conforming compiler is free to implement arg.b = 2 by setting the low-order bits of a register to 2, leaving the high-order bits unchanged and containing sensitive information. Then the platform copies all register bits into memory, leaving sensitive information in the padding bits. Consequently, this implementation could leak the high-order bits from the register to a user."
        },
        "compliant": {
          "heading": "Compliant Solution (Structure Packing—Microsoft Visual Studio)",
          "pre_code_commentary": "Microsoft Visual Studio  supports #pragma pack() to suppress padding bytes [ MSDN ]. The compiler adds padding bytes for memory alignment, depending on the current packing mode, but still honors the alignment specified by __declspec(align()) . In this compliant solution, the packing mode is set to 1 in an attempt to ensure all fields are given adjacent offsets:",
          "code": "#include <stddef.h>\n\n#pragma pack(push, 1) /* 1 byte */\nstruct test {\n  int a;\n  char b;\n  int c;\n};\n#pragma pack(pop)\n \n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  struct test arg = {1, 2, 3};\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\n",
          "explanation_after": "The pack pragma takes effect at the first struct declaration after the pragma is seen."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example also runs in kernel space and copies data from struct test to user space. However, padding bits will be used within the structure due to the bit-field member lengths not adding up to the number of bits in an unsigned object. Further, there is an unnamed bit-field that causes no further bit-fields to be packed into the same storage unit. These padding bits may contain sensitive information, which may then be leaked when the data is copied to user space. For instance, the uninitialized bits may contain a sensitive kernel space pointer value that can be trivially reconstructed by an attacker in user space.",
          "code": "#include <stddef.h>\n\nstruct test {\n  unsigned a : 1;\n  unsigned : 0;\n  unsigned b : 4;\n};\n\n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  struct test arg = { .a = 1, .b = 10 };\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Padding bits can be explicitly declared, allowing the programmer to specify the value of those bits. When explicitly declaring all of the padding bits, any unnamed bit-fields of length 0 must be removed from the structure because the explicit padding bits ensure that no further bit-fields will be packed into the same storage unit.",
          "code": "#include <assert.h>\n#include <limits.h>\n#include <stddef.h>\n\nstruct test {\n  unsigned a : 1;\n  unsigned padding1 : sizeof(unsigned) * CHAR_BIT - 1;\n  unsigned b : 4;\n  unsigned padding2 : sizeof(unsigned) * CHAR_BIT - 4;\n};\n/* Ensure that we have added the correct number of padding bits. */\nstatic_assert(sizeof(struct test) == sizeof(unsigned) * 2,\n              \"Incorrect number of padding bits for type: unsigned\");\n\n/* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n\nvoid do_stuff(void *usr_buf) {\n  struct test arg = { .a = 1, .padding1 = 0, .b = 10, .padding2 = 0 };\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}",
          "explanation_after": "This solution is not portable, however, because it depends on the implementation and target memory architecture. The explicit insertion of padding bits into the struct should ensure that no additional padding bits are added by the compiler. However, it is still necessary to validate these assumptions to ensure that the solution is correct for a particular implementation. For instance, the DEC Alpha is an example of a 64-bit architecture with 32-bit integers that allocates 64 bits to a storage unit.\n\nIn addition, this solution assumes that there are no integer padding bits in an unsigned int .  The portable version of the width calculation from INT35-C. Use correct integer precisions cannot be used because the bit-field width must be an integer constant expression.\n\nFrom this situation, it can be seen that special care must be taken because no solution to the bit-field padding issue will be 100% portable.\n\nRisk Assessment\n\nPadding units might contain sensitive data because the C Standard allows any padding to take unspecified values . A pointer to such a structure could be passed to other functions, causing information leakage.\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nDCL39-C\n\nLow\n\nUnlikely\n\nNo\n\nYes\n\nP2\n\nL3\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\n7.2.0\n\nMISC.PADDING.POTB\n\nPadding Passed Across a Trust Boundary\n\npremium-cert-dcl39-c\n\n2025.2\n\nDF4941, DF4942, DF4943\n\n2024.2\n\nA pointer to a structure should not be passed to a function that can copy data to the user space\n\nPolyspace Bug Finder\n\nR2024b\n\n6.02\n\nNumerous vulnerabilities in the Linux Kernel have resulted from violations of this rule. CVE-2010-4083 describes a vulnerability in which the semctl() system call allows unprivileged users to read uninitialized kernel stack memory because various fields of a semid_ds struct declared on the stack are not altered or zeroed before being copied back to the user.\n\nCVE-2010-3881 describes a vulnerability in which structure padding and reserved fields in certain data structures in QEMU-KVM were not initialized properly before being copied to user space. A privileged host user with access to /dev/kvm could use this flaw to leak kernel stack memory to user space.\n\nCVE-2010-3477 describes a kernel information leak in act_police where incorrectly initialized structures in the traffic-control dump code may allow the disclosure of kernel memory to user space applications.\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL40-C",
    "title": "Do not create incompatible declarations of the same function or object",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL40-C.+Do+not+create+incompatible+declarations+of+the+same+function+or+object",
    "description": "Two or more incompatible declarations of the same function or object must not appear in the same program because they result in undefined behavior . The C Standard, 6.2.7, mentions that two types may be distinct yet compatible and addresses precisely when two distinct types are compatible.\n\nThe C Standard identifies four situations in which undefined behavior (UB) may arise as a result of incompatible declarations of the same function or object:\n\nUB Description Code 14 Two declarations of the same object or function specify types that are not compatible (6.2.7). All noncompliant code in this guideline 30 Two identifiers differ only in nonsignificant characters (6.4.2.1). Excessively Long Identifiers 36 An object has its stored value accessed other than by an lvalue of an allowable type (6.5). Incompatible Object Declarations Incompatible Array Declarations 37 A function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function (6.5.2.2). Incompatible Function Declarations Excessively Long Identifiers\n\nAlthough the effect of two incompatible declarations simply appearing in the same program may be benign on most implementations , the effects of invoking a function through an expression whose type is incompatible with the function definition are typically catastrophic. Similarly, the effects of accessing an object using an lvalue of a type that is incompatible with the object definition may range from unintended information exposure to memory overwrite to a hardware trap.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Incompatible Object Declarations)",
          "pre_code_commentary": "In this noncompliant code example, the variable i is declared to have type int in file a.c but defined to be of type short in file b.c . The declarations are incompatible, resulting in undefined behavior 14 . Furthermore, accessing the object using an lvalue of an incompatible type, as shown in function f() , is undefined behavior 36 with possible observable results ranging from unintended information exposure to memory overwrite to a hardware trap.",
          "code": "/* In a.c */\nextern int i;   /* UB 14 */\n\nint f(void) {\n  return ++i;   /* UB 36 */\n}\n\n/* In b.c */\nshort i;   /* UB 14 */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Incompatible Object Declarations)",
          "pre_code_commentary": "This compliant solution has compatible declarations of the variable i :",
          "code": "/* In a.c */\nextern int i;   \n\nint f(void) {\n  return ++i;   \n}\n\n/* In b.c */\nint i;   ",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Incompatible Array Declarations)",
          "pre_code_commentary": "In this noncompliant code example, the variable a is declared to have a pointer type in file a.c but defined to have an array type in file b.c . The two declarations are incompatible, resulting in undefined behavior 14 . As before, accessing the object in function f() is undefined behavior 36 with the typical effect of triggering a hardware trap.",
          "code": "/* In a.c */\nextern int *a;   /* UB 14 */\n\nint f(unsigned int i, int x) {\n  int tmp = a[i];   /* UB 36: read access */\n  a[i] = x;         /* UB 36: write access */\n  return tmp;\n}\n\n/* In b.c */\nint a[] = { 1, 2, 3, 4 };   /* UB 14 */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Incompatible Array Declarations)",
          "pre_code_commentary": "This compliant solution declares a as an array in a.c and b.c :",
          "code": "/* In a.c */\nextern int a[];   \n\nint f(unsigned int i, int x) {\n  int tmp = a[i];   \n  a[i] = x;         \n  return tmp;\n}\n\n/* In b.c */\nint a[] = { 1, 2, 3, 4 };  ",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Incompatible Function Declarations)",
          "pre_code_commentary": "In this noncompliant code example, the function f() is declared in file a.c with one prototype but defined in file b.c with another. The two prototypes are incompatible, resulting in undefined behavior 14 . Furthermore, invoking the function is undefined behavior 37 and typically has catastrophic consequences.",
          "code": "/* In a.c */\nextern int f(int a);   /* UB 14 */\n\nint g(int a) {\n  return f(a);   /* UB 37 */\n}\n\n/* In b.c */\nlong f(long a) {   /* UB 14 */\n  return a * 2;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Incompatible Function Declarations)",
          "pre_code_commentary": "This compliant solution has compatible prototypes for the function f() :",
          "code": "/* In a.c */\nextern int f(int a);   \n\nint g(int a) {\n  return f(a);   \n}\n\n/* In b.c */\nint f(int a) {   \n  return a * 2;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Incompatible Variadic Function Declarations)",
          "pre_code_commentary": "In this noncompliant code example, the function buginf() is defined to take a variable number of arguments and expects them all to be signed integers with a sentinel value of -1 :",
          "code": "/* In a.c */\nvoid buginf(const char *fmt, ...) {\n   /* ... */\n}\n \n/* In b.c */\nvoid buginf();",
          "explanation_after": "Although this code appears to be well defined because of the prototype-less declaration of buginf() , it exhibits undefined behavior 76 in accordance with the C Standard, 6.7.7.4, paragraph 14 [ ISO/IEC 9899:2024 ],\n\nFor two function types to be compatible, both shall specify compatible return types. Moreover, the parameter type lists shall agree in the number of parameters and in use of the final ellipsis; corresponding parameters shall have compatible types. In the determination of type compatibility and of a composite type, each parameter declared with function or array type is taken as having the adjusted type and each parameter declared with qualified type is taken as having the unqualified version of its declared type."
        },
        "compliant": {
          "heading": "Compliant Solution (Incompatible Variadic Function Declarations)",
          "pre_code_commentary": "In this compliant solution, the prototype for the function buginf() is included in the scope in the source file where it will be used:",
          "code": "/* In a.c */\nvoid buginf(const char *fmt, ...) {\n   /* ... */\n}\n\n/* In b.c */\nvoid buginf(const char *fmt, ...);",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Excessively Long Identifiers)",
          "pre_code_commentary": "In this noncompliant code example, the length of the identifier declaring the function pointer bash_groupname_completion_function() in the file bashline.h exceeds by 3 the minimum implementation limit of 31 significant initial characters in an external identifier. This introduces the possibility of colliding with the bash_groupname_completion_funct integer variable defined in file b.c , which is exactly 31 characters long. On an implementation that exactly meets this limit, this is undefined behavior 30 . It results in two incompatible declarations of the same function. (See undefined behavior 14 .) In addition, invoking the function leads to undefined behavior 37 with typically catastrophic effects.",
          "code": "/* In bashline.h */\n/* UB 14, UB 30 */\nextern char * bash_groupname_completion_function(const char *, int);\n\n/* In a.c */\n#include \"bashline.h\"\n\nvoid f(const char *s, int i) {\n  bash_groupname_completion_function(s, i);  /* UB 37 */\n}\n\n/* In b.c */\nint bash_groupname_completion_funct;  /* UB 14, UB 30 */\n",
          "explanation_after": "NOTE: The identifier bash_groupname_completion_function referenced here was taken from GNU Bash , version 3.2."
        },
        "compliant": {
          "heading": "Compliant Solution (Excessively Long Identifiers)",
          "pre_code_commentary": "In this compliant solution, the length of the identifier declaring the function pointer bash_groupname_completion() in bashline.h is less than 32 characters. Consequently, it cannot clash with bash_groupname_completion_funct on any compliant platform.",
          "code": "/* In bashline.h */\nextern char * bash_groupname_completion(const char *, int);   \n\n/* In a.c */\n#include \"bashline.h\"\n\nvoid f(const char *s, int i) {\n  bash_groupname_completion(s, i);  \n}\n\n/* In b.c */\nint bash_groupname_completion_funct; ",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL41-C",
    "title": "Do not declare variables inside a switch statement before the first case label",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/DCL41-C.+Do+not+declare+variables+inside+a+switch+statement+before+the+first+case+label",
    "description": "According to the C Standard, 6.8.5.3, paragraph 4 [ ISO/IEC 9899:2024 ],\n\nA switch statement causes control to jump to, into, or past the statement that is the switch body , depending on the value of a controlling expression, and on the presence of a default label and the values of any case labels on or in the switch body. A case or default label is accessible only within the closest enclosing switch statement.\n\nIf a programmer declares variables, initializes them before the first case statement, and then tries to use them inside any of the case statements, those variables will have scope inside the switch block but will not be initialized and will consequently contain indeterminate values.  Reading such values also violates EXP33-C. Do not read uninitialized memory .\n\nswitch",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example declares variables and contains executable statements before the first case label within the switch statement:",
          "code": "#include <stdio.h>\n \nextern void f(int i);\n \nvoid func(int expr) {\n  switch (expr) {\n    int i = 4;\n    f(i);\n  case 0:\n    i = 17;\n    /* Falls through into default code */\n  default:\n    printf(\"%d\\n\", i);\n  }\n}\n",
          "explanation_after": "When the preceding example is executed on GCC 4.8.1, the variable i is instantiated with automatic storage duration within the block, but it is not initialized. Consequently, if the controlling expression expr has a nonzero value, the call to printf() will access an indeterminate value of i . Similarly, the call to f() is not executed.\n\nValue of expr\n\nOutput\n\n0\n\n17\n\nNonzero\n\nIndeterminate"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the statements before the first case label occur before the switch statement:",
          "code": "#include <stdio.h>\n \nextern void f(int i);\n \nint func(int expr) {\n  /*\n   * Move the code outside the switch block; now the statements\n   * will get executed.\n   */\n  int i = 4;\n  f(i);\n\n  switch (expr) {\n    case 0:\n      i = 17;\n      /* Falls through into default code */\n    default:\n      printf(\"%d\\n\", i);\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using test conditions or initializing variables before the first case statement in a switch block can result in unexpected behavior and undefined behavior 20 .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ENV01-C",
    "title": "Do not make assumptions about the size of an environment variable",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ENV01-C.+Do+not+make+assumptions+about+the+size+of+an+environment+variable",
    "description": "Do not make any assumptions about the size of environment variables because an adversary might have full control over the environment. If the environment variable needs to be stored, the length of the associated string should be calculated and the storage dynamically allocated (see STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator ).",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example copies the string returned by getenv() into a fixed-size buffer:",
          "code": "void f() {\n  char path[PATH_MAX]; /* Requires PATH_MAX to be defined */\n  strcpy(path, getenv(\"PATH\"));\n  /* Use path */\n}\n",
          "explanation_after": "Even if your platform assumes that $PATH is defined, defines PATH_MAX , and enforces that paths not have more than PATH_MAX characters, the $PATH environment variable still is not required to have less than PATH_MAX chars. And if it has more than PATH_MAX chars, a buffer overflow will result. Also, if $PATH is not defined, then strcpy() will attempt to dereference a null pointer."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the strlen() function is used to calculate the size of the string, and the required space is dynamically allocated:",
          "code": "void f() {\n  char *path = NULL;\n  /* Avoid assuming $PATH is defined or has limited length */\n  const char *temp = getenv(\"PATH\");\n  if (temp != NULL) {\n    path = (char*) malloc(strlen(temp) + 1);\n    if (path == NULL) {\n      /* Handle error condition */\n    } else {\n      strcpy(path, temp);\n    }\n    /* Use path */\n    free(path);\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example copies the string returned by getenv() into a fixed-size buffer:",
          "code": "void f() {\n  char path[PATH_MAX]; /* Requires PATH_MAX to be defined */\n  strcpy(path, getenv(\"PATH\"));\n  /* Use path */\n}\n",
          "explanation_after": "Even if your platform assumes that $PATH is defined, defines PATH_MAX , and enforces that paths not have more than PATH_MAX characters, the $PATH environment variable still is not required to have less than PATH_MAX chars. And if it has more than PATH_MAX chars, a buffer overflow will result. Also, if $PATH is not defined, then strcpy() will attempt to dereference a null pointer."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX or C2x)",
          "pre_code_commentary": "In this compliant solution, the strdup() function is used to dynamically allocate a duplicate of the string:",
          "code": "void f() {\n  char *path = NULL;\n  /* Avoid assuming $PATH is defined or has limited length */\n  const char *temp = getenv(\"PATH\");\n  if (temp != NULL) {\n    path = strdup(temp);\n    if (path == NULL) {\n      /* Handle error condition */\n    }\n    /* Use path */\n    free(path);\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Making assumptions about the size of an environmental variable can result in a buffer overflow.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ENV02-C",
    "title": "Beware of multiple environment variables with the same effective name",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ENV02-C.+Beware+of+multiple+environment+variables+with+the+same+effective+name",
    "description": "The getenv() function searches an environment list for a string that matches a specified name and returns a pointer to a string associated with the matched list member.\n\ngetenv()\n\nSubclause 7.22.4.6 of the C Standard [ ISO/IEC 9899:2011 ] states:\n\nThe set of environment names and the method for altering the environment list are implementation-defined .\n\nDepending on the implementation , multiple environment variables with the same name may be allowed and can cause unexpected results if a program cannot consistently choose the same value. The GNU glibc library addresses this issue in getenv() and setenv() by always using the first variable it encounters and ignoring the rest. However, it is unwise to rely on this behavior.\n\ngetenv()\n\nsetenv()\n\nOne common difference between implementations is whether or not environment variables are case sensitive. Although UNIX-like implementations are generally case sensitive, environment variables are \"not case sensitive in Windows 98/Me and Windows NT/2000/XP\" [ MSDN ].",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example behaves differently when compiled and run on Linux and Microsoft Windows platforms:",
          "code": "if (putenv(\"TEST_ENV=foo\") != 0) {\n  /* Handle error */\n}\nif (putenv(\"Test_ENV=bar\") != 0) {\n  /* Handle error */\n}\n\nconst char *temp = getenv(\"TEST_ENV\");\n\nif (temp == NULL) {\n  /* Handle error */\n}\n\nprintf(\"%s\\n\", temp);\n",
          "explanation_after": "On an IA-32 Linux machine with GCC 3.4.4, this code prints\n\nwhereas, on an IA-32 Windows XP machine with Microsoft Visual C++ 2008 Express, it prints"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Portable code should use environment variables that differ by more than capitalization:",
          "code": "if (putenv(\"TEST_ENV=foo\") != 0) {\n  /* Handle error */\n}\nif (putenv(\"OTHER_ENV=bar\") != 0) {\n  /* Handle error */\n}\n\nconst char *temp = getenv(\"TEST_ENV\");\n\nif (temp == NULL) {\n  /* Handle error */\n}\n\nprintf(\"%s\\n\", temp);\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "An attacker can create multiple environment variables with the same name (for example, by using the POSIX execve() function). If the program checks one copy but uses another, security checks may be circumvented.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ENV03-C",
    "title": "Sanitize the environment when invoking external programs",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs",
    "description": "Many programs and libraries, including the shared library loader on both UNIX and Windows systems, depend on environment variable settings. Because environment variables are inherited from the parent process when a program is executed, an attacker can easily sabotage variables, causing a program to behave in an unexpected and insecure manner [ Viega 2003 ].\n\nAll programs, particularly those running with higher privileges than the caller (such as those with setuid/setgid flags), should treat their environment as untrusted user input. Because the environment is inherited by processes spawned by calls to the fork() , system() , or exec() functions, it is important to verify that the environment does not contain any values that can lead to unexpected behavior.\n\nsetuid/setgid\n\nfork()\n\nsystem()\n\nexec()\n\nThe best practice for such programs is to\n\nDrop privileges once they are no longer necessary. (See POS02-C. Follow the principle of least privilege .) Avoid calling system() . (See ENV33-C. Do not call system() .) Clear the environment and fill it with trusted or default values.\n\nsystem()\n\nThis recommendation is a more specific instance of STR02-C. Sanitize data passed to complex subsystems .\n\nSubclause 7.22.4.6 of the C Standard states that \"the set of environment names and the method for altering the environment list are implementation-defined .\" Consequently, it is important to understand which functions are available for clearing, modifying, and looking up default values for environment variables. Because some programs may behave in unexpected ways when certain environment variables are not set, it is important to understand which variables are necessary on your system and what are safe values for them.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX, ls )",
          "pre_code_commentary": "This noncompliant code example invokes the C system() function to execute the /bin/ls program. The system() function passes a string to the command processor in the host environment to be executed.",
          "code": "if (system(\"/bin/ls dir.`date +%Y%m%d`\") == -1) {\n  /* Handle error */\n}\n",
          "explanation_after": "Although IFS does not affect the command portion of this string, /bin/ls , it does determine how the argument is built after calling date . If the default shell does not ignore the incoming value of the IFS environment value, and an attacker sets IFS to \".\" , the intended directory will not be found."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX, ls )",
          "pre_code_commentary": "The nonstandard function clearenv() may be used to clear out the environment where available: otherwise, the environment can be cleared by obtaining the environment variable names from environ and removing each one using unsetenv() .\n\nIn this compliant solution, the environment is cleared by clearenv() , and then the PATH and IFS variables are set to safe values before system() is invoked. Sanitizing shell commands can be difficult, and doing so can adversely affect the power and flexibility associated with them.",
          "code": "char *pathbuf;\nsize_t n;\n\nif (clearenv() != 0) {\n  /* Handle error */\n}\n\nn = confstr(_CS_PATH, NULL, 0);\nif (n == 0) {\n  /* Handle error */\n}\n\nif ((pathbuf = malloc(n)) == NULL) {\n  /* Handle error */\n}\n\nif (confstr(_CS_PATH, pathbuf, n) == 0) {\n  /* Handle error */\n}\n\nif (setenv(\"PATH\", pathbuf, 1) == -1) {\n  /* Handle error */\n}\n\nif (setenv(\"IFS\", \" \\t\\n\", 1) == -1) {\n  /* Handle error */\n}\n\nif (system(\"ls dir.`date +%Y%m%d`\") == -1) {\n  /* Handle error */\n}\n",
          "explanation_after": "POSIX also specifies the confstr() function, which can be used to look up default values for environment variables [ IEEE Std 1003.1:2013 ]. The _CS_V7_ENV argument to confstr() retrieves a list of environment variable settings required for a default conforming environment [ IEEE Std 1003.1:2013 ]. A space-separated list of variable=value pairs is returned, with variable names guaranteed not to contain equal signs (=), and variable=value pairs guaranteed not to contain spaces. Used together with the _CS_PATH request, this completely describes the minimum environment variable settings required to obtain a clean, conforming environment. On systems conforming to the POSIX.1-2008 standard, this should be used to create a sanitized environment.\n\nOn systems that have no clearenv() function, the following implementation can be used:"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX, ls )",
          "pre_code_commentary": "This noncompliant code example invokes the C system() function to execute the /bin/ls program. The system() function passes a string to the command processor in the host environment to be executed.",
          "code": "if (system(\"/bin/ls dir.`date +%Y%m%d`\") == -1) {\n  /* Handle error */\n}\n",
          "explanation_after": "Although IFS does not affect the command portion of this string, /bin/ls , it does determine how the argument is built after calling date . If the default shell does not ignore the incoming value of the IFS environment value, and an attacker sets IFS to \".\" , the intended directory will not be found."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "There is no portable or guaranteed way to clear out the environment under Windows. Following ENV33-C. Do not call system() , care should be taken to use _execle() , _execlpe() , _execve() , or _execvpe() instead of system() , because they allow the environment to be explicitly specified.\n\nIf it is explicitly known which environment variables need to be kept, Secure Programming Cookbook for C and C++ [ Viega 2003 ] defines a function, spc_sanitize_environment() , that will remove everything else.",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Invoking an external program in an attacker-controlled environment is inherently dangerous.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ENV30-C",
    "title": "Do not modify the object referenced by the return value of certain functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ENV30-C.+Do+not+modify+the+object+referenced+by+the+return+value+of+certain+functions",
    "description": "Some functions return a pointer to an object that cannot be modified without causing undefined behavior . These functions include getenv() , setlocale() , localeconv() , asctime() , and strerror() . In such cases, the function call results must be treated as being const -qualified.\n\ngetenv()\n\nsetlocale()\n\nlocaleconv()\n\nasctime()\n\nstrerror()\n\nconst\n\nThe C Standard, 7.24.4.6, paragraph 4 [ ISO/IEC 9899:2024 ], defines getenv() as follows:\n\ngetenv()\n\nThe getenv function returns a pointer to a string associated with the matched list member. The string pointed to shall not be modified by the program, but may be overwritten by a subsequent call to the getenv function. If the specified name cannot be found, a null pointer is returned.\n\ngetenv\n\ngetenv\n\nIf the string returned by getenv() must be altered, a local copy should be created. Altering the string returned by getenv() is undefined behavior . (See undefined behavior 189 .)\n\ngetenv()\n\ngetenv()\n\nSimilarly, subclause 7.11.1.1, paragraph 8 [ ISO/IEC 9899:2024 ], defines setlocale() as follows:\n\nsetlocale()\n\nThe pointer to string returned by the setlocale function is such that a subsequent call with that string value and its associated category will restore that part of the program's locale. The string pointed to shall not be modified by the program, but may be overwritten by a subsequent call to the setlocale function.\n\nsetlocale\n\nsetlocale\n\nAnd subclause 7.11.2.1, paragraph 8 [ ISO/IEC 9899:2024 ], defines localeconv() as follows:\n\nlocaleconv()\n\nThe localeconv function returns a pointer to the filled-in object. The structure pointed to by the return value shall not be modified by the program, but may be overwritten by a subsequent call to the localeconv function. In addition, calls to the setlocale function with categories LC_ALL , LC_MONETARY , or LC_NUMERIC may overwrite the contents of the structure.\n\nlocaleconv\n\nlocaleconv\n\nsetlocale\n\nLC_ALL\n\nLC_MONETARY\n\nLC_NUMERIC\n\nAltering the string returned by setlocale() or the structure returned by localeconv() are undefined behaviors . (See undefined behaviors 119 and 121 .) Furthermore, the C Standard imposes no requirements on the contents of the string by setlocale() . Consequently, no assumptions can be made as to the string's internal contents or structure.\n\nsetlocale()\n\nlocaleconv()\n\nsetlocale()\n\nFinally, subclause 7.26.6.3, paragraph 4 [ ISO/IEC 9899:2024 ], states\n\nThe strerror function returns a pointer to the string, the contents of which are locale-specific. The array pointed to shall not be modified by the program. The behavior is undefined if the returned value is used after a subsequent call to the strerror function, or after the thread which called the function to obtain the returned value has exited.\n\nstrerror\n\nstrerror\n\nAltering the string returned by strerror() is undefined behavior . (See undefined behavior 189 .)\n\nstrerror()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( getenv() )",
          "pre_code_commentary": "This noncompliant code example modifies the string returned by getenv() by replacing all double quotation marks ( \" ) with underscores ( _ ):",
          "code": "#include <stdlib.h>\n \nvoid trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n\nvoid func(void) {\n  char *env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n  trstr(env,'\"', '_');\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( getenv() ) (Environment Not Modified)",
          "pre_code_commentary": "If the programmer does not intend to modify the environment, this compliant solution demonstrates how to modify a copy of the return value:",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nvoid trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n \nvoid func(void) {\n  const char *env;\n  char *copy_of_env;\n\n  env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n\n  copy_of_env = (char *)malloc(strlen(env) + 1);\n  if (copy_of_env == NULL) {\n    /* Handle error */\n  }\n\n  strcpy(copy_of_env, env);\n  trstr(copy_of_env,'\"', '_');\n  /* ... */\n  free(copy_of_env);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( getenv() )",
          "pre_code_commentary": "This noncompliant code example modifies the string returned by getenv() by replacing all double quotation marks ( \" ) with underscores ( _ ):",
          "code": "#include <stdlib.h>\n \nvoid trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n\nvoid func(void) {\n  char *env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n  trstr(env,'\"', '_');\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( getenv() ) (Modifying the Environment in POSIX)",
          "pre_code_commentary": "If the programmer's intent is to modify the environment, this compliant solution, which saves the altered string back into the environment by using the POSIX setenv() and strdup() functions, can be used:",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nvoid trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n \nvoid func(void) {\n  const char *env;\n  char *copy_of_env;\n\n  env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n\n  copy_of_env = strdup(env);\n  if (copy_of_env == NULL) {\n    /* Handle error */\n  }\n\n  trstr(copy_of_env,'\"', '_');\n\n  if (setenv(\"TEST_ENV\", copy_of_env, 1) != 0) {\n    /* Handle error */\n  }\n  /* ... */\n  free(copy_of_env);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( localeconv() )",
          "pre_code_commentary": "In this noncompliant example, the object returned by localeconv() is directly modified:",
          "code": "#include <locale.h>\n \nvoid f2(void) {\n  struct lconv *conv = localeconv();\n \n  if ('\\0' == conv->decimal_point[0]) {\n    conv->decimal_point = \".\";\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( localeconv() ) (Copy)",
          "pre_code_commentary": "This compliant solution modifies a copy of the object returned by localeconv() :",
          "code": "#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid f2(void) {\n  const struct lconv *conv = localeconv();\n  if (conv == NULL) {\n     /* Handle error */\n  }\n  \n  struct lconv *copy_of_conv = (struct lconv *)malloc(\n    sizeof(struct lconv));\n  if (copy_of_conv == NULL) {\n    /* Handle error */\n  }\n \n  memcpy(copy_of_conv, conv, sizeof(struct lconv));\n \n  if ('\\0' == copy_of_conv->decimal_point[0]) {\n    copy_of_conv->decimal_point = \".\";  \n  }\n  /* ... */\n  free(copy_of_conv);\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Modifying the object pointed to by the return value of getenv() , setlocale() , localeconv() , asctime() , or strerror() is undefined behavior . Even if the modification succeeds, the modified object can be overwritten by a subsequent call to the same function.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ENV31-C",
    "title": "Do not rely on an environment pointer following an operation that may invalidate it",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it",
    "description": "Some implementations provide a nonportable environment pointer that is valid when main() is called but may be invalidated by operations that modify the environment.\n\nmain()\n\nThe C Standard, J.5.2 [ ISO/IEC 9899:2024 ], states\n\nIn a hosted environment, the main function receives a third argument, char * envp [] , that points to a null-terminated array of pointers to char , each of which points to a string that provides information about the environment for this execution of the program (5.1.2.3.2).\n\nConsequently, under a hosted environment supporting this common extension, it is possible to access the environment through a modified form of main() :\n\nmain()\n\nmain(int argc, char *argv[], char *envp[]){ /* ... */ }\n\nmain(int argc, char *argv[], char *envp[]){ /* ... */ }\n\nHowever, modifying the environment by any means may cause the environment memory to be reallocated, with the result that envp now references an incorrect location. For example, when compiled with GCC 4.8.1 and run on a 32-bit Intel GNU/Linux machine, the following code,\n\nenvp\n\n#include <stdio.h>\n#include <stdlib.h>\n \nextern char **environ;\n\nint main(int argc, const char *argv[], const char *envp[]) {\n  printf(\"environ:  %p\\n\", environ);\n  printf(\"envp:     %p\\n\", envp);\n  setenv(\"MY_NEW_VAR\", \"new_value\", 1);\n  puts(\"--Added MY_NEW_VAR--\");\n  printf(\"environ:  %p\\n\", environ);\n  printf(\"envp:     %p\\n\", envp);\n  return 0;\n}\n\n#include <stdio.h>\n#include <stdlib.h>\n \nextern char **environ;\n\nint main(int argc, const char *argv[], const char *envp[]) {\n  printf(\"environ:  %p\\n\", environ);\n  printf(\"envp:     %p\\n\", envp);\n  setenv(\"MY_NEW_VAR\", \"new_value\", 1);\n  puts(\"--Added MY_NEW_VAR--\");\n  printf(\"environ:  %p\\n\", environ);\n  printf(\"envp:     %p\\n\", envp);\n  return 0;\n}\n\nyields\n\n% ./envp-environ\nenviron: 0xbf8656ec\nenvp:    0xbf8656ec\n--Added MY_NEW_VAR--\nenviron: 0x804a008\nenvp:    0xbf8656ec\n\n% ./envp-environ\nenviron: 0xbf8656ec\nenvp:    0xbf8656ec\n--Added MY_NEW_VAR--\nenviron: 0x804a008\nenvp:    0xbf8656ec\n\nIt is evident from these results that the environment has been relocated as a result of the call to setenv() . The external variable environ is updated to refer to the current environment; the envp parameter is not.\n\nsetenv()\n\nenviron\n\nenvp\n\nAn environment pointer may also become invalidated by subsequent calls to getenv(). (See ENV34-C. Do not store pointers returned by certain functions for more information.)\n\ngetenv().",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "After a call to the POSIX setenv() function or to another function that modifies the environment, the envp pointer may no longer reference the current environment. The Portable Operating System Interface (POSIX ® ), Base Specifications, Issue 7 [ IEEE Std 1003.1:2013 ], states\n\nUnanticipated results may occur if setenv() changes the external variable environ . In particular, if the optional envp argument to main() is present, it is not changed, and thus may point to an obsolete copy of the environment (as may any other copy of environ ).\n\nThis noncompliant code example accesses the envp pointer after calling setenv() :",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint main(int argc, const char *argv[], const char *envp[]) {\n  if (setenv(\"MY_NEW_VAR\", \"new_value\", 1) != 0) {\n    /* Handle error */\n  }\n  if (envp != NULL) {\n    for (size_t i = 0; envp[i] != NULL; ++i) {\n      puts(envp[i]);\n    }\n  }\n  return 0;\n}\n",
          "explanation_after": "Because envp may no longer point to the current environment, this program has unanticipated behavior."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "Use environ in place of envp when defined:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nextern char **environ;\n\nint main(void) {\n  if (setenv(\"MY_NEW_VAR\", \"new_value\", 1) != 0) {\n    /* Handle error */\n  }\n  if (environ != NULL) {\n    for (size_t i = 0; environ[i] != NULL; ++i) {\n      puts(environ[i]);\n    }\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "After a call to the Windows _putenv_s() function or to another function that modifies the environment, the envp pointer may no longer reference the environment.\n\nAccording to the Visual C++ reference [ MSDN ]\n\nThe environment block passed to main and wmain is a \"frozen\" copy of the current environment. If you subsequently change the environment via a call to _putenv or _wputenv , the current environment (as returned by getenv / _wgetenv and the _environ / _wenviron variable) will change, but the block pointed to by envp will not change.\n\nThis noncompliant code example accesses the envp pointer after calling _putenv_s() :",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint main(int argc, const char *argv[], const char *envp[]) {\n  if (_putenv_s(\"MY_NEW_VAR\", \"new_value\") != 0) {\n    /* Handle error */\n  }\n  if (envp != NULL) {\n    for (size_t i = 0; envp[i] != NULL; ++i) {\n      puts(envp[i]);\n    }\n  }\n  return 0;\n}\n",
          "explanation_after": "Because envp no longer points to the current environment, this program has unanticipated behavior."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "This compliant solution uses the _environ variable in place of envp :",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \n_CRTIMP extern char **_environ;\n\nint main(int argc, const char *argv[]) {\n  if (_putenv_s(\"MY_NEW_VAR\", \"new_value\") != 0) {\n    /* Handle error */\n  }\n  if (_environ != NULL) {\n    for (size_t i = 0; _environ[i] != NULL; ++i) {\n      puts(_environ[i]);\n    }\n  }\nreturn 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "After a call to the Windows _putenv_s() function or to another function that modifies the environment, the envp pointer may no longer reference the environment.\n\nAccording to the Visual C++ reference [ MSDN ]\n\nThe environment block passed to main and wmain is a \"frozen\" copy of the current environment. If you subsequently change the environment via a call to _putenv or _wputenv , the current environment (as returned by getenv / _wgetenv and the _environ / _wenviron variable) will change, but the block pointed to by envp will not change.\n\nThis noncompliant code example accesses the envp pointer after calling _putenv_s() :",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint main(int argc, const char *argv[], const char *envp[]) {\n  if (_putenv_s(\"MY_NEW_VAR\", \"new_value\") != 0) {\n    /* Handle error */\n  }\n  if (envp != NULL) {\n    for (size_t i = 0; envp[i] != NULL; ++i) {\n      puts(envp[i]);\n    }\n  }\n  return 0;\n}\n",
          "explanation_after": "Because envp no longer points to the current environment, this program has unanticipated behavior."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution can reduce remediation time when a large amount of noncompliant envp code exists. It replaces",
          "code": "int main(int argc, char *argv[], char *envp[]) {\n  /* ... */\n}\n",
          "explanation_after": "with\n\nThis compliant solution may need to be extended to support other implementations that support forms of the external variable environ ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using the envp environment pointer after the environment has been modified can result in undefined behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ENV32-C",
    "title": "All exit handlers must return normally",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ENV32-C.+All+exit+handlers+must+return+normally",
    "description": "The C Standard provides three functions that cause an application to terminate normally: _Exit() , exit() , and quick_exit() . These are collectively called exit functions . When the exit() function is called, or control transfers out of the main() entry point function, functions registered with atexit() are called (but not at_quick_exit() ). When the quick_exit() function is called, functions registered with at_quick_exit() (but not atexit() ) are called. These functions are collectively called exit handlers .  When the _Exit() function is called, no exit handlers or signal handlers are called.\n\n_Exit()\n\nexit()\n\nquick_exit()\n\nexit()\n\nmain()\n\natexit()\n\nat_quick_exit()\n\nquick_exit()\n\nat_quick_exit()\n\natexit()\n\n_Exit()\n\nExit handlers must terminate by returning. It is important and potentially safety-critical for all exit handlers to be allowed to perform their cleanup actions. This is particularly true because the application programmer does not always know about handlers that may have been installed by support libraries. Two specific issues include nested calls to an exit function and terminating a call to an exit handler by invoking longjmp .\n\nlongjmp\n\nA nested call to an exit function is undefined behavior . (See undefined behavior 187 .) This behavior can occur only when an exit function is invoked from an exit handler or when an exit function is called from within a signal handler. (See SIG30-C. Call only asynchronous-safe functions within signal handlers .)\n\nIf a call to the longjmp() function is made that would terminate the call to a function registered with atexit() , the behavior is undefined behavior 187 .\n\nlongjmp()\n\natexit()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the exit1() and exit2() functions are registered by atexit() to perform required cleanup upon program termination. However, if some_condition evaluates to true, exit() is called a second time, resulting in undefined behavior 187 .",
          "code": "#include <stdlib.h>\n\nvoid exit1(void) {\n  /* ... Cleanup code ... */\n  return;\n}\n \nvoid exit2(void) {\n  extern int some_condition;\n  if (some_condition) {\n    /* ... More cleanup code ... */\n    exit(0);\n  }\n  return;\n}\n\nint main(void) {\n  if (atexit(exit1) != 0) {\n    /* Handle error */\n  }\n  if (atexit(exit2) != 0) {\n    /* Handle error */\n  }\n  /* ... Program code ... */\n  return 0;\n}\n",
          "explanation_after": "Functions registered by the atexit() function are called in the reverse order from which they were registered. Consequently, if exit2() exits in any way other than by returning, exit1() will not be executed. The same may also be true for atexit() handlers installed by support libraries."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "A function that is registered as an exit handler by atexit() must exit by returning, as in this compliant solution:",
          "code": "#include <stdlib.h>\n\nvoid exit1(void) {\n  /* ... Cleanup code ... */\n  return;\n}\n \nvoid exit2(void) {\n  extern int some_condition;\n  if (some_condition) {\n    /* ... More cleanup code ... */\n  }\n  return;\n}\n\nint main(void) {\n  if (atexit(exit1) != 0) {\n    /* Handle error */\n  }\n  if (atexit(exit2) != 0) {\n    /* Handle error */\n  }\n  /* ... Program code ... */\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, exit1() is registered by atexit() so that upon program termination, exit1() is called. The exit1() function jumps back to main() to return, with undefined results.",
          "code": "#include <stdlib.h>\n#include <setjmp.h>\n\njmp_buf env;\nint val;\n\nvoid exit1(void) {\n  longjmp(env, 1);\n}\n\nint main(void) {\n  if (atexit(exit1) != 0) {\n    /* Handle error */\n  }\n  if (setjmp(env) == 0) {\n    exit(0);\n  } else {\n    return 0;\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not call longjmp() but instead returns from the exit handler normally:",
          "code": "#include <stdlib.h>\n\nvoid exit1(void) {\n  return;\n}\n\nint main(void) {\n  if (atexit(exit1) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Terminating a call to an exit handler in any way other than by returning is undefined behavior and may result in abnormal program termination or other unpredictable behavior. It may also prevent other registered handlers from being invoked.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "ENV34-C",
    "title": "Do not store pointers returned by certain functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions",
    "description": "The C Standard, 7.24.4.6, paragraph 4 [ ISO/IEC 9899:2024 ], states\n\nThe getenv function returns a pointer to a string associated with the matched list member. The string pointed to shall not be modified by the program but may be overwritten by a subsequent call to the getenv function. If the specified name cannot be found, a null pointer is returned.\n\ngetenv\n\ngetenv\n\nname\n\nThis paragraph gives an implementation the latitude, for example, to return a pointer to a statically allocated buffer. Consequently, do not store this pointer because the string data it points to may be overwritten by a subsequent call to the getenv() function or invalidated by modifications to the environment. This string should be referenced immediately and discarded. If later use is anticipated, the string should be copied so the copy can be safely referenced as needed.\n\ngetenv()\n\nThe getenv() function is not thread-safe. Make sure to address any possible race conditions resulting from the use of this function.\n\ngetenv()\n\nThe asctime() , localeconv() , setlocale() , and strerror() functions have similar restrictions. Do not access the objects returned by any of these functions after a subsequent call.\n\nasctime()\n\nlocaleconv()\n\nsetlocale()\n\nstrerror()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to compare the value of the TMP and TEMP environment variables to determine if they are the same:",
          "code": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n \nvoid func(void) {\n  char *tmpvar;\n  char *tempvar;\n\n  tmpvar = getenv(\"TMP\");\n  if (!tmpvar) {\n    /* Handle error */\n  }\n  tempvar = getenv(\"TEMP\");\n  if (!tempvar) {\n    /* Handle error */\n  }\n  if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n}\n",
          "explanation_after": "This code example is noncompliant because the string referenced by tmpvar may be overwritten as a result of the second call to the getenv() function. As a result, it is possible that both tmpvar and tempvar will compare equal even if the two environment variables have different values."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses the malloc() and strcpy() functions to copy the string returned by getenv() into a dynamically allocated buffer:",
          "code": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n \nvoid func(void) {\n  char *tmpvar;\n  char *tempvar;\n\n  const char *temp = getenv(\"TMP\");\n  if (temp != NULL) {\n    tmpvar = (char *)malloc(strlen(temp)+1);\n    if (tmpvar != NULL) {\n      strcpy(tmpvar, temp);\n    } else {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n\n  temp = getenv(\"TEMP\");\n  if (temp != NULL) {\n    tempvar = (char *)malloc(strlen(temp)+1);\n    if (tempvar != NULL) {\n      strcpy(tempvar, temp);\n    } else {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n\n  if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n  free(tmpvar);\n  free(tempvar);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to compare the value of the TMP and TEMP environment variables to determine if they are the same:",
          "code": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n \nvoid func(void) {\n  char *tmpvar;\n  char *tempvar;\n\n  tmpvar = getenv(\"TMP\");\n  if (!tmpvar) {\n    /* Handle error */\n  }\n  tempvar = getenv(\"TEMP\");\n  if (!tempvar) {\n    /* Handle error */\n  }\n  if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n}\n",
          "explanation_after": "This code example is noncompliant because the string referenced by tmpvar may be overwritten as a result of the second call to the getenv() function. As a result, it is possible that both tmpvar and tempvar will compare equal even if the two environment variables have different values."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "Microsoft Windows provides the _dupenv_s() and wdupenv_s() functions for getting a value from the current environment [ MSDN ]. The _dupenv_s() function searches the list of environment variables for a specified name. If the name is found, a buffer is allocated; the variable's value is copied into the buffer, and the buffer's address and number of elements are returned. The _dupenv_s() and _wdupenv_s() functions provide more convenient alternatives to getenv_s() and _wgetenv_s() because each function handles buffer allocation directly.\n\nThe caller is responsible for freeing any allocated buffers returned by these functions by calling free() .",
          "code": "#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n \nvoid func(void) {\n  char *tmpvar;\n  char *tempvar;\n  size_t len;\n\n  errno_t err = _dupenv_s(&tmpvar, &len, \"TMP\");\n  if (err) {\n    /* Handle error */\n  }\n  err = _dupenv_s(&tempvar, &len, \"TEMP\");\n  if (err) {\n    /* Handle error */\n  }\n\n  if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n  free(tmpvar);\n  tmpvar = NULL;\n  free(tempvar);\n  tempvar = NULL;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to compare the value of the TMP and TEMP environment variables to determine if they are the same:",
          "code": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n \nvoid func(void) {\n  char *tmpvar;\n  char *tempvar;\n\n  tmpvar = getenv(\"TMP\");\n  if (!tmpvar) {\n    /* Handle error */\n  }\n  tempvar = getenv(\"TEMP\");\n  if (!tempvar) {\n    /* Handle error */\n  }\n  if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n}\n",
          "explanation_after": "This code example is noncompliant because the string referenced by tmpvar may be overwritten as a result of the second call to the getenv() function. As a result, it is possible that both tmpvar and tempvar will compare equal even if the two environment variables have different values."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX or C2x)",
          "pre_code_commentary": "POSIX provides the strdup() function, which can make a copy of the environment variable string [ IEEE Std 1003.1:2013 ]. The strdup() function is also included in Extensions to the C Library—Part II [ ISO/IEC TR 24731-2:2010 ]. Further, it is expected to be present in the C2x standard.",
          "code": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n \nvoid func(void) {\n  char *tmpvar;\n  char *tempvar;\n\n  const char *temp = getenv(\"TMP\");\n  if (temp != NULL) {\n    tmpvar = strdup(temp);\n    if (tmpvar == NULL) {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n\n  temp = getenv(\"TEMP\");\n  if (temp != NULL) {\n    tempvar = strdup(temp);\n    if (tempvar == NULL) {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n\n  if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n  free(tmpvar);\n  tmpvar = NULL;\n  free(tempvar);\n  tempvar = NULL;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Storing the pointer to the string returned by getenv() , localeconv() , setlocale() , or strerror() can result in overwritten data.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ERR00-C",
    "title": "Adopt and implement a consistent and comprehensive error-handling policy",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR00-C.+Adopt+and+implement+a+consistent+and+comprehensive+error-handling+policy",
    "description": "A secure system is invariably subject to stresses, such as those caused by attack, erroneous or malicious inputs, hardware or software faults, unanticipated user behavior, and unexpected environmental changes that are outside the bounds of \"normal operation.\" Yet the system must continue to deliver essential services in a timely manner, safely and securely. To accomplish this, the system must exhibit qualities such as robustness , reliability , error tolerance , fault tolerance , performance, and security. All of these system-quality attributes depend on consistent and comprehensive error handling that supports the goals of the overall system.\n\nISO/IEC TR 24772, section 6.39.1 [ ISO/IEC TR 24772 ], says:\n\nExpectations that a system will be dependable are based on the confidence that the system will operate as expected and not fail in normal use. The dependability of a system and its fault tolerance can be measured through the component part's reliability, availability, safety and security. Reliability is the ability of a system or component to perform its required functions under stated conditions for a specified period of time [ IEEE 1990 glossary ]. Availability is how timely and reliable the system is to its intended users. Both of these factors matter highly in systems used for safety and security. In spite of the best intentions, systems may encounter a failure, either from internally poorly written software or external forces such as power outages/variations, floods, or other natural disasters. The reaction to a fault can affect the performance of a system and in particular, the safety and security of the system and its users.\n\nEffective error handling (which includes error reporting, report aggregation, analysis, response, and recovery) is a central aspect of the design, implementation, maintenance, and operation of systems that exhibit survivability under stress. Survivability is the capability of a system to fulfill its mission, in a timely manner, despite an attack, accident, or other stress that is outside the bounds of normal operation [ Lipson 2000 ]. If full services cannot be maintained under a given stress, survivable systems degrade gracefully, continue to deliver essential services, and recover full services as conditions permit.\n\nError reporting and error handling play a central role in the engineering and operation of survivable systems. Survivability is an emergent property of a system as a whole [ Fisher 1999 ] and depends on the behavior of all of the system's components and the interactions among them. From the viewpoint of error handling, every system component, down to the smallest routine, can be considered to be a sensor capable of reporting on some aspect of the health of the system. Any error or anomaly, ignored or improperly handled, can threaten delivery of essential system services and, as a result, put at risk the organizational or business mission that the system supports.\n\nThe key characteristics of survivability include the 3 Rs: resistance, recognition, and recovery. Resistance refers to measures that harden a system against particular stresses, recognition refers to situational awareness with respect to instances of stress and their impact on the system, and recovery is the ability of a system to restore services after (and possibly during) an attack, accident, or other event that has disrupted those services.\n\nRecognition of the full nature of adverse events and the determination of appropriate measures for recovery and response are often not possible in the context of the component or routine in which a related error first manifests. Aggregation of multiple error reports and the interpretation of those reports in a higher context may be required both to understand what is happening and to decide on the appropriate action to take. Of course, the domain-specific context in which the system operates plays a huge role in determining proper recovery strategies and tactics. For safety-critical systems, simply halting the system (or even just terminating an offending process) in response to an error is rarely the best course of action and may lead to disaster. From a system perspective, error-handling strategies should map directly into survivability strategies, which may include recovery by activating fully redundant backup services or by providing alternative sets of roughly equivalent services that fulfill the mission with sufficient diversity to greatly improve the odds of survival against common mode failures.\n\nAn error-handling policy must specify a comprehensive approach to error reporting and response. Components and routines should always generate status indicators, and all called routines should have their error returns checked. All input should be checked for compliance with the formal requirements for such input rather than be blindly trusted. Moreover, never assume, on the basis of specific knowledge about the system or its domain, that the success of a called routine is guaranteed. The failure to report or properly respond to errors or other anomalies from a system perspective can threaten the survivability of the system as a whole.\n\nISO/IEC TR 24772:2013, section 6.39.5 [ ISO/IEC TR 24772:2013 ], describes the following mitigation strategies:\n\nSoftware developers can avoid the vulnerability or mitigate its ill effects in the following ways: A strategy for fault handling should be decided. Consistency in fault handling should be the same with respect to critically similar parts. A multi-tiered approach of fault prevention, fault detection, and fault reaction should be used. System-defined components that assist in uniformity of fault handling should be used when available. For one example, designing a \"runtime constraint handler\" permits the application to intercept various erroneous situations and perform one consistent response, such as flushing a previous transaction and restarting at the next one. When there are multiple tasks, a fault-handling policy should be specified whereby a task may halt, and keep its resources available for other tasks (perhaps permitting restarting of the faulting task) halt, and remove its resources (perhaps to allow other tasks to use the resources so freed, or to allow a recreation of the task) halt, and signal the rest of the program to likewise halt",
    "examples": null,
    "risk_assessment": {
      "explanation": "Failure to adopt and implement a consistent and comprehensive error-handling policy is detrimental to system survivability and can result in a broad range of vulnerabilities depending on the operational characteristics of the system.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ERR01-C",
    "title": "Use ferror() rather than errno to check for FILE stream errors",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR01-C.+Use+ferror%28%29+rather+than+errno+to+check+for+FILE+stream+errors",
    "description": "Use ferror() rather than errno to check whether an error has occurred on a file stream (for example, after a long chain of stdio calls). The ferror() function tests the error indicator for a specified stream and returns nonzero if and only if the error indicator is set for the stream.\n\nferror()\n\nerrno\n\nstdio\n\nferror()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Many implementations of the stdio package adjust their behavior slightly if stdout is a terminal. To make the determination, these implementations perform some operation that fails (with ENOTTY ) if stdout is not a terminal. Although the output operation goes on to complete successfully, errno still contains ENOTTY . This behavior can be mildly confusing, but it is not strictly incorrect because it is meaningful for a program to inspect the contents of errno only after an error has been reported. More precisely, errno is meaningful only after a library function that sets errno on error has returned an error code.",
          "code": "errno = 0;\nprintf(\"This\\n\");\nprintf(\"is\\n\");\nprintf(\"a\\n\");\nprintf(\"test.\\n\");\nif (errno != 0) {\n  fprintf(stderr, \"printf failed: %s\\n\", strerror(errno));\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses ferror() to detect an error. In addition, if an early call to printf() fails, later calls may modify errno , whether they fail or not, so the program cannot rely on being able to detect the root cause of the original failure if it waits until after a sequence of library calls to check.",
          "code": "printf(\"This\\n\");\nprintf(\"is\\n\");\nprintf(\"a\\n\");\nprintf(\"test.\\n\");\nif (ferror(stdout)) {\n  fprintf(stderr, \"printf failed\\n\");\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Checking errno after multiple calls to library functions can lead to spurious error reporting, possibly resulting in incorrect program operation.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ERR02-C",
    "title": "Avoid in-band error indicators",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR02-C.+Avoid+in-band+error+indicators",
    "description": "Avoid in-band error indicators while designing interfaces. This practice is commonly used by C library functions but is not recommended. One example from the C Standard of a troublesome in-band error indicator is EOF (see FIO34-C. Distinguish between characters read from a file and EOF or WEOF ). Another problematic use of in-band error indicators from the C Standard involving the size_t and time_t types is described by\n\nEOF\n\nsize_t\n\ntime_t\n\nINT31-C. Ensure that integer conversions do not result in lost or misinterpreted data FLP07-C. Cast the return value of a function that returns a floating-point type INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( sprintf() )",
          "pre_code_commentary": "This noncompliant code example is from the Linux Kernel Mailing List archive site, although similar examples are common:",
          "code": "int i;\nssize_t count = 0;\n\nfor (i = 0; i < 9; ++i) {\n  count += sprintf(\n    buf + count, \"%02x \", ((u8 *)&slreg_num)[i]\n  );\n}\ncount += sprintf(buf + count, \"\\n\");\n",
          "explanation_after": "The sprintf() function returns the number of characters written in the array, not counting the terminating null character. This number is frequently added to an existing counter to keep track of the location of the index into the array. However, the call to sprintf() can (and will) return −1 on error conditions, such as an encoding error. If this error happens on the first call (which is likely), the count variable, already at 0, is decremented. If this index is subsequently used, it will result in an out-of-bounds read or write."
        },
        "compliant": {
          "heading": "Compliant Solution ( sprintf_m() )",
          "pre_code_commentary": "This compliant solution shows the redesigned API for sprintf() from the CERT managed string library [ Burch 2006 ]:",
          "code": "errno_t sprintf_m(\n  string_m buf, \n  const string_m fmt, \n  int *count, \n  ...\n);\n",
          "explanation_after": "The sprintf_m() API separates the return status of the function from information about the number of characters written. In this case, *count is set to the number of characters written in buf , and the return value indicates the return status. Returning the status as the return value of the function increases the likelihood that a programmer will check the return status of the function.\n\nThe preceding code example can be amended as follows:"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX ssize_t )",
          "pre_code_commentary": "The ssize_t data type is designed as a \"signed representation of size_t .\" Consequently, it is often used as a return type for functions that can return an unsigned value upon success and a negative value upon error. For instance, the POSIX read() function has the following signature:",
          "code": "ssize_t read(int fildes, void *buf, size_t nbyte);\n",
          "explanation_after": "read() returns −1 if an error occurs; if no errors occur, it returns the number of bytes actually read.\n\nAs with all in-band error indicators, this type is not recommended because developers are tempted to ignore the possibility that a ssize_t value is negative."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX size_t )",
          "pre_code_commentary": "An alternative hypothetical signature for the read() function is",
          "code": "errno_t read(int fildes, void *buf, size_t nbyte, size_t* rbytes);\n",
          "explanation_after": "where rbytes is a pointer to a size_t . If no error occurs, and rbytes is not NULL , its value is set to the total number of bytes read, and read() returns 0. If an error occurs, read() returns a nonzero value indicating the error.\n\nERR02-EX1: Null pointers are another example of an in-band error indicator. Use of null pointers is allowed because it is supported by the language. According to the C Standard, subclause 6.3.2.3 [ ISO/IEC 9899:2011 ]:\n\nIf a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.\n\nERR02-EX2: You may design a function that returns in-band error indicators if it is possible to securely guarantee that the program will not try to continue processing should an error occur in the function. For example, after calling the glibc function feenableexcept (FE_OVERFLOW) , you can call the exp function without needing to check for overflow on the result yourself, because if it occurs, then a SIGFPE will cause the program to terminate in a similar manner as abort() ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The risk in using in-band error indicators is difficult to quantify and is consequently given as low. However, if the use of in-band error indicators results in programmers' failing to check status codes or incorrectly checking them, the consequences can be more severe.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ERR04-C",
    "title": "Choose an appropriate termination strategy",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR04-C.+Choose+an+appropriate+termination+strategy",
    "description": "Some errors, such as out-of-range values, might be the result of erroneous user input. Interactive programs typically handle such errors by rejecting the input and prompting the user for an acceptable value. Servers reject invalid user input by indicating an error to the client while at the same time continuing to service other clients' valid requests. All robust programs must be prepared to gracefully handle resource exhaustion, such as low memory or disk space conditions, at a minimum by preventing the loss of user data kept in volatile storage. Interactive programs may give the user the option to save data on an alternative medium, whereas network servers may respond by reducing throughput or otherwise degrading the quality of service. However, when certain kinds of errors are detected, such as irrecoverable logic errors, rather than risk data corruption by continuing to execute in an indeterminate state, the appropriate strategy may be for the system to quickly shut down, allowing the operator to start it afresh in a determinate state.\n\nISO/IEC TR 24772:2013, Section 6.39, \"Termination Strategy [REU],\" [ ISO/IEC TR 24772:2013 ], says:\n\nWhen a fault is detected, there are many ways in which a system can react. The quickest and most noticeable way is to fail hard, also known as fail fast or fail stop. The reaction to a detected fault is to immediately halt the system. Alternatively, the reaction to a detected fault could be to fail soft. The system would keep working with the faults present, but the performance of the system would be degraded. Systems used in a high availability environment such as telephone switching centers, e-commerce, or other \"always available\" applications would likely use a fail soft approach. What is actually done in a fail soft approach can vary depending on whether the system is used for safety-critical or security critical purposes. For fail-safe systems, such as flight controllers, traffic signals, or medical monitoring systems, there would be no effort to meet normal operational requirements, but rather to limit the damage or danger caused by the fault. A system that fails securely, such as cryptologic systems, would maintain maximum security when a fault is detected, possibly through a denial of service.\n\nAnd\n\nThe reaction to a fault in a system can depend on the criticality of the part in which the fault originates. When a program consists of several tasks, each task may be critical, or not. If a task is critical, it may or may not be restartable by the rest of the program. Ideally, a task that detects a fault within itself should be able to halt leaving its resources available for use by the rest of the program, halt clearing away its resources, or halt the entire program. The latency of task termination and whether tasks can ignore termination signals should be clearly specified. Having inconsistent reactions to a fault can potentially be a vulnerability.\n\nC provides several options for program termination, including exit() , returning from main() , _Exit() , and abort() .\n\nexit()\n\nmain()\n\n_Exit()\n\nabort()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The abort() function should not be called if it is important to perform application-specific cleanup before exiting. In this noncompliant code example, abort() is called after data is sent to an open file descriptor. The data may or may not be written to the file.",
          "code": "#include <stdlib.h>\n#include <stdio.h>\n\nint write_data(void) {\n  const char *filename = \"hello.txt\";\n  FILE *f = fopen(filename, \"w\");\n  if (f == NULL) {\n    /* Handle error */\n  }\n  fprintf(f, \"Hello, World\\n\");\n  /* ... */\n  abort(); /* Oops! Data might not be written! */\n  /* ... */\n  return 0;\n}\n\nint main(void) {\n  write_data();\n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the call to abort() is replaced with exit() , which guarantees that buffered I/O data is flushed to the file descriptor and the file descriptor is properly closed:",
          "code": "#include <stdlib.h>\n#include <stdio.h>\n\nint write_data(void) {\n  const char *filename = \"hello.txt\";\n  FILE *f = fopen(filename, \"w\");\n  if (f == NULL) {\n    /* Handle error */\n  }\n  fprintf(f, \"Hello, World\\n\");\n  /* ... */\n  exit(EXIT_FAILURE); /* Writes data and closes f */\n  /* ... */\n  return 0;\n}\n\nint main(void) {\n  write_data();\n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": "Although this particular example benefits from calling exit() over abort() , in some situations, abort() is the better choice. Usually, abort() is preferable when a programmer does not need to close any file descriptors or call any handlers registered with atexit() , for instance, if the speed of terminating the program is critical.\n\nFor more details on proper usage of abort() , see ERR06-C. Understand the termination behavior of assert() and abort() ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "As an example, using abort() or _Exit() in place of exit() may leave written files in an inconsistent state and may also leave sensitive temporary files on the file system.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ERR05-C",
    "title": "Application-independent code should provide error detection without dictating error handling",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR05-C.+Application-independent+code+should+provide+error+detection+without+dictating+error+handling",
    "description": "Application-independent code includes code that is\n\nShipped with the compiler or operating system From a third-party library Developed in-house\n\nWhen application-specific code detects an error, it can immediately respond with a specific action, as in\n\nif (something_really_bad_happens) {\n  take_me_some_place_safe();\n}\n\nif (something_really_bad_happens) {\n  take_me_some_place_safe();\n}\n\nThis response occurs because the application must both detect errors and provide a mechanism for handling errors. Application-independent code, by contrast, is not associated with any application, so it cannot handle errors. However, it must still detect errors and report them to an application so that the application may handle them.\n\nError detection and reporting can take several forms:\n\nA return value (especially of type errno_t ) An argument passed by address A global object (such as errno ) longjmp() Some combination of the above\n\nerrno_t\n\nerrno\n\nlongjmp()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example consists of two application-independent functions, f() and g() . The f() function is part of the external API for the module; the g() function is an internal function.",
          "code": "void g(void) {\n  /* ... */\n  if (something_really_bad_happens) {\n    fprintf(stderr, \"Something really bad happened!\\n\");\n    abort();\n  }\n  /* ... */\n}\n\nvoid f(void) {\n  g();\n  /* ... Do the rest of f ... */\n}\n",
          "explanation_after": "If something_really_bad_happens in g() , the function prints an error message to stderr and then calls abort() . The problem is that this application-independent code does not know the context in which it is being called, so it is erroneous to handle the error.\n\n“ Smart Libraries, ” Practice 23 [ Miller 2004 ], says:\n\nWhen a library aborts due to some kind of anomaly, it is saying there is no hope for execution to proceed normally beyond the point where the anomaly is detected. Nonetheless, it is dictatorially making this decision on behalf of the client. Even if the anomaly turns out to be some kind of internal bug in the library, which obviously cannot be resolved in the current execution, aborting is a bad thing to do. The fact is, a library developer cannot possibly know the fault-tolerant context in which his/her library is being used. The client may indeed be able to recover from the situation even if the library cannot.\n\nIt is equally bad to eliminate the call to abort() from g() . In this case, the calling function has no indication that an error has occurred."
        },
        "compliant": {
          "heading": "Compliant Solution (Return Value)",
          "pre_code_commentary": "One way to inform the calling function of errors is to return a value indicating success or failure. This compliant solution ensures each function returns a value of type errno_t , where 0 indicates that no error has occurred:",
          "code": "const errno_t ESOMETHINGREALLYBAD = 1;\n\nerrno_t g(void) {\n  /* ... */\n  if (something_really_bad_happens) {\n    return ESOMETHINGREALLYBAD;\n  }\n  /* ... */\n  return 0;\n}\n\nerrno_t f(void) {\n  errno_t status = g();\n  if (status != 0) {\n    return status;\n  }\n\n  /* ... Do the rest of f ... */\n\n  return 0;\n}\n",
          "explanation_after": "A call to f() returns a status indicator, which is 0 upon success and a nonzero value upon failure indicating what went wrong.\n\nA return type of errno_t indicates that the function returns a status indicator (see DCL09-C. Declare functions that return errno with a return type of errno_t ).\n\nThis error-handling approach is secure, but it has the following drawbacks:\n\nSource and object code can significantly increase in size, some sources suggest by as much as 30 to 40 percent [ Saks 2007b ]. All function return values must be checked (see ERR33-C. Detect and handle standard library errors ). Functions should not return other values if they return error indicators (see ERR02-C. Avoid in-band error indicators ). Any function that allocates resources must ensure they are freed in cases where errors occur."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example consists of two application-independent functions, f() and g() . The f() function is part of the external API for the module; the g() function is an internal function.",
          "code": "void g(void) {\n  /* ... */\n  if (something_really_bad_happens) {\n    fprintf(stderr, \"Something really bad happened!\\n\");\n    abort();\n  }\n  /* ... */\n}\n\nvoid f(void) {\n  g();\n  /* ... Do the rest of f ... */\n}\n",
          "explanation_after": "If something_really_bad_happens in g() , the function prints an error message to stderr and then calls abort() . The problem is that this application-independent code does not know the context in which it is being called, so it is erroneous to handle the error.\n\n“ Smart Libraries, ” Practice 23 [ Miller 2004 ], says:\n\nWhen a library aborts due to some kind of anomaly, it is saying there is no hope for execution to proceed normally beyond the point where the anomaly is detected. Nonetheless, it is dictatorially making this decision on behalf of the client. Even if the anomaly turns out to be some kind of internal bug in the library, which obviously cannot be resolved in the current execution, aborting is a bad thing to do. The fact is, a library developer cannot possibly know the fault-tolerant context in which his/her library is being used. The client may indeed be able to recover from the situation even if the library cannot.\n\nIt is equally bad to eliminate the call to abort() from g() . In this case, the calling function has no indication that an error has occurred."
        },
        "compliant": {
          "heading": "Compliant Solution (Address Argument)",
          "pre_code_commentary": "Instead of encoding status indicators in the return value, each function can take a pointer as an argument, which is used to indicate errors. In the following example, each function uses an errno_t\\ * argument to report errors:",
          "code": "const errno_t ESOMETHINGREALLYBAD = 1;\n\nvoid g(errno_t * err) {\n  if (err == NULL) {\n    /* Handle null pointer */\n  }\n  /* ... */\n  if (something_really_bad_happens) {\n    *err = ESOMETHINGREALLYBAD;\n  } else {\n    /* ... */\n    *err = 0;\n  }\n}\n\nvoid f(errno_t * err) {\n  if (err == NULL) {\n    /* Handle null pointer */\n  }\n  g(err);\n  if (*err == 0) {\n    /* ... Do the rest of f ... */\n  }\n  return 0;\n}\n",
          "explanation_after": "A call to f() provides a status indicator that is 0 upon success and a nonzero value upon failure, assuming the user provided a valid pointer to an object of type errno_t .\n\nThis solution is secure, but it has the following drawbacks:\n\nA return status can be returned only if the caller provides a valid pointer to an object of type errno_t . If this argument is NULL , there is no way to indicate this error. Source code becomes even larger because of the possibilities of receiving a null pointer. All error indicators must be checked after calling functions. Any function that allocates resources must ensure they are freed in cases where errors occur. Unlike return values, static analysis tools generally do not diagnose a failure to check error indicators passed as argument pointers."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example consists of two application-independent functions, f() and g() . The f() function is part of the external API for the module; the g() function is an internal function.",
          "code": "void g(void) {\n  /* ... */\n  if (something_really_bad_happens) {\n    fprintf(stderr, \"Something really bad happened!\\n\");\n    abort();\n  }\n  /* ... */\n}\n\nvoid f(void) {\n  g();\n  /* ... Do the rest of f ... */\n}\n",
          "explanation_after": "If something_really_bad_happens in g() , the function prints an error message to stderr and then calls abort() . The problem is that this application-independent code does not know the context in which it is being called, so it is erroneous to handle the error.\n\n“ Smart Libraries, ” Practice 23 [ Miller 2004 ], says:\n\nWhen a library aborts due to some kind of anomaly, it is saying there is no hope for execution to proceed normally beyond the point where the anomaly is detected. Nonetheless, it is dictatorially making this decision on behalf of the client. Even if the anomaly turns out to be some kind of internal bug in the library, which obviously cannot be resolved in the current execution, aborting is a bad thing to do. The fact is, a library developer cannot possibly know the fault-tolerant context in which his/her library is being used. The client may indeed be able to recover from the situation even if the library cannot.\n\nIt is equally bad to eliminate the call to abort() from g() . In this case, the calling function has no indication that an error has occurred."
        },
        "compliant": {
          "heading": "Compliant Solution (Global Error Indicator)",
          "pre_code_commentary": "Instead of encoding error indicators in the return value or arguments, a function can indicate its status by assigning a value to a global variable. In the following example, each function uses a static indicator called my_errno .\n\nThe original errno variable was the standard C library's implementation of error handling using this approach.",
          "code": "errno_t my_errno; /* Also declared in a .h file */\nconst errno_t ESOMETHINGREALLYBAD = 1;\n\nvoid g(void) {\n  /* ... */\n  if (something_really_bad_happens) {\n    my_errno = ESOMETHINGREALLYBAD;\n    return;\n  }\n  /* ... */\n}\n\nvoid f(void) {\n  my_errno = 0;\n  g();\n  if (my_errno != 0) {\n    return;\n  }\n  /* ... Do the rest of f ... */\n}\n",
          "explanation_after": "The call to f() provides a status indicator that is 0 upon success and a nonzero value upon failure.\n\nThis solution has many of the same properties as those observed with errno , including advantages and drawbacks.\n\nSource code size is inflated, though not by as much as in other approaches. All error indicators must be checked after calling functions. Nesting of function calls that all use this mechanism is problematic. Any function that allocates resources must ensure they are freed in cases where errors occur. In general, combining registries of different sets of errors is difficult. For example, changing this compliant solution code to use errno is difficult and bug-prone because the programmer must be precisely aware of when C library functions set and clear errno and also must be aware of all valid errno values before adding new ones. Calling f() from other application-independent code has major limitations. Because f() sets my_errno to 0, it may be overwriting a nonzero error value set by another application-independent calling function.\n\nFor these reasons, among others, this approach is generally discouraged."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example consists of two application-independent functions, f() and g() . The f() function is part of the external API for the module; the g() function is an internal function.",
          "code": "void g(void) {\n  /* ... */\n  if (something_really_bad_happens) {\n    fprintf(stderr, \"Something really bad happened!\\n\");\n    abort();\n  }\n  /* ... */\n}\n\nvoid f(void) {\n  g();\n  /* ... Do the rest of f ... */\n}\n",
          "explanation_after": "If something_really_bad_happens in g() , the function prints an error message to stderr and then calls abort() . The problem is that this application-independent code does not know the context in which it is being called, so it is erroneous to handle the error.\n\n“ Smart Libraries, ” Practice 23 [ Miller 2004 ], says:\n\nWhen a library aborts due to some kind of anomaly, it is saying there is no hope for execution to proceed normally beyond the point where the anomaly is detected. Nonetheless, it is dictatorially making this decision on behalf of the client. Even if the anomaly turns out to be some kind of internal bug in the library, which obviously cannot be resolved in the current execution, aborting is a bad thing to do. The fact is, a library developer cannot possibly know the fault-tolerant context in which his/her library is being used. The client may indeed be able to recover from the situation even if the library cannot.\n\nIt is equally bad to eliminate the call to abort() from g() . In this case, the calling function has no indication that an error has occurred."
        },
        "compliant": {
          "heading": "Compliant Solution ( setjmp() and longjmp() )",
          "pre_code_commentary": "C provides two functions, setjmp() and longjmp() , that can be used to alter control flow. Using these functions, a user can ignore error values and trust that control flow will be correctly diverted in the event of error.\n\nThe following example uses setjmp() and longjmp() to ensure that control flow is disrupted in the event of error; it also uses the my_errno indicator from the previous example. See MSC22-C. Use the setjmp(), longjmp() facility securely for more information on setjmp() and longjmp() .",
          "code": "#include <setjmp.h>\n\nconst errno_t ESOMETHINGREALLYBAD = 1;\n\njmp_buf exception_env;\n\nvoid g(void) {\n  /* ... */\n  if (something_really_bad_happens) {\n    longjmp(exception_env, ESOMETHINGREALLYBAD);\n  }\n  /* ... */\n}\n\nvoid f(void) {\n  g();\n  /* ... Do the rest of f ... */\n}\n\n/* ... */\nif (setjmp(exception_env) != 0) {\n  /*\n   * If we get here, an error occurred; \n   * do not continue processing.\n   */\n}\n/* ... */\nf();\n/* If we get here, no errors occurred */\n/* ... */\n",
          "explanation_after": "Calls to f() will either succeed or divert control to an if clause designed to catch the error.\n\nThe source code is not significantly larger because the function signatures do not change, and neither do functions that neither detect nor handle the error. Allocated resources must still be freed despite the error. The application must call setjmp() before invoking application-independent code. Signals are not necessarily preserved through longjmp() calls. The use of setjmp() / longjmp() bypasses the normal function call and return discipline. Any function that allocates resources must ensure they are freed in cases where errors occur."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Lack of an error-detection mechanism prevents applications from knowing when an error has disrupted normal program behavior.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ERR07-C",
    "title": "Prefer functions that support error checking over equivalent functions that don't",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR07-C.+Prefer+functions+that+support+error+checking+over+equivalent+functions+that+don%27t",
    "description": "When you have a choice of two functions to accomplish the same task, prefer the one with better error checking and reporting.\n\nThe following table shows a list of C standard library functions that provide limited or no error checking and reporting along with preferable alternatives:\n\nFunction Preferable Alternative Comments atof strtod No error indication, undefined behavior on error atoi strtol No error indication, undefined behavior on error atol strtol No error indication, undefined behavior on error atoll strtoll No error indication, undefined behavior on error rewind fseek No error indication, silent failure on error setbuf setvbuf No error indication, silent failure on error ctime asctime / localtime Undefined behavior if localtime fails\n\natof\n\nstrtod\n\natoi\n\nstrtol\n\natol\n\nstrtol\n\natoll\n\nstrtoll\n\nrewind\n\nfseek\n\nsetbuf\n\nsetvbuf\n\nctime\n\nasctime\n\nlocaltime\n\nlocaltime",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( atoi() )",
          "pre_code_commentary": "This noncompliant code example converts the string token stored in the static array buff to a signed integer value using the atoi() function:",
          "code": "int si;\n\nif (argc > 1) {\n  si = atoi(argv[1]);\n}\n",
          "explanation_after": "The atoi() , atol() , and atoll() functions convert the initial portion of a string token to int , long int , and long long int representation respectively. Except for the behavior on error, they are equivalent as follows:\n\nCall\n\nEquivalent on Success\n\natoi(nptr)\n\n(int)strtol(nptr, (char **)NULL, 10)\n\natol(nptr)\n\nstrtol(nptr, (char **)NULL, 10)\n\natoll(nptr)\n\nstrtoll(nptr, (char **)NULL, 10)\n\nUnfortunately, atoi() and related functions lack a mechanism for reporting errors for invalid values. Specifically, the atoi() , atol() , and atoll() functions\n\nDo not need to set errno on an error. Have undefined behavior if the value of the result cannot be represented. (See undefined behavior 118 of Annex J of the C Standard.) Return 0 if the string does not represent an integer (which is indistinguishable from a correctly formatted, zero-denoting input string), but the C Standard only specifies the behavior of these functions on success.\n\nSee also MSC24-C. Do not use deprecated or obsolescent functions ."
        },
        "compliant": {
          "heading": "Compliant Solution ( strtol() )",
          "pre_code_commentary": "The strtol() , strtoll() , strtoul() , and strtoull() functions convert a null-terminated byte string to long int , long long int , unsigned long int , and unsigned long long int representation respectively.\n\nThis compliant solution uses strtol() to convert a string token to an integer and ensures that the value is in the range of int :",
          "code": "long sl;\nint si;\nchar *end_ptr;\n\nif (argc > 1) {\n  errno = 0;\n\n  sl = strtol(argv[1], &end_ptr, 10);\n\n  if ((sl == LONG_MIN || sl == LONG_MAX)\n   && errno != 0)\n  {\n    perror(\"strtol error\");\n  }\n  else if (end_ptr == argv[1]) {\n    if (puts(\"error encountered during conversion\") == EOF) {\n      /* Handle error */\n    }\n  }\n  else if (sl > INT_MAX) {\n    printf(\"%ld too large!\\n\", sl);\n  }\n  else if (sl < INT_MIN) {\n    printf(\"%ld too small!\\n\", sl);\n  }\n  else if ('\\0' != *end_ptr) {\n    if (puts(\"extra characters on input line\\n\") == EOF) {\n      /* Handle error */\n    }\n  }\n  else {\n    si = (int)sl;\n  }\n}\n",
          "explanation_after": "Both the noncompliant code example and the compliant solution are taken from ERR34-C. Detect errors when converting a string to a number ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( rewind() )",
          "pre_code_commentary": "This noncompliant code example sets the file position indicator of an input stream back to the beginning using rewind() :",
          "code": "char *file_name;\nFILE *fp;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"r\");\nif (fp == NULL) {\n  /* Handle open error */\n}\n\n/* Read data */\n\nrewind(fp);\n\n/* Continue */\n",
          "explanation_after": "It is impossible to determine if rewind() succeeded."
        },
        "compliant": {
          "heading": "Compliant Solution ( fseek() )",
          "pre_code_commentary": "This compliant solution uses fseek() instead of rewind() and checks to see if the operation succeeded:",
          "code": "char *file_name;\nFILE *fp;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"r\");\nif (fp == NULL) {\n  /* Handle open error */\n}\n\n/* Read data */\n\nif (fseek(fp, 0L, SEEK_SET) != 0) {\n  /* Handle repositioning error */\n}\n\n/* Continue */\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( setbuf() )",
          "pre_code_commentary": "This noncompliant code example calls setbuf() with a buf argument of NULL :",
          "code": "FILE *file;\n/* Setup file */\nsetbuf(file, NULL);\n/* ... */\n",
          "explanation_after": "It is not possible to determine if the call to setbuf() succeeded.\n\nOn 4.2BSD and 4.3BSD systems, setbuf() always uses a suboptimal buffer size and should be avoided."
        },
        "compliant": {
          "heading": "Compliant Solution ( setvbuf() )",
          "pre_code_commentary": "This compliant solution calls setvbuf() , which returns nonzero if the operation failed:",
          "code": "FILE *file;\nchar *buf = NULL;\n/* Setup file */\nif (setvbuf(file, buf, buf ? _IOFBF : _IONBF, BUFSIZ) != 0) {\n  /* Handle error */\n}\n/* ... */\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Although it is rare for a violation of this rule to result in a security vulnerability , it can easily result in lost or misinterpreted data.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "ERR30-C",
    "title": "Take care when reading errno",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR30-C.+Take+care+when+reading+errno",
    "description": "The value of errno is initialized to zero at program startup, but it is never subsequently set to zero by any C standard library function. The value of errno may be set to nonzero by a C standard library function call whether or not there is an error, provided the use of errno is not documented in the description of the function. It is meaningful for a program to inspect the contents of errno only after an error might have occurred. More precisely, errno is meaningful only after a library function that sets errno on error has returned an error code.\n\nerrno\n\nerrno\n\nerrno\n\nerrno\n\nerrno\n\nerrno\n\nAccording to Question 20.4 of C-FAQ [ Summit 2005 ],\n\nIn general, you should detect errors by checking return values, and use errno only to distinguish among the various causes of an error, such as \"File not found\" or \"Permission denied.\" (Typically, you use perror or strerror to print these discriminating error messages.) It's only necessary to detect errors with errno when a function does not have a unique, unambiguous, out-of-band error return (that is, because all of its possible return values are valid; one example is atoi [ sic ] ). In these cases (and in these cases only; check the documentation to be sure whether a function allows this), you can detect errors by setting errno to 0, calling the function, and then testing errno . (Setting errno to 0 first is important, as no library function ever does that for you.)\n\nerrno\n\nperror\n\nstrerror\n\nerrno\n\natoi [\nsic\n]\n\nerrno\n\nerrno\n\nerrno\n\nNote that atoi() is not required to set the value of errno .\n\natoi()\n\nerrno\n\nLibrary functions fall into the following categories:\n\nThose that set errno and return an out-of-band error indicator Those that set errno and return an in-band error indicator Those that do not promise to set errno Those with differing standards documentation\n\nerrno\n\nerrno\n\nerrno",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( strtoul() )",
          "pre_code_commentary": "This noncompliant code example fails to set errno to 0 before invoking strtoul() . If an error occurs, strtoul() returns a valid value ( ULONG_MAX ), so errno is the only means of determining if strtoul() ran successfully.",
          "code": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n \nvoid func(const char *c_str) {\n  unsigned long number;\n  char *endptr;\n  \n  number = strtoul(c_str, &endptr, 0);\n  if (endptr == c_str || (number == ULONG_MAX \n                         && errno == ERANGE)) {\n    /* Handle error */\n  } else {\n    /* Computation succeeded */\n  }\n}",
          "explanation_after": "Any error detected in this manner may have occurred earlier in the program or may not represent an actual error."
        },
        "compliant": {
          "heading": "Compliant Solution ( strtoul() )",
          "pre_code_commentary": "This compliant solution sets errno to 0 before the call to strtoul() and inspects errno after the call:",
          "code": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n \nvoid func(const char *c_str) {\n  unsigned long number;\n  char *endptr;\n \n  errno = 0;\n  number = strtoul(c_str, &endptr, 0);\n  if (endptr == c_str || (number == ULONG_MAX \n                         && errno == ERANGE)) {\n    /* Handle error */\n  } else {\n    /* Computation succeeded */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( ftell() )",
          "pre_code_commentary": "This noncompliant code example, after calling ftell() , examines errno without first checking whether the out-of-band indicator returned by ftell() indicates an error.",
          "code": "#include <errno.h>\n#include <stdio.h>\n\nvoid func(FILE* fp) { \n  errno=0;\n  ftell(fp);\n  if (errno) {\n    perror(\"ftell\");\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( ftell() )",
          "pre_code_commentary": "This compliant solution first detects that ftell() failed using its out-of-band error indicator. Once an error has been confirmed, reading errno (implicitly by using the perror() function) is permitted.",
          "code": "#include <errno.h>\n#include <stdio.h>\n\nvoid func(FILE* fp) { \n  if (ftell(fp) == -1) {\n    perror(\"ftell\");\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "This noncompliant code example may fail to diagnose errors because fopen() might not set errno even if an error occurs:",
          "code": "#include <errno.h>\n#include <stdio.h>\n \nvoid func(const char *filename) {\n  FILE *fileptr;\n\n  errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (errno != 0) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( fopen() , C)",
          "pre_code_commentary": "The C Standard makes no mention of errno when describing fopen() . In this compliant solution, the results of the call to fopen() are used to determine failure and errno is not checked:",
          "code": "#include <stdio.h>\n \nvoid func(const char *filename) {\n  FILE *fileptr = fopen(filename, \"rb\");\n  if (fileptr == NULL)  {\n    /* An error occurred in fopen() */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "This noncompliant code example may fail to diagnose errors because fopen() might not set errno even if an error occurs:",
          "code": "#include <errno.h>\n#include <stdio.h>\n \nvoid func(const char *filename) {\n  FILE *fileptr;\n\n  errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (errno != 0) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( fopen() , POSIX)",
          "pre_code_commentary": "In this compliant solution, errno is checked only after an error has already been detected by another means:",
          "code": "#include <errno.h>\n#include <stdio.h>\n \nvoid func(const char *filename) {\n  FILE *fileptr;\n\n  errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (fileptr == NULL)  {\n    /*\n     * An error occurred in fopen(); now it's valid \n     * to examine errno.\n     */\n    perror(filename);\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The improper use of errno may result in failing to detect an error condition or in incorrectly identifying an error condition when none exists.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "ERR32-C",
    "title": "Do not rely on indeterminate values of errno",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR32-C.+Do+not+rely+on+indeterminate+values+of+errno",
    "description": "According to the C Standard Annex J.2 (133) [ ISO/IEC 9899:2024 ], the behavior of a program is undefined when\n\nthe value of errno is referred to after a signal occurred other than as the result of calling the abort or raise function and the corresponding signal handler obtained a SIG_ERR return from a call to the signal function.\n\nerrno\n\nabort\n\nraise\n\nSIG_ERR\n\nsignal\n\nSee undefined behavior 133 .\n\nA signal handler is allowed to call signal(); if that fails, signal() returns SIG_ERR and sets errno to a positive value. However, if the event that caused a signal was external (not the result of the program calling abort() or raise() ), the only functions the signal handler may call are _Exit() or abort() , or it may call signal() on the signal currently being handled; if signal() fails, the value of errno is indeterminate .\n\nsignal();\n\nsignal()\n\nSIG_ERR\n\nerrno\n\nabort()\n\nraise()\n\n_Exit()\n\nabort()\n\nsignal()\n\nsignal()\n\nerrno\n\nThis rule is also a special case of SIG31-C. Do not access shared objects in signal handlers . The object designated by errno is of static storage duration and is not a volatile sig_atomic_t . As a result, performing any action that would require errno to be set would normally cause undefined behavior 132 . The C Standard, 7.14.1.1, paragraph 5, makes a special exception for errno in this case, allowing errno to take on an indeterminate value but specifying that there is no other undefined behavior . This special exception makes it possible to call signal() from within a signal handler without risking undefined behavior , but the handler, and any code executed after the handler returns, must not depend on the value of errno being meaningful.\n\nerrno\n\nvolatile sig_atomic_t\n\nerrno\n\nerrno\n\nerrno\n\nsignal()\n\nerrno",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The handler() function in this noncompliant code example attempts to restore default handling for the signal indicated by signum . If the request to set the signal to default can be honored, the signal() function returns the value of the signal handler for the most recent successful call to the signal() function for the specified signal. Otherwise, a value of SIG_ERR is returned and a positive value is stored in errno . Unfortunately, the value of errno is indeterminate because the handler() function is called when an external signal is raised, so any attempt to read errno (for example, by the perror() function) is undefined behavior :",
          "code": "#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ntypedef void (*pfv)(int);\n\nvoid handler(int signum) {\n  pfv old_handler = signal(signum, SIG_DFL);\n  if (old_handler == SIG_ERR) {\n    perror(\"SIGINT handler\"); /* Undefined behavior */\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  pfv old_handler = signal(SIGINT, handler);\n  if (old_handler == SIG_ERR) {\n    perror(\"SIGINT handler\");\n    /* Handle error */\n  }\n\n  /* Main code loop */\n\n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": "The call to perror() from handler() also violates SIG30-C. Call only asynchronous-safe functions within signal handlers ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not reference errno and does not return from the signal handler if the signal() call fails:",
          "code": "#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ntypedef void (*pfv)(int);\n\nvoid handler(int signum) {\n  pfv old_handler = signal(signum, SIG_DFL);\n  if (old_handler == SIG_ERR) {\n    abort();\n  }\n}\n\nint main(void) {\n  pfv old_handler = signal(SIGINT, handler);\n  if (old_handler == SIG_ERR) {\n    perror(\"SIGINT handler\");\n    /* Handle error */\n  }\n\n  /* Main code loop */\n\n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "POSIX is less restrictive than C about what applications can do in signal handlers. It has a long list of asynchronous-safe functions that can be called. (See SIG30-C. Call only asynchronous-safe functions within signal handlers .) Many of these functions set errno on error, which can lead to a signal handler being executed between a call to a failed function and the subsequent inspection of errno . Consequently, the value inspected is not the one set by that function but the one set by a function call in the signal handler. POSIX applications can avoid this problem by ensuring that signal handlers containing code that might alter errno ; always save the value of errno on entry and restore it before returning.\n\nThe signal handler in this noncompliant code example alters the value of errno . As a result, it can cause incorrect error handling if executed between a failed function call and the subsequent inspection of errno :",
          "code": "#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/wait.h>\n\nvoid reaper(int signum) {\n  errno = 0;\n  for (;;) {\n    int rc = waitpid(-1, NULL, WNOHANG);\n    if ((0 == rc) || (-1 == rc && EINTR != errno)) {\n      break;\n    }\n  }\n  if (ECHILD != errno) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  struct sigaction act;\n  act.sa_handler = reaper;\n  act.sa_flags = 0;\n  if (sigemptyset(&act.sa_mask) != 0) {\n    /* Handle error */\n  }\n  if (sigaction(SIGCHLD, &act, NULL) != 0) {\n    /* Handle error */\n  }\n\n  /* ... */\n\n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution saves and restores the value of errno in the signal handler:",
          "code": "#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/wait.h>\n\nvoid reaper(int signum) {\n  errno_t save_errno = errno;\n  errno = 0;\n  for (;;) {\n    int rc = waitpid(-1, NULL, WNOHANG);\n    if ((0 == rc) || (-1 == rc && EINTR != errno)) {\n      break;\n    }\n  }\n  if (ECHILD != errno) {\n    /* Handle error */\n  }\n  errno = save_errno;\n}\n\nint main(void) {\n  struct sigaction act;\n  act.sa_handler = reaper;\n  act.sa_flags = 0;\n  if (sigemptyset(&act.sa_mask) != 0) {\n    /* Handle error */\n  }\n  if (sigaction(SIGCHLD, &act, NULL) != 0) {\n    /* Handle error */\n  }\n\n  /* ... */\n\n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Referencing indeterminate values of errno is undefined behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ERR33-C",
    "title": "Detect and handle standard library errors",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors",
    "description": "The majority of the standard library functions, including I/O functions and memory allocation functions, return either a valid value or a value of the correct return type that indicates an error (for example, −1 or a null pointer). Assuming that all calls to such functions will succeed and failing to check the return value for an indication of an error is a dangerous practice that may lead to unexpected or undefined behavior when an error occurs. It is essential that programs detect and appropriately handle all errors in accordance with an error-handling policy.\n\nThe successful completion or failure of each of the standard library functions listed in the following table shall be determined either by comparing the function’s return value with the value listed in the column labeled “Error Return” or by calling one of the library functions mentioned in the footnotes.\n\nStandard Library Functions\n\nFunction Successful Return Error Return aligned_alloc () Pointer to space NULL asctime_s () 0 Nonzero at_quick_exit () 0 Nonzero atexit () 0 Nonzero bsearch () Pointer to matching element NULL bsearch_s () Pointer to matching element NULL btowc () Converted wide character WEOF c16rtomb () Number of bytes (size_t)(-1) c32rtomb () Number of bytes (size_t)(-1) calloc () Pointer to space NULL clock () Processor time (clock_t)(-1) cnd_broadcast () thrd_success thrd_error cnd_init () thrd_success thrd_nomem or thrd_error cnd_signal () thrd_success thrd_error cnd_timedwait () thrd_success thrd_timedout or thrd_error cnd_wait () thrd_success thrd_error ctime_s () 0 Nonzero fclose () 0 EOF (negative) fflush () 0 EOF (negative) fgetc () Character read EOF 1 fgetpos () 0 Nonzero, errno > 0 fgets () Pointer to string NULL fgetwc () Wide character read WEOF 1 fopen () Pointer to stream NULL fopen_s () 0 Nonzero fprintf () Number of characters (nonnegative) Negative fprintf_s () Number of characters (nonnegative) Negative fputc () Character written EOF 2 fputs () Nonnegative EOF (negative) fputwc() Wide character written WEOF fputws () Nonnegative EOF (negative) fread () Elements read Elements read freopen () Pointer to stream NULL freopen_s () 0 Nonzero fscanf () Number of conversions (nonnegative) EOF (negative) fscanf_s () Number of conversions (nonnegative) EOF (negative) fseek () 0 Nonzero fsetpos () 0 Nonzero, errno > 0 ftell () File position −1L , errno > 0 fwprintf () Number of wide characters (nonnegative) Negative fwprintf_s () Number of wide characters (nonnegative) Negative fwrite () Elements written Elements written fwscanf () Number of conversions (nonnegative) EOF (negative) fwscanf_s () Number of conversions (nonnegative) EOF (negative) getc () Character read EOF 1 getchar () Character read EOF 1 getenv () Pointer to string NULL getenv_s () Pointer to string NULL gets_s () Pointer to string NULL getwc () Wide character read WEOF getwchar () Wide character read WEOF gmtime () Pointer to broken-down time NULL gmtime_s () Pointer to broken-down time NULL localtime () Pointer to broken-down time NULL localtime_s () Pointer to broken-down time NULL malloc () Pointer to space NULL mblen () , s != NULL Number of bytes −1 mbrlen () , s != NULL Number of bytes or status (size_t)(-1) mbrtoc16 () Number of bytes or status (size_t)(-1) , errno == EILSEQ mbrtoc32 () Number of bytes or status (size_t)(-1) , errno == EILSEQ mbrtowc () , s != NULL Number of bytes or status (size_t)(-1) , errno == EILSEQ mbsrtowcs () Number of non-null elements (size_t)(-1) , errno == EILSEQ mbsrtowcs_s () 0 Nonzero mbstowcs () Number of non-null elements (size_t)(-1) mbstowcs_s () 0 Nonzero mbtowc () , s != NULL Number of bytes −1 memchr () Pointer to located character NULL mktime () Calendar time (time_t)(-1) mtx_init () thrd_success thrd_error mtx_lock () thrd_success thrd_error mtx_timedlock () thrd_success thrd_timedout or thrd_error mtx_trylock () thrd_success thrd_busy or thrd_error mtx_unlock () thrd_success thrd_error printf_s () Number of characters (nonnegative) Negative putc () Character written EOF 2 putwc () Wide character written WEOF raise () 0 Nonzero realloc () Pointer to space NULL remove () 0 Nonzero rename () 0 Nonzero setlocale () Pointer to string NULL setvbuf () 0 Nonzero scanf () Number of conversions (nonnegative) EOF (negative) scanf_s () Number of conversions (nonnegative) EOF (negative) signal () Pointer to previous function SIG_ERR , errno > 0 snprintf () Number of characters that would be written (nonnegative) Negative snprintf_s () Number of characters that would be written (nonnegative) Negative sprintf () Number of non-null characters written Negative sprintf_s () Number of non-null characters written Negative sscanf () Number of conversions (nonnegative) EOF (negative) sscanf_s () Number of conversions (nonnegative) EOF (negative) strchr () Pointer to located character NULL strerror_s () 0 Nonzero strftime () Number of non-null characters 0 strpbrk () Pointer to located character NULL strrchr () Pointer to located character NULL strstr () Pointer to located string NULL strtod () Converted value 0 , errno == ERANGE strtof () Converted value 0 , errno == ERANGE strtoimax () Converted value INTMAX_MAX or INTMAX_MIN , errno == ERANGE strtok () Pointer to first character of a token NULL strtok_s () Pointer to first character of a token NULL strtol () Converted value LONG_MAX or LONG_MIN , errno == ERANGE strtold () Converted value 0, errno == ERANGE strtoll () Converted value LLONG_MAX or LLONG_MIN , errno == ERANGE strtoumax () Converted value UINTMAX_MAX , errno == ERANGE strtoul () Converted value ULONG_MAX , errno == ERANGE strtoull () Converted value ULLONG_MAX , errno == ERANGE strxfrm () Length of transformed string >= n swprintf () Number of non-null wide characters Negative swprintf_s () Number of non-null wide characters Negative swscanf () Number of conversions (nonnegative) EOF (negative) swscanf_s () Number of conversions (nonnegative) EOF (negative) thrd_create () thrd_success thrd_nomem or thrd_error thrd_detach () thrd_success thrd_error thrd_join () thrd_success thrd_error thrd_sleep () 0 Negative time () Calendar time (time_t)(-1) timespec_get () Base 0 tmpfile () Pointer to stream NULL tmpfile_s () 0 Nonzero tmpnam () Non-null pointer NULL tmpnam_s () 0 Nonzero tss_create () thrd_success thrd_error tss_get () Value of thread-specific storage 0 tss_set () thrd_success thrd_error ungetc () Character pushed back EOF (see below ) ungetwc () Character pushed back WEOF vfprintf () Number of characters (nonnegative) Negative vfprintf_s () Number of characters (nonnegative) Negative vfscanf () Number of conversions (nonnegative) EOF (negative) vfscanf_s () Number of conversions (nonnegative) EOF (negative) vfwprintf () Number of wide characters (nonnegative) Negative vfwprintf_s () Number of wide characters (nonnegative) Negative vfwscanf () Number of conversions (nonnegative) EOF (negative) vfwscanf_s () Number of conversions (nonnegative) EOF (negative) vprintf_s () Number of characters (nonnegative) Negative vscanf () Number of conversions (nonnegative) EOF (negative) vscanf_s () Number of conversions (nonnegative) EOF (negative) vsnprintf () Number of characters that would be written (nonnegative) Negative vsnprintf_s () Number of characters that would be written (nonnegative) Negative vsprintf () Number of non-null characters (nonnegative) Negative vsprintf_s () Number of non-null characters (nonnegative) Negative vsscanf () Number of conversions (nonnegative) EOF (negative) vsscanf_s () Number of conversions (nonnegative) EOF (negative) vswprintf () Number of non-null wide characters Negative vswprintf_s () Number of non-null wide characters Negative vswscanf () Number of conversions (nonnegative) EOF (negative) vswscanf_s () Number of conversions (nonnegative) EOF (negative) vwprintf_s () Number of wide characters (nonnegative) Negative vwscanf () Number of conversions (nonnegative) EOF (negative) vwscanf_s () Number of conversions (nonnegative) EOF (negative) wcrtomb () Number of bytes stored (size_t)(-1) wcschr () Pointer to located wide character NULL wcsftime () Number of non-null wide characters 0 wcspbrk () Pointer to located wide character NULL wcsrchr () Pointer to located wide character NULL wcsrtombs () Number of non-null bytes (size_t)(-1) , errno == EILSEQ wcsrtombs_s () 0 Nonzero wcsstr () Pointer to located wide string NULL wcstod () Converted value 0 , errno == ERANGE wcstof () Converted value 0 , errno == ERANGE wcstoimax () Converted value INTMAX_MAX or INTMAX_MIN , errno == ERANGE wcstok () Pointer to first wide character of a token NULL wcstok_s () Pointer to first wide character of a token NULL wcstol () Converted value LONG_MAX or LONG_MIN , errno == ERANGE wcstold () Converted value 0 , errno == ERANGE wcstoll () Converted value LLONG_MAX or LLONG_MIN , errno == ERANGE wcstombs () Number of non-null bytes (size_t)(-1) wcstombs_s () 0 Nonzero wcstoumax () Converted value UINTMAX_MAX , errno == ERANGE wcstoul () Converted value ULONG_MAX , errno == ERANGE wcstoull () Converted value ULLONG_MAX , errno == ERANGE wcsxfrm () Length of transformed wide string >= n wctob () Converted character EOF wctomb () , s != NULL Number of bytes stored −1 wctomb_s () , s != NULL Number of bytes stored −1 wctrans () Valid argument to towctrans 0 wctype () Valid argument to iswctype 0 wmemchr () Pointer to located wide character NULL wprintf_s () Number of wide characters (nonnegative) Negative wscanf () Number of conversions (nonnegative) EOF (negative) wscanf_s () Number of conversions (nonnegative) EOF (negative)\n\naligned_alloc\n()\n\nNULL\n\nasctime_s\n()\n\n0\n\nat_quick_exit\n()\n\n0\n\natexit\n()\n\n0\n\nbsearch\n()\n\nNULL\n\nbsearch_s\n()\n\nNULL\n\nbtowc\n()\n\nWEOF\n\nc16rtomb\n()\n\n(size_t)(-1)\n\nc32rtomb\n()\n\n(size_t)(-1)\n\ncalloc\n()\n\nNULL\n\nclock\n()\n\n(clock_t)(-1)\n\ncnd_broadcast\n()\n\nthrd_success\n\nthrd_error\n\ncnd_init\n()\n\nthrd_success\n\nthrd_nomem\n\nthrd_error\n\ncnd_signal\n()\n\nthrd_success\n\nthrd_error\n\ncnd_timedwait\n()\n\nthrd_success\n\nthrd_timedout\n\nthrd_error\n\ncnd_wait\n()\n\nthrd_success\n\nthrd_error\n\nctime_s\n()\n\n0\n\nfclose\n()\n\n0\n\nEOF\n\nfflush\n()\n\n0\n\nEOF\n\nfgetc\n()\n\nEOF\n\nfgetpos\n()\n\n0\n\nerrno > 0\n\nfgets\n()\n\nNULL\n\nfgetwc\n()\n\nWEOF\n\nfopen\n()\n\nNULL\n\nfopen_s\n()\n\n0\n\nfprintf\n()\n\nfprintf_s\n()\n\nfputc\n()\n\nEOF\n\nfputs\n()\n\nEOF\n\nfputwc()\n\nWEOF\n\nfputws\n()\n\nEOF\n\nfread\n()\n\nfreopen\n()\n\nNULL\n\nfreopen_s\n()\n\n0\n\nfscanf\n()\n\nEOF\n\nfscanf_s\n()\n\nEOF\n\nfseek\n()\n\n0\n\nfsetpos\n()\n\n0\n\nerrno > 0\n\nftell\n()\n\n−1L\n\nerrno > 0\n\nfwprintf\n()\n\nfwprintf_s\n()\n\nfwrite\n()\n\nfwscanf\n()\n\nEOF\n\nfwscanf_s\n()\n\nEOF\n\ngetc\n()\n\nEOF\n\ngetchar\n()\n\nEOF\n\ngetenv\n()\n\nNULL\n\ngetenv_s\n()\n\nNULL\n\ngets_s\n()\n\nNULL\n\ngetwc\n()\n\nWEOF\n\ngetwchar\n()\n\nWEOF\n\ngmtime\n()\n\nNULL\n\ngmtime_s\n()\n\nNULL\n\nlocaltime\n()\n\nNULL\n\nlocaltime_s\n()\n\nNULL\n\nmalloc\n()\n\nNULL\n\nmblen\n()\n, s != NULL\n\n−1\n\nmbrlen\n()\n, s != NULL\n\n(size_t)(-1)\n\nmbrtoc16\n()\n\n(size_t)(-1)\n\nerrno == EILSEQ\n\nmbrtoc32\n()\n\n(size_t)(-1)\n\nerrno == EILSEQ\n\nmbrtowc\n()\n, s != NULL\n\n(size_t)(-1)\n\nerrno == EILSEQ\n\nmbsrtowcs\n()\n\n(size_t)(-1)\n\nerrno == EILSEQ\n\nmbsrtowcs_s\n()\n\n0\n\nmbstowcs\n()\n\n(size_t)(-1)\n\nmbstowcs_s\n()\n\n0\n\nmbtowc\n()\n, s != NULL\n\n−1\n\nmemchr\n()\n\nNULL\n\nmktime\n()\n\n(time_t)(-1)\n\nmtx_init\n()\n\nthrd_success\n\nthrd_error\n\nmtx_lock\n()\n\nthrd_success\n\nthrd_error\n\nmtx_timedlock\n()\n\nthrd_success\n\nthrd_timedout\n\nthrd_error\n\nmtx_trylock\n()\n\nthrd_success\n\nthrd_busy\n\nthrd_error\n\nmtx_unlock\n()\n\nthrd_success\n\nthrd_error\n\nprintf_s\n()\n\nputc\n()\n\nEOF\n\nputwc\n()\n\nWEOF\n\nraise\n()\n\n0\n\nrealloc\n()\n\nNULL\n\nremove\n()\n\n0\n\nrename\n()\n\n0\n\nsetlocale\n()\n\nNULL\n\nsetvbuf\n()\n\n0\n\nscanf\n()\n\nEOF\n\nscanf_s\n()\n\nEOF\n\nsignal\n()\n\nSIG_ERR\n\nerrno > 0\n\nsnprintf\n()\n\nsnprintf_s\n()\n\nsprintf\n()\n\nsprintf_s\n()\n\nsscanf\n()\n\nEOF\n\nsscanf_s\n()\n\nEOF\n\nstrchr\n()\n\nNULL\n\nstrerror_s\n()\n\n0\n\nstrftime\n()\n\n0\n\nstrpbrk\n()\n\nNULL\n\nstrrchr\n()\n\nNULL\n\nstrstr\n()\n\nNULL\n\nstrtod\n()\n\n0\n\nerrno == ERANGE\n\nstrtof\n()\n\n0\n\nerrno == ERANGE\n\nstrtoimax\n()\n\nINTMAX_MAX\n\nINTMAX_MIN\n\nerrno == ERANGE\n\nstrtok\n()\n\nNULL\n\nstrtok_s\n()\n\nNULL\n\nstrtol\n()\n\nLONG_MAX\n\nLONG_MIN\n\nerrno == ERANGE\n\nstrtold\n()\n\n0, errno == ERANGE\n\nstrtoll\n()\n\nLLONG_MAX\n\nLLONG_MIN\n\nerrno == ERANGE\n\nstrtoumax\n()\n\nUINTMAX_MAX\n\nerrno == ERANGE\n\nstrtoul\n()\n\nULONG_MAX\n\nerrno == ERANGE\n\nstrtoull\n()\n\nULLONG_MAX\n\nerrno == ERANGE\n\nstrxfrm\n()\n\n>= n\n\nswprintf\n()\n\nswprintf_s\n()\n\nswscanf\n()\n\nEOF\n\nswscanf_s\n()\n\nEOF\n\nthrd_create\n()\n\nthrd_success\n\nthrd_nomem\n\nthrd_error\n\nthrd_detach\n()\n\nthrd_success\n\nthrd_error\n\nthrd_join\n()\n\nthrd_success\n\nthrd_error\n\nthrd_sleep\n()\n\n0\n\ntime\n()\n\n(time_t)(-1)\n\ntimespec_get\n()\n\n0\n\ntmpfile\n()\n\nNULL\n\ntmpfile_s\n()\n\n0\n\ntmpnam\n()\n\nNULL\n\ntmpnam_s\n()\n\n0\n\ntss_create\n()\n\nthrd_success\n\nthrd_error\n\ntss_get\n()\n\n0\n\ntss_set\n()\n\nthrd_success\n\nthrd_error\n\nungetc\n()\n\nEOF\n\nungetwc\n()\n\nWEOF\n\nvfprintf\n()\n\nvfprintf_s\n()\n\nvfscanf\n()\n\nEOF\n\nvfscanf_s\n()\n\nEOF\n\nvfwprintf\n()\n\nvfwprintf_s\n()\n\nvfwscanf\n()\n\nEOF\n\nvfwscanf_s\n()\n\nEOF\n\nvprintf_s\n()\n\nvscanf\n()\n\nEOF\n\nvscanf_s\n()\n\nEOF\n\nvsnprintf\n()\n\nvsnprintf_s\n()\n\nvsprintf\n()\n\nvsprintf_s\n()\n\nvsscanf\n()\n\nEOF\n\nvsscanf_s\n()\n\nEOF\n\nvswprintf\n()\n\nvswprintf_s\n()\n\nvswscanf\n()\n\nEOF\n\nvswscanf_s\n()\n\nEOF\n\nvwprintf_s\n()\n\nvwscanf\n()\n\nEOF\n\nvwscanf_s\n()\n\nEOF\n\nwcrtomb\n()\n\n(size_t)(-1)\n\nwcschr\n()\n\nNULL\n\nwcsftime\n()\n\n0\n\nwcspbrk\n()\n\nNULL\n\nwcsrchr\n()\n\nNULL\n\nwcsrtombs\n()\n\n(size_t)(-1)\n\nerrno == EILSEQ\n\nwcsrtombs_s\n()\n\n0\n\nwcsstr\n()\n\nNULL\n\nwcstod\n()\n\n0\n\nerrno == ERANGE\n\nwcstof\n()\n\n0\n\nerrno == ERANGE\n\nwcstoimax\n()\n\nINTMAX_MAX\n\nINTMAX_MIN\n\nerrno == ERANGE\n\nwcstok\n()\n\nNULL\n\nwcstok_s\n()\n\nNULL\n\nwcstol\n()\n\nLONG_MAX\n\nLONG_MIN\n\nerrno == ERANGE\n\nwcstold\n()\n\n0\n\nerrno == ERANGE\n\nwcstoll\n()\n\nLLONG_MAX\n\nLLONG_MIN\n\nerrno == ERANGE\n\nwcstombs\n()\n\n(size_t)(-1)\n\nwcstombs_s\n()\n\n0\n\nwcstoumax\n()\n\nUINTMAX_MAX\n\nerrno == ERANGE\n\nwcstoul\n()\n\nULONG_MAX\n\nerrno == ERANGE\n\nwcstoull\n()\n\nULLONG_MAX\n\nerrno == ERANGE\n\nwcsxfrm\n()\n\n>= n\n\nwctob\n()\n\nEOF\n\nwctomb\n()\n, s != NULL\n\n−1\n\nwctomb_s\n()\n, s != NULL\n\n−1\n\nwctrans\n()\n\n towctrans\n\n0\n\nwctype\n()\n\n iswctype\n\n0\n\nwmemchr\n()\n\nNULL\n\nwprintf_s\n()\n\nwscanf\n()\n\nEOF\n\nwscanf_s\n()\n\nEOF\n\nNote: According to FIO35-C . Use feof() and ferror() to detect end-of-file and file errors when sizeof(int) == sizeof(char) , callers should verify end-of-file and file errors for the functions in this table as follows:\n\n1 By calling ferror() and feof() 2 By calling ferror()\n\nferror()\n\nfeof()\n\nferror()\n\nThe ungetc() function does not set the error indicator even when it fails, so it is not possible to check for errors reliably unless it is known that the argument is not equal to EOF .\n\nungetc()\n\nEOF\n\nThe C Standard 7.31.3.10 paragraph 3 [ ISO/IEC 9899:2024 ] states that\n\n)ne wide character of pushback is guaranteed...\n\nso this should not be an issue if, at most, one character is ever pushed back before reading again. (See FIO13-C . Never push back anything other than one read character .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( setlocale() )",
          "pre_code_commentary": "In this noncompliant code example, the function utf8_to_wcs() attempts to convert a sequence of UTF-8 characters to wide characters . It first invokes setlocale() to set the global locale to the implementation-defined en_US.UTF-8 but does not check for failure. The setlocale() function will fail by returning a null pointer, for example, when the locale is not installed. The function may fail for other reasons as well, such as the lack of resources.  Depending on the sequence of characters pointed to by utf8 , the subsequent call to mbstowcs() may fail or result in the function storing an unexpected sequence of wide characters in the supplied buffer wcs .",
          "code": "#include <locale.h>\n#include <stdlib.h>\n \nint utf8_to_wcs(wchar_t *wcs, size_t n, const char *utf8,\n                size_t *size) {\n  if (NULL == size) {\n    return -1;\n  }\n  setlocale(LC_CTYPE, \"en_US.UTF-8\");\n  *size = mbstowcs(wcs, utf8, n);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( setlocale() )",
          "pre_code_commentary": "This compliant solution checks the value returned by setlocale() and avoids calling mbstowcs() if the function fails. The function also takes care to restore the locale to its initial setting before returning control to the caller.",
          "code": "#include <locale.h>\n#include <stdlib.h>\n \nint utf8_to_wcs(wchar_t *wcs, size_t n, const char *utf8,\n                size_t *size) {\n  if (NULL == size) {\n    return -1;\n  }\n  const char *save = setlocale(LC_CTYPE, \"en_US.UTF-8\");\n  if (NULL == save) {\n    return -1;\n  }\n\n  *size = mbstowcs(wcs, utf8, n);\n  if (NULL == setlocale(LC_CTYPE, save)) {\n    return -1;\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( calloc() )",
          "pre_code_commentary": "In this noncompliant code example, temp_num , tmp2 , and num_of_records are derived from a tainted source . Consequently, an attacker can easily cause calloc() to fail by providing a large value for num_of_records .",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nenum { SIG_DESC_SIZE = 32 };\n\ntypedef struct {\n  char sig_desc[SIG_DESC_SIZE];\n} signal_info;\n \nvoid func(size_t num_of_records, size_t temp_num,\n          const char *tmp2, size_t tmp2_size_bytes) {\n  signal_info *start = (signal_info *)calloc(num_of_records,\n                                          sizeof(signal_info));\n\n  if (tmp2 == NULL) {\n    /* Handle error */\n  } else if (temp_num > num_of_records || temp_num == 0) {\n    /* Handle error */\n  } else if (tmp2_size_bytes < SIG_DESC_SIZE) {\n    /* Handle error */\n  }\n\n  signal_info *point = start + temp_num - 1;\n  memcpy(point->sig_desc, tmp2, SIG_DESC_SIZE);\n  point->sig_desc[SIG_DESC_SIZE - 1] = '\\0';\n  /* ... */\n  free(start);\n}",
          "explanation_after": "When calloc() fails, it returns a null pointer that is assigned to start . If start is null, an attacker can provide a value for temp_num that, when scaled by sizeof(signal_info) , references a writable address to which control is eventually transferred. The contents of the string referenced by tmp2 can then be used to overwrite the address, resulting in an arbitrary code execution vulnerability ."
        },
        "compliant": {
          "heading": "Compliant Solution ( calloc() )",
          "pre_code_commentary": "To correct this error, ensure the pointer returned by calloc() is not null:",
          "code": "#include <stdlib.h>\n#include <string.h>\n\nenum { SIG_DESC_SIZE = 32 };\n\ntypedef struct {\n  char sig_desc[SIG_DESC_SIZE];\n} signal_info;\n \nvoid func(size_t num_of_records, size_t temp_num,\n          const char *tmp2, size_t tmp2_size_bytes) {\n  signal_info *start = (signal_info *)calloc(num_of_records,\n                                           sizeof(signal_info));\n  if (start == NULL) {\n    /* Handle allocation error */\n  } else if (tmp2 == NULL) {\n    /* Handle error */\n  } else if (temp_num > num_of_records || temp_num == 0) {\n    /* Handle error */\n  } else if (tmp2_size_bytes < SIG_DESC_SIZE) {\n    /* Handle error */\n  }\n\n  signal_info *point = start + temp_num - 1; \n  memcpy(point->sig_desc, tmp2, SIG_DESC_SIZE);\n  point->sig_desc[SIG_DESC_SIZE - 1] = '\\0';\n  /* ... */\n  free(start);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( realloc() )",
          "pre_code_commentary": "This noncompliant code example calls realloc() to resize the memory referred to by p . However, if realloc() fails, it returns a null pointer and the connection between the original block of memory and p is lost, resulting in a memory leak.",
          "code": "#include <stdlib.h>\n \nvoid *p;\nvoid func(size_t new_size) {\n  if (new_size == 0) {\n    /* Handle error */\n  }\n  p = realloc(p, new_size);\n  if (p == NULL) {\n   /* Handle error */\n  }\n}",
          "explanation_after": "This code example complies with MEM04-C . Do not perform zero-length allocations ."
        },
        "compliant": {
          "heading": "Compliant Solution ( realloc() )",
          "pre_code_commentary": "In this compliant solution, the result of realloc() is assigned to the temporary pointer q and validated before it is assigned to the original pointer p :",
          "code": "#include <stdlib.h>\n \nvoid *p;\nvoid func(size_t new_size) {\n  void *q;\n\n  if (new_size == 0) {\n    /* Handle error */\n  }\n \n  q = realloc(p, new_size);\n  if (q == NULL) {\n   /* Handle error */\n  } else {\n    p = q;\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fseek() )",
          "pre_code_commentary": "In this noncompliant code example, the fseek() function is used to set the file position to a location offset in the file referred to by file prior to reading a sequence of bytes from the file. However, if an I/O error occurs during the seek operation, the subsequent read will fill the buffer with the wrong contents.",
          "code": "#include <stdio.h>\n \nsize_t read_at(FILE *file, long offset,\n               void *buf, size_t nbytes) {\n  fseek(file, offset, SEEK_SET);\n  return fread(buf, 1, nbytes, file);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( fseek() )",
          "pre_code_commentary": "According to the C Standard, the fseek() function returns a nonzero value to indicate that an error occurred. This compliant solution tests for this condition before reading from a file to eliminate the chance of operating on the wrong portion of the file if fseek() fails:",
          "code": "#include <stdio.h>\n \nsize_t read_at(FILE *file, long offset,\n               void *buf, size_t nbytes) {\n  if (fseek(file, offset, SEEK_SET) != 0) {\n    /* Indicate error to caller */\n    return 0;\n  }\n  return fread(buf, 1, nbytes, file);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( snprintf() )",
          "pre_code_commentary": "In this noncompliant code example, snprintf() is assumed to succeed. However, if the call fails (for example, because of insufficient memory, as described in GNU libc bug 441945 ), the subsequent call to log_message() has undefined behavior 174 because the character buffer is uninitialized and need not be null-terminated.",
          "code": "#include <stdio.h>\n \nextern void log_message(const char *);\n\nvoid f(int i, int width, int prec) {\n  char buf[40];\n  snprintf(buf, sizeof(buf), \"i = %*.*i\", width, prec, i);\n  log_message(buf);\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( snprintf() )",
          "pre_code_commentary": "This compliant solution does not assume that snprintf() will succeed regardless of its arguments. It tests the return value of snprintf() before subsequently using the formatted buffer. This compliant solution also treats the case where the static buffer is not large enough for snprintf() to append the terminating null character as an error.",
          "code": "#include <stdio.h>\n#include <string.h>\n \nextern void log_message(const char *);\n\nvoid f(int i, int width, int prec) {\n  char buf[40];\n  int n;\n  n = snprintf(buf, sizeof(buf), \"i = %*.*i\", width, prec, i);\n  if (n < 0 || n >= sizeof(buf)) {\n    /* Handle snprintf() error */\n    strcpy(buf, \"unknown error\");\n  }\n  log_message(buf);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( snprintf() )",
          "pre_code_commentary": "In this noncompliant code example, snprintf() is assumed to succeed. However, if the call fails (for example, because of insufficient memory, as described in GNU libc bug 441945 ), the subsequent call to log_message() has undefined behavior 174 because the character buffer is uninitialized and need not be null-terminated.",
          "code": "#include <stdio.h>\n \nextern void log_message(const char *);\n\nvoid f(int i, int width, int prec) {\n  char buf[40];\n  snprintf(buf, sizeof(buf), \"i = %*.*i\", width, prec, i);\n  log_message(buf);\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( snprintf( null ) )",
          "pre_code_commentary": "If unknown, the length of the formatted string can be discovered by invoking snprintf() with a null buffer pointer to determine the size required for the output, then dynamically allocating a buffer of sufficient size, and finally calling snprintf() again to format the output into the dynamically allocated buffer. Even with this approach, the success of all calls still needs to be tested, and any errors must be appropriately handled. A possible optimization is to first attempt to format the string into a reasonably small buffer allocated on the stack and, only when the buffer turns out to be too small, dynamically allocate one of a sufficient size:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nextern void log_message(const char *); \n \nvoid f(int i, int width, int prec) {\n  char buffer[20];\n  char *buf = buffer;\n  int n  = sizeof(buffer);\n  const char fmt[] = \"i = %*.*i\";\n\n  n = snprintf(buf, n, fmt, width, prec, i);\n  if (n < 0) {\n    /* Handle snprintf() error */\n    strcpy(buffer, \"unknown error\");\n    goto write_log;\n  }\n\n  if (n < sizeof(buffer)) {\n    goto write_log;\n  }\n\n  buf = (char *)malloc(n + 1);\n  if (NULL == buf) {\n    /* Handle malloc() error */\n    strcpy(buffer, \"unknown error\");\n    goto write_log;\n  }\n\n  n = snprintf(buf, n, fmt, width, prec, i);\n  if (n < 0) {\n    /* Handle snprintf() error */\n    strcpy(buffer, \"unknown error\");\n  }\n\nwrite_log:\n  log_message(buf);\n\n  if (buf != buffer) {\n    free(buf);\n  }\n}\n",
          "explanation_after": "This solution uses the goto statement, as suggested in MEM12-C . Consider using a goto chain when leaving a function on error when using and releasing resources ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to detect error conditions can lead to unpredictable results, including abnormal program termination and denial-of-service attacks or, in some situations, could even allow an attacker to run arbitrary code.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P27",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "ERR34-C",
    "title": "Detect errors when converting a string to a number",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/ERR34-C.+Detect+errors+when+converting+a+string+to+a+number",
    "description": "The process of parsing an integer or floating-point number from a string can produce many errors. The string might not contain a number. It might contain a number of the correct type that is out of range (such as an integer that is larger than INT_MAX ). The string may also contain extra information after the number, which may or may not be useful after the conversion. These error conditions must be detected and addressed when a string-to-number conversion is performed using a C Standard Library function.\n\nINT_MAX\n\nThe strtol() , strtoll() , strtoimax() , strtoul(), strtoull(), strtoumax() , strtof(), strtod() , and strtold() functions convert the initial portion of a null-terminated byte string to a long int , long long int , intmax_t , unsigned long int , unsigned long long int, uintmax_t, float, double , and long double representation, respectively.\n\nstrtol()\n\nstrtoll()\n\nstrtoimax()\n\nstrtoul(), strtoull(), \nstrtoumax()\n, strtof(),\n\nstrtoumax()\n\nstrtod()\n\nstrtold()\n\nlong int\n\nlong long int\n\nintmax_t\n\nunsigned long int\n\nunsigned long long int, uintmax_t, float, double\n\nlong double\n\nUse one of the C Standard Library strto*() functions to parse an integer or floating-point number from a string. These functions provide more robust error handling than alternative solutions. Also, use the strtol() function to convert to a smaller signed integer type such as signed int , signed short , and signed char , testing the result against the range limits for that type. Likewise, use the strtoul() function to convert to a smaller unsigned integer type such as unsigned int , unsigned short , and unsigned char , and test the result against the range limits for that type. These range tests do nothing if the smaller type happens to have the same size and representation for a particular implementation.\n\nstrto*()\n\nstrtol()\n\nsigned int\n\nsigned short\n\nsigned char\n\nstrtoul()\n\nunsigned int\n\nunsigned short\n\nunsigned char",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( atoi() )",
          "pre_code_commentary": "This noncompliant code example converts the string token stored in the buff to a signed integer value using the atoi() function:",
          "code": "#include <stdlib.h>\n \nvoid func(const char *buff) {\n  int si;\n\n  if (buff) {\n    si = atoi(buff);\n  } else {\n    /* Handle error */\n  }\n}",
          "explanation_after": "The atoi() , atol() , atoll() , and atof() functions convert the initial portion of a string token to int , long int, long long int , and double representation, respectively. Except for the behavior on error ( [ ISO/IEC 9899:2024 ], s7.24.1.2) , they are equivalent to\n\nUnfortunately, atoi() and related functions lack a mechanism for reporting errors for invalid values. Specifically, these functions:\n\ndo not need to set errno on an error; have undefined behavior 16 if the value of the result cannot be represented; return 0 (or 0.0) if the string does not represent an integer (or decimal), which is indistinguishable from a correctly formatted, zero-denoting input string."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Example ( sscanf() )",
          "pre_code_commentary": "This noncompliant example uses the sscanf() function to convert a string token to an integer. The sscanf() function has the same limitations as atoi() :",
          "code": "#include <stdio.h>\n \nvoid func(const char *buff) {\n  int matches;\n  int si;\n\n  if (buff) {\n    matches = sscanf(buff, \"%d\", &si);\n    if (matches != 1) {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n}",
          "explanation_after": "The sscanf() function returns the number of input items successfully matched and assigned, which can be fewer than provided for, or even 0 in the event of an early matching failure. However, sscanf() fails to report the other errors reported by strtol() , such as numeric overflow."
        },
        "compliant": {
          "heading": "Compliant Solution ( strtol() )",
          "pre_code_commentary": "The strtol() , strtoll() , strtoimax()) , strtoul(), strtoull(), strtoumax(), strtof(), strtod() , and strtold() functions convert a null-terminated byte string to long int , long long int , intmax_t , unsigned long int , unsigned long long int, uintmax_t, float, double , and long double representation, respectively.\n\nThis compliant solution uses strtol() to convert a string token to an integer and ensures that the value is in the range of int :",
          "code": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n \nvoid func(const char *buff) {\n  char *end;\n  int si;\n\n  errno = 0;\n\n  const long sl = strtol(buff, &end, 10);\n\n  if (end == buff) {\n    (void) fprintf(stderr, \"%s: not a decimal number\\n\", buff);\n  } else if ('\\0' != *end) {\n    (void) fprintf(stderr, \"%s: extra characters at end of input: %s\\n\", buff, end);\n  } else if ((LONG_MIN == sl || LONG_MAX == sl) && ERANGE == errno) {\n    (void) fprintf(stderr, \"%s out of range of type long\\n\", buff);\n  } else if (sl > INT_MAX) {\n    (void) fprintf(stderr, \"%ld greater than INT_MAX\\n\", sl);\n  } else if (sl < INT_MIN) {\n    (void) fprintf(stderr, \"%ld less than INT_MIN\\n\", sl);\n  } else {\n    si = (int)sl;\n\n    /* Process si */\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "It is rare for a violation of this rule to result in a security vulnerability unless it occurs in security-sensitive code. However, violations of this rule can easily result in lost or misinterpreted data.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP00-C",
    "title": "Use parentheses for precedence of operation",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP00-C.+Use+parentheses+for+precedence+of+operation",
    "description": "C programmers commonly make errors regarding the precedence rules of C operators because of the unintuitive low-precedence levels of & , | , ^ , << , and >> . Mistakes regarding precedence rules can be avoided by the suitable use of parentheses. Using parentheses defensively reduces errors and, if not taken to excess, makes the code more readable.\n\n&\n\n|\n\n^\n\n<<\n\n>>\n\nSubclause 6.5 of the C Standard defines the precedence of operation by the order of the subclauses.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The intent of the expression in this noncompliant code example is to test the least significant bit of x :",
          "code": "x & 1 == 0\n",
          "explanation_after": "Because of operator precedence rules, the expression is parsed as\n\nwhich evaluates to\n\nand then to 0 ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, parentheses are used to ensure the expression evaluates as expected:",
          "code": "(x & 1) == 0\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Mistakes regarding precedence rules may cause an expression to be evaluated in an unintended way, which can lead to unexpected and abnormal program behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP02-C",
    "title": "Be aware of the short-circuit behavior of the logical AND and OR operators",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP02-C.+Be+aware+of+the+short-circuit+behavior+of+the+logical+AND+and+OR+operators",
    "description": "The logical AND and logical OR operators ( && and || , respectively) exhibit \"short-circuit\" operation. That is, the second operand is not evaluated if the result can be deduced solely by evaluating the first operand.\n\n&&\n\n||\n\nProgrammers should exercise caution if the second operand contains side effects because it may not be apparent whether the side effects actually occur.\n\nIn the following code, the value of i is incremented only when i >= 0 :\n\ni\n\ni >= 0\n\nenum { max = 15 };\nint i = /* Initialize to user-supplied value */;\n\nif ( (i >= 0) && ( (i++) <= max) ) {\n  /* Code */\n}\n\nenum { max = 15 };\nint i = /* Initialize to user-supplied value */;\n\nif ( (i >= 0) && ( (i++) <= max) ) {\n  /* Code */\n}\n\nAlthough the behavior is well defined, it is not immediately obvious whether or not i gets incremented.\n\ni",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the second operand of the logical OR operator invokes a function that results in side effects:",
          "code": "char *p = /* Initialize; may or may not be NULL */\n\nif (p || (p = (char *) malloc(BUF_SIZE)) ) {\n  /* Perform some computation based on p */\n  free(p);\n  p = NULL;\n} else {\n  /* Handle malloc() error */\n  return;\n}\n",
          "explanation_after": "Because malloc() is called only if p is NULL when entering the if clause, free() might be called with a pointer to local data not allocated by malloc() . (See MEM34-C. Only free memory allocated dynamically .) This behavior is partially due to the uncertainty of whether or not malloc() is actually called."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, a second pointer, q , is used to indicate whether malloc() is called; if not, q remains set to NULL . Passing NULL to free() is guaranteed to safely do nothing.",
          "code": "char *p = /* Initialize; may or may not be NULL */\nchar *q = NULL;\nif (p == NULL) {\n  q = (char *) malloc(BUF_SIZE);\n  p = q;\n}\nif (p == NULL) {\n  /* Handle malloc() error */\n  return;\n}\n\n/* Perform some computation based on p */\nfree(q);\nq = NULL;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to understand the short-circuit behavior of the logical OR or AND operator may cause unintended program behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP03-C",
    "title": "Do not assume the size of a structure is the sum of the sizes of its members",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP03-C.+Do+not+assume+the+size+of+a+structure+is+the+sum+of+the+sizes+of+its+members",
    "description": "The size of a structure is not always equal to the sum of the sizes of its members. Subclause 6.7.2.1 of the C Standard states, \"There may be unnamed padding within a structure object, but not at its beginning\" [ ISO/IEC 9899:2011 ].\n\nThis unnamed padding is often called structure padding . Structure members are arranged in memory as they are declared in the program text. Padding may be added to the structure to ensure the structure is properly aligned in memory. Structure padding allows for faster member access on many architectures.\n\nRearranging the fields in a struct can change the size of the struct . It is possible to minimize padding anomalies if the fields are arranged in such a way that fields of the same size are grouped together.\n\nstruct\n\nstruct\n\nPadding is also called struct member alignment . Many compilers provide a flag that controls how the members of a structure are packed into memory. Modifying this flag may cause the size of the structures to vary. Most compilers also include a keyword that removes all padding; the resulting structures are called packed structures . Overriding the default behavior is often unwise because it leads to interface compatibility problems (the nominally same struct has its layout interpreted differently in different modules).\n\nstruct\n\nstruct",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example assumes that the size of struct buffer is equal to the sum of the size of its individual components, which may not be the case [ Dowd 2006 ]. The size of struct buffer may actually be larger because of structure padding.",
          "code": "enum { buffer_size = 50 };\n\nstruct buffer {\n  size_t size;\n  char bufferC[buffer_size];\n};\n\n/* ... */\n\nvoid func(const struct buffer *buf) {\n\n  /*\n   * Incorrectly assumes sizeof(struct buffer) =\n   * sizeof(size_t) + sizeof(bufferC)\n   */\n  struct buffer *buf_cpy = (struct buffer *)malloc(\n    sizeof(size_t) + (buffer_size * sizeof(char) /* 1 */)\n  );\n\n  if (buf_cpy == NULL) {\n    /* Handle malloc() error */\n  }\n\n  /* \n   * With padding, sizeof(struct buffer) may be greater than\n   * sizeof(size_t) + sizeof(buff.bufferC), causing some data  \n   * to be written outside the bounds of the memory allocated.\n   */\n  memcpy(buf_cpy, buf, sizeof(struct buffer));\n\n  /* ... */\n\n  free(buf_cpy);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Accounting for structure padding prevents these types of errors:",
          "code": "enum { buffer_size = 50 };\n\nstruct buffer {\n  size_t size;\n  char bufferC[buffer_size];\n};\n\n/* ... */\n\nvoid func(const struct buffer *buf) {\n\n  struct buffer *buf_cpy = \n    (struct buffer *)malloc(sizeof(struct buffer));\n\n  if (buf_cpy == NULL) {\n    /* Handle malloc() error */\n  }\n\n  /* ... */\n\n  memcpy(buf_cpy, buf, sizeof(struct buffer));\n\n  /* ... */\n\n  free(buf_cpy);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to correctly determine the size of a structure can lead to subtle logic errors and incorrect calculations, the effects of which can lead to abnormal program termination, memory corruption, or execution of arbitrary code.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP05-C",
    "title": "Do not cast away a const qualification",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP05-C.+Do+not+cast+away+a+const+qualification",
    "description": "Do not cast away a const qualification on an object of pointer type. Casting away the const qualification allows a program to modify the object referred to by the pointer, which may result in undefined behavior . See undefined behavior 61 in Appendix J of the C Standard.\n\nconst\n\nconst\n\nAs an illustration, the C Standard [ ISO/IEC 9899:2011 ] provides a footnote (subclause 6.7.3, paragraph 4):\n\nThe implementation may place a const object that is not volatile in a read-only region of storage. Moreover, the implementation need not allocate storage for such an object if its address is never used.\n\nconst",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The remove_spaces() function in this noncompliant code example accepts a pointer to a string str and a string length slen and removes the space character from the string by shifting the remaining characters toward the front of the string. The function remove_spaces() is passed a const char pointer as an argument. The const qualification is cast away, and then the contents of the string are modified.",
          "code": "void remove_spaces(const char *str, size_t slen) {\n  char *p = (char *)str;\n  size_t i;\n  for (i = 0; i < slen && str[i]; i++) {\n    if (str[i] != ' ') *p++ = str[i];\n  }\n  *p = '\\0';\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the function remove_spaces() is passed a non- const char pointer. The calling function must ensure that the null-terminated byte string passed to the function is not const by making a copy of the string or by other means.",
          "code": "void remove_spaces(char *str, size_t slen) {\n  char *p = str;\n  size_t i;\n  for (i = 0; i < slen && str[i]; i++) {\n    if (str[i] != ' ') *p++ = str[i];\n  }\n  *p = '\\0';\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the contents of the const int array vals are cleared by the call to memset() :",
          "code": "const int vals[3] = {3, 4, 5};\nmemset(vals, 0, sizeof(vals));\n",
          "explanation_after": "Because the memset() function takes a (non- const ) pointer to void , the compiler must implicitly cast away const .\n\nThe GCC compiler issues a warning when an implicit cast is performed."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "If the intention is to allow the array values to be modified, do not declare the array as const :",
          "code": "int vals[3] = {3, 4, 5};\nmemset(vals, 0, sizeof(vals));\n",
          "explanation_after": "Otherwise, do not attempt to modify the contents of the array."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "If the object is constant, the compiler may allocate storage in ROM or write-protected memory. Attempting to modify such an object may lead to a program crash or denial-of-service attack .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP07-C",
    "title": "Do not diminish the benefits of constants by assuming their values in expressions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP07-C.+Do+not+diminish+the+benefits+of+constants+by+assuming+their+values+in+expressions",
    "description": "If a constant value is given for an identifier, do not diminish the maintainability of the code in which it is used by assuming its value in expressions. Simply giving the constant a name is not enough to ensure modifiability; you must be careful to always use the name, and remember that the value can change. This recommendation is related to DCL06-C. Use meaningful symbolic constants to represent literal values .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The header stdio.h defines the BUFSIZ macro, which expands to an integer constant expression that is the size of the buffer used by the setbuf() function. This noncompliant code example defeats the purpose of defining BUFSIZ as a constant by assuming its value in the following expression:",
          "code": "#include <stdio.h>\n/* ... */\nnblocks = 1 + ((nbytes - 1) >> 9); /* BUFSIZ = 512 = 2^9 */\n",
          "explanation_after": "The programmer's assumption underlying this code is that \"everyone knows that BUFSIZ equals 512,\" and right-shifting 9 bits is the same (for positive numbers) as dividing by 512. However, if BUFSIZ changes to 1024 on some systems, modifications are difficult and error prone."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses the identifier assigned to the constant value in the expression:",
          "code": "#include <stdio.h>\n/* ... */\nnblocks = 1 + (nbytes - 1) / BUFSIZ;\n",
          "explanation_after": "Most modern C compilers will optimize this code appropriately."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Assuming the value of an expression diminishes the maintainability of code and can produce unexpected behavior under any circumstances in which the constant changes.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP08-C",
    "title": "Ensure pointer arithmetic is used correctly",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP08-C.+Ensure+pointer+arithmetic+is+used+correctly",
    "description": "When performing pointer arithmetic, the size of the value to add to a pointer is automatically scaled to the size of the type of the pointed-to object. For instance, when adding a value to the byte address of a 4-byte integer, the value is scaled by a factor of 4 and then added to the pointer. Failing to understand how pointer arithmetic works can lead to miscalculations that result in serious errors, such as buffer overflows.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, integer values returned by parseint(getdata()) are stored into an array of INTBUFSIZE elements of type int called buf [ Dowd 2006 ]. If data is available for insertion into buf (which is indicated by havedata() ) and buf_ptr has not been incremented past buf + sizeof(buf) , an integer value is stored at the address referenced by buf_ptr . However, the sizeof operator returns the total number of bytes in buf , which is typically a multiple of the number of elements in buf . This value is scaled to the size of an integer and added to buf . As a result, the check to make sure integers are not written past the end of buf is incorrect, and a buffer overflow is possible.",
          "code": "int buf[INTBUFSIZE];\nint *buf_ptr = buf;\n\nwhile (havedata() && buf_ptr < (buf + sizeof(buf))) {\n  *buf_ptr++ = parseint(getdata());\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the size of buf , INTBUFSIZE , is added directly to buf and used as an upper bound. The integer literal INTBUFSIZE is scaled to the size of an integer, and the upper bound of buf is checked correctly.",
          "code": "int buf[INTBUFSIZE];\nint *buf_ptr = buf;\n\nwhile (havedata() && buf_ptr < (buf + INTBUFSIZE)) {\n  *buf_ptr++ = parseint(getdata());\n}\n",
          "explanation_after": "An arguably better solution is to use the address of the nonexistent element following the end of the array, as follows:\n\nThis solution works because the C Standard guarantees the address of buf[INTBUFSIZE] even though no such element exists."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example is based on a flaw in the OpenBSD operating system. An integer, skip , is added as an offset to a pointer of type struct big . The adjusted pointer is then used as a destination address in a call to memset() . However, when skip is added to the struct big pointer, it is automatically scaled by the size of struct big , which is 32 bytes (assuming 4-byte integers, 8-byte long long integers, and no structure padding). This scaling results in the call to memset() writing to unintended memory.",
          "code": "struct big {\n  unsigned long long ull_1; /* Typically 8 bytes */\n  unsigned long long ull_2; /* Typically 8 bytes */\n  unsigned long long ull_3; /* Typically 8 bytes */\n  int si_4; /* Typically 4 bytes */\n  int si_5; /* Typically 4 bytes */\n};\n/* ... */\n \nint f(void) {\n  size_t skip = offsetof(struct big, ull_2);\n  struct big *s = (struct big *)malloc(sizeof(struct big));\n  if (!s) {\n   return -1; /* Indicate malloc() failure */\n  }\n\n  memset(s + skip, 0, sizeof(struct big) - skip);\n  /* ... */\n  free(s);\n  s = NULL;\n  \n  return 0;\n}",
          "explanation_after": "A similar situation occurred in OpenBSD's make command [ Murenin 2007 ]."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "To correct this example, the struct big pointer is cast as a char * , which causes skip to be scaled by a factor of 1:",
          "code": "struct big {\n  unsigned long long ull_1; /* Typically 8 bytes */\n  unsigned long long ull_2; /* Typically 8 bytes */\n  unsigned long long ull_3; /* Typically 8 bytes */\n  int si_4; /* Typically 4 bytes */\n  int si_5; /* Typically 4 bytes */\n};\n/* ... */\n \nint f(void) {\n  size_t skip = offsetof(struct big, ull_2);\n  struct big *s = (struct big *)malloc(sizeof(struct big));\n  if (!s) {\n    return -1; /* Indicate malloc() failure */\n  }\n\n  memset((char *)s + skip, 0, sizeof(struct big) - skip);\n/* ... */\n  free(s);\n  s = NULL;\n\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to understand and properly use pointer arithmetic can allow an attacker to execute arbitrary code.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP09-C",
    "title": "Use sizeof to determine the size of a type or variable",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP09-C.+Use+sizeof+to+determine+the+size+of+a+type+or+variable",
    "description": "Do not hard code the size of a type into an application. Because of alignment, padding, and differences in basic types (e.g., 32-bit versus 64-bit pointers), the size of most types can vary between compilers and even versions of the same compiler. Using the sizeof operator to determine sizes improves the clarity of what is meant and ensures that changes between compilers or versions will not affect the code.\n\nsizeof\n\nType alignment requirements can also affect the size of structures. For example, the size of the following structure is implementation-defined :\n\nstruct s {\n  int i;\n  double d;\n};\n\nstruct s {\n  int i;\n  double d;\n};\n\nAssuming 32-bit integers and 64-bit doubles, for example, the size can range from 12 to 16 bytes, depending on alignment rules.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to declare a two-dimensional array of integers with variable length rows. On a platform with 64-bit integers, the loop will access memory outside the allocated memory section.",
          "code": "int f(void) { /* Assuming 32-bit pointer, 32-bit integer */\n  size_t i;\n  int **matrix = (int **)calloc(100, 4);\n  if (matrix == NULL) {\n    return -1; /* Indicate calloc() failure */\n  }\n\n  for (i = 0; i < 100; i++) {\n    matrix[i] = (int *)calloc(i, 4);\n    if (matrix[i] == NULL) {\n      return -1; /* Indicate calloc() failure */\n    }\n  }\n return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution replaces the hard-coded value 4 with sizeof(int *) :",
          "code": "int f(void) {\n  size_t i;\n  int **matrix = (int **)calloc(100, sizeof(*matrix));\n  if (matrix == NULL) {\n    return -1; /* Indicate calloc() failure */\n  }\n\n  for (i = 0; i < 100; i++) {\n    matrix[i] = (int *)calloc(i, sizeof(**matrix));\n    if (matrix[i] == NULL) {\n      return -1; /* Indicate calloc() failure */\n    }\n  }\n\n  return 0;\n}",
          "explanation_after": "Also see MEM02-C. Immediately cast the result of a memory allocation function call into a pointer to the allocated type for a discussion on the use of the sizeof operator with memory allocation functions.\n\nEXP09-C-EX1: The C Standard explicitly declares sizeof(char) == 1 , so any sizes based on characters or character arrays may be evaluated without using sizeof . This does not apply to char* or any other data types."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Porting code with hard-coded sizes can result in a buffer overflow or related vulnerability .",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP10-C",
    "title": "Do not depend on the order of evaluation of subexpressions or the order in which side effects take place",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP10-C.+Do+not+depend+on+the+order+of+evaluation+of+subexpressions+or+the+order+in+which+side+effects+take+place",
    "description": "The order of evaluation of subexpressions and the order in which side effects take place are frequently defined as unspecified behavior by the C Standard. Counterintuitively, unspecified behavior in behavior for which the standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance. Consequently, unspecified behavior can be a portability issue because different implementations can make different choices. If dynamic scheduling is used, however, there may not be a fixed-code execution sequence over the life of a process. Operations that can be executed in different sequences may in fact be executed in a different order.\n\nAccording to the C Standard, subclause 6.5 [ ISO/IEC 9899:2011 ],\n\nExcept as specified later, side effects and value computations of subexpressions are unsequenced.\n\nFollowing are specific examples of situations in which the order of evaluation of subexpressions or the order in which side effects take place is unspecified:\n\nThe order in which the arguments to a function are evaluated (C Standard, subclause 6.5.2.2, \"Function Calls\") The order of evaluation of the operands in an assignment statement (C Standard, subclause 6.5.16, \"Assignment Operators\") The order in which any side effects occur among the initialization list expressions is unspecified. In particular, the evaluation order need not be the same as the order of subobject initialization (C Standard, subclause 6.7.9, \"Initialization\")\n\nThis recommendation is related to EXP30-C. Do not depend on the order of evaluation for side effects , but it focuses on behavior that is nonportable or potentially confusing.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The order of evaluation of the function designator, the actual arguments, and subexpressions within the actual arguments are unspecified, but there is a sequence point before the actual call. For example, in the function call",
          "code": "(*pf[f1()]) (f2(), f3() + f4())\n",
          "explanation_after": "the functions f1() , f2() , f3() , and f4() may be called in any order. All side effects have to be completed before the function pointed to by pf[f1()] is called.\n\nConsequently, the result of this noncompliant code example depends on unspecified behavior :\n\nThis code may result in g being assigned the value 1 , or equally likely, being assigned the value 2 ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution is independent of the order of evaluation of the operands and can be interpreted in only one way:",
          "code": "#include <stdio.h>\n\nint g;\n\nint f(int i) {\n  g = i;\n  return i;\n}\n\nint main(void) {\n  int x = f(1); \n  x += f(2);\n  printf(\"g = %d\\n\", g);\n  /* ... */\n  return 0;\n}\n",
          "explanation_after": "This code always results in g being assigned the value 2 ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP11-C",
    "title": "Do not make assumptions regarding the layout of structures with bit-fields",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP11-C.+Do+not+make+assumptions+regarding+the+layout+of+structures+with+bit-fields",
    "description": "The internal representations of bit-field structures have several properties (such as internal padding) that are implementation-defined . Additionally, bit-field structures have several implementation-defined constraints:\n\nThe alignment of bit-fields in the storage unit (for example, the bit-fields may be allocated from the high end or the low end of the storage unit) Whether or not bit-fields can overlap a storage unit boundary\n\nConsequently, it is impossible to write portable safe code that makes assumptions regarding the layout of bit-field structure members.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Bit-Field Alignment)",
          "pre_code_commentary": "Bit-fields can be used to allow flags or other integer values with small ranges to be packed together to save storage space. Bit-fields can improve the storage efficiency of structures. Compilers typically allocate consecutive bit-field structure members into the same int -sized storage, as long as they fit completely into that storage unit. However, the order of allocation within a storage unit is implementation-defined. Some implementations are right-to-left : the first member occupies the low-order position of the storage unit. Others are left-to-right : the first member occupies the high-order position of the storage unit. Calculations that depend on the order of bits within a storage unit may produce different results on different implementations.\n\nConsider the following structure made up of four 8-bit bit-field members:",
          "code": "struct bf {\n  unsigned int m1 : 8;\n  unsigned int m2 : 8;\n  unsigned int m3 : 8;\n  unsigned int m4 : 8;\n};\t/* 32 bits total */\n",
          "explanation_after": "Right-to-left implementations will allocate struct bf as one storage unit with this format:\n\nConversely, left-to-right implementations will allocate struct bf as one storage unit with this format:\n\nThe following code behaves differently depending on whether the implementation is left-to-right or right-to-left:"
        },
        "compliant": {
          "heading": "Compliant Solution (Bit-Field Alignment)",
          "pre_code_commentary": "This compliant solution is explicit in which fields it modifies:",
          "code": "struct bf {\n  unsigned int m1 : 8;\n  unsigned int m2 : 8;\n  unsigned int m3 : 8;\n  unsigned int m4 : 8;\n}; /* 32 bits total */\n\nvoid function() {\n  struct bf data;\n  data.m1 = 0;\n  data.m2 = 0;\n  data.m3 = 0;\n  data.m4 = 0;\n  data.m1++;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Bit-Field Overlap)",
          "pre_code_commentary": "In this noncompliant code example, assuming 8 bits to a byte, if bit-fields of 6 and 4 bits are declared, is each bit-field contained within a byte, or are the bit-fields split across multiple bytes?",
          "code": "struct bf {\n  unsigned int m1 : 6;\n  unsigned int m2 : 4;\n};\n\nvoid function() {\n  unsigned char *ptr;\n  struct bf data;\n  data.m1 = 0;\n  data.m2 = 0;\n  ptr = (unsigned char *)&data;\n  ptr++;\n  *ptr += 1; /* What does this increment? */\n}\n",
          "explanation_after": "If each bit-field lives within its own byte, then m2 (or m1 , depending on alignment) is incremented by 1. If the bit-fields are indeed packed across 8-bit bytes, then m2 might be incremented by 4."
        },
        "compliant": {
          "heading": "Compliant Solution (Bit-Field Overlap)",
          "pre_code_commentary": "This compliant solution is explicit in which fields it modifies:",
          "code": "struct bf {\n  unsigned int m1 : 6;\n  unsigned int m2 : 4;\n};\n\nvoid function() {\n  struct bf data;\n  data.m1 = 0;\n  data.m2 = 0;\n  data.m2 += 1;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Making invalid assumptions about the type of type-cast data, especially bit-fields, can result in unexpected data values.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP12-C",
    "title": "Do not ignore values returned by functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP12-C.+Do+not+ignore+values+returned+by+functions",
    "description": "Many functions return useful values whether or not the function has side effects. In most cases, this value is used to signify whether the function successfully completed its task or if some error occurred (see ERR02-C. Avoid in-band error indicators ). Other times, the value is the result of some computation and is an integral part of the function's API.\n\nSubclause 6.8.3 of the C Standard [ ISO/IEC 9899:2011 ] states:\n\nThe expression in an expression statement is evaluated as a void expression for its side effects.\n\nAll expression statements, such as function calls with an ignored value, are implicitly cast to void . Because a return value often contains important information about possible errors, it should always be checked; otherwise, the cast should be made explicit to signify programmer intent. If a function returns no meaningful value, it should be declared with return type void .\n\nvoid\n\nvoid\n\nThis recommendation encompasses ERR33-C. Detect and handle standard library errors . Unlike this recommendation, that rule is restricted to functions from the Standard C library.\n\nCompliance with this recommendation is required in order to comply with ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The asprintf() function has been provided by the GNU C library. It works like sprintf() , but if given a null pointer as the destination string, it will create a buffer sufficient to hold the resulting string. It relies on malloc() to allocate the buffer. If malloc() fails, then asprintf() returns a negative number.\n\nThis noncompliant code example calls asprintf(), but fails to check whether the string was successfully created.",
          "code": "void func(char* name) {\n  char* s = NULL;\n  asprintf(&s,\"Hello, %s!\\n\", name);\n  (void) puts(s);\n  free(s);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution checks to make sure no error occurred.",
          "code": "void func(char* name) {\n  char* s = NULL;\n  if (asprintf(&s,\"Hello, %s!\\n\", name) < 0) {\n    /* Handle error */\n  }\n  (void) puts(s);\n  free(s);\n} ",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to handle error codes or other values returned by functions can lead to incorrect program flow and violations of data integrity.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP13-C",
    "title": "Treat relational and equality operators as if they were nonassociative",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP13-C.+Treat+relational+and+equality+operators+as+if+they+were+nonassociative",
    "description": "The relational and equality operators are left-associative in C. Consequently, C, unlike many other languages, allows chaining of relational and equality operators. Subclause 6.5.8, footnote 107, of the C Standard [ ISO/IEC 9899:2011 ], says:\n\nThe expression a<b<c is not interpreted as in ordinary mathematics. As the syntax indicates, it means (a<b)<c ; in other words, \"if a is less than b , compare 1 to c ; otherwise, compare 0 to c .\"\n\na<b<c\n\n(a<b)<c\n\na\n\nb\n\nc\n\nc\n\nThese operators are left-associative , which means the leftmost comparison is performed first, and the result is compared with the rightmost comparison. This syntax allows a programmer to write an expression (particularly an expression used as a condition) that can be easily misinterpreted.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Although this noncompliant code example compiles correctly, it is unlikely that it means what the author of the code intended:",
          "code": "int a = 2;\nint b = 2;\nint c = 2;\n/* ... */\nif (a < b < c) /* Misleading; likely bug */\n/* ... */\nif (a == b == c) /* Misleading; likely bug */\n",
          "explanation_after": "The expression a < b < c evaluates to true rather than, as its author probably intended, to false, and the expression a == b == c evaluates to false rather than, as its author probably intended, to true."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Treat relational and equality operators as if it were invalid to chain them:",
          "code": "if ( (a < b) && (b < c) ) /* Clearer and probably what was intended */\n/* ... */\nif ( (a == b) && (a == c) ) /* Ditto */\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrect use of relational and equality operators can lead to incorrect control flow.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP14-C",
    "title": "Beware of integer promotion when performing bitwise operations on integer types smaller than int",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP14-C.+Beware+of+integer+promotion+when+performing+bitwise+operations+on+integer+types+smaller+than+int",
    "description": "Deprecated This guideline has been deprecated by INT02-C. Understand integer conversion rules\n\nInteger types smaller than int are promoted when an operation is performed on them. If all values of the original type can be represented as an int , the value of the smaller type is converted to an int ; otherwise, it is converted to an unsigned int (see INT02-C. Understand integer conversion rules ). If the conversion is to a wider type, the original value is zero-extended for unsigned values or sign-extended for signed types. Consequently, bitwise operations on integer types smaller than int may have unexpected results.\n\nint\n\nint\n\nint\n\nunsigned int\n\nint",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example demonstrates how performing bitwise operations on integer types smaller than int may have unexpected results.",
          "code": "uint8_t port = 0x5a;\nuint8_t result_8 = ( ~port ) >> 4;\n",
          "explanation_after": "In this example, a bitwise complement of port is first computed and then shifted 4 bits to the right. If both of these operations are performed on an 8-bit unsigned integer, then result_8 will have the value 0x0a . However, port is first promoted to a signed int , with the following results (on a typical architecture where type int is 32 bits wide):\n\nExpression\n\nType\n\nValue\n\nNotes\n\nport\n\nuint8_t\n\n0x5a\n\n~port\n\nint\n\n0xffffffa5\n\n~port >> 4\n\n0x0ffffffa\n\nWhether or not value is negative is implementation-defined.\n\nresult_8\n\n0xfa"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the bitwise complement of port is converted back to 8 bits. Consequently, result_8 is assigned the expected value of 0x0aU .",
          "code": "uint8_t port = 0x5a;\nuint8_t result_8 = (uint8_t) (~port) >> 4;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Bitwise operations on shorts and chars can produce incorrect data.",
      "metrics": {
        "severity": "low",
        "likelihood": "likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP15-C",
    "title": "Do not place a semicolon on the same line as an if, for, or while statement",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP15-C.+Do+not+place+a+semicolon+on+the+same+line+as+an+if%2C+for%2C+or+while+statement",
    "description": "Do not use a semicolon on the same line as an if , for , or while statement because it typically indicates programmer error and can result in unexpected behavior.\n\nif\n\nfor\n\nwhile",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a semicolon is used on the same line as an if statement:",
          "code": "if (a == b); {\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "It is likely, in this example, that the semicolon was accidentally inserted:",
          "code": "if (a == b) {\n  /* ... */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Errors of omission can result in unintended program flow.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P27",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "EXP16-C",
    "title": "Do not compare function pointers to constant values",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP16-C.+Do+not+compare+function+pointers+to+constant+values",
    "description": "Comparing a function pointer to a value that is not a null function pointer of the same type will be diagnosed because it typically indicates programmer error and can result in unexpected behavior . Implicit comparisons will be diagnosed, as well.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the addresses of the POSIX functions getuid and geteuid are compared for equality to 0. Because no function address shall be null, the first subexpression will always evaluate to false (0), and the second subexpression always to true (nonzero). Consequently, the entire expression will always evaluate to true, leading to a potential security vulnerability.",
          "code": "/* First the options that are allowed only for root */\nif (getuid == 0 || geteuid != 0) {\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the function pointers getuid and geteuid are compared to 0. This example is from an actual vulnerability ( VU#837857 ) discovered in some versions of the X Window System server. The vulnerability exists because the programmer neglected to provide the open and close parentheses following the geteuid() function identifier. As a result, the geteuid token returns the address of the function, which is never equal to 0. Consequently, the or condition of this if statement is always true, and access is provided to the protected block for all users. Many compilers issue a warning noting such pointless expressions. Therefore, this coding error is normally detected by adherence to MSC00-C. Compile cleanly at high warning levels .",
          "code": "/* First the options that are allowed only for root */\nif (getuid() == 0 || geteuid != 0) {\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The solution is to provide the open and close parentheses following the geteuid token so that the function is properly invoked:",
          "code": "/* First the options that are allowed only for root */\nif (getuid() == 0 || geteuid() != 0) {\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the function pointers getuid and geteuid are compared to 0. This example is from an actual vulnerability ( VU#837857 ) discovered in some versions of the X Window System server. The vulnerability exists because the programmer neglected to provide the open and close parentheses following the geteuid() function identifier. As a result, the geteuid token returns the address of the function, which is never equal to 0. Consequently, the or condition of this if statement is always true, and access is provided to the protected block for all users. Many compilers issue a warning noting such pointless expressions. Therefore, this coding error is normally detected by adherence to MSC00-C. Compile cleanly at high warning levels .",
          "code": "/* First the options that are allowed only for root */\nif (getuid() == 0 || geteuid != 0) {\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "A function pointer can be compared to a null function pointer of the same type:",
          "code": "/* First the options that are allowed only for root */ \nif (getuid == (uid_t(*)(void))0 || geteuid != (uid_t(*)(void))0) { \n  /* ... */ \n} \n",
          "explanation_after": "This code should not be diagnosed by an analyzer."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the function pointer do_xyz is implicitly compared unequal to 0:",
          "code": "int do_xyz(void); \n \nint f(void) {\n/* ... */\n  if (do_xyz) { \n    return -1; /* Indicate failure */ \n  }\n/* ... */\n  return 0;\n} \n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the function do_xyz() is invoked and the return value is compared to 0:",
          "code": "int do_xyz(void); \n \nint f(void) {\n/* ... */ \n  if (do_xyz()) { \n    return -1; /* Indicate failure */\n  }\n/* ... */\n  return 0;  \n} \n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Errors of omission can result in unintended program flow.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP19-C",
    "title": "Use braces for the body of an if, for, or while statement",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP19-C.+Use+braces+for+the+body+of+an+if%2C+for%2C+or+while+statement",
    "description": "Opening and closing braces for if , for , and while statements should always be used even if the statement's body contains only a single statement.\n\nif\n\nfor\n\nwhile\n\nIf an if , while , or for statement is used in a macro, the macro definition should not conclude with a semicolon. (See PRE11-C. Do not conclude macro definitions with a semicolon .)\n\nif\n\nwhile\n\nfor\n\nBraces improve the uniformity and readability of code. More important, when inserting an additional statement into a body containing only a single statement, it is easy to forget to add braces because the indentation gives strong (but misleading) guidance to the structure.\n\nBraces also help ensure that macros with multiple statements are properly expanded. Such a macro should be wrapped in a do-while loop. (See PRE10-C. Wrap multistatement macros in a do-while loop .) However, when the do-while loop is not present, braces can still ensure that the macro expands as intended.\n\ndo-while\n\ndo-while",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example uses an if statement without braces to authenticate a user:",
          "code": "int login;\n\nif (invalid_login())\n  login = 0;\nelse\n  login = 1;\n",
          "explanation_after": "A developer might add a debugging statement to determine when the login is valid but forget to add opening and closing braces:\n\nBecause of the indentation of the code, it is difficult to tell that the code will not function as intended by the programmer, potentially leading to a security breach."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In the compliant solution, opening and closing braces are used even when the body is a single statement:",
          "code": "int login;\n\nif (invalid_login()) {\n  login = 0;\n} else {\n  login = 1;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example has an if statement nested in another if statement without braces around the if and else bodies:",
          "code": "int privileges;\n\nif (invalid_login())\n  if (allow_guests())\n    privileges = GUEST;\nelse\n  privileges = ADMINISTRATOR;\n",
          "explanation_after": "The indentation could lead the programmer to believe that a user is given administrator privileges only when the user's login is valid. However, the else statement actually attaches to the inner if statement:\n\nThis is a security loophole: users with invalid logins can still obtain administrator privileges."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In the compliant solution, adding braces removes the ambiguity and ensures that privileges are correctly assigned:",
          "code": "int privileges;\n\nif (invalid_login()) {\n  if (allow_guests()) {\n    privileges = GUEST;\n  } \n} else {\n  privileges = ADMINISTRATOR;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (empty block)",
          "pre_code_commentary": "This noncompliant code example has a while statement with no block:",
          "code": "while (invalid_login());",
          "explanation_after": "Note that if invalid_login() has no side effects (such as warning the user if their login failed), this code also violates MSC12-C. Detect and remove code that has no effect or is never executed ."
        },
        "compliant": {
          "heading": "Compliant Solution (empty block)",
          "pre_code_commentary": "This compliant solution features an explicit empty block, which clarifies the developer's intent:",
          "code": "while (invalid_login()) {}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "EXP20-C",
    "title": "Perform explicit tests to determine success, true and false, and equality",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP20-C.+Perform+explicit+tests+to+determine+success%2C+true+and+false%2C+and+equality",
    "description": "Perform explicit tests to determine success, true/false, and equality to improve the readability and maintainability of code and for compatibility with common conventions.\n\nIn particular, do not default the test for nonzero. For instance, suppose a foo() function returns 0 to indicate failure or a nonzero value to indicate success. Testing for inequality with 0,\n\nfoo()\n\nif (foo() != 0) ...\n\nif (foo() != 0) ...\n\nis preferable to\n\nif (foo()) ...\n\nif (foo()) ...\n\ndespite the convention that 0 indicates failure. Explicitly testing for inequality with 0 benefits maintainability if foo() is later modified to return −1 rather than 0 on failure.\n\nfoo()\n\nThis recommendation is derived from and considers the implications of the following common conventions:\n\nFunctions return 0 if false and nonzero if true [StackOvflw 2009 ]. Function failures can typically be indicated by −1 or any nonzero number. Comparison functions (such as the standard library function strcmp() , which has a trinary return value) return 0 if the arguments are equal and nonzero otherwise (see strcmp function ).\n\nstrcmp()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, is_banned() returns 0 if false and nonzero if true:",
          "code": "LinkedList bannedUsers;\n\nint is_banned(User usr) {\n  int x = 0;\n\n  Node cur_node = (bannedUsers->head);\n\n  while (cur_node != NULL) {\n    if(!strcmp((char *)cur_node->data, usr->name)) {\n      x++;\n    }\n    cur_node = cur_node->next;\n  }\n\n  return x;\n}\n\nvoid processRequest(User usr) {\n  if(is_banned(usr) == 1) {\n    return;\n  }\n  serveResults();\n}\n",
          "explanation_after": "If a banned user is listed twice, the user is granted access. Although is_banned() follows the common convention of returning nonzero for true, processRequest checks for equality only with 1."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Because most functions guarantee a return value of nonzero only for true, the preceding code is better written by checking for inequality with 0 (false), as follows:",
          "code": "LinkedList bannedUsers;\n\nint is_banned(User usr) {\n  int x = 0;\n\n  Node cur_node = (bannedUsers->head);\n\n  while(cur_node != NULL) {\n    if (strcmp((char *)cur_node->data, usr->name)==0) {\n      x++;\n    }\n    cur_node = cur_node->next;\n  }\n\n  return x;\n}\n\nvoid processRequest(User usr) {\n  if (is_banned(usr) != 0) {\n    return;\n  }\n  serveResults();\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In noncompliant code, function status can typically be indicated by returning −1 on failure or any nonnegative number on success. This is a common convention in the standard C library, but it is discouraged in ERR02-C. Avoid in-band error indicators .\n\nAlthough failures are frequently indicated by a return value of 0, some common conventions may conflict in the future with code in which the test for nonzero is not explicit. In this case, defaulting the test for nonzero welcomes bugs if and when a developer modifies validateUser() to return an error code or −1 rather than 0 to indicate a failure (all of which are also common conventions).",
          "code": "int validateUser(User usr) {\n  if(listContains(validUsers, usr)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nvoid processRequest(User usr, Request request) {\n  if(!validateUser(usr)) {\n    return \"invalid user\";\n  }\n  else {\n    serveResults();\n  }\n}\n",
          "explanation_after": "Although the code will work as intended, it is possible that a future modification will result in the following:\n\nIn this code, the programmer intended to add error code functionality to indicate the cause of a validation failure. The new code, however, validates any invalid or nonexisting user. Because there is no explicit test in processRequest() , the logical error is not obvious and seems correct by certain conventions."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant code is preferable for improved maintenance. By defining what constitutes a failure and explicitly testing for it, the behavior is clearly implied, and future modifications are more likely to preserve it. If a future modification is made, such as in the previous example, it is immediately obvious that the if statement in processRequest() does not correctly utilize the specification of validateUser() .",
          "code": "int validateUser(User usr) {\n  if(list_contains(validUsers, usr)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nvoid processRequest(User usr, Request request) {\n  if(validateUser(usr) == 0) {\n    return \"invalid user\";\n  }\n  else {\n    serveResults();\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Comparison functions (such as the standard library strcmp() function) return 0 if the arguments are equal and nonzero otherwise.\n\nBecause many comparison functions return 0 for equality and nonzero for inequality, they can cause confusion when used to test for equality. If someone were to switch the following strcmp() call with a function testing for equality, but the programmer did not follow the same convention as strcmp() , the programmer might instinctively just replace the function name. Also, when quickly reviewed, the code could easily appear to test for inequality.",
          "code": "void login(char *usr, char *pw) {\n  User user = find_user(usr);\n  if (!strcmp((user->password),pw)) {\n    grantAccess();\n  }\n  else {\n    denyAccess(\"Incorrect Password\");\n  }\n}\n",
          "explanation_after": "The preceding code works correctly. However, to simplify the login code or to facilitate checking a user's password more than once, a programmer can separate the password-checking code from the login function in the following way:\n\nIn an attempt to leave the previous logic intact, the developer just replaces strcmp() with a call to the new function. However, doing so produces incorrect behavior. In this case, any user who inputs an incorrect password is granted access. Again, two conventions conflict and produce code that is easily corrupted when modified. To make code maintainable and to avoid these conflicts, such a result should never be defaulted."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution, using a comparison function for this purpose, is the preferred approach. By performing an explicit test, any programmer who wishes to modify the equality test can clearly see the implied behavior and convention that is being followed.",
          "code": "void login(char *usr, char *pw) {\n  User user = find_user(usr);\n  if (strcmp((user->password),pw) == 0) {\n    grantAccess();\n  }\n  else {\n    denyAccess(\"Incorrect Password\");\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Code that does not conform to the common practices presented is difficult to maintain. Bugs can easily arise when modifying helper functions that evaluate true/false or success/failure. Bugs can also easily arise when modifying code that tests for equality using a comparison function that obeys the same conventions as standard library functions such as strcmp .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "EXP30-C",
    "title": "Do not depend on the order of evaluation for side effects",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP30-C.+Do+not+depend+on+the+order+of+evaluation+for+side+effects",
    "description": "Evaluation of an expression may produce side effects . At specific points during execution, known as sequence points , all side effects of previous evaluations are complete, and no side effects of subsequent evaluations have yet taken place. Do not depend on the order of evaluation for side effects unless there is an intervening sequence point.\n\nThe C Standard, 6.5, paragraph 2 [ ISO/IEC 9899:2024 ], states\n\nIf a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.\n\nThis requirement must be met for each allowable ordering of the subexpressions of a full expression; otherwise, the behavior is undefined . (See undefined behavior 34 .)\n\nThe following sequence points are defined in the C Standard, Annex C [ ISO/IEC 9899:2011 ]:\n\nBetween the evaluations of the function designator and actual arguments in a function call and the actual call Between the evaluations of the first and second operands of the following operators: Logical AND: && Logical OR: || Comma: , Between the evaluations of the first operand of the conditional ?: operator and whichever of the second and third operands is evaluated The end of a full declarator Between the evaluation of a full expression and the next full expression to be evaluated; the following are full expressions: An initializer that is not part of a compound literal The expression in an expression statement The controlling expression of a selection statement ( if or switch ) The controlling expression of a while or do statement Each of the (optional) expressions of a for statement The (optional) expression in a return statement Immediately before a library function returns After the actions associated with each formatted input/output function conversion specifier Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call\n\n&&\n\n||\n\n,\n\n?:\n\nif \n\nswitch\n\nwhile\n\ndo\n\nfor\n\nreturn\n\nFurthermore, Section 6.5.17.1, paragraph 3 [ ISO/IEC 9899:2024 ] says (regarding assignment operations):\n\nThe side effect of updating the stored value of the left operand is sequenced after the value computations of the left and right operands.\n\nThis rule means that statements such as\n\ni = i + 1;\na[i] = i;\n\ni = i + 1;\na[i] = i;\n\nhave defined behavior, and statements such as the following do not:\n\n/* i is modified twice between sequence points */\ni = ++i + 1;  \n\n/* i is read other than to determine the value to be stored */\na[i++] = i;\n\n/* i is modified twice between sequence points */\ni = ++i + 1;  \n\n/* i is read other than to determine the value to be stored */\na[i++] = i;   \n\nNot all instances of a comma in C code denote a usage of the comma operator. For example, the comma between arguments in a function call is not a sequence point. However, according to the C Standard, 6.5.3.3, paragraph 8 [ ISO/IEC 9899:2024 ]\n\nEvery evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function.\n\nThis rule means that the order of evaluation for function call arguments is unspecified and can happen in any order.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Programs cannot safely rely on the order of evaluation of operands between sequence points. In this noncompliant code example, i is evaluated twice without an intervening sequence point, so the behavior of the expression is undefined :",
          "code": "#include <stdio.h>\n\nvoid func(int i, int *b) {\n  int a = i + b[++i];\n  printf(\"%d, %d\", a, i);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "These examples are independent of the order of evaluation of the operands and can be interpreted in only one way:",
          "code": "#include <stdio.h>\n\nvoid func(int i, int *b) {\n  int a;\n  ++i;\n  a = i + b[i];\n  printf(\"%d, %d\", a, i);\n}",
          "explanation_after": "Alternatively:"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The call to func() in this noncompliant code example has undefined behavior 34 because there is no sequence point between the argument expressions:",
          "code": "extern void func(int i, int j);\n \nvoid f(int i) {\n  func(i++, i);\n}",
          "explanation_after": "The first (left) argument expression reads the value of i (to determine the value to be stored) and then modifies i . The second (right) argument expression reads the value of i between the same pair of sequence points as the first argument, but not to determine the value to be stored in i . This additional attempt to read the value of i has undefined behavior 34 ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution is appropriate when the programmer intends for both arguments to func() to be equivalent:",
          "code": "extern void func(int i, int j);\n \nvoid f(int i) {\n  i++;\n  func(i, i);\n}",
          "explanation_after": "This compliant solution is appropriate when the programmer intends for the second argument to be 1 greater than the first:"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The order of evaluation for function arguments is unspecified. This noncompliant code example exhibits unspecified behavior but not undefined behavior :",
          "code": "extern void c(int i, int j);\nint glob;\n \nint a(void) {\n  return glob + 10;\n}\n\nint b(void) {\n  glob = 42;\n  return glob;\n}\n \nvoid func(void) {\n  c(a(), b());\n}",
          "explanation_after": "It is unspecified what order a() and b() are called in; the only guarantee is that both a() and b() will be called before c() is called. If a() or b() rely on shared state when calculating their return value, as they do in this example, the resulting arguments passed to c() may differ between compilers or architectures."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the order of evaluation for a() and b() is fixed, and so no unspecified behavior occurs:",
          "code": "extern void c(int i, int j);\nint glob;\n \nint a(void) {\n  return glob + 10;\n}\nint b(void) {\n  glob = 42;\n  return glob;\n}\n \nvoid func(void) {\n  int a_val, b_val;\n \n  a_val = a();\n  b_val = b();\n\n  c(a_val, b_val);\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Attempting to modify an object multiple times between sequence points may cause that object to take on an unexpected value, which can lead to unexpected program behavior .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP32-C",
    "title": "Do not access a volatile object through a nonvolatile reference",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP32-C.+Do+not+access+a+volatile+object+through+a+nonvolatile+reference",
    "description": "An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects . Referencing a volatile object by using a non-volatile lvalue is undefined behavior . The C Standard, 6.7.4 paragraph 7 [ ISO/IEC 9899:2024 ], states\n\nIf an attempt is made to refer to an object defined with a volatile-qualified type through use of an lvalue with non-volatile-qualified type, the behavior is undefined.\n\nSee undefined behavior 62 .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a volatile object is accessed through a non-volatile-qualified reference, resulting in undefined behavior 62 :",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  static volatile int **ipp;\n  static int *ip;\n  static volatile int i = 0;\n\n  printf(\"i = %d.\\n\", i);\n\n  ipp = &ip; /* May produce a warning diagnostic */\n  ipp = (int**) &ip; /* Constraint violation; may produce a warning diagnostic */\n  *ipp = &i; /* Valid */\n  if (*ip != 0) { /* Valid */\n    /* ... */\n  }\n}",
          "explanation_after": "The assignment ipp = &ip is not safe because it allows the valid code that follows to reference the value of the volatile object i through the non-volatile-qualified reference ip . In this example, the compiler may optimize out the entire if block because *ip != 0 must be false if the object to which ip points is not volatile.\n\nThis example compiles without warning on Microsoft Visual Studio 2013 when compiled in C mode ( /TC ) but causes errors when compiled in C++ mode ( /TP ).\n\nGCC 4.8.1 generates a warning but compiles successfully."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, ip is declared volatile :",
          "code": "#include <stdio.h>\n\nvoid func(void) {\n  static volatile int **ipp;\n  static volatile int *ip;\n  static volatile int i = 0;\n\n  printf(\"i = %d.\\n\", i);\n\n  ipp = &ip;\n  *ipp = &i;\n  if (*ip != 0) {\n    /* ... */\n  }\n\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Accessing an object with a volatile-qualified type through a reference with a non-volatile-qualified type is undefined behavior 62 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP33-C",
    "title": "Do not read uninitialized memory",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP33-C.+Do+not+read+uninitialized+memory",
    "description": "Local, automatic variables assume unexpected values if they are read before they are initialized. The C Standard, 6.7.11, paragraph 11, specifies [ ISO/IEC 9899:2024 ]\n\nIf an object that has automatic storage duration is not initialized explicitly, its representation is indeterminate .\n\nSee undefined behavior 11 .\n\nWhen local, automatic variables are stored on the program stack, for example, their values default to whichever values are currently stored in stack memory.\n\nAdditionally, some dynamic memory allocation functions do not initialize the contents of the memory they allocate.\n\nFunction Initialization aligned_alloc() Does not perform initialization calloc() Zero-initializes allocated memory malloc() Does not perform initialization realloc() Copies contents from original pointer; may not initialize all memory\n\naligned_alloc()\n\ncalloc()\n\nmalloc()\n\nrealloc()\n\nUninitialized automatic variables or dynamically allocated memory has indeterminate values , which for objects of some types, can be a trap representation . Reading such trap representations is undefined behavior ; it can cause a program to behave in an unexpected manner and provide an avenue for attack. (See undefined behavior 10 and undefined behavior 12 .)  In many cases, compilers issue a warning diagnostic message when reading uninitialized variables. (See MSC00-C. Compile cleanly at high warning levels for more information.)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Return-by-Reference)",
          "pre_code_commentary": "In this noncompliant code example, the set_flag() function is intended to set the parameter, sign_flag , to the sign of number . However, the programmer neglected to account for the case where number is equal to 0 . Because the local variable sign is uninitialized when calling set_flag() and is never written to by set_flag() , the comparison operation exhibits undefined behavior when reading sign .",
          "code": "void set_flag(int number, int *sign_flag) {\n  if (NULL == sign_flag) {\n    return;\n  }\n\n  if (number > 0) {\n    *sign_flag = 1;\n  } else if (number < 0) {\n    *sign_flag = -1;\n  }\n}\n\nint is_negative(int number) {\n  int sign;\n  set_flag(number, &sign);\n  return sign < 0;\n}\n",
          "explanation_after": "Some compilers assume that when the address of an uninitialized variable is passed to a function, the variable is initialized within that function. Because compilers frequently fail to diagnose any resulting failure to initialize the variable, the programmer must apply additional scrutiny to ensure the correctness of the code.\n\nThis defect results from a failure to consider all possible data states. (See MSC01-C. Strive for logical completeness for more information.)"
        },
        "compliant": {
          "heading": "Compliant Solution (Return-by-Reference)",
          "pre_code_commentary": "This compliant solution trivially repairs the problem by accounting for the possibility that number can be equal to 0.\n\nAlthough compilers and static analysis tools often detect uses of uninitialized variables when they have access to the source code, diagnosing the problem is difficult or impossible when either the initialization or the use takes place in object code for which the source code is inaccessible. Unless doing so is prohibitive for performance reasons, an additional defense-in-depth practice worth considering is to initialize local variables immediately after declaration.",
          "code": "void set_flag(int number, int *sign_flag) {\n  if (NULL == sign_flag) {\n    return;\n  }\n\n  /* Account for number being 0 */\n  if (number >= 0) { \n    *sign_flag = 1;\n  } else {\n    *sign_flag = -1;\n  }\n}\n\nint is_negative(int number) {\n  int sign = 0; /* Initialize for defense-in-depth */\n  set_flag(number, &sign);\n  return sign < 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Uninitialized Local)",
          "pre_code_commentary": "In this noncompliant code example, the programmer mistakenly fails to set the local variable error_log to the msg argument in the report_error() function [ Mercy 2006 ]. Because error_log has not been initialized, an indeterminate value is read. The sprintf() call copies data from the arbitrary location pointed to by the indeterminate error_log variable until a null byte is reached, which can result in a buffer overflow.",
          "code": "#include <stdio.h>\n\n/* Get username and password from user, return -1 on error */\nextern int do_auth(void);\nenum { BUFFERSIZE = 24 }; \nvoid report_error(const char *msg) {\n  const char *error_log;\n  char buffer[BUFFERSIZE];\n\n  sprintf(buffer, \"Error: %s\", error_log);\n  printf(\"%s\\n\", buffer);\n}\n\nint main(void) {\n  if (do_auth() == -1) {\n    report_error(\"Unable to login\");\n  }\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Uninitialized Local)",
          "pre_code_commentary": "In this noncompliant code example, the report_error() function has been modified so that error_log is properly initialized:",
          "code": "#include <stdio.h>\nenum { BUFFERSIZE = 24 }; \nvoid report_error(const char *msg) {\n  const char *error_log = msg;\n  char buffer[BUFFERSIZE];\n\n  sprintf(buffer, \"Error: %s\", error_log);\n  printf(\"%s\\n\", buffer);\n}\n",
          "explanation_after": "This example remains problematic because a buffer overflow will occur if the null-terminated byte string referenced by msg is greater than 17 characters, including the null terminator. (See STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator for more information.)"
        },
        "compliant": {
          "heading": "Compliant Solution (Uninitialized Local)",
          "pre_code_commentary": "In this compliant solution, the buffer overflow is eliminated by calling the snprintf() function:",
          "code": "#include <stdio.h>\nenum { BUFFERSIZE = 24 };\nvoid report_error(const char *msg) {\n  char buffer[BUFFERSIZE];\n\n  if (0 < snprintf(buffer, BUFFERSIZE, \"Error: %s\", msg))\n    printf(\"%s\\n\", buffer);\n  else\n    puts(\"Unknown error\");\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Uninitialized Local)",
          "pre_code_commentary": "In this noncompliant code example, the report_error() function has been modified so that error_log is properly initialized:",
          "code": "#include <stdio.h>\nenum { BUFFERSIZE = 24 }; \nvoid report_error(const char *msg) {\n  const char *error_log = msg;\n  char buffer[BUFFERSIZE];\n\n  sprintf(buffer, \"Error: %s\", error_log);\n  printf(\"%s\\n\", buffer);\n}\n",
          "explanation_after": "This example remains problematic because a buffer overflow will occur if the null-terminated byte string referenced by msg is greater than 17 characters, including the null terminator. (See STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator for more information.)"
        },
        "compliant": {
          "heading": "Compliant Solution (Uninitialized Local)",
          "pre_code_commentary": "A less error-prone compliant solution is to simply print the error message directly instead of using an intermediate buffer:",
          "code": "#include <stdio.h>\n \nvoid report_error(const char *msg) {\n  printf(\"Error: %s\\n\", msg);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( mbstate_t )",
          "pre_code_commentary": "In this noncompliant code example, the function mbrlen() is passed the address of an automatic mbstate_t object that has not been properly initialized. This is undefined behavior 200 because mbrlen() dereferences and reads its third argument.",
          "code": "#include <string.h> \n#include <wchar.h>\n \nvoid func(const char *mbs) {\n  size_t len;\n  mbstate_t state;\n\n  len = mbrlen(mbs, strlen(mbs), &state);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( mbstate_t )",
          "pre_code_commentary": "Before being passed to a multibyte conversion function, an mbstate_t object must be either initialized to the initial conversion state or set to a value that corresponds to the most recent shift state by a prior call to a multibyte conversion function. This compliant solution sets the mbstate_t object to the initial conversion state by setting it to all zeros:",
          "code": "#include <string.h> \n#include <wchar.h>\n \nvoid func(const char *mbs) {\n  size_t len;\n  mbstate_t state;\n\n  memset(&state, 0, sizeof(state));\n  len = mbrlen(mbs, strlen(mbs), &state);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX, Entropy)",
          "pre_code_commentary": "In this noncompliant code example described in \" More Randomness or Less \" [ Wang 2012 ], the process ID, time of day, and uninitialized memory junk is used to seed a random number generator. This behavior is characteristic of some distributions derived from Debian Linux that use uninitialized memory as a source of entropy because the value stored in junk is indeterminate. However, because accessing an indeterminate value is undefined behavior 11 , compilers may optimize out the uninitialized variable access completely, leaving only the time and process ID and resulting in a loss of desired entropy.",
          "code": "#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n  \nvoid func(void) {\n  struct timeval tv;\n  unsigned long junk;\n\n  gettimeofday(&tv, NULL);\n  srandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ junk);\n}",
          "explanation_after": "In security protocols that rely on unpredictability, such as RSA encryption, a loss in entropy results in a less secure system."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX, Entropy)",
          "pre_code_commentary": "This compliant solution seeds the random number generator by using the CPU clock and the real-time clock instead of reading uninitialized memory:",
          "code": "#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\nvoid func(void) {     \n  double cpu_time;\n  struct timeval tv;\n\n  cpu_time = ((double) clock()) / CLOCKS_PER_SEC;\n  gettimeofday(&tv, NULL);\n  srandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ cpu_time);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( realloc() )",
          "pre_code_commentary": "The realloc() function changes the size of a dynamically allocated memory object. The initial size bytes of the returned memory object are unchanged, but any newly added space is uninitialized, and its value is indeterminate . As in the case of malloc() , accessing memory beyond the size of the original object is undefined behavior 186 .\n\nIt is the programmer's responsibility to ensure that any memory allocated with malloc() and realloc() is properly initialized before it is used.\n\nIn this noncompliant code example, an array is allocated with malloc() and properly initialized. At a later point, the array is grown to a larger size but not initialized beyond what the original array contained. Subsequently accessing the uninitialized bytes in the new array is undefined behavior.",
          "code": "#include <stdlib.h>\n#include <stdio.h>\nenum { OLD_SIZE = 10, NEW_SIZE = 20 };\n \nint *resize_array(int *array, size_t count) {\n  if (0 == count) {\n    return 0;\n  }\n \n  int *ret = (int *)realloc(array, count * sizeof(int));\n  if (!ret) {\n    free(array);\n    return 0;\n  }\n \n  return ret;\n}\n \nvoid func(void) {\n \n  int *array = (int *)malloc(OLD_SIZE * sizeof(int));\n  if (0 == array) {\n    /* Handle error */\n  }\n \n  for (size_t i = 0; i < OLD_SIZE; ++i) {\n    array[i] = i;\n  }\n \n  array = resize_array(array, NEW_SIZE);\n  if (0 == array) {\n    /* Handle error */\n  }\n \n  for (size_t i = 0; i < NEW_SIZE; ++i) {\n    printf(\"%d \", array[i]);\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( realloc() )",
          "pre_code_commentary": "In this compliant solution, the resize_array() helper function takes a second parameter for the old size of the array so that it can initialize any newly allocated elements:",
          "code": "#include <stdlib.h>\n#include <stdio.h> \n#include <string.h>\n\nenum { OLD_SIZE = 10, NEW_SIZE = 20 };\n \nint *resize_array(int *array, size_t old_count, size_t new_count) {\n  if (0 == new_count) {\n    return 0;\n  }\n \n  int *ret = (int *)realloc(array, new_count * sizeof(int));\n  if (!ret) {\n    free(array);\n    return 0;\n  }\n \n  if (new_count > old_count) {\n    memset(ret + old_count, 0, (new_count - old_count) * sizeof(int));\n  }\n \n  return ret;\n}\n \nvoid func(void) {\n \n  int *array = (int *)malloc(OLD_SIZE * sizeof(int));\n  if (0 == array) {\n    /* Handle error */\n  }\n \n  for (size_t i = 0; i < OLD_SIZE; ++i) {\n    array[i] = i;\n  }\n \n  array = resize_array(array, OLD_SIZE, NEW_SIZE);\n  if (0 == array) {\n    /* Handle error */\n  }\n \n  for (size_t i = 0; i < NEW_SIZE; ++i) {\n    printf(\"%d \", array[i]);\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Reading uninitialized variables is undefined behavior 20 and can result in unexpected program behavior . In some cases, these security flaws may allow the execution of arbitrary code.\n\nReading uninitialized variables for creating entropy is problematic because these memory accesses can be removed by compiler optimization. VU#925211 is an example of a vulnerability caused by this coding error.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "EXP34-C",
    "title": "Do not dereference null pointers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers",
    "description": "Dereferencing a null pointer is undefined behavior .\n\nOn many platforms, dereferencing a null pointer results in abnormal program termination , but this is not required by the standard. See \" Clever Attack Exploits Fully-Patched Linux Kernel \" [ Goodin 2009 ] for an example of a code execution exploit that resulted from a null pointer dereference.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example is derived from a real-world example taken from a vulnerable version of the libpng library as deployed on a popular ARM-based cell phone [ Jack 2007 ]. The libpng library allows applications to read, create, and manipulate PNG (Portable Network Graphics) raster image files. The libpng library implements its own wrapper to malloc() that returns a null pointer on error or on being passed a 0-byte-length argument.\n\nThis code also violates ERR33-C. Detect and handle standard library errors .",
          "code": "#include <png.h> /* From libpng */\n#include <string.h>\n \nvoid func(png_structp png_ptr, int length, const void *user_data) { \n  png_charp chunkdata;\n  chunkdata = (png_charp)png_malloc(png_ptr, length + 1);\n  /* ... */\n  memcpy(chunkdata, user_data, length);\n  /* ... */\n }",
          "explanation_after": "If length has the value −1 , the addition yields 0, and png_malloc() subsequently returns a null pointer, which is assigned to chunkdata . The chunkdata pointer is later used as a destination argument in a call to memcpy() , resulting in user-defined data overwriting memory starting at address 0. In the case of the ARM and XScale architectures, the 0x0 address is mapped in memory and serves as the exception vector table; consequently, dereferencing 0x0 did not cause an abnormal program termination ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution ensures that the pointer returned by png_malloc() is not null. It also uses the unsigned type size_t to pass the length parameter, ensuring that negative values are not passed to func() .\n\nThis solution also ensures that the user_data pointer is not null. Passing a null pointer to memcpy() would produce undefined behavior, even if the number of bytes to copy were 0.  The user_data pointer could be invalid in other ways, such as pointing to freed memory. However there is no portable way to verify that the pointer is valid, other than checking for null.",
          "code": "#include <png.h> /* From libpng */\n#include <string.h>\n\n void func(png_structp png_ptr, size_t length, const void *user_data) { \n  png_charp chunkdata;\n  if (length == SIZE_MAX) {\n    /* Handle error */\n  }\n  if (NULL == user_data) {\n    /* Handle error */\n  }\n  chunkdata = (png_charp)png_malloc(png_ptr, length + 1);\n  if (NULL == chunkdata) {\n    /* Handle error */\n  }\n  /* ... */\n  memcpy(chunkdata, user_data, length);\n  /* ... */\n\n }",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, input_str is copied into dynamically allocated memory referenced by c_str . If malloc() fails, it returns a null pointer that is assigned to c_str . When c_str is dereferenced in memcpy() , the program exhibits undefined behavior .  Additionally, if input_str is a null pointer, the call to strlen() dereferences a null pointer, also resulting in undefined behavior. This code also violates ERR33-C. Detect and handle standard library errors .",
          "code": "#include <string.h>\n#include <stdlib.h>\n \nvoid f(const char *input_str) {\n  size_t size = strlen(input_str) + 1;\n  char *c_str = (char *)malloc(size);\n  memcpy(c_str, input_str, size);\n  /* ... */\n  free(c_str);\n  c_str = NULL;\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution ensures that both input_str and the pointer returned by malloc() are not null:",
          "code": "#include <string.h>\n#include <stdlib.h>\n \nvoid f(const char *input_str) {\n  size_t size;\n  char *c_str;\n \n  if (NULL == input_str) {\n    /* Handle error */\n  }\n  \n  size = strlen(input_str) + 1;\n  c_str = (char *)malloc(size);\n  if (NULL == c_str) {\n    /* Handle error */\n  }\n  memcpy(c_str, input_str, size);\n  /* ... */\n  free(c_str);\n  c_str = NULL;\n  /* ... */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example is from a version of drivers/net/tun.c and affects Linux kernel 2.6.30 [ Goodin 2009 ]:",
          "code": "static unsigned int tun_chr_poll(struct file *file, poll_table *wait)  {\n  struct tun_file *tfile = file->private_data;\n  struct tun_struct *tun = __tun_get(tfile);\n  struct sock *sk = tun->sk;\n  unsigned int mask = 0;\n\n  if (!tun)\n    return POLLERR;\n\n  DBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\n  poll_wait(file, &tun->socket.wait, wait);\n\n  if (!skb_queue_empty(&tun->readq))\n    mask |= POLLIN | POLLRDNORM;\n\n  if (sock_writeable(sk) ||\n     (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n     sock_writeable(sk)))\n    mask |= POLLOUT | POLLWRNORM;\n\n  if (tun->dev->reg_state != NETREG_REGISTERED)\n    mask = POLLERR;\n\n  tun_put(tun);\n  return mask;\n}\n",
          "explanation_after": "The sk pointer is initialized to tun->sk before checking if tun is a null pointer. Because null pointer dereferencing is undefined behavior , the compiler (GCC in this case) can optimize away the if (!tun) check because it is performed after tun->sk is accessed, implying that tun is non-null. As a result, this noncompliant code example is vulnerable to a null pointer dereference exploit, because null pointer dereferencing can be permitted on several platforms, for example, by using mmap(2) with the MAP_FIXED flag on Linux and Mac OS X, or by using the shmat() POSIX function with the SHM_RND flag [ Liu 2009 ]."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution eliminates the null pointer deference by initializing sk to tun->sk following the null pointer check. It also adds assertions to document that certain other pointers must not be null.",
          "code": "static unsigned int tun_chr_poll(struct file *file, poll_table *wait)  {\n  assert(file);\n  struct tun_file *tfile = file->private_data;\n  struct tun_struct *tun = __tun_get(tfile);\n  struct sock *sk;\n  unsigned int mask = 0;\n\n  if (!tun)\n    return POLLERR;\n  assert(tun->dev);\n  sk = tun->sk;\n  assert(sk);\n  assert(sk->socket);\n  /* The remaining code is omitted because it is unchanged... */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Dereferencing a null pointer is undefined behavior , typically abnormal program termination . In some situations, however, dereferencing a null pointer can lead to the execution of arbitrary code [ Jack 2007 , van Sprundel 2006 ]. The indicated severity is for this more severe case; on platforms where it is not possible to exploit a null pointer dereference to execute arbitrary code, the actual severity is low.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "EXP35-C",
    "title": "Do not modify objects with temporary lifetime",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP35-C.+Do+not+modify+objects+with+temporary+lifetime",
    "description": "The C11 Standard [ ISO/IEC 9899:2011 ] introduced a new term: temporary lifetime . This term still remains in the C23 Standard. Modifying an object with temporary lifetime is undefined behavior . According to subclause 6.2.4, paragraph 8 [ ISO/IEC 9899:2024 ]\n\nA non-lvalue expression with structure or union type, where the structure or union contains a member with array type (including, recursively, members of all contained structures and unions) refers to an object with automatic storage duration and temporary lifetime . Its lifetime begins when the expression is evaluated and its initial value is the value of the expression. Its lifetime ends when the evaluation of the containing full expression ends. Any attempt to modify an object with temporary lifetime results in undefined behavior.\n\nThis definition differs from the C99 Standard (which defines modifying the result of a function call or accessing it after the next sequence point as undefined behavior) because a temporary object's lifetime ends when the evaluation containing the full expression or full declarator ends, so the result of a function call can be accessed. This extension to the lifetime of a temporary also removes a quiet change to C90 and improves compatibility with C++.\n\nC functions may not return arrays; however, functions can return a pointer to an array or a struct or union that contains arrays. Consequently, in any version of C, if a function call returns by value a struct or union containing an array, do not modify those arrays within the expression containing the function call. In C99 and older, do not access an array returned by a function after the next sequence point or after the evaluation of the containing full expression or full declarator ends.\n\nstruct\n\nunion\n\nstruct\n\nunion",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example conforms to the C11 Standard; however, it fails to conform to C99. If compiled with a C99-conforming implementation, this code has undefined behavior 34 because the sequence point preceding the call to printf() comes between the call and the access by printf() of the string in the returned object.",
          "code": "#include <stdio.h>\n\nstruct X { char a[8]; };\n\nstruct X salutation(void) {\n  struct X result = { \"Hello\" };\n  return result;\n}\n\nstruct X addressee(void) {\n  struct X result = { \"world\" };\n  return result;\n}\n\nint main(void) {\n  printf(\"%s, %s!\\n\", salutation().a, addressee().a);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (C11 and newer)",
          "pre_code_commentary": "This compliant solution checks __STDC_VERSION__ to ensure that a pre-C11 compiler will fail to compile the code, rather than invoking undefined behavior.",
          "code": "#include <stdio.h>\n\n#if __STDC_VERSION__ < 201112L\n#error This code requires a compiler supporting the C11 standard or newer\n#endif\n\nstruct X { char a[8]; };\n\nstruct X salutation(void) {\n  struct X result = { \"Hello\" };\n  return result;\n}\n\nstruct X addressee(void) {\n  struct X result = { \"world\" };\n  return result;\n}\n\nint main(void) {\n  printf(\"%s, %s!\\n\", salutation().a, addressee().a);\n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example conforms to the C11 Standard; however, it fails to conform to C99. If compiled with a C99-conforming implementation, this code has undefined behavior 34 because the sequence point preceding the call to printf() comes between the call and the access by printf() of the string in the returned object.",
          "code": "#include <stdio.h>\n\nstruct X { char a[8]; };\n\nstruct X salutation(void) {\n  struct X result = { \"Hello\" };\n  return result;\n}\n\nstruct X addressee(void) {\n  struct X result = { \"world\" };\n  return result;\n}\n\nint main(void) {\n  printf(\"%s, %s!\\n\", salutation().a, addressee().a);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution stores the structures returned by the call to addressee() before calling the printf() function. Consequently, this program conforms to both C99 and C11.",
          "code": "#include <stdio.h>\n\nstruct X { char a[8]; };\n \nstruct X salutation(void) {\n  struct X result = { \"Hello\" };\n  return result;\n}\n\nstruct X addressee(void) {\n  struct X result = { \"world\" };\n  return result;\n}\n\nint main(void) {\n  struct X my_salutation = salutation();\n  struct X my_addressee = addressee();\n \n  printf(\"%s, %s!\\n\", my_salutation.a, my_addressee.a);\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to retrieve an array and increment the array's first value. The array is part of a struct that is returned by a function call. Consequently, the array has temporary lifetime, and modifying the array is undefined behavior in both C99 and C11.",
          "code": "#include <stdio.h>\n\nstruct X { int a[6]; };\n\nstruct X addressee(void) {\n  struct X result = { { 1, 2, 3, 4, 5, 6 } };\n  return result;\n}\n\nint main(void) {\n  printf(\"%x\", ++(addressee().a[0]));\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution stores the structure returned by the call to addressee() as my_x before calling the printf() function. When the array is modified, its lifetime is no longer temporary but matches the lifetime of the block in main() .",
          "code": "#include <stdio.h>\n\nstruct X { int a[6]; };\n\nstruct X addressee(void) {\n  struct X result = { { 1, 2, 3, 4, 5, 6 } };\n  return result;\n}\n\nint main(void) {\n  struct X my_x = addressee();\n  printf(\"%x\", ++(my_x.a[0]));\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to save a pointer to an array that is part of a struct that is returned by a function call. Consequently, the array has temporary lifetime, and using the pointer to it outside of the full expression is undefined behavior in both C99 and C11.",
          "code": "#include <stdio.h>\n\nstruct X { int a[6]; };\n\nstruct X addressee(void) {\n  struct X result = { { 1, 2, 3, 4, 5, 6 } };\n  return result;\n}\n\nint main(void) {\n  int *my_a = addressee().a;\n  printf(\"%x\", my_a[0]);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution stores the structure returned by the call to addressee() as my_x before saving a pointer to its array member. When the pointer is used, its lifetime is no longer temporary but matches the lifetime of the block in main() .",
          "code": "#include <stdio.h>\n\nstruct X { int a[6]; };\n\nstruct X addressee(void) {\n  struct X result = { { 1, 2, 3, 4, 5, 6 } };\n  return result;\n}\n\nint main(void) {\n  struct X my_x = addressee();\n  int *my_a = my_x.a;\n  printf(\"%x\", my_a[0]);\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Attempting to modify an array or access it after its lifetime expires may result in erroneous program behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP36-C",
    "title": "Do not cast pointers into more strictly aligned pointer types",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP36-C.+Do+not+cast+pointers+into+more+strictly+aligned+pointer+types",
    "description": "Do not convert a pointer value to a pointer type that is more strictly aligned than the referenced type. Different alignments are possible for different types of objects. If the type-checking system is overridden by an explicit cast or the pointer is converted to a void pointer ( void * ) and then to a different type, the alignment of an object may be changed.\n\nvoid *\n\nThe C Standard, 6.3.2.3, paragraph 7 [ ISO/IEC 9899:2024 ], states\n\nA pointer to an object type may be converted to a pointer to a different object type. If the resulting pointer is not correctly aligned for the referenced type, the behavior is undefined.\n\nSee undefined behavior 24.\n\nIf the misaligned pointer is dereferenced, the program may terminate abnormally . On some architectures, the cast alone may cause a loss of information even if the value is not dereferenced if the types involved have differing alignment requirements.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, the char pointer &c is converted to the more strictly aligned int pointer ip . On some implementations , cp will not match &c . As a result, if a pointer to one object type is converted to a pointer to a different object type, the second object type must not require stricter alignment than the first.",
          "code": "#include <assert.h>\n \nvoid func(void) {\n  char c = 'x';\n  int *ip = (int *)&c; /* This can lose information */\n  char *cp = (char *)ip;\n\n  /* Will fail on some conforming implementations */\n  assert(cp == &c);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Intermediate Object)",
          "pre_code_commentary": "In this compliant solution, the char value is stored into an object of type int so that the pointer's value will be properly aligned:",
          "code": "#include <assert.h>\n \nvoid func(void) {\n  char c = 'x';\n  int i = c;\n  int *ip = &i;\n\n  assert(ip == &i);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The C Standard allows any object pointer to be cast to and from void * . As a result, it is possible to silently convert from one pointer type to another without the compiler diagnosing the problem by storing or casting a pointer to void * and then storing or casting it to the final type. In this noncompliant code example, loop_function() is passed the char pointer char_ptr but returns an object of type int pointer:",
          "code": "int *loop_function(void *v_pointer) {\n  /* ... */\n  return v_pointer;\n}\n \nvoid func(char *char_ptr) {\n  int *int_ptr = loop_function(char_ptr);\n\n  /* ... */\n}",
          "explanation_after": "This example compiles without warning using GCC 4.8 on Ubuntu Linux 14.04. However, int_pointer can be more strictly aligned than an object of type char * ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Because the input parameter directly influences the return value, and loop_function() returns an object of type int * , the formal parameter v_pointer is redeclared to accept only an object of type int * :",
          "code": "int *loop_function(int *v_pointer) {\n  /* ... */\n  return v_pointer;\n}\n \nvoid func(int *loop_ptr) {\n  int *int_ptr = loop_function(loop_ptr);\n\n  /* ... */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Some architectures require that pointers are correctly aligned when accessing objects larger than a byte. However, it is common in system code that unaligned data (for example, the network stacks) must be copied to a properly aligned memory location, such as in this noncompliant code example:",
          "code": "#include <string.h>\n \nstruct foo_header {\n  int len;\n  /* ... */\n};\n \nvoid func(char *data, size_t offset) {\n  struct foo_header *tmp;\n  struct foo_header header;\n\n  tmp = (struct foo_header *)(data + offset);\n  memcpy(&header, tmp, sizeof(header));\n\n  /* ... */\n}",
          "explanation_after": "Assigning an unaligned value to a pointer that references a type that needs to be aligned is undefined behavior 24 . An implementation may notice, for example, that tmp and header must be aligned and use an inline memcpy() that uses instructions that assume aligned data."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution avoids the use of the foo_header pointer:",
          "code": "#include <string.h>\n \nstruct foo_header {\n  int len;\n  /* ... */\n};\n  \nvoid func(char *data, size_t offset) {\n  struct foo_header header; \n  memcpy(&header, data + offset, sizeof(header));\n\n  /* ... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Accessing a pointer or an object that is not properly aligned can cause a program to crash or give erroneous information, or it can cause slow pointer accesses (if the architecture allows misaligned accesses).",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP37-C",
    "title": "Call functions with the correct number and type of arguments",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP37-C.+Call+functions+with+the+correct+number+and+type+of+arguments",
    "description": "Do not call a function with the wrong number or type of arguments.\n\nThe C Standard identifies two distinct situations in which undefined behavior (UB) may arise as a result of invoking a function using a declaration that is incompatible with its definition or by supplying incorrect types or numbers of arguments:\n\nUB Description 25 A pointer is used to call a function whose type is not compatible with the referenced type (6.3.2.3). 37 A function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function (6.5.2.2).\n\nFunctions that are appropriately declared (as in DCL40-C. Do not create incompatible declarations of the same function or object ) will typically generate a compiler diagnostic message if they are supplied with the wrong number or types of arguments. However, there are cases in which supplying the incorrect arguments to a function will, at best, generate compiler warnings . Although such warnings should be resolved, they do not prevent program compilation. (See MSC00-C. Compile cleanly at high warning levels .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The header <tgmath.h> provides type-generic macros for math functions. Although most functions from the <math.h> header have a complex counterpart in <complex.h> , several functions do not. Calling any of the following type-generic functions with complex values is undefined behavior 205 .\n\nFunctions That Should Not Be Called with Complex Values\n\nThis noncompliant code example attempts to take the base-2 logarithm of a complex number, resulting in undefined behavior:",
          "code": "#include <tgmath.h>\n \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log2(c);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Complex Number)",
          "pre_code_commentary": "If the clog2() function is not available for an implementation as an extension, the programmer can take the base-2 logarithm of a complex number, using log() instead of log2() , because log() can be used on complex arguments, as shown in this compliant solution:",
          "code": "#include <tgmath.h>\n \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log(c)/log(2);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The header <tgmath.h> provides type-generic macros for math functions. Although most functions from the <math.h> header have a complex counterpart in <complex.h> , several functions do not. Calling any of the following type-generic functions with complex values is undefined behavior 205 .\n\nFunctions That Should Not Be Called with Complex Values\n\nThis noncompliant code example attempts to take the base-2 logarithm of a complex number, resulting in undefined behavior:",
          "code": "#include <tgmath.h>\n \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log2(c);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Real Number)",
          "pre_code_commentary": "The programmer can use this compliant solution if the intent is to take the base-2 logarithm of the real part of the complex number:",
          "code": "#include <tgmath.h>\n \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log2(creal(c));\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, the C standard library function strchr() is called through the function pointer fp declared with a prototype with incorrectly typed arguments. According to the C Standard, 6.3.2.3, paragraph 8 [ ISO/IEC 9899:2024 ]\n\nA pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the referenced type, the behavior is undefined.\n\nSee undefined behavior 25.",
          "code": "#include <stdio.h>\n#include <string.h>\n\nchar *(*fp)();\n\nint main(void) {\n  const char *c;\n  fp = strchr;\n  c = fp('e', \"Hello\");\n  printf(\"%s\\n\", c);\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the function pointer fp , which points to the C standard library function strchr() , is declared with the correct parameters and is invoked with the correct number and type of arguments:",
          "code": "#include <stdio.h>\n#include <string.h>\n\nchar *(*fp)(const char *, int);\n\nint main(void) {\n  const char *c;\n  fp = strchr;\n  c = fp(\"Hello\",'e');\n  printf(\"%s\\n\", c);\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, the function f() is defined to take an argument of type long but f() is called from another file with an argument of type int :",
          "code": "/* In another source file */\nlong f(long x) {\n  return x < 0 ? -x : x;\n}\n\n/* In this source file, no f prototype in scope */\nlong f();\n \nlong g(int x) {\n  return f(x);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the prototype for the function f() is included in the source file in the scope of where it is called, and the function f() is correctly called with an argument of type long :",
          "code": "/* In another source file */\n \nlong f(long x) {\n  return x < 0 ? -x : x;\n}\n\n/* f prototype in scope in this source file */\n\nlong f(long x); \n\nlong g(int x) {\n  return f((long)x);  \n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "The POSIX function open() [ IEEE Std 1003.1:2013 ] is a variadic function with the following prototype:",
          "code": "int open(const char *path, int oflag, ... );\n",
          "explanation_after": "The open() function accepts a third argument to determine a newly created file's access mode. If open() is used to create a new file and the third argument is omitted, the file may be created with unintended access permissions. (See FIO06-C. Create files with appropriate access permissions .)\n\nIn this noncompliant code example from a vulnerability in the useradd() function of the shadow-utils package CVE-2006-1174 , the third argument to open() is accidentally omitted:\n\nTechnically, it is incorrect to pass a third argument to open() when not creating a new file (that is, with the O_CREAT flag not set)."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "In this compliant solution, a third argument is specified in the call to open() :",
          "code": "#include <fcntl.h>\n \nvoid func(const char *ms, mode_t perms) {\n  /* ... */\n  int fd;\n  fd = open(ms, O_CREAT | O_EXCL | O_WRONLY | O_TRUNC, perms);\n  if (fd == -1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Calling a function with incorrect arguments can result in unexpected or unintended program behavior.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP39-C",
    "title": "Do not access a variable through a pointer of an incompatible type",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP39-C.+Do+not+access+a+variable+through+a+pointer+of+an+incompatible+type",
    "description": "Modifying a variable through a pointer of an incompatible type (other than unsigned char ) can lead to unpredictable results. Subclause 6.2.7 of the C Standard states that two types may be distinct yet compatible and addresses precisely when two distinct types are compatible.\n\nunsigned char\n\nThis problem is often caused by a violation of aliasing rules. The C Standard, 6.5, paragraph 7 [ ISO/IEC 9899:2024 ], specifies those circumstances in which an object may or may not be aliased.\n\nAn object shall have its stored value accessed only by an lvalue expression that has one of the following types: a type compatible with the effective type of the object, a qualified version of a type compatible with the effective type of the object, the signed or unsigned type compatible with the underlying type of the effective type of the object, the signed or unsigned type compatible with a qualified version of the underlying type of the effective type of the object, an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or a character type.\n\nAccessing an object by means of any other lvalue expression (other than unsigned char ) is undefined behavior 36 .\n\nunsigned char",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, an object of type float is incremented through an int * . The programmer can use the unit in the last place to get the next representable value for a floating-point type.  However, accessing an object through a pointer of an incompatible type is undefined behavior.",
          "code": "#include <stdio.h>\n \nvoid f(void) {\n  if (sizeof(int) == sizeof(float)) {\n    float f = 0.0f;\n    int *ip = (int *)&f;\n    (*ip)++;\n    printf(\"float is %f\\n\", f);\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the standard C function nextafterf() is used to round toward the highest representable floating-point value:",
          "code": "#include <float.h>\n#include <math.h>\n#include <stdio.h>\n \nvoid f(void) {\n  float f = 0.0f;\n  f = nextafterf(f, FLT_MAX);\n  printf(\"float is %f\\n\", f);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, an array of two values of type short is treated as an integer and assigned an integer value. The resulting values are indeterminate.",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  short a[2];\n  a[0]=0x1111;\n  a[1]=0x1111;\n\n  *(int *)a = 0x22222222;\n\n  printf(\"%x %x\\n\", a[0], a[1]);\n}",
          "explanation_after": "When translating this code, an implementation can assume that no access through an integer pointer can change the array a , consisting of shorts. Consequently, printf() may be called with the original values of a[0] and a[1] .\n\nRecent versions of GCC turn on the option -fstrict-aliasing, which allows alias-based optimizations, by default with -O2 . Some architectures then print \"1111 1111\" as a result. Without optimization, the executable generates the expected output \"2222 2222.\"\n\nTo disable optimizations based on alias analysis for faulty legacy code, the option -fno-strict-aliasing can be used as a workaround. The option -Wstrict-aliasing, which is included in -Wall, warns about some, but not all, violations of aliasing rules when -fstrict-aliasing is active.\n\nWhen GCC 3.4.6 compiles this code with optimization, the assignment through the aliased pointer is effectively eliminated."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses a union type that includes a type compatible with the effective type of the object:",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  union {\n    short a[2];\n    int i;\n  } u;\n\n  u.a[0]=0x1111;\n  u.a[1]=0x1111;\n  u.i = 0x22222222;\n\n  printf(\"%x %x\\n\", u.a[0], u.a[1]);\n\n  /* ... */\n}",
          "explanation_after": "The C standard states:\n\nIf the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called “type punning”). This might be a trap representation\n\nThe call to printf() typically outputs \"2222 2222\". However, there is no guarantee that this will be true; the object representations of a and i are unspecified and need not be compatible in this way, despite this operation being commonly accepted as an implementation extension. (See unspecified behavior 11 .)"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a gadget object is allocated, then realloc() is called to create a widget object using the memory from the gadget object. Although reusing memory to change types is acceptable, accessing the memory copied from the original object is undefined behavior.",
          "code": "#include <stdlib.h>\n \nstruct gadget {\n  int i;\n  double d;\n  char *p;\n};\n \nstruct widget {\n  char *q;\n  int j;\n  double e;\n};\n \nvoid func(void) {\n  struct gadget *gp;\n  struct widget *wp;\n \n  gp = (struct gadget *)malloc(sizeof(struct gadget));\n  if (!gp) {\n    /* Handle error */\n  }\n  /* ... Initialize gadget ... */\n  wp = (struct widget *)realloc(gp, sizeof(struct widget));\n  if (!wp) {\n    free(gp);\n    /* Handle error */\n  }\n  if (wp->j == 12) {\n    /* ... */\n  }\n  /* ... */\n  free(wp);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution reuses the memory from the gadget object but reinitializes the memory to a consistent state before reading from it:",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nstruct gadget {\n  int i;\n  double d;\n  char *p;\n};\n \nstruct widget {\n  char *q;\n  int j;\n  double e;\n};\n \nvoid func(void) {\n  struct gadget *gp;\n  struct widget *wp;\n \n  gp = (struct gadget *)malloc(sizeof (struct gadget));\n  if (!gp) {\n    /* Handle error */\n  }\n  /* ... */\n  wp = (struct widget *)realloc(gp, sizeof(struct widget));\n  if (!wp) {\n    free(gp);\n    /* Handle error */\n  }\n  memset(wp, 0, sizeof(struct widget));\n  /* ... Initialize widget ... */\n\n  if (wp->j == 12) {\n    /* ... */\n  }\n  /* ... */\n  free(wp);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "According to the C Standard, 6.7.7.3 [ ISO/IEC 9899:2024 ], using two or more incompatible arrays in an expression is undefined behavior . (See also undefined behavior 73 .)\n\nFor two array types to be compatible, both should have compatible underlying element types, and both size specifiers should have the same constant value. If either of these properties is violated, the resulting behavior is undefined.\n\nIn this noncompliant code example, the two arrays a and b fail to satisfy the equal size specifier criterion for array compatibility. Because a and b are not equal, writing to what is believed to be a valid member of a might exceed its defined memory boundary, resulting in an arbitrary memory overwrite.",
          "code": "enum { ROWS = 10, COLS = 15 };\n \nvoid func(void) {\n  int a[ROWS][COLS];\n  int (*b)[ROWS] = a;\n}",
          "explanation_after": "Most compilers will produce a warning diagnostic if the two array types used in an expression are incompatible."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, b is declared to point to an array with the same number of elements as a , satisfying the size specifier criterion for array compatibility:",
          "code": "enum { ROWS = 10, COLS = 15 };\n \nvoid func(void) {\n  int a[ROWS][COLS];\n  int (*b)[COLS] = a;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Optimizing for performance can lead to aliasing errors that can be quite difficult to detect. Furthermore, as in the preceding example, unexpected results can lead to buffer overflow attacks, bypassing security checks, or unexpected execution.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP40-C",
    "title": "Do not modify constant objects",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP40-C.+Do+not+modify+constant+objects",
    "description": "The C Standard, 6.7.4, paragraph 7 [ IS O/IEC 9899:2024 ], states\n\nIf an attempt is made to modify an object defined with a const -qualified type through use of an lvalue with non- const -qualified type, the behavior is undefined.\n\nconst\n\nconst\n\nSee also undefined behavior 61 .\n\nThere are existing compiler implementations that allow const -qualified objects to be modified without generating a warning message.\n\nconst\n\nAvoid casting away const qualification because doing so makes it possible to modify const -qualified objects without issuing diagnostics. (See EXP05-C. Do not cast away a const qualification and STR30-C. Do not attempt to modify string literals for more details.)\n\nconst\n\nconst",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example allows a constant object to be modified:",
          "code": "const int **ipp;\nint *ip;\nconst int i = 42;\n\nvoid func(void) {\n  ipp = &ip; /* Constraint violation */\n  *ipp = &i; /* Valid */\n  *ip = 0;   /* Modifies constant i (was 42) */\n}",
          "explanation_after": "The first assignment is unsafe because it allows the code that follows it to attempt to change the value of the const object i .\n\nIf ipp , ip , and i are declared as automatic variables, this example compiles without warning with Microsoft Visual Studio 2013 when compiled in C mode ( /TC ) and the resulting program changes the value of i . GCC 4.8.1 generates a warning but compiles, and the resulting program changes the value of i .\n\nIf ipp , ip , and i are declared with static storage duration, this program compiles without warning and terminates abnormally with Microsoft Visual Studio 2013, and compiles with warning and terminates abnormally with GCC 4.8.1."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution depends on the intent of the programmer. If the intent is that the value of i is modifiable, then it should not be declared as a constant, as in this compliant solution:",
          "code": "int **ipp;\nint *ip;\nint i = 42;\n\nvoid func(void) {\n  ipp = &ip; /* Valid */\n  *ipp = &i; /* Valid */\n  *ip = 0; /* Valid */\n}",
          "explanation_after": "If the intent is that the value of i is not meant to change, then do not write noncompliant code that attempts to modify it."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Modifying constant objects through nonconstant references is undefined behavior 61 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP42-C",
    "title": "Do not compare padding data",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP42-C.+Do+not+compare+padding+data",
    "description": "The C Standard, 6.7.3.2 paragraph 19 [ ISO/IEC 9899:2024 ], states\n\nThere may be unnamed padding within a structure object, but not at its beginning. . . . There may be unnamed padding at the end of a structure or union.\n\nSubclause 6.7.11, paragraph 10, states that\n\nunnamed members of objects of structure and union type do not participate in initialization. Unnamed members of structure objects have indeterminate representation even after initialization.\n\nThe only exception is that padding bits are set to zero when a static or thread-local object is implicitly initialized (paragraph 11):\n\nIf an object that has static or thread storage duration is not initialized explicitly, or any object is initialized with an empty initializer, then it is subject to default initialization , which initializes an object as follows: —  if it is an aggregate, every member is initialized (recursively) according to these rules, and any padding is initialized to zero bits; —  if it is a union, the first named member is initialized (recursively) according to these rules, and any padding is initialized to zero bits.\n\nBecause these padding values are unspecified, attempting a byte-by-byte comparison between structures can lead to incorrect results [ Summit 1995 ].",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, memcmp() is used to compare the contents of two structures, including any padding bytes:",
          "code": "#include <string.h>\n \nstruct s {\n  char c;\n  int i;\n  char buffer[13];\n};\n \nvoid compare(const struct s *left, const struct s *right) {  \n  if ((left && right) &&\n      (0 == memcmp(left, right, sizeof(struct s)))) {\n    /* ... */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, all of the fields are compared manually to avoid comparing any padding bytes:",
          "code": "#include <string.h>\n \nstruct s {\n  char c;\n  int i;\n  char buffer[13];\n};\n \nvoid compare(const struct s *left, const struct s *right) {  \n  if ((left && right) &&\n      (left->c == right->c) &&\n      (left->i == right->i) &&\n      (0 == memcmp(left->buffer, right->buffer, 13))) {\n    /* ... */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Comparing padding bytes, when present, can lead to unexpected program behavior .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "EXP43-C",
    "title": "Avoid undefined behavior when using restrict-qualified pointers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP43-C.+Avoid+undefined+behavior+when+using+restrict-qualified+pointers",
    "description": "An object that is accessed through a restrict -qualified pointer has a special association with that pointer. This association requires that all accesses to that object use, directly or indirectly, the value of that particular pointer. The intended use of the restrict qualifier is to promote optimization, and deleting all instances of the qualifier from a program does not change its meaning (that is, observable behavior). In the absence of this qualifier, other pointers can alias this object. Caching the value in an object designated through a restrict -qualified pointer is safe at the beginning of the block in which the pointer is declared because no preexisting aliases may also be used to reference that object. The cached value must be restored to the object by the end of the block, where preexisting aliases again become available. New aliases may be formed within the block, but these must all depend on the value of the restrict -qualified pointer so that they can be identified and adjusted to refer to the cached value. For a restrict -qualified pointer at file scope, the block is the body of each function in the file [ Walls 2006 ]. Developers should be aware that C++ does not support the restrict qualifier, but some C++ compiler implementations support an equivalent qualifier as an extension.\n\nrestrict\n\nrestrict\n\nrestrict\n\nrestrict\n\nrestrict\n\nThe C Standard [ ISO/IEC 9899:2024 ] identifies the following undefined behavior 66 :\n\nA restrict-qualified pointer is assigned a value based on another restricted pointer whose associated block neither began execution before the block associated with this pointer, nor ended before the assignment (6.7.4.2).\n\nThis is an oversimplification, however, and it is important to review the formal definition of restrict in subclause 6.7.3.1 of the C Standard to properly understand undefined behaviors associated with the use of restrict -qualified pointers.\n\nrestrict",
    "examples": null,
    "risk_assessment": {
      "explanation": "The incorrect use of restrict -qualified pointers can result in undefined behavior 66\n\nthat might be exploited to cause data integrity violations.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP44-C",
    "title": "Do not rely on side effects in operands to sizeof, _Alignof, or _Generic",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP44-C.+Do+not+rely+on+side+effects+in+operands+to+sizeof%2C+_Alignof%2C+or+_Generic",
    "description": "Some operators do not evaluate their operands beyond the type information the operands provide. When using one of these operators, do not pass an operand that would otherwise yield a side effect since the side effect will not be generated.\n\nThe sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type.  In most cases, the operand is not evaluated.  A possible exception is when the type of the operand is a variable length array type (VLA); then the expression is evaluated. When part of the operand of the sizeof operator is a VLA type and when changing the value of the VLA's size expression would not affect the result of the operator, it is unspecified whether or not the size expression is evaluated. (See unspecified behavior 22 .)\n\nsizeof\n\nThe operand passed to _Alignof is never evaluated, despite not being an expression. For instance, if the operand is a VLA type and the VLA's size expression contains a side effect, that side effect is never evaluated.\n\n_Alignof\n\nThe operand used in the controlling expression of a _Generic selection expression is never evaluated.\n\n_Generic\n\nProviding an expression that appears to produce side effects may be misleading to programmers who are not aware that these expressions are not evaluated, and in the case of a VLA used in sizeof , have unspecified results. As a result, programmers may make invalid assumptions about program state, leading to errors and possible software vulnerabilities .\n\nsizeof\n\nThis rule is similar to PRE31-C. Avoid side effects in arguments to unsafe macros .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( sizeof )",
          "pre_code_commentary": "In this noncompliant code example, the expression a++ is not evaluated:",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  int a = 14;\n  int b = sizeof(a++);\n  printf(\"%d, %d\\n\", a, b);\n}",
          "explanation_after": "Consequently, the value of a after b has been initialized is 14."
        },
        "compliant": {
          "heading": "Compliant Solution ( sizeof )",
          "pre_code_commentary": "In this compliant solution, the variable a is incremented outside of the sizeof operation:",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  int a = 14;\n  int b = sizeof(a);\n  ++a;\n  printf(\"%d, %d\\n\", a, b);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( sizeof , VLA)",
          "pre_code_commentary": "In this noncompliant code example, the expression ++n in the initialization expression of a must be evaluated because its value affects the size of the VLA operand of the sizeof operator. However, in the initialization expression of b , the expression ++n % 1 evaluates to 0. This means that the value of n does not affect the result of the sizeof operator. Consequently, it is unspecified whether or not n will be incremented when initializing b .",
          "code": "#include <stddef.h>\n#include <stdio.h>\n  \nvoid f(size_t n) {\n  /* n must be incremented */ \n  size_t a = sizeof(int[++n]);\n \n  /* n need not be incremented */\n  size_t b = sizeof(int[++n % 1 + 1]);\n\n  printf(\"%zu, %zu, %zu\\n\", a, b, n);\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( sizeof , VLA)",
          "pre_code_commentary": "This compliant solution avoids changing the value of the variable n used in each sizeof expression and instead increments n safely afterwards:",
          "code": "#include <stddef.h>\n#include <stdio.h>\n  \nvoid f(size_t n) {\n  size_t a = sizeof(int[n + 1]);\n  ++n;\n\n  size_t b = sizeof(int[n % 1 + 1]);\n  ++n;\n  printf(\"%zu, %zu, %zu\\n\", a, b, n);\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( _Generic )",
          "pre_code_commentary": "This noncompliant code example attempts to modify a variable's value as part of the _Generic selection control expression. The programmer may expect that a is incremented, but because _Generic does not evaluate its control expression, the value of a is not modified.",
          "code": "#include <stdio.h>\n\n#define S(val) _Generic(val, int : 2, \\\n                             short : 3, \\\n                             default : 1)\nvoid func(void) {\n  int a = 0;\n  int b = S(a++);\n  printf(\"%d, %d\\n\", a, b);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( _Generic )",
          "pre_code_commentary": "In this compliant solution, a is incremented outside of the _Generic selection expression:",
          "code": "#include <stdio.h>\n\n#define S(val) _Generic(val, int : 2, \\\n                             short : 3, \\\n                             default : 1)\nvoid func(void) {\n  int a = 0;\n  int b = S(a);\n  ++a;\n  printf(\"%d, %d\\n\", a, b);\n} ",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( _Alignof )",
          "pre_code_commentary": "This noncompliant code example attempts to modify a variable while getting its default alignment value. The user may have expected val to be incremented as part of the _Alignof expression, but because _Alignof does not evaluate its operand, val is unchanged.",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  int val = 0; \n  /* ... */ \n  size_t align = _Alignof(int[++val]);\n  printf(\"%zu, %d\\n\", align, val);\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( _Alignof )",
          "pre_code_commentary": "This compliant solution moves the expression out of the _Alignof operator:",
          "code": "#include <stdio.h>\nvoid func(void) {\n  int val = 0; \n  /* ... */ \n  ++val;\n  size_t align = _Alignof(int[val]);\n  printf(\"%zu, %d\\n\", align, val);\n  /* ... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "If expressions that appear to produce side effects are supplied to an operator that does not evaluate its operands, the results may be different than expected. Depending on how this result is used, it can lead to unintended program behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "EXP45-C",
    "title": "Do not perform assignments in selection statements",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP45-C.+Do+not+perform+assignments+in+selection+statements",
    "description": "Do not use the assignment operator in the contexts listed in the following table because doing so typically indicates programmer error and can result in unexpected behavior .\n\nOperator Context if Controlling expression while Controlling expression do ... while Controlling expression for Second operand ?: First operand ?: Second or third operands, where the ternary expression is used in any of these contexts && Either operand || either operand , Second operand, when the comma expression is used in any of these contexts\n\nif\n\nwhile\n\ndo ... while\n\nfor\n\n?:\n\n?:\n\n&&\n\n||\n\n,\n\nPerforming assignment statements in other contexts do not violate this rule. However, they may violate other rules, such as EXP30-C. Do not depend on the order of evaluation for side effects .\n\nNoncompliant Code Example\n\nIn this noncompliant code example, an assignment expression is the outermost expression in an if statement:\n\nif\n\nif (a = b) {\n  /* ... */\n}\n\nif (a = b) {\n  /* ... */\n}\n\nAlthough the intent of the code may be to assign b to a and test the value of the result for equality to 0, it is frequently a case of the programmer mistakenly using the assignment operator = instead of the equals operator == . Consequently, many compilers will warn about this condition, making this coding error detectable by adhering to MSC00-C. Compile cleanly at high warning levels .\n\nb\n\na\n\n=\n\n==",
    "examples": [
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution (Unintentional Assignment)",
          "pre_code_commentary": "When the assignment of b to a is not intended, the conditional block is now executed when a is equal to b :",
          "code": "if (a == b) {\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution (Intentional Assignment)",
          "pre_code_commentary": "When the assignment is intended, this compliant solution explicitly uses inequality as the outermost expression while performing the assignment in the inner expression:",
          "code": "if ((a = b) != 0) {\n  /* ... */\n}\n",
          "explanation_after": "It is less desirable in general, depending on what was intended, because it mixes the assignment in the condition, but it is clear that the programmer intended the assignment to occur."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the expression x = y is used as the controlling expression of the while statement:",
          "code": " do { /* ... */ } while (foo(), x = y);",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Unintentional Assignment)",
          "pre_code_commentary": "When the assignment of y to x is not intended, the conditional block should be executed only when x is equal to y , as in this compliant solution:",
          "code": "do { /* ... */ } while (foo(), x == y); \n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the expression x = y is used as the controlling expression of the while statement:",
          "code": " do { /* ... */ } while (foo(), x = y);",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Intentional Assignment)",
          "pre_code_commentary": "When the assignment is intended, this compliant solution can be used:",
          "code": "do { /* ... */ } while (foo(), (x = y) != 0);\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the expression x = y is used as the controlling expression of the while statement:",
          "code": " do { /* ... */ } while (foo(), x = y);",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( for statement)",
          "pre_code_commentary": "The same result can be obtained using the for statement, which is specifically designed to evaluate an expression on each iteration of the loop, just before performing the test in its controlling expression. Remember that its controlling expression is the second operand, where the assignment occurs in its third operand:",
          "code": " for (; x; foo(), x = y) { /* ... */ }",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, the expression p = q is used as the controlling expression of the while statement:",
          "code": " do { /* ... */ } while (x = y, p = q);",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the expression x = y is not used as the controlling expression of the while statement:",
          "code": "do { /* ... */ } while (x = y, p == q); \n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example has a typo that results in an assignment rather than a comparison.\n\nMany compilers will warn about this condition. This coding error would typically be eliminated by adherence to MSC00-C. Compile cleanly at high warning levels . Although this code compiles, it will cause unexpected behavior to an unsuspecting programmer. If the intent was to verify a string such as a password, user name, or group user ID, the code may produce significant vulnerabilities and require significant debugging.\n\nWhen comparisons are made between a variable and a literal or const-qualified variable, placing the variable on the right of the comparison operation can prevent a spurious assignment.\n\nIn this code example, the literals are placed on the left-hand side of each comparison. If the programmer were to inadvertently use an assignment operator, the statement would assign ch to '\\t' , which is invalid and produces a diagnostic message.\n\nDue to the diagnostic, the typo will be easily spotted and fixed.\n\nAs a result, any mistaken use of the assignment operator that could otherwise create a vulnerability for operations such as string verification will result in a compiler diagnostic regardless of compiler, warning level, or implementation .\n\nEXP45-C-EX1 : Assignment can be used where the result of the assignment is itself an operand to a comparison expression or relational expression. In this compliant example, the expression x = y is itself an operand to a comparison operation:\n\nEXP45-C-EX2 : Assignment can be used where the expression consists of a single primary expression. The following code is compliant because the expression x = y is a single primary expression:\n\nThe following controlling expression is noncompliant because && is not a comparison or relational operator and the entire expression is not primary:\n\nWhen the assignment of v to w is not intended, the following controlling expression can be used to execute the conditional block when v is equal to w :\n\nWhen the assignment is intended, the following controlling expression can be used:\n\nEXP45-C-EX3 : Assignment can be used in a function argument or array index. In this compliant solution, the expression x = y is used in a function argument:\n\nErrors of omission can result in unintended program flow.\n\nRecommendation\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nEXP45-C\n\nLow\n\nLikely\n\nYes\n\nNo\n\nP6\n\nL2\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\n7.2.0\n\nCould detect violations of this recommendation by identifying any assignment expression as the top-level expression in an if or while statement\n\n24.11.0\n\nECLAIR\n\nCC2.EXP18 CC2.EXP21\n\nFully implemented\n\nCan detect violations of this recommendation when the -Wall flag is used\n\n2025.2\n\nC3314, C3326, C3344, C3416\n\nC++4071, C++4074\n\nASSIGCOND.CALL ASSIGCOND.GEN MISRA.ASSIGN.COND\n\n114 S, 132 S\n\nCERT_C-EXP45-b CERT_C-EXP45-d\n\nAssignment operators shall not be used in conditions without brackets Assignment operators shall not be used in expressions that yield a Boolean value\n\n1.4\n\n720\n\nPartially supported: reports Boolean test of unparenthesized assignment\n\nR2024b\n\n7.38\n\n24.04\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website .",
          "code": null,
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (RHS Variable)",
          "pre_code_commentary": "When comparisons are made between a variable and a literal or const-qualified variable, placing the variable on the right of the comparison operation can prevent a spurious assignment.\n\nIn this code example, the literals are placed on the left-hand side of each comparison. If the programmer were to inadvertently use an assignment operator, the statement would assign ch to '\\t' , which is invalid and produces a diagnostic message.",
          "code": "while ('\\t' = ch || ' ' == ch || '\\n' == ch) {\n  /* ... */\n}",
          "explanation_after": "Due to the diagnostic, the typo will be easily spotted and fixed.\n\nAs a result, any mistaken use of the assignment operator that could otherwise create a vulnerability for operations such as string verification will result in a compiler diagnostic regardless of compiler, warning level, or implementation ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP46-C",
    "title": "Do not use a bitwise operator with a Boolean-like operand",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP46-C.+Do+not+use+a+bitwise+operator+with+a+Boolean-like+operand",
    "description": "Mixing bitwise and relational operators in the same full expression can be a sign of a logic error in the expression where a logical operator is usually the intended operator. Do not use the bitwise AND ( & ), bitwise OR ( | ), or bitwise XOR ( ^ ) operators with an operand of type _Bool , or the result of a relational-expression or equality-expression . If the bitwise operator is intended, it should be indicated with use of a parenthesized expression.\n\n&\n\n|\n\n^\n\n_Bool",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a bitwise & operator is used with the results of two equality-expressions :",
          "code": "if (getuid() == 0 & getgid() == 0) { \n  /* ... */ \n} \n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses the && operator for the logical operation within the conditional expression:",
          "code": "if (getuid() == 0 && getgid() == 0) {\n  /* ... */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": null,
        "repairable": "Low",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP47-C",
    "title": "Do not call va_arg with an argument of the incorrect type",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/EXP47-C.+Do+not+call+va_arg+with+an+argument+of+the+incorrect+type",
    "description": "The variable arguments passed to a variadic function are accessed by calling the va_arg() macro. This macro accepts the va_list representing the variable arguments of the function invocation and the type denoting the expected argument type for the argument being retrieved. The macro is typically invoked within a loop, being called once for each expected argument. However, there are no type safety guarantees that the type passed to va_arg matches the type passed by the caller, and there are generally no compile-time checks that prevent the macro from being invoked with no argument available to the function call.\n\nva_arg()\n\nva_list\n\nva_arg\n\nThe C Standard, 7.16.1.1, states [ ISO/IEC 9899:2024 ], in part:\n\nIf type is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined, except for the following cases: —  both types are pointers to qualified or unqualified versions of compatible types; —  one type is compatible with a signed integer type, the other type is compatible with the corresponding unsigned integer type, and the value is representable in both types; —  one type is pointer to qualified or unqualified void and the other is a pointer to a qualified or unqualified character type; —  or, the type of the next argument is nullptr _ t and type is a pointer type that has the same representation and alignment requirements as a pointer to a character type.\n\nEnsure that an invocation of the va_arg() macro does not attempt to access an argument that was not passed to the variadic function. Further, the type passed to the va_arg() macro must match the type passed to the variadic function after default argument promotions have been applied. Either circumstance results in undefined behavior 141 .\n\nva_arg()\n\nva_arg()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to read a variadic argument of type unsigned char with va_arg() . However, when a value of type unsigned char is passed to a variadic function, the value undergoes default argument promotions, resulting in a value of type int being passed.",
          "code": "#include <stdarg.h>\n#include <stddef.h>\n\nvoid func(size_t num_vargs, ...) {\n  va_list ap;  \n  va_start(ap, num_vargs);\n  if (num_vargs > 0) {\n    unsigned char c = va_arg(ap, unsigned char);\n    // ...\n  }\n  va_end(ap);\n}\n \nvoid f(void) {\n  unsigned char c = 0x12;\n  func(1, c);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution accesses the variadic argument with type int , and then casts the resulting value to type unsigned char :",
          "code": "#include <stdarg.h>\n#include <stddef.h>\n\nvoid func(size_t num_vargs, ...) {\n  va_list ap;  \n  va_start(ap, num_vargs);\n  if (num_vargs > 0) {\n    unsigned char c = (unsigned char) va_arg(ap, int);\n    // ...\n  }\n  va_end(ap);\n}\n\nvoid f(void) {\n  unsigned char c = 0x12;\n  func(1, c);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example assumes that at least one variadic argument is passed to the function, and attempts to read it using the va_arg() macro. This pattern arises frequently when a variadic function uses a sentinel value to denote the end of the variable argument list. However, the caller passes no variadic arguments to the function, which results in undefined behavior.",
          "code": "#include <stdarg.h>\n \nvoid func(const char *cp, ...) {\n  va_list ap;  \n  va_start(ap, cp);\n  int val = va_arg(ap, int);\n  // ...\n  va_end(ap);\n}\n \nvoid f(void) {\n  func(\"The only argument\");\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Standard C provides no mechanism to enable a variadic function to determine how many variadic arguments are actually provided to the function call. That information must be passed in an out-of-band manner. Oftentimes this results in the information being encoded in the initial parameter, as in this compliant solution:",
          "code": "#include <stdarg.h>\n#include <stddef.h>\n\nvoid func(size_t num_vargs, const char *cp, ...) {\n  va_list ap;  \n  va_start(ap, cp);\n  if (num_vargs > 0) {\n    int val = va_arg(ap, int);\n    // ...\n  }\n  va_end(ap);\n}\n \nvoid f(void) {\n  func(0, \"The only argument\");\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrect use of va_arg() results in undefined behavior that can include accessing stack memory.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": null,
        "repairable": "High",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FIO01-C",
    "title": "Be careful using functions that use file names for identification",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification",
    "description": "Many file-related security vulnerabilities result from a program accessing an unintended file object because file names are only loosely bound to underlying file objects. File names provide no information regarding the nature of the file object itself. Furthermore, the binding of a file name to a file object is reasserted every time the file name is used in an operation. File descriptors and FILE pointers are bound to underlying file objects by the operating system. (See FIO03-C. Do not make assumptions about fopen() and file creation .)\n\nFILE\n\nAccessing files via file descriptors or FILE pointers rather than file names provides a greater degree of certainty as to which object is actually acted upon. It is recommended that files be accessed through file descriptors or FILE pointers where possible.\n\nFILE\n\nFILE\n\nThe following C functions rely solely on file names for file identification:\n\nremove() rename() fopen() freopen()\n\nremove()\n\nrename()\n\nfopen()\n\nfreopen()\n\nUse these functions with caution. See FIO10-C. Take care when using the rename() function , and FIO08-C. Take care when calling remove() on an open file .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the file identified by file_name is opened, processed, closed, and removed. However, it is possible that the file object identified by file_name in the call to remove() is not the same file object identified by file_name in the call to fopen() .",
          "code": "char *file_name;\nFILE *f_ptr;\n\n/* Initialize file_name */\n\nf_ptr = fopen(file_name, \"w\");\nif (f_ptr == NULL) {\n  /* Handle error */\n}\n\n/*... Process file ...*/\n\nif (fclose(f_ptr) != 0) {\n  /* Handle error */\n}\n\nif (remove(file_name) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Not much can be done programmatically to ensure the file removed is the same file that was opened, processed, and closed except to make sure that the file is opened in a secure directory with privileges that would prevent the file from being manipulated by an untrusted user. (See FIO15-C. Ensure that file operations are performed in a secure directory .)",
          "code": null,
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "In this noncompliant code example, the function chmod() is called to set the permissions of a file. However, it is not clear whether the file object referred to by file_name refers to the same object in the call to fopen() and in the call to chmod() .",
          "code": "char *file_name;\nFILE *f_ptr;\n\n/* Initialize file_name */\n\nf_ptr = fopen(file_name, \"w\");\nif (f_ptr == NULL)  {\n  /* Handle error */\n}\n\n/* ... */\n\nif (chmod(file_name, S_IRUSR) == -1) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution uses the POSIX fchmod() and open() functions [ IEEE Std 1003.1:2013 ]. Using these functions guarantees that the file opened is the same file that is operated on.",
          "code": "char *file_name;\nint fd;\n\n/* Initialize file_name */\n\nfd = open(\n  file_name,\n  O_WRONLY | O_CREAT | O_EXCL,\n  S_IRWXU\n);\nif (fd == -1) {\n  /* Handle error */\n}\n\n/* ... */\n\nif (fchmod(fd, S_IRUSR) == -1) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Many file-related vulnerabilities, such as time-of-check, time-of-use (TOCTOU) race conditions, can be exploited to cause a program to access an unintended file. Using FILE pointers or file descriptors to identify files instead of file names reduces the chance of accessing an unintended file. Remediation costs are medium because, although insecure functions can be easily identified, simple drop-in replacements are not always available.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "FIO02-C",
    "title": "Canonicalize path names originating from tainted sources",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources",
    "description": "Path names, directory names, and file names may contain characters that make validation difficult and inaccurate. Furthermore, any path name component can be a symbolic link, which further obscures the actual location or identity of a file. To simplify file name validation, it is recommended that names be translated into their canonical form. Canonicalizing file names makes it much easier to verify a path, directory, or file name by making it easier to compare names.\n\nBecause the canonical form can vary between operating systems and file systems, it is best to use operating-system-specific mechanisms for canonicalization.\n\nAs an illustration, here is a function that ensures that a path name refers to a file in the user's home directory on POSIX systems:\n\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n\nint verify_file(char *const filename) {\n  /* Get /etc/passwd entry for current user */\n  struct passwd *pwd = getpwuid(getuid());\n  if (pwd == NULL) {\n    /* Handle error */\n    return 0;\n  }\n\n  const size_t len = strlen( pwd->pw_dir);\n  if (strncmp( filename, pwd->pw_dir, len) != 0) {\n    return 0;\n  }\n  /* Make sure there is only one '/', immediately after homedir */\n  if (strrchr( filename, '/') == filename + len) {\n    return 1;\n  }\n  return 0;\n}\n\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n\nint verify_file(char *const filename) {\n  /* Get /etc/passwd entry for current user */\n  struct passwd *pwd = getpwuid(getuid());\n  if (pwd == NULL) {\n    /* Handle error */\n    return 0;\n  }\n\n  const size_t len = strlen( pwd->pw_dir);\n  if (strncmp( filename, pwd->pw_dir, len) != 0) {\n    return 0;\n  }\n  /* Make sure there is only one '/', immediately after homedir */\n  if (strrchr( filename, '/') == filename + len) {\n    return 1;\n  }\n  return 0;\n}\n\nThe verify_file() function requires that the file name be an absolute path name. Furthermore, it can be deceived if the file name being referenced is actually a symbolic link to a file name not in the users's home directory.\n\nverify_file()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, argv[1] contains a file name that originates from a tainted source and is opened for writing. Before this file name is used in file operations, it should be validated to ensure that it refers to an expected and valid file. Unfortunately, the file name referenced by argv[1] may contain special characters, such as directory characters, that make validation difficult if not impossible. Furthermore, any path name component in argv[1] may be a symbolic link, resulting in the file name referring to an invalid file even though it passes validation.\n\nIf validation is not performed correctly, the call to fopen() may result in an unintended file being accessed.",
          "code": "/* Verify argv[1] is supplied */\n\nif (!verify_file(argv[1])) {\n  /* Handle error */\n}\n\nif (fopen(argv[1], \"w\") == NULL) {\n  /* Handle error */\n}\n\n/* ... */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "Canonicalizing file names is difficult and involves an understanding of the underlying file system.\n\nThe POSIX realpath() function can assist in converting path names to their canonical form. According to Standard for Information Technology—Portable Operating System Interface (POSIX®), Base Specifications, Issue 7 (IEEE Std 1003.1, 2013 Edition) [ IEEE Std 1003.1:2013 ],\n\nThe realpath() function shall derive, from the pathname pointed to by file_name , an absolute pathname that names the same file, whose resolution does not involve ' . ', ' .. ', or symbolic links.\n\nFurther verification, such as ensuring that two successive slashes or unexpected special files do not appear in the file name, must be performed. See Section 4.12, \"Pathname Resolution,\" of IEEE Std 1003.1, 2013 Edition, for more details on how path name resolution is performed [ IEEE Std 1003.1:2013 ].\n\nMany manual pages for the realpath() function come with an alarming warning, such as this one from the Linux Programmer's Manual [ Linux 2008 ]:\n\nAvoid using this function. It is broken by design since (unless using the non-standard resolved_path == NULL feature) it is impossible to determine a suitable size for the output buffer, resolved_path . According to POSIX a buffer of size PATH_MAX suffices, but PATH_MAX need not be a defined constant, and may have to be obtained using pathconf(3) . And asking pathconf(3) does not really help, since on the one hand POSIX warns that the result of pathconf(3) may be huge and unsuitable for mallocing memory. And on the other hand pathconf(3) may return −1 to signify that PATH_MAX is not bounded. The libc4 and libc5 implementation contains a buffer overflow (fixed in libc-5.4.13). As a result, set-user-ID programs like mount(8) need a private version.\n\nThe realpath() function was changed in POSIX.1-2008. Older versions of POSIX allow implementation-defined behavior in situations where the resolved_name is a null pointer. The current POSIX revision and many current implementations (led by glibc and Linux) allocate memory to hold the resolved name if a null pointer is used for this argument.\n\nThe following statement can be used to conditionally include code that depends on this revised form of the realpath() function:",
          "code": "#if _POSIX_VERSION >= 200809L || defined (linux)\n",
          "explanation_after": "Consequently, despite the alarming warnings, it is safe to call realpath() with resolved_name assigned the value NULL (on systems that support it), as shown in this compliant solution:\n\nIt is also safe to call realpath() with a non-null resolved_path provided that PATH_MAX is defined as a constant in <limits.h> . In this case, the realpath() function expects resolved_path to refer to a character array that is large enough to hold the canonicalized path. If PATH_MAX is defined, allocate a buffer of size PATH_MAX to hold the result of realpath() , as shown in this compliant solution:\n\nCare still must be taken to avoid creating a time-of-check, time-of-use (TOCTOU) condition by using realpath() to check a file name."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "Calling the realpath() function with a non-null resolved_path when PATH_MAX is not defined as a constant is not safe. IEEE Std 1003.1, 2013 Edition [ IEEE Std 1003.1:2013 ], effectively forbids such uses of realpath() :\n\nIf resolved_name is not a null pointer and {PATH_MAX} is not defined as a constant in the <limits.h> header, the behavior is undefined.\n\nThe rationale from IEEE Std 1003.1, 2013 Edition, explains why this case is unsafe:\n\nSince realpath ( ) has no length argument, if {PATH_MAX} is not defined as a constant in <limits.h> , applications have no way of determining how large a buffer they need to allocate for it to be safe to pass to realpath ( ). A {PATH_MAX} value obtained from a prior pathconf ( ) call is out-of-date by the time realpath ( ) is called. Hence the only reliable way to use realpath ( ) when {PATH_MAX} is not defined in <limits.h> is to pass a null pointer for resolved_name so that realpath ( ) will allocate a buffer of the necessary size.\n\nPATH_MAX can vary among file systems (which is the reason for obtaining it with pathconf() and not sysconf() ). A PATH_MAX value obtained from a prior pathconf() call can be invalidated, for example, if a directory in the path is replaced with a symlink to a different file system or if a new file system is mounted somewhere along the path.",
          "code": "char *realpath_res = NULL;\nchar *canonical_filename = NULL;\nsize_t path_size = 0;\nlong pc_result;\n\n/* Verify argv[1] is supplied */\n\nerrno = 0;\n\n/* Query for PATH_MAX */\npc_result = pathconf(argv[1], _PC_PATH_MAX);\n\nif ( (pc_result == -1) && (errno != 0) ) {\n  /* Handle error */\n} else if (pc_result == -1) {\n  /* Handle error */\n} else if (pc_result <= 0) {\n  /* Handle error */\n}\npath_size = (size_t)pc_result;\n\nif (path_size > 0) {\n  canonical_filename = malloc(path_size);\n\n  if (canonical_filename == NULL) {\n    /* Handle error */\n  }\n\n  realpath_res = realpath(argv[1], canonical_filename);\n}\n\nif (realpath_res == NULL) {\n  /* Handle error */\n}\n\nif (!verify_file(realpath_res)) {\n  /* Handle error */\n}\n\nif (fopen(realpath_res, \"w\") == NULL) {\n  /* Handle error */\n}\n\n/* ... */\n\nfree(canonical_filename);\ncanonical_filename = NULL;\n",
          "explanation_after": "The libc4 and libc5 implementations of realpath() contain a buffer overflow (fixed in libc-5.4.13) [ VU#743092 ]. Consequently, programs need a private version of this function in which this issue is known to be fixed."
        },
        "compliant": {
          "heading": "Compliant Solution (glibc)",
          "pre_code_commentary": "The realpath() function can be difficult to use and inefficient. Another solution, available as a GNU extension, is canonicalize_file_name() . This function has the same effect as realpath() , but the result is always returned in a newly allocated buffer [ Drepper 2006 ].",
          "code": "/* Verify argv[1] is supplied */\n\nchar *canonical_filename = canonicalize_file_name(argv[1]);\nif (canonical_filename == NULL) {\n  /* Handle error */\n}\n\n/* Verify file name */\n\nif (fopen(canonical_filename, \"w\") == NULL) {\n  /* Handle error */\n}\n\n/* ... */\n\nfree(canonical_filename);\ncanonical_filename = NULL;\n",
          "explanation_after": "Because memory is allocated by canonicalize_file_name() , the programmer must remember to free the allocated memory."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "This noncompliant code example uses the Windows function GetFullPathName() for canonicalization [ MSDN ]:",
          "code": "/* ... */\n\nenum { INITBUFSIZE = 256 };\nDWORD ret = 0;\nDWORD new_ret = 0;\nchar *canonical_filename;\nchar *new_file;\nchar *file_name;\n\n/* ... */\n\nfile_name = (char *)malloc(strlen(argv[1])+1);\ncanonical_filename = (char *)malloc(INITBUFSIZE);\n\nif ( (file_name != NULL) && (canonical_filename != NULL) ) {\n  strcpy(file_name, argv[1]);\n  strcpy(canonical_filename, \"\");\n} else {\n  /* Handle error */\n}\n\nret = GetFullPathName(\n  file_name,\n  INITBUFSIZE,\n  canonical_filename,\n  NULL\n);\n\nif (ret == 0) {\n  /* Handle error */\n}\nelse if (ret > INITBUFSIZE) {\n  new_file = (char *)realloc(canonical_filename, ret);\n  if (new_file == NULL) {\n    /* Handle error */\n  }\n\n  canonical_filename = new_file;\n\n  new_ret = GetFullPathName(\n    file_name,\n    ret,\n    canonical_filename,\n    NULL\n  );\n  if (new_ret > ret) {\n    /*\n     * The length of the path changed between calls\n     * to GetFullPathName(); handle error.\n     */\n  }\n  else if (new_ret == 0) {\n    /* Handle error */\n  }\n}\n\nif (!verify_file(canonical_filename)) {\n  /* Handle error */\n}\n/* Verify file name before using */\n",
          "explanation_after": "The GetFullPathName() function can be used to eliminate the .. and /./ components from a path name, but there are numerous other canonicalization issues that are not addressed by use of GetFullPathName() , including universal naming convention (UNC) shares, short (8.3) names, long names, Unicode names, trailing dots, forward slashes, backslashes, short cuts, and so on.\n\nCare also must be taken to avoid creating a TOCTOU condition by using GetFullPathName() to check a file name."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "Producing canonical file names for Windows operating systems is extremely complex and beyond the scope of this standard. The best advice is to try to avoid making decisions based on a path, directory, or file name [ Howard 2002 ]. Alternatively, use operating-system-based mechanisms, such as access control lists (ACLs) or other authorization techniques.",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "File-related vulnerabilities can often be exploited to cause a program with elevated privileges to access an unintended file. Canonicalizing a file path makes it easier to identify the reference file object.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO03-C",
    "title": "Do not make assumptions about fopen() and file creation",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO03-C.+Do+not+make+assumptions+about+fopen%28%29+and+file+creation",
    "description": "The C fopen() function is used to open an existing file or create a new one. The C11 version of the fopen() function provides a mode flag, x , that provides the mechanism needed to determine if the file that is to be opened exists. Not using this mode flag can lead to a program overwriting or accessing an unintended file.\n\nfopen()\n\nfopen()\n\nx",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "In this noncompliant code example, the file referenced by file_name is opened for writing. This example is noncompliant if the programmer's intent was to create a new file, but the referenced file already exists.",
          "code": "char *file_name;\nFILE *fp;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"w\");\nif (!fp) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (fopen(\"x\"), C11)",
          "pre_code_commentary": "Starting in C11 a new mode suffix (\"x\") was added to the fopen() function which causes fopen() to return NULL if the file already exists or cannot be created [ ISO/IEC 9899:2011 ].",
          "code": "char *file_name;\nFILE *fp;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"wx\");\nif (!fp) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "In this noncompliant code example, the file referenced by file_name is opened for writing. This example is noncompliant if the programmer's intent was to create a new file, but the referenced file already exists.",
          "code": "char *file_name;\nFILE *fp;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"w\");\nif (!fp) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( open() , POSIX)",
          "pre_code_commentary": "The open() function, as defined in the Standard for Information Technology—Portable Operating System Interface (POSIX®), Base Specifications, Issue 7 [ IEEE Std 1003.1:2013 ], is available on many platforms and provides finer control than fopen() . In particular, open() accepts the O_CREAT and O_EXCL flags. When used together, these flags instruct the open() function to fail if the file specified by file_name already exists.",
          "code": "char *file_name;\nint new_file_mode;\n\n/* Initialize file_name and new_file_mode */\n\nint fd = open(file_name, O_CREAT | O_EXCL | O_WRONLY, new_file_mode);\nif (fd == -1) {\n  /* Handle error */\n}\n",
          "explanation_after": "Care should be taken when using O_EXCL with remote file systems because it does not work with NFS version 2. NFS version 3 added support for O_EXCL mode in open() . IETF RFC 1813 [ Callaghan 1995 ] defines the EXCLUSIVE value to the mode argument of CREATE :\n\nEXCLUSIVE specifies that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. No attributes may be provided in this case, since the server may use the target file metadata to store the createverf3 verifier.\n\nFor examples of how to check for the existence of a file without opening it, see recommendation FIO10-C. Take care when using the rename() function ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "In this noncompliant code example, the file referenced by file_name is opened for writing. This example is noncompliant if the programmer's intent was to create a new file, but the referenced file already exists.",
          "code": "char *file_name;\nFILE *fp;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"w\");\nif (!fp) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( fdopen() , POSIX)",
          "pre_code_commentary": "For code that operates on FILE pointers and not file descriptors, the POSIX fdopen() function can be used to associate an open stream with the file descriptor returned by open() , as shown in this compliant solution [ IEEE Std 1003.1:2013 ]:",
          "code": "char *file_name;\nint new_file_mode;\nFILE *fp;\nint fd;\n\n/* Initialize file_name and new_file_mode */\n\nfd = open(file_name, O_CREAT | O_EXCL | O_WRONLY, new_file_mode);\nif (fd == -1) {\n  /* Handle error */\n}\n\nfp = fdopen(fd, \"w\");\nif (fp == NULL) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "In this noncompliant code example, the file referenced by file_name is opened for writing. This example is noncompliant if the programmer's intent was to create a new file, but the referenced file already exists.",
          "code": "char *file_name;\nFILE *fp;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"w\");\nif (!fp) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "The Win32 API CreateFile() allows a programmer to create or open a file depending on the flags passed in. Passing in the CREATE_NEW flag ensures the call fails if the file already exists. This compliant solution demonstrates how to open a file for reading and writing without sharing access to the file such that the call fails if the file already exists.",
          "code": "TCHAR *file_name;\nHANDLE hFile = CreateFile(file_name, GENERIC_READ | GENERIC_WRITE, 0, 0, \n                          CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);\nif (INVALID_HANDLE_VALUE == hFile) {\n  DWORD err = GetLastError();\n  if (ERROR_FILE_EXISTS == err) {\n    /* Handle file exists error */\n  } else {\n    /* Handle other error */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The ability to determine whether an existing file has been opened or a new file has been created provides greater assurance that a file other than the intended file is not acted upon.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO05-C",
    "title": "Identify files using multiple file attributes",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO05-C.+Identify+files+using+multiple+file+attributes",
    "description": "Files can often be identified by attributes other than the file name, such as by comparing file ownership or creation time. Information about a file that has been created and closed can be stored and then used to validate the identity of the file when it is reopened.\n\nComparing multiple attributes of the file increases the likelihood that the reopened file is the same file that had been previously operated on.\n\nFile identification is less of an issue if applications maintain their files in secure directories, where they can be accessed only by the owner of the file and (possibly) by a system administrator. (See FIO15-C. Ensure that file operations are performed in a secure directory .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Reopen)",
          "pre_code_commentary": "This noncompliant code example opens a file for writing, closes it, opens the same named file for reading, and then closes it again. The logic relies solely on the file name to identify the file.",
          "code": "char *file_name;\n\n/* Initialize file_name */\n\nFILE *fd = fopen(file_name, \"w\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/*... Write to file ...*/\n\nfclose(fd);\nfd = NULL;\n\n/*\n * A race condition here allows for an attacker  \n * to switch out the file for another. \n */\n\n/* ... */\n\nfd = fopen(file_name, \"r\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/*... Read from file ...*/\n\nfclose(fd);\nfd = NULL;\n",
          "explanation_after": "There is no guarantee that the file opened for reading is the same file that is opened for writing. An attacker can replace the original file (for example, with a symbolic link) between the first fclose() and the second fopen() ."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX) (Device/I-node)",
          "pre_code_commentary": "Reopening a file stream should generally be avoided. However, it may sometimes be necessary in long-running applications to avoid depleting available file descriptors.\n\nThis compliant solution uses a \"check, use, check\" pattern to ensure that the file opened for reading is the same file that was opened for writing. In this solution, the file is opened for writing using the open() function. If the file is successfully opened, the fstat() function is used to read information about the file into the orig_st structure. When the file is reopened for reading, information about the file is read into the new_st structure, and the st_dev and st_ino fields in orig_st and new_st are compared to improve identification.",
          "code": "struct stat orig_st;\nstruct stat new_st;\nchar *file_name;\n\n/* Initialize file_name */\n\nint fd = open(file_name, O_WRONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n\n/*... Write to file ...*/\n\nif (fstat(fd, &orig_st) == -1) {\n  /* Handle error */\n}\nclose(fd);\nfd = -1;\n\n/* ... */\n\nfd = open(file_name, O_RDONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n\nif (fstat(fd, &new_st) == -1) {\n  /* Handle error */\n}\n\nif ((orig_st.st_dev != new_st.st_dev) ||\n    (orig_st.st_ino != new_st.st_ino)) {\n  /* File was tampered with! */\n}\n\n/*... Read from file ...*/\n\nclose(fd);\nfd = -1;\n",
          "explanation_after": "This solution enables the program to recognize if an attacker has switched files between the first close() and the second open() . The program does not recognize whether the file has been modified in place, however.\n\nAlternatively, the same solution can be implemented using the C fopen() function to open the file and the POSIX fileno() function to convert the FILE object pointer to a file descriptor.\n\nThe structure members st_mode , st_ino , st_dev , st_uid , st_gid , st_atime , st_ctime , and st_mtime all should have meaningful values for all file types on POSIX-compliant systems. The st_ino field contains the file serial number. The st_dev field identifies the device containing the file. The st_ino and st_dev fields, taken together, uniquely identify the file. The st_dev value is not necessarily consistent across reboots or system crashes, however, so this field may not be useful for file identification if a system crash or reboot may have occurred before you attempt to reopen a file.\n\nCall the fstat() function on a file that is already opened instead of calling stat() on a file name followed by open() . Doing so ensures that the file for which the information is being collected is the same file that is already opened. See FIO01-C. Be careful using functions that use file names for identification for more information on avoiding race conditions resulting from the use of file names for identification.\n\nIt may also be necessary to call open() with O_NONBLOCK , as per FIO32-C. Do not perform operations on devices that are only appropriate for files , to ensure that the program does not hang when trying to open special files.\n\nThis compliant solution may not work in some cases. For instance, a long-running service might choose to occasionally reopen a log file to add log messages but leave the file closed so that the log file may be periodically rotated. In this case, the i-node number would change, and this solution would no longer apply."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Reopen)",
          "pre_code_commentary": "This noncompliant code example opens a file for writing, closes it, opens the same named file for reading, and then closes it again. The logic relies solely on the file name to identify the file.",
          "code": "char *file_name;\n\n/* Initialize file_name */\n\nFILE *fd = fopen(file_name, \"w\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/*... Write to file ...*/\n\nfclose(fd);\nfd = NULL;\n\n/*\n * A race condition here allows for an attacker  \n * to switch out the file for another. \n */\n\n/* ... */\n\nfd = fopen(file_name, \"r\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/*... Read from file ...*/\n\nfclose(fd);\nfd = NULL;\n",
          "explanation_after": "There is no guarantee that the file opened for reading is the same file that is opened for writing. An attacker can replace the original file (for example, with a symbolic link) between the first fclose() and the second fopen() ."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX) (Open Only Once)",
          "pre_code_commentary": "A simpler solution is to not reopen the file. In this code example, the file is opened once for both writing and reading. Once writing is complete, the fseek() function resets the file pointer to the beginning of the file, and its contents are read back. (See void FIO07-C. Prefer fseek() to rewind() .)\n\nBecause the file is not reopened, the possibility of an attacker tampering with the file between the writes and subsequent reads is eliminated.",
          "code": "char *file_name;\nFILE *fd;\n\n/* Initialize file_name */\n\nfd = fopen(file_name, \"w+\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/*... Write to file ...*/\n\n/* Go to beginning of file */\nfseek(fd, 0, SEEK_SET);\n\n/*... Read from file ...*/\n\nfclose(fd);\nfd = NULL;\n",
          "explanation_after": "Be sure to use fflush() after writing data to the file, in accordance with FIO39-C. Do not alternately input and output from a stream without an intervening flush or positioning call ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Owner)",
          "pre_code_commentary": "In this noncompliant code example, the programmer's intent is to open a file for reading, but only if the user running the process owns the specified file. This requirement is more restrictive than that imposed by the operating system, which requires only that the effective user have permissions to read the file. The code, however, relies solely on the file name to identify the file.",
          "code": "char *file_name;\nFILE *fd;\n\n/* Initialize file_name */\n\nfd = fopen(file_name, \"r+\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/* Read user's file */\n\nfclose(fd);\nfd = NULL; \n",
          "explanation_after": "If this code is run with superuser privileges, for example, as part of a setuid-root program, an attacker can exploit this program to read files for which the real user normally lacks sufficient privileges, including files not owned by the user."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX) (Owner)",
          "pre_code_commentary": "In this compliant solution, the file is opened using the open() function. If the file is successfully opened, the fstat() function is used to read information about the file into the stat structure. This information is compared with existing information about the real user (obtained by the getuid() and getgid() functions).",
          "code": "struct stat st;\nchar *file_name;\n\n/* Initialize file_name */\n\nint fd = open(file_name, O_RDONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n\nif ((fstat(fd, &st) == -1) ||\n   (st.st_uid != getuid()) ||\n   (st.st_gid != getgid())) {\n  /* File does not belong to user */\n}\n\n/*... Read from file ...*/\n\nclose(fd);\nfd = -1;\n",
          "explanation_after": "By matching the file owner's user and group IDs to the process's real user and group IDs, this program now successfully restricts access to files owned by the real user of the program. This solution can be used to verify that the owner of the file is the one the program expects, reducing opportunities for attackers to replace configuration files with malicious ones, for example.\n\nAlternatively, the same solution can be implemented using the C fopen() function to open the file and the POSIX fileno() function to convert the FILE object pointer to a file descriptor."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Many file-related vulnerabilities are exploited to cause a program to access an unintended file. Proper file identification is necessary to prevent exploitation .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO06-C",
    "title": "Create files with appropriate access permissions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions",
    "description": "Creating a file with insufficiently restrictive access permissions may allow an unprivileged user to access that file. Although access permissions are heavily dependent on the file system, many file-creation functions provide mechanisms to set (or at least influence) access permissions. When these functions are used to create files, appropriate access permissions should be specified to prevent unintended access.\n\nWhen setting access permissions, it is important to make sure that an attacker cannot alter them. (See FIO15-C. Ensure that file operations are performed in a secure directory .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "The fopen() function does not allow the programmer to explicitly specify file access permissions. In this noncompliant code example, if the call to fopen() creates a new file, the access permissions are implementation-defined :",
          "code": "char *file_name;\nFILE *fp;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"w\");\nif (!fp){\n  /* Handle error */\n}\n",
          "explanation_after": "On POSIX-compliant systems, the permissions may be restricted by the value of the POSIX umask() function [ IEEE Std 1003.1:2013 ].\n\nThe operating system modifies the access permissions by computing the intersection of the inverse of the umask and the permissions requested by the process [ Viega 2003 ]. For example, if the variable requested_permissions contained the permissions passed to the operating system to create a new file, the variable actual_permissions would be the actual permissions that the operating system would use to create the file:\n\nFor OpenBSD and Linux operating systems, any file created will have mode S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH (0666), as modified by the process's umask value. (See fopen(3) in the OpenBSD Manual Pages [ OpenBSD ].)"
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( open() , POSIX)",
          "pre_code_commentary": "Using the POSIX open() function to create a file but failing to provide access permissions for that file may cause the file to be created with overly permissive access permissions. This omission has been known to lead to vulnerabilities —for example, CVE-2006-1174 .",
          "code": "char *file_name;\nint fd;\n\n/* Initialize file_name */\n\nfd = open(file_name, O_CREAT | O_WRONLY);\n/* Access permissions were missing */\n\nif (fd == -1){\n  /* Handle error */\n}\n",
          "explanation_after": "This example also violates EXP37-C. Call functions with the correct number and type of arguments ."
        },
        "compliant": {
          "heading": "Compliant Solution ( open() , POSIX)",
          "pre_code_commentary": "Access permissions for the newly created file should be specified in the third argument to open() . Again, the permissions are modified by the value of umask() .",
          "code": "char *file_name;\nint file_access_permissions;\n\n/* Initialize file_name and file_access_permissions */\n\nint fd = open(\n  file_name,\n  O_CREAT | O_WRONLY,\n  file_access_permissions\n);\nif (fd == -1){\n  /* Handle error */\n}\n",
          "explanation_after": "John Viega and Matt Messier also provide the following advice [ Viega 2003 ]:\n\nDo not rely on setting the umask to a \"secure\" value once at the beginning of the program and then calling all file or directory creation functions with overly permissive file modes. Explicitly set the mode of the file at the point of creation. There are two reasons to do this. First, it makes the code clear; your intent concerning permissions is obvious. Second, if an attacker managed to somehow reset the umask between your adjustment of the umask and any of your file creation calls, you could potentially create sensitive files with wide-open permissions."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Creating files with weak access permissions may allow unintended access to those files.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO08-C",
    "title": "Take care when calling remove() on an open file",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO08-C.+Take+care+when+calling+remove%28%29+on+an+open+file",
    "description": "Invoking remove() on an open file is implementation-defined . Removing an open file is sometimes recommended to hide the names of temporary files that may be prone to attack. (See FIO21-C. Do not create temporary files in shared directories .)\n\nremove()\n\nIn cases requiring the removal of an open file, a more strongly defined function, such as the POSIX unlink() function, should be considered. To be strictly conforming and portable, remove() should not be called on an open file.\n\nunlink()\n\nremove()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example shows a case where a file is removed while it is still open:",
          "code": "char *file_name;\nFILE *file;\n\n/* Initialize file_name */\n\nfile = fopen(file_name, \"w+\");\nif (file == NULL) {\n  /* Handle error condition */\n}\n\n/* ... */\n\nif (remove(file_name) != 0) {\n  /* Handle error condition */\n}\n\n/* Continue performing I/O operations on file */\n\nfclose(file);\n",
          "explanation_after": "Some implementations will not remove the file specified by file_name because the stream is still open.\n\nCode compiled for Microsoft Windows prevents the remove() call from succeeding when the file is open, meaning that the file link will remain after execution completes."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution uses the POSIX unlink() function to remove the file. The unlink() function is guaranteed to unlink the file from the file system hierarchy but keep the file on disk until all open instances of the file are closed [ IEEE Std 1003.1:2013 ].",
          "code": "FILE *file;\nchar *file_name;\n\n/* Initialize file_name */\n\nfile = fopen(file_name, \"w+\");\nif (file == NULL) {\n  /* Handle error condition */\n}\n\nif (unlink(file_name) != 0) {\n  /* Handle error condition */\n}\n\n/* Continue performing I/O operations on file */\n\nfclose(file);\n",
          "explanation_after": "Note that there is a race window between the fopen() call and the unlink() call, which could be exploited. This exploitation can be mitigated if the operations occur in a secure directory; see FIO45-C. Avoid TOCTOU race conditions while accessing files for more information."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Calling remove() on an open file has different implications for different implementations and may cause abnormal termination if the removed file is written to or read from, or it may result in unintended information disclosure from files not deleted as intended.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO09-C",
    "title": "Be careful with binary data when transferring data across systems",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO09-C.+Be+careful+with+binary+data+when+transferring+data+across+systems",
    "description": "Portability is a concern when using the fread() and fwrite() functions across multiple, heterogeneous systems. In particular, it is never guaranteed that reading or writing of scalar data types such as integers, let alone aggregate types such as arrays or structures, will preserve the representation or value of the data. Implementations may differ in structure padding, floating-point model, number of bits per byte, endianness, and other attributes that cause binary data formats to be incompatible.\n\nfread()\n\nfwrite()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example reads data from a file stream into a data structure:",
          "code": "struct myData {\n  char c;\n  long l;\n};\n\n/* ... */\n\nFILE *file;\nstruct myData data;\n\n/* Initialize file */\n\nif (fread(&data, sizeof(struct myData), 1, file) < sizeof(struct myData)) {\n  /* Handle error */\n}\n",
          "explanation_after": "However, the code makes assumptions about the layout of myData , which may be represented differently on a different platform."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The best solution is to use either a text representation or a special library that ensures data integrity:",
          "code": "struct myData {\n  char c;\n  long l;\n};\n\n/* ... */\n\nFILE *file;\nstruct myData data;\nchar buf[25];\nchar *end_ptr;\n\n/* Initialize file */\n\nif (fgets(buf, 1, file) == NULL) {\n  /* Handle error */\n}\n\ndata.c = buf[0];\n\nif (fgets(buf, sizeof(buf), file) == NULL) {\n  /* Handle Error */\n}\n\ndata.l = strtol(buf, &end_ptr, 10);\n\nif ((ERANGE == errno)\n || (end_ptr == buf)\n || ('\\n' != *end_ptr && '\\0' != *end_ptr)) {\n    /* Handle Error */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Reading binary data that has a different format than expected may result in unintended program behavior.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO10-C",
    "title": "Take care when using the rename() function",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO10-C.+Take+care+when+using+the+rename%28%29+function",
    "description": "The rename() function has the following prototype:\n\nrename()\n\nint rename(const char *src_file, const char *dest_file);\n\nint rename(const char *src_file, const char *dest_file);\n\nIf the file referenced by dest_file exists prior to calling rename() , the behavior is implementation-defined . On POSIX systems, the destination file is removed. On Windows systems, the rename() fails. Consequently, issues arise when trying to write portable code or when trying to implement alternative behavior.\n\ndest_file\n\nrename()\n\nrename()\n\nPreserve Existing Destination File\n\nIf the desired behavior is to ensure that the destination file is not erased or overwritten, POSIX programmers must implement additional safeguards.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "This code example is noncompliant because any existing destination file is removed by rename() :",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "If the programmer's intent is not to remove an existing destination file, the POSIX access() function can be used to check for the existence of a file [ IEEE Std 1003.1:2013 ]. This compliant solution renames the source file only if the destination file does not exist:",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\n\nif (access(dest_file, F_OK) != 0) {\n  if (rename(src_file, dest_file) != 0) {\n    /* Handle error condition */\n  }\n} \nelse {\n  /* Handle file-exists condition */\n}\n",
          "explanation_after": "This code contains an unavoidable race condition between the call to access() and the call to rename() and can consequently be safely executed only when the destination file is located within a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory .)\n\nOn file systems where the program does not have sufficient permissions in the directory to view the file, access() may return -1 even when the file exists. In such cases, rename() will also fail because the program lacks adequate permissions to perform the operation.\n\nIn situations where the source file is supposed not to be a directory or symbolic link, an alternative solution is to use link() to link the source file to the destination file and then use unlink() (or remove() ) to delete the source file. Because link() fails if the destination file exists, the need for calling access() is avoided. However, this solution has two race conditions related to the source file. First, before calling link() , the program must use lstat() to check that the source file is not a directory or symbolic link. Second, the source file could change during the time window between the link() and the unlink() . Consequently, this alternative solution can be safely executed only when the source file is located within a secure directory."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "This code example is noncompliant because any existing destination file is removed by rename() :",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "On Windows, the rename() function fails if a\n\nfile or directory specified by newname already exists or could not be created (invalid path). [ MSDN ]\n\nConsequently, it is unnecessary to explicitly check for the existence of the destination file before calling rename() .",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": "If the desired behavior is to ensure that the destination file is erased by the rename() operation, Windows programmers must write additional code."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "If the intent of the programmer is to remove the file referenced by dest_file if it exists prior to calling rename() , this code example is noncompliant on Windows platforms because rename() will fail:",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "On Windows systems, it is necessary to explicitly remove the destination file before calling rename() if the programmer wants the file to be overwritten and the rename() operation to succeed:",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\n\nif (_access_s(dest_file, 0) == 0) {\n  if (remove(dest_file) != 0) {\n    /* Handle error condition */\n  }\n}\n\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error condition */\n}\n",
          "explanation_after": "This code contains unavoidable race conditions between the calls to _access_s() , remove() , and rename() and can consequently be safely executed only within a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory .)  Another option would be to use the MoveFileEx API and pass in the MOVEFILE_REPLACE_EXISTING flag:\n\nAlthough this code is not portable, it does avoid the race condition when using _access_s() , remove() , and rename() ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "If the intent of the programmer is to remove the file referenced by dest_file if it exists prior to calling rename() , this code example is noncompliant on Windows platforms because rename() will fail:",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "On POSIX systems, if the destination file exists prior to calling rename() , the file is automatically removed:",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error condition */\n}\n",
          "explanation_after": "A programmer who wants an application to behave the same on any C implementation must first determine what behavior to implement."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "If the intent of the programmer is to remove the file referenced by dest_file if it exists prior to calling rename() , this code example is noncompliant on Windows platforms because rename() will fail:",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Remove Existing Destination File)",
          "pre_code_commentary": "This compliant solution ensures that any destination file is portably removed:",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\n\n(void)remove(dest_file);\n\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error condition */\n}\n",
          "explanation_after": "This code contains an unavoidable race condition between the call to remove() and the call to rename() and consequently can be safely executed only within a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory .)\n\nThe return value of remove() is deliberately not checked because it is expected to fail if the file does not exist. If the file exists but cannot be removed, the rename() call will also fail, and the error will be detected at that point. This is a valid exception (EXP12-C-EX1) to EXP12-C. Do not ignore values returned by functions ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "If the intent of the programmer is to remove the file referenced by dest_file if it exists prior to calling rename() , this code example is noncompliant on Windows platforms because rename() will fail:",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Preserve Existing Destination File)",
          "pre_code_commentary": "This compliant solution renames the source file only if the destination file does not exist:",
          "code": "const char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\n\nif (!file_exists(dest_file)) {\n  if (rename(src_file, dest_file) != 0) {\n    /* Handle error condition */\n  }\n} \nelse {\n  /* Handle file-exists condition */\n}\n",
          "explanation_after": "This code contains an unavoidable race condition between the call to file_exists() and the call to rename() and can consequently be safely executed only within a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory .)\n\nThe file_exists() function is provided by the application and is not shown here because it must be implemented differently on different platforms. (On POSIX systems, it would use access() ; on Windows, _access_s() ; and on other platforms, whatever function is available to test file existence.)"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Calling rename() has implementation-defined behavior when the new file name refers to an existing file. Incorrect use of rename() can result in a file being unexpectedly overwritten or other unexpected behavior .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO13-C",
    "title": "Never push back anything other than one read character",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO13-C.+Never+push+back+anything+other+than+one+read+character",
    "description": "Subclause 7.21.7.10 of the C Standard [ ISO/IEC 9899:2011 ] defines ungetc() as follows:\n\nungetc()\n\nThe ungetc function pushes the character specified by c (converted to an unsigned char ) back onto the input stream pointed to by stream . Pushed-back characters will be returned by subsequent reads on that stream in the reverse order of their pushing. A successful intervening call (with the stream pointed to by stream ) to a file positioning function ( fseek , fsetpos , or rewind ) discards any pushed-back characters for the stream. The external storage corresponding to the stream is unchanged. One character of pushback is guaranteed.\n\nungetc\n\nc\n\nunsigned char\n\nstream\n\nstream\n\nfseek\n\nfsetpos\n\nrewind\n\nConsequently, multiple calls to ungetc() on the same stream must be separated by a call to a read function or a file-positioning function (which will discard any data pushed by ungetc() ).\n\nungetc()\n\nungetc()\n\nLikewise, for ungetwc() , C guarantees only one wide character of pushback (subclause 7.29.3.10). Consequently, multiple calls to ungetwc() on the same stream must be separated by a call to a read function or a file-positioning function (which will discard any data pushed by ungetwc() ).\n\nungetwc()\n\nungetwc()\n\nungetwc()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, more than one character is pushed back on the stream referenced by fp :",
          "code": "FILE *fp;\nchar *file_name;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"rb\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\n/* Read data */\n\nif (ungetc('\\n', fp) == EOF) {\n  /* Handle error */\n}\nif (ungetc('\\r', fp) == EOF) {\n  /* Handle error */\n}\n\n/* Continue */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "If more than one character needs to be pushed by ungetc() , then fgetpos() and fsetpos() should be used before and after reading the data instead of pushing it back with ungetc() . Note that this solution applies only if the input is seekable.",
          "code": "FILE *fp;\nfpos_t pos;\nchar *file_name;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"rb\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\n/* Read data */\n\nif (fgetpos(fp, &pos)) {\n  /* Handle error */\n}\n\n/* Read the data that will be \"pushed back\" */\n\nif (fsetpos(fp, &pos)) {\n  /* Handle error */\n}\n\n/* Continue */\n",
          "explanation_after": "Remember to always call fgetpos() before fsetpos() . (See FIO44-C. Only use values for fsetpos() that are returned from fgetpos() .)"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "If used improperly, ungetc() and ungetwc() can cause data to be truncated or lost.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO14-C",
    "title": "Understand the difference between text mode and binary mode with file streams",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO14-C.+Understand+the+difference+between+text+mode+and+binary+mode+with+file+streams",
    "description": "Input and output are mapped into logical data streams whose properties are more uniform than their various inputs and outputs. Two forms of mapping are supported, one for text streams and one for binary streams. They differ in the actual representation of data as well as in the functionality of some C functions.\n\nText Streams",
    "examples": null,
    "risk_assessment": {
      "explanation": "Failure to understand file stream mappings can result in unexpectedly formatted files.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO15-C",
    "title": "Ensure that file operations are performed in a secure directory",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO15-C.+Ensure+that+file+operations+are+performed+in+a+secure+directory",
    "description": "File operations should be performed in a secure directory . In most cases, a secure directory is a directory in which no one other than the user, or possibly the administrator, has the ability to create, rename, delete, or otherwise manipulate files. (Other users may read or search the directory but generally may not modify the directory's contents in any way.) Also, other users must not be able to delete or rename files in the parent of the secure directory and all higher directories, although creating new files or deleting or renaming files they own is permissible.\n\nPerforming file operations in a secure directory eliminates the possibility that an attacker might tamper with the files or file system to exploit a file system vulnerability in a program. These vulnerabilities often exist because there is a loose binding between the file name and the actual file. (See FIO01-C. Be careful using functions that use file names for identification .) In some cases, file operations can be performed securely anywhere. In other cases, the only way to ensure secure file operations is to perform the operation within a secure directory.\n\nEnsuring that file systems are configured in a safe manner is typically a system administration function. However, programs can often check that a file system is securely configured before performing file operations that may lead to security vulnerabilities if the system is misconfigured. There is a slight possibility that file systems will be reconfigured in an insecure manner while a process is running and after the check has been made. As a result, it is always advisable to implement your code in a secure manner (that is, consistent with the other rules and recommendations in this section) even when running in a secure directory.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the file identified by file_name is opened, processed, closed, and removed:",
          "code": "char *file_name;\nFILE *fp;\n\n/* Initialize file_name */\n\nfp = fopen(file_name, \"w\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\n/* ... Process file ... */\n\nif (fclose(fp) != 0) {\n  /* Handle error */\n}\n\nif (remove(file_name) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": "An attacker can replace the file object identified by file_name with a link to an arbitrary file before the call to fopen() . It is also possible that the file object identified by file_name in the call to remove() is not the same file object identified by file_name in the call to fopen() . If the file is not in a secure directory, for example, /tmp/app/tmpdir/passwd , then an attacker can manipulate the location of the file as follows:\n\nNot much can be done programmatically to ensure the file removed is the same file that was opened, processed, and closed, except to make sure that the file is opened in a secure directory with privileges that would prevent the file from being manipulated by an untrusted user."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This sample implementation of the function secure_dir() ensures that the directory fullpath and all directories above it are owned by either the user or the superuser and that other users do not have write access to the directories. When checking directories, it is important to traverse from the root to the leaf to avoid a dangerous race condition in which an attacker who has privileges to at least one of the directories can rename and re-create a directory after the privilege verification.\n\nfullpath need not be canonicalized (see FIO02-C. Canonicalize path names originating from tainted sources ). If the path contains a symbolic link, this routine recursively invokes itself on the linked-to directory and ensures it is also secure. A symbolically linked directory may be secure if both its source and linked-to directory are secure.\n\nNote that this function is effective only on file systems that are fully compatible with UNIX permissions, and it may not behave normally for file systems with other permission mechanisms, such as AFS (Andrew File System).",
          "code": "#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\nenum { MAX_SYMLINKS = 5 };\n\n/* Returns nonzero if directory is secure, zero otherwise */\nint secure_dir(const char *fullpath) {\n  static unsigned int num_symlinks = 0;\n  char *path_copy = NULL;\n  char **dirs = NULL;\n  int num_of_dirs = 1;\n  int secure = 1;\n  int i, r;\n  struct stat buf;\n  uid_t my_uid = geteuid();\n  size_t linksize;\n  char* link;\n   \n  if (!fullpath || fullpath[0] != '/') {\n    /* Handle error */\n  }\n   \n  if (num_symlinks > MAX_SYMLINKS) {  /* Could be a symlink loop */\n    /* Handle error */\n  }\n  \n  if (!(path_copy = strdup(fullpath))) {\n    /* Handle error */\n  }\n  \n  /* Figure out how far it is to the root */\n  char* path_parent = path_copy;\n  for (; ((strcmp(path_parent, \"/\") != 0) &&\n          (strcmp(path_parent, \"//\") != 0) &&\n          (strcmp(path_parent, \".\") != 0));\n       path_parent = dirname(path_parent)) {\n    num_of_dirs++;\n  } /* Now num_of_dirs indicates # of dirs we must check */\n  free(path_copy);\n  path_copy = NULL;\n  \n  if (!(dirs = (char **)malloc(num_of_dirs * sizeof(char *)))) {\n    /* Handle error */\n  }\n   \n  if (!(dirs[num_of_dirs - 1] = strdup(fullpath))) {\n    /* Handle error */\n  }\n  \n  if (!(path_copy = strdup(fullpath))) {\n    /* Handle error */\n  }\n  \n  /* Now fill the dirs array */\n  path_parent = path_copy;\n  for (i = num_of_dirs - 2; i >= 0; i--) {\n    path_parent = dirname(path_parent);\n    if (!(dirs[i] = strdup(path_parent))) {\n      /* Handle error */\n    }\n  }\n  free(path_copy);\n  path_copy = NULL;\n  \n  /*\n   * Traverse from the root to the fullpath,\n   * checking permissions along the way.\n   */\n for (i = 0; i < num_of_dirs; i++) {\n    if (lstat(dirs[i], &buf) != 0) {\n      /* Handle error */\n    }\n     \n    if (S_ISLNK(buf.st_mode)) { /* Symlink, test linked-to file */\n      linksize = buf.st_size + 1;\n      if (!(link = (char *)malloc(linksize))) {\n        /* Handle error */\n      }\n       \n      r = readlink(dirs[i], link, linksize);\n      if (r == -1) {\n        /* Handle error */\n      } else if (r >= linksize) {\n        /* Handle truncation error */\n      }\n      link[r] = '\\0';\n \n      num_symlinks++;\n      r = secure_dir(link);\n      num_symlinks--;\n       \n      if (!r) {\n        secure = 0;\n \n        free(link);\n        link = NULL;\n        break;\n      }\n       \n      free(link);\n      link = NULL;\n       \n      continue;\n    }\n     \n    if (!S_ISDIR(buf.st_mode)) { /* Not a directory */\n      secure = 0;\n      break;\n    }\n     \n    if ((buf.st_uid != my_uid) && (buf.st_uid != 0)) {\n      /* Directory is owned by someone besides user or root */\n      secure = 0;\n      break;\n    }\n     \n    if (buf.st_mode & (S_IWGRP | S_IWOTH)) { /* dir is writable by others */\n      secure = 0;\n      break;\n    }\n  }\n   \n  for (i = 0; i < num_of_dirs; i++) {\n    free(dirs[i]);\n    dirs[i] = NULL;\n  }\n  \n  free(dirs);\n  dirs = NULL;\n  \n  return secure;\n}\n",
          "explanation_after": "This compliant solution uses the secure_dir() function to ensure that an attacker may not tamper with the file to be opened and subsequently removed. Note that once the path name of a directory has been checked using secure_dir() , all further file operations on that directory must be performed using the same path."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to perform file I/O operations in a secure directory that cannot otherwise be securely performed can result in a broad range of file system vulnerabilities.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO18-C",
    "title": "Never expect fwrite() to terminate the writing process at a null character",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO18-C.+Never+expect+fwrite%28%29+to+terminate+the+writing+process+at+a+null+character",
    "description": "The C Standard, subclause 7.21.8.2 [ ISO/IEC 9899:2011 ], defines the fwrite() function as follows:\n\nfwrite()\n\nSynopsis size_t fwrite(const void *restrict ptr, size_t size, size_t nmemb, FILE *restrict stream); Description The fwrite() function writes, from the array pointed to by ptr , up to nmemb elements whose size is specified by size , to the stream pointed to by stream . For each object, size calls are made to the fputc() function, taking the values (in order) from an array of unsigned char exactly overlaying the object. The file position indicator for the stream (if defined) is advanced by the number of bytes successfully written. If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.\n\nsize_t fwrite(const void *restrict ptr, size_t size, size_t nmemb, FILE *restrict stream);\n\nfwrite()\n\nptr\n\nnmemb\n\nsize\n\nstream\n\nsize\n\nfputc()\n\nunsigned char\n\nThe definition does not state that the fwrite() function will stop copying characters into the file if a null character is encountered. Therefore, when writing a null-terminated byte string to a file using the fwrite() function, always use the length of the string plus 1 (to account for the null character) as the nmemb parameter.\n\nfwrite()\n\nfwrite()\n\nnmemb",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the size of the buffer is stored in size1 , but size2 number of characters are written to the file. If size2 is greater than size1 , write() will not stop copying characters at the null character.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\nchar *buffer = NULL;\nsize_t size1;\nsize_t size2;\nFILE *filedes;\n\n/* Assume size1 and size2 are appropriately initialized */\n\nfiledes = fopen(\"out.txt\", \"w+\");\nif (filedes == NULL) {\n  /* Handle error */\n}\n\nbuffer = (char *)calloc( 1, size1);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\nfwrite(buffer, 1, size2, filedes);\n\nfree(buffer);\nbuffer = NULL;\nfclose(filedes);\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution ensures that the correct number of characters are written to the file:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nchar *buffer = NULL;\nsize_t size1;\nsize_t size2;\nFILE *filedes;\n\n/* Assume size1 is appropriately initialized */\n\nfiledes = fopen(\"out.txt\", \"w+\");\nif (filedes == NULL){\n  /* Handle error */\n}\n\nbuffer = (char *)calloc( 1, size1);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/*\n * Accept characters in to the buffer.\n * Check for buffer overflow.\n */\n\nsize2 = strlen(buffer) + 1;\n\nfwrite(buffer, 1, size2, filedes);\n\nfree(buffer);\nbuffer = NULL;\nfclose(filedes);\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to follow the recommendation could result in a non-null-terminated string being written to a file, which will create problems when the program tries to read it back as a null-terminated byte string.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO19-C",
    "title": "Do not use fseek() and ftell() to compute the size of a regular file",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO19-C.+Do+not+use+fseek%28%29+and+ftell%28%29+to+compute+the+size+of+a+regular+file",
    "description": "Understanding the difference between text mode and binary mode is important when using functions that operate on file streams. (See FIO14-C. Understand the difference between text mode and binary mode with file streams for more information.)\n\nSubclause 7.21.9.2 of the C Standard [ ISO/IEC 9899:2011 ] specifies the following behavior for fseek() when opening a binary file in binary mode:\n\nfseek()\n\nA binary stream need not meaningfully support fseek calls with a whence value of SEEK_END .\n\nwhence\n\nSEEK_END\n\nIn addition, footnote 268 of subclause 7.21.3 says:\n\nSetting the file position indicator to end-of-file, as with fseek(file, 0, SEEK_END) , has undefined behavior for a binary stream (because of possible trailing null characters) or for any stream with state-dependent encoding that does not assuredly end in the initial shift state.\n\nfseek(file, 0, SEEK_END)\n\nSeeking to the end of a binary stream in binary mode with fseek() is not meaningfully supported and is not a recommended method for computing the size of a file.\n\nfseek()\n\nSubclause 7.21.9.4 of the C Standard [ ISO/IEC 9899:2011 ] specifies the following behavior for ftell() when opening a text file in text mode:\n\nftell()\n\nFor a text stream, its file position indicator contains unspecified information, usable by the fseek function for returning the file position indicator for the stream to its position at the time of the ftell call.\n\nfseek\n\nftell\n\nConsequently, the return value of ftell() for streams opened in text mode should never be used for offset calculations other than in calls to fseek() .\n\nftell()\n\nfseek()\n\nPOSIX [ IEEE Std 1003.1:2013 ] provides several guarantees that the problems described in the C Standard do not occur on POSIX systems.\n\nFirst, the fopen page says:\n\nfopen\n\nThe character ' b ' shall have no effect, but is allowed for ISO C standard conformance.\n\nb\n\nThis guarantees that binary files are treated the same as text files in POSIX.\n\nSecond, the fwrite page says:\n\nfwrite\n\nFor each object, size calls shall be made to the fputc() function, taking the values (in order) from an array of unsigned char exactly overlaying the object. The file-position indicator for the stream (if defined) shall be advanced by the number of bytes successfully written.\n\nThis means that the file position indicator, and consequently the file size, is directly based on the number of bytes actually written to a file.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Binary File)",
          "pre_code_commentary": "This code example attempts to open a binary file in binary mode and use fseek() and ftell() to obtain the file size. This code is noncompliant on systems that do not provide the same guarantees as POSIX. On these systems, setting the file position indicator to the end of the file using fseek() is not guaranteed to work for a binary stream, and consequently, the amount of memory allocated may be incorrect, leading to a potential vulnerability .",
          "code": "FILE *fp;\nlong file_size;\nchar *buffer;\n\nfp = fopen(\"foo.bin\", \"rb\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\nif (fseek(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n\nfile_size = ftell(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX ftello() )",
          "pre_code_commentary": "If the code needs to handle large files, it is preferable to use fseeko() and ftello() because, for some implementations, they can handle larger file offsets than fseek() and ftell() can handle. If they are used, the file_size variable should have type off_t to avoid the possibility of overflow when assigning the return value of ftello() to it. This solution works only with regular files.",
          "code": "FILE* fp;\nint fd;\noff_t file_size;\nchar *buffer;\nstruct stat st;\n  \nfd = open(\"foo.bin\", O_RDONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n\nfp = fdopen(fd, \"r\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\n/* Ensure that the file is a regular file */\nif ((fstat(fd, &st) != 0) || (!S_ISREG(st.st_mode))) {\n  /* Handle error */\n}\n \nif (fseeko(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n  \nfile_size = ftello(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n \nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ ",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Binary File)",
          "pre_code_commentary": "This code example attempts to open a binary file in binary mode and use fseek() and ftell() to obtain the file size. This code is noncompliant on systems that do not provide the same guarantees as POSIX. On these systems, setting the file position indicator to the end of the file using fseek() is not guaranteed to work for a binary stream, and consequently, the amount of memory allocated may be incorrect, leading to a potential vulnerability .",
          "code": "FILE *fp;\nlong file_size;\nchar *buffer;\n\nfp = fopen(\"foo.bin\", \"rb\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\nif (fseek(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n\nfile_size = ftell(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX fstat() )",
          "pre_code_commentary": "This compliant solution uses the size provided by the POSIX fstat() function, rather than by fseek() and ftell() , to obtain the size of the binary file. This solution works only with regular files.",
          "code": "off_t file_size;\nchar *buffer;\nstruct stat stbuf;\nint fd;\n \nfd = open(\"foo.bin\", O_RDONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n \nif ((fstat(fd, &stbuf) != 0) || (!S_ISREG(stbuf.st_mode))) {\n  /* Handle error */\n}\n \nfile_size = stbuf.st_size;\n \nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Binary File)",
          "pre_code_commentary": "This code example attempts to open a binary file in binary mode and use fseek() and ftell() to obtain the file size. This code is noncompliant on systems that do not provide the same guarantees as POSIX. On these systems, setting the file position indicator to the end of the file using fseek() is not guaranteed to work for a binary stream, and consequently, the amount of memory allocated may be incorrect, leading to a potential vulnerability .",
          "code": "FILE *fp;\nlong file_size;\nchar *buffer;\n\nfp = fopen(\"foo.bin\", \"rb\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\nif (fseek(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n\nfile_size = ftell(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "This compliant solution uses the Windows _filelength() function to determine the size of the file on a 32-bit operating system. For a 64-bit operating system, consider using _filelengthi64 instead.",
          "code": "int fd;\nlong file_size;\nchar *buffer;\n\n_sopen_s(&fd, \"foo.bin\", _O_RDONLY, _SH_DENYRW, _S_IREAD);\nif (fd == -1) {\n  /* Handle error */\n}\n\nfile_size = _filelength(fd);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Binary File)",
          "pre_code_commentary": "This code example attempts to open a binary file in binary mode and use fseek() and ftell() to obtain the file size. This code is noncompliant on systems that do not provide the same guarantees as POSIX. On these systems, setting the file position indicator to the end of the file using fseek() is not guaranteed to work for a binary stream, and consequently, the amount of memory allocated may be incorrect, leading to a potential vulnerability .",
          "code": "FILE *fp;\nlong file_size;\nchar *buffer;\n\nfp = fopen(\"foo.bin\", \"rb\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\nif (fseek(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n\nfile_size = ftell(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "This compliant solution uses the Windows GetFileSizeEx() function to determine the size of the file on a 32- or 64-bit operating system:",
          "code": "HANDLE file;\nLARGE_INTEGER file_size;\nchar *buffer;\n\n \nfile = CreateFile(TEXT(\"foo.bin\"), GENERIC_READ, 0, NULL, \n                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\nif (INVALID_FILE_HANDLE == file) {\n  /* Handle error */\n}\n \nif (!GetFileSizeEx(file, &file_size)) {\n  /* Handle error */\n}\n \n/* \n * Note: 32-bit portability issue with LARGE_INTEGER\n * truncating to a size_t.\n */\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Text File)",
          "pre_code_commentary": "This noncompliant code example attempts to open a text file in text mode and use fseek() and ftell() to obtain the file size:",
          "code": "FILE *fp;\nlong file_size;\nchar *buffer;\n\nfp = fopen(\"foo.txt\", \"r\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\nif (fseek(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n\nfile_size = ftell(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \n",
          "explanation_after": "However, the file position indicator returned by ftell() with a file opened in text mode is useful only in calls to fseek() . As such, the value of file_size may not necessarily be a meaningful measure of the number of characters in the file, and consequently, the amount of memory allocated may be incorrect, leading to a potential vulnerability .\n\nThe Visual Studio documentation for ftell() [ MSDN ] states:\n\nThe value returned by ftell may not reflect the physical byte offset for streams opened in text mode, because text mode causes carriage return-linefeed translation. Use ftell with fseek to return to file locations correctly.\n\nAgain, this indicates that the return value of ftell() for streams opened in text mode is useful only in calls to fseek() and should not be used for any other purpose."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "The compliant solution used for binary files on Windows can also be used for text files.",
          "code": null,
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Text File)",
          "pre_code_commentary": "This noncompliant code example attempts to open a text file in text mode and use fseek() and ftell() to obtain the file size:",
          "code": "FILE *fp;\nlong file_size;\nchar *buffer;\n\nfp = fopen(\"foo.txt\", \"r\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\nif (fseek(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n\nfile_size = ftell(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \n",
          "explanation_after": "However, the file position indicator returned by ftell() with a file opened in text mode is useful only in calls to fseek() . As such, the value of file_size may not necessarily be a meaningful measure of the number of characters in the file, and consequently, the amount of memory allocated may be incorrect, leading to a potential vulnerability .\n\nThe Visual Studio documentation for ftell() [ MSDN ] states:\n\nThe value returned by ftell may not reflect the physical byte offset for streams opened in text mode, because text mode causes carriage return-linefeed translation. Use ftell with fseek to return to file locations correctly.\n\nAgain, this indicates that the return value of ftell() for streams opened in text mode is useful only in calls to fseek() and should not be used for any other purpose."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "Because binary files are treated the same as text files in POSIX, either compliant solution can be used for determining the size of a binary file under POSIX to determine the size of a text file as well.",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Understanding the difference between text mode and binary mode with file streams is critical when working with functions that operate on them. Setting the file position indicator to end-of-file with fseek() has undefined behavior for a binary stream. In addition, the return value of ftell() for streams opened in text mode is useful only in calls to fseek() , not for determining file sizes or for any other use. As such, fstat() or other platform-equivalent functions should be used to determine the size of a file.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO21-C",
    "title": "Do not create temporary files in shared directories",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO21-C.+Do+not+create+temporary+files+in+shared+directories",
    "description": "Programmers frequently create temporary files in directories that are writable by everyone (examples are /tmp and /var/tmp on UNIX and %TEMP% on Windows) and may be purged regularly (for example, every night or during reboot).\n\n/tmp\n\n/var/tmp\n\n%TEMP%\n\nTemporary files are commonly used for auxiliary storage for data that does not need to, or otherwise cannot, reside in memory and also as a means of communicating with other processes by transferring data through the file system. For example, one process will create a temporary file in a shared directory with a well-known name or a temporary name that is communicated to collaborating processes. The file then can be used to share information among these collaborating processes.\n\nThis practice is dangerous because a well-known file in a shared directory can be easily hijacked or manipulated by an attacker. Mitigation strategies include the following:\n\nUse other low-level IPC (interprocess communication) mechanisms such as sockets or shared memory. Use higher-level IPC mechanisms such as remote procedure calls. Use a secure directory or a jail that can be accessed only by application instances (ensuring that multiple instances of the application running on the same platform do not compete).\n\nThere are many different IPC mechanisms; some require the use of temporary files, and others do not. An example of an IPC mechanism that uses temporary files is the POSIX mmap() function. Berkeley Sockets, POSIX Local IPC Sockets, and System V Shared Memory do not require temporary files. Because the multiuser nature of shared directories poses an inherent security risk, the use of shared temporary files for IPC is discouraged.\n\nmmap()\n\nWhen two or more users or a group of users have write permission to a directory, the potential for deception is far greater than it is for shared access to a few files. Consequently, temporary files in shared directories must be\n\nCreated unpredictable file names Created with unique names Opened only if the file doesn't already exist (atomic open) Opened with exclusive access Opened with appropriate permissions Removed before the program exits\n\nThe following table lists common temporary file functions and their respective conformance to these criteria:\n\nConformance of File Functions to Criteria for Temporary Files\n\ntmpnam (C) tmpfile (C/POSIX) mktemp (POSIX) mkstemp (POSIX) Unpredictable Name Not portably Not portably Not portably Not portably Unique Name Yes Yes Yes Yes Atomic open No Yes No Yes Exclusive Access Possible No Possible If supported by OS Appropriate Permissions Possible If supported by OS * Possible Not portably File Removed No Yes* No No\n\ntmpnam\n\ntmpfile\n\nmktemp\n\nmkstemp\n\n* If the program terminates abnormally, this behavior is implementation-defined .\n\nSecurely creating temporary files is error prone and dependent on the version of the C runtime library used, the operating system, and the file system. Code that works for a locally mounted file system, for example, may be vulnerable when used with a remotely mounted file system. Moreover, none of these functions are without problems. The only secure solution is to not create temporary files in shared directories.\n\nUnique and Unpredictable File Names\n\nPrivileged programs that create temporary files in world-writable directories can be exploited to overwrite protected system files. An attacker who can predict the name of a file created by a privileged program can create a symbolic link (with the same name as the file used by the program) to point to a protected system file. Unless the privileged program is coded securely, the program will follow the symbolic link instead of opening or creating the file that it is supposed to be using. As a result, a protected system file to which the symbolic link points can be overwritten when the program is executed [ HP 2003 ]. Unprivileged programs can be similarly exploited to overwrite protected user files.\n\nExclusive Access\n\nExclusive access grants unrestricted file access to the locking process while denying access to all other processes and eliminates the potential for a race condition on the locked region. (See Secure Coding in C and C++, Chapter 8 [ Seacord 2013 ].)\n\nFiles, or regions of files, can be locked to prevent two processes from concurrent access. Windows supports two types of file locks:\n\nShared locks , provided by LockFile() , prohibit all write access to the locked file region while allowing concurrent read access to all processes. Exclusive locks , provided by LockFileEx() , grant unrestricted file access to the locking process while denying access to all other processes.\n\nLockFile()\n\nLockFileEx()\n\nIn both cases, the lock is removed by calling UnlockFile() .\n\nUnlockFile()\n\nBoth shared locks and exclusive locks eliminate the potential for a race condition on the locked region. The exclusive lock is similar to a mutual exclusion solution, and the shared lock eliminates race conditions by removing the potential for altering the state of the locked file region (one of the required properties for a race).\n\nThese Windows file-locking mechanisms are called mandatory locks because every process attempting to access a locked file region is subject to the restriction. Linux implements mandatory locks and advisory locks. An advisory lock is not enforced by the operating system, which severely diminishes its value from a security perspective. Unfortunately, the mandatory file lock in Linux is also largely impractical for the following reasons:\n\nMandatory locking works only on local file systems and does not extend to network file systems (such as NFS or AFS). File systems must be mounted with support for mandatory locking, and this is disabled by default. Locking relies on the group ID bit that can be turned off by another process (thereby defeating the lock).\n\nRemoval before Termination\n\nRemoving temporary files when they are no longer required allows file names and other resources (such as secondary storage) to be recycled. In the case of abnormal termination , there is no sure method that can guarantee the removal of orphaned files. For this reason, temporary file cleaner utilities, which are invoked manually by a system administrator or periodically run by a daemon to sweep temporary directories and remove old files, are widely used. However, these utilities are themselves vulnerable to file-based exploits and often require the use of shared directories. During normal operation, it is the responsibility of the program to ensure that temporary files are removed either explicitly or through the use of library routines, such as tmpfile_s , which guarantee temporary file deletion upon program termination.\n\ntmpfile_s",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen()/open() with tmpnam() )",
          "pre_code_commentary": "This noncompliant code example creates a file with a hard-coded file_name (presumably in a shared directory such as /tmp or C:\\Temp ):",
          "code": "#include <stdio.h>\n \nvoid func(const char *file_name) {\n  FILE *fp = fopen(file_name, \"wb+\");\n  if (fp == NULL) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "Because the name is hard coded and consequently neither unique nor unpredictable, an attacker need only replace a file with a symbolic link, and the target file referenced by the link is opened and truncated.\n\nThis noncompliant code example attempts to remedy the problem by generating the file name at runtime using tmpnam() . The C tmpnam() function generates a string that is a valid file name and that is not the same as the name of an existing file. Files created using strings generated by the tmpnam() function are temporary in that their names should not collide with those generated by conventional naming rules for the implementation . The function is potentially capable of generating TMP_MAX different strings, but any or all of them may already be in use by existing files.\n\nBecause tmpnam() does not guarantee a unique name and fopen() does not provide a facility for an exclusive open, this code is still vulnerable.\n\nThe next noncompliant code example attempts to remedy the problem by using the POSIX open() function and providing a mechanism to indicate whether an existing file has been opened for writing or a new file has been created [ IEEE Std 1003.1:2013 ]. If the O_CREAT and O_EXCL flags are used together, the open() function fails when the file specified by file_name already exists. To prevent an existing file from being opened and truncated, include the flags O_CREAT and O_EXCL when calling open() :\n\nThis call to open() fails whenever file_name already exists, including when it is a symbolic link, but a temporary file is presumably still required. Additionally, the method used by tmpnam() to generate file names is not guaranteed to be unpredictable, which leaves room for an attacker to guess the file name ahead of time.\n\nCare should be observed when using O_EXCL with remote file systems because it does not work with NFS version 2. NFS version 3 added support for O_EXCL mode in open() ; see IETF RFC 1813 [ Callaghan 1995 ], particularly the EXCLUSIVE value to the mode argument of CREATE .\n\nMoreover, the open() function, as specified by the Standard for Information Technology—Portable Operating System Interface (POSIX®), Base Specifications, Issue 7 [ IEEE Std 1003.1:2013 ], does not include support for shared or exclusive locks. However, BSD systems support two additional flags that allow you to obtain these locks:\n\nO_SHLOCK : Atomically obtain a shared lock. O_EXLOCK : Atomically obtain an exclusive lock."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( mktemp()/open() , POSIX)",
          "pre_code_commentary": "The POSIX function mktemp() takes a given file name template and overwrites a portion of it to create a file name. The template may be any file name with exactly six X's appended to it (for example, /tmp/temp.XXXXXX ). The six trailing X's are replaced with the current process number and/or a unique letter combination.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nvoid func(void) {\n  char file_name[] = \"tmp-XXXXXX\";\n  int fd;\n\n  if (!mktemp(file_name)) {\n    /* Handle error */\n  }\n\n  /* A TOCTOU race condition exists here */\n\n  fd = open(file_name, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,\n            0600);\n  if (fd < 0) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "The mktemp() function is marked \"LEGACY\" in the Open Group Base Specifications Issue 6 [ Open Group 2004 ]. The manual page for mktemp() gives more detail:\n\nNever use mktemp() . Some implementations follow BSD 4.3 and replace XXXXXX by the current process id and a single letter, so that at most 26 different names can be returned. Since on the one hand the names are easy to guess, and on the other hand there is a race between testing whether the name exists and opening the file, every use of mktemp() is a security risk. The race is avoided by mkstemp(3) ."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( tmpfile() )",
          "pre_code_commentary": "The tmpfile() function creates a temporary binary file that is different from any other existing file and that is automatically removed when it is closed or at program termination.\n\nIt should be possible to open at least TMP_MAX temporary files during the lifetime of the program. (This limit may be shared with tmpnam() .) Subclause 7.21.4.4, paragraph 6, of the C Standard allows for the value of the macro TMP_MAX to be as small as 25.\n\nMost historic implementations provide only a limited number of possible temporary file names (usually 26) before file names are recycled.",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  FILE *fp = tmpfile();\n  if (fp == NULL) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( mkstemp() , POSIX)",
          "pre_code_commentary": "The mkstemp() algorithm for selecting file names has shown to be immune to attacks. The mkstemp() function is available on systems that support the Open Group Base Specifications Issue 4, version 2 or later.\n\nA call to mkstemp() replaces the six X 's in the template string with six randomly selected characters and returns a file descriptor for the file (opened for reading and writing), as in this compliant solution:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n \nextern int secure_dir(const char *sdn);\n \nvoid func(void) {\n  const char *sdn = \"/home/usr1/\";\n  char sfn[] = \"/home/usr1/temp-XXXXXX\";\n  FILE *sfp;\n\n  if (!secure_dir(sdn)) {\n    /* Handle error */\n  }\n\n  int fd = mkstemp(sfn);\n  if (fd == -1) {\n    /* Handle error */\n  }\n\n  /* \n   * Unlink immediately to hide the file name. The race\n   * condition here is inconsequential if the file is created\n   * with exclusive permissions (glibc >= 2.0.7).\n   */\n  if (unlink(sfn) == -1) {\n    /* Handle error */\n  }\n\n  sfp = fdopen(fd, \"w+\");\n  if (sfp == NULL) {\n    close(fd);\n    /* Handle error */\n  }\n\n  /* Use temporary file */\n\n  fclose(sfp); /* Also closes fd */\n}",
          "explanation_after": "This solution is not serially reusable, however, because the mkstemp() function replaces the \"XXXXXX\" in template the first time it is invoked. This is not a problem as long as template is reinitialized before calling mkstemp() again. If template is not reinitialized, the mkstemp() function will return -1 and leave template unmodified because template did not contain six X 's.\n\nThe Open Group Base Specification Issue 6 [ Open Group 2004 ] does not specify the permissions the file is created with, so these are implementation-defined . However, IEEE Std 1003.1, 2013 Edition [ IEEE Std 1003.1:2013 ] specifies them as S_IRUSR|S_IWUSR (0600).\n\nThis compliant solution invokes the user-defined function secure_dir() (such as the one defined in FIO15-C. Ensure that file operations are performed in a secure directory ) to ensure the temporary file resides in a secure directory.\n\nFor GLIBC, versions 2.0.6 and earlier, the file is created with permissions 0666; for GLIBC, versions 2.0.7 and later, the file is created with permissions 0600. On NetBSD, the file is created with permissions 0600. This creates a security risk in that an attacker will have write access to the file immediately after creation. Consequently, programs need a private version of the mkstemp() function in which this issue is known to be fixed.\n\nIn many older implementations , the name is a function of process ID and time, so it is possible for the attacker to predict the name and create a decoy in advance. FreeBSD changed the mk*temp() family to eliminate the process ID component of the file name and replace the entire field with base-62 encoded randomness. This raises the number of possible temporary files for the typical use of six X 's significantly, meaning that even mktemp() with six X 's is reasonably (probabilistically) secure against guessing except under frequent usage [ Kennaway 2000 ]."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Insecure temporary file creation can lead to a program accessing unintended files and permission escalation on local systems.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO22-C",
    "title": "Close files before spawning processes",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO22-C.+Close+files+before+spawning+processes",
    "description": "Standard FILE objects and their underlying representation (file descriptors on POSIX platforms or handles elsewhere) are a finite resource that must be carefully managed. The number of files that an implementation guarantees may be open simultaneously is bounded by the FOPEN_MAX macro defined in <stdio.h> . The value of the macro is guaranteed to be at least 8. Consequently, portable programs must either avoid keeping more than FOPEN_MAX files at the same time or be prepared for functions such as fopen() to fail due to resource exhaustion.\n\nFILE\n\nFOPEN_MAX\n\n<stdio.h>\n\nFOPEN_MAX\n\nfopen()\n\nFailing to close files when they are no longer needed may allow attackers to exhaust, and possibly manipulate, system resources. This phenomenon is sometimes called file descriptor leakage , although file pointers may also be used as an attack vector. In addition, keeping files open longer than necessary increases the risk that data written into in-memory file buffers will not be flushed in the event of abnormal program termination . To prevent file descriptor leaks and to guarantee that any buffered data will be flushed into permanent storage, files must be closed when they are no longer needed.\n\nThe behavior of a program is undefined when it uses the value of a pointer to a FILE object after the associated file is closed (see undefined behavior 153 .) Programs that close the standard streams (especially stdout but also stderr and stdin ) must be careful not to use the stream objects in subsequent function calls, particularly those that implicitly operate on such objects (such as printf() , perror() , and getc() ).\n\nFILE\n\nstdout\n\nstderr\n\nstdin\n\nprintf()\n\nperror()\n\ngetc()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, derived from a vulnerability in OpenBSD's chpass program [ NAI 1998 ], a file containing sensitive data is opened for reading. The get_validated_editor() function retrieves the registered editor from the EDITOR environment variable and sanitizes it to be a valid editor in accordance with FIO02-C. Canonicalize path names originating from tainted sources. The function returns a command for invoking the editor  which is subsequently passed as a command system() function. If the system() function is implemented in a way that spawns a child process, then the child process could inherit the file descriptors opened by its parent. If this happens, as it does in POSIX systems, the child process will be able to access the contents of the potentially sensitive file called file_name .",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nextern const char *get_validated_editor(void);\n \nvoid func(const char *file_name) {\n  FILE *f;\n  const char *editor;\n\n  f = fopen(file_name, \"r\");\n  if (f == NULL) {\n    /* Handle error */\n  }\n \n  editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle error */\n  }\n \n  if (system(editor) == -1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "If the command returned by get_validated_editor() will always be a simple path (such as /usr/bin/vim ), and runs on a POSIX system, this program could be strengthened by using a call to execve() rather than system() , in accordance with ENV33-C. Do not call system() .\n\nOn UNIX-based systems, child processes are typically spawned using a form of fork() and exec() , and the child process always inherits from its parent any file descriptors that do not have the close-on-exec flag set. Under Microsoft Windows, file-handle inheritance is determined on a per-file and per-spawned process basis. See WIN03-C. Understand HANDLE inheritance for more information."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, file_name is closed before launching the editor:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nextern const char *get_validated_editor(void);\n \nvoid func(const char *file_name) {\n  FILE *f;\n  const char *editor;\n\n  f = fopen(file_name, \"r\");\n  if (f == NULL) {\n    /* Handle error */\n  }\n  \n  fclose(f);\n  f = NULL;\n  \n  editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle error */\n  }\n \n  /* Sanitize environment before calling system() */\n  if (system(editor) == -1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, derived from a vulnerability in OpenBSD's chpass program [ NAI 1998 ], a file containing sensitive data is opened for reading. The get_validated_editor() function retrieves the registered editor from the EDITOR environment variable and sanitizes it to be a valid editor in accordance with FIO02-C. Canonicalize path names originating from tainted sources. The function returns a command for invoking the editor  which is subsequently passed as a command system() function. If the system() function is implemented in a way that spawns a child process, then the child process could inherit the file descriptors opened by its parent. If this happens, as it does in POSIX systems, the child process will be able to access the contents of the potentially sensitive file called file_name .",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nextern const char *get_validated_editor(void);\n \nvoid func(const char *file_name) {\n  FILE *f;\n  const char *editor;\n\n  f = fopen(file_name, \"r\");\n  if (f == NULL) {\n    /* Handle error */\n  }\n \n  editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle error */\n  }\n \n  if (system(editor) == -1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "If the command returned by get_validated_editor() will always be a simple path (such as /usr/bin/vim ), and runs on a POSIX system, this program could be strengthened by using a call to execve() rather than system() , in accordance with ENV33-C. Do not call system() .\n\nOn UNIX-based systems, child processes are typically spawned using a form of fork() and exec() , and the child process always inherits from its parent any file descriptors that do not have the close-on-exec flag set. Under Microsoft Windows, file-handle inheritance is determined on a per-file and per-spawned process basis. See WIN03-C. Understand HANDLE inheritance for more information."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "Sometimes it is not practical for a program to close all active file descriptors before issuing a system call such as system() or exec() . An alternative on POSIX systems is to use the FD_CLOEXEC flag, or O_CLOEXEC when available, to set the close-on-exec flag for the file descriptor:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n \nextern const char *get_validated_editor(void);\n \nvoid func(const char *file_name) {\n  int flags;\n  char *editor;\n\n  int fd = open(file_name, O_RDONLY);\n  if (fd == -1) {\n    /* Handle error */\n  }\n\n  flags = fcntl(fd, F_GETFD);\n  if (flags == -1) {\n    /* Handle error */\n  }\n\n  if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1) {\n    /* Handle error */\n  }\n\n  editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle getenv() error */\n  }\n \n  if (system(editor) == -1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, derived from a vulnerability in OpenBSD's chpass program [ NAI 1998 ], a file containing sensitive data is opened for reading. The get_validated_editor() function retrieves the registered editor from the EDITOR environment variable and sanitizes it to be a valid editor in accordance with FIO02-C. Canonicalize path names originating from tainted sources. The function returns a command for invoking the editor  which is subsequently passed as a command system() function. If the system() function is implemented in a way that spawns a child process, then the child process could inherit the file descriptors opened by its parent. If this happens, as it does in POSIX systems, the child process will be able to access the contents of the potentially sensitive file called file_name .",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nextern const char *get_validated_editor(void);\n \nvoid func(const char *file_name) {\n  FILE *f;\n  const char *editor;\n\n  f = fopen(file_name, \"r\");\n  if (f == NULL) {\n    /* Handle error */\n  }\n \n  editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle error */\n  }\n \n  if (system(editor) == -1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "If the command returned by get_validated_editor() will always be a simple path (such as /usr/bin/vim ), and runs on a POSIX system, this program could be strengthened by using a call to execve() rather than system() , in accordance with ENV33-C. Do not call system() .\n\nOn UNIX-based systems, child processes are typically spawned using a form of fork() and exec() , and the child process always inherits from its parent any file descriptors that do not have the close-on-exec flag set. Under Microsoft Windows, file-handle inheritance is determined on a per-file and per-spawned process basis. See WIN03-C. Understand HANDLE inheritance for more information."
        },
        "compliant": {
          "heading": "Compliant Solution (Linux)",
          "pre_code_commentary": "Some systems (such as those with Linux kernel versions 2.6.23 and later) have an O_CLOEXEC flag that provides the close-on-exec function directly in open() . This flag is required by IEEE Std 1003.1 [ IEEE Std 1003.1:2013 ]. In multithreaded programs, this flag should be used, if possible, because it prevents a timing hole between open() and fcntl() when using FD_CLOEXEC , during which another thread can create a child process while the file descriptor does not have close-on-exec set.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nextern const char *get_validated_editor(void);\n \nvoid func(const char *file_name) {\n  char *editor;\n  int fd = open(file_name, O_RDONLY | O_CLOEXEC);\n  if (fd == -1) {\n    /* Handle error */\n  }\n \n  editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle error */\n  }\n \n  if (system(editor) == -1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to properly close files may allow unintended access to, or exhaustion of, system resources.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO23-C",
    "title": "Do not exit with unflushed data in stdout or stderr",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO23-C.+Do+not+exit+with+unflushed+data+in+stdout+or+stderr",
    "description": "Deprecated This guideline does not apply to code that need conform only to C23. Code that must conform to older versions of the C standard should still comply with this guideline.\n\nThe C standard makes no guarantees as to when output to stdout (standard output) or stderr (standard error) is actually flushed. On many platforms, output to stdout is buffered unless stdout outputs to a terminal, and stderr output is typically not buffered. However, programs are free to modify the buffering rules for either stdout or stderr . Programs are also free to explicitly close stdout or stderr ; if they do not do so, these streams will be closed upon program termination.\n\nstdout\n\nstderr\n\nstdout\n\nstdout\n\nstderr\n\nstdout\n\nstderr\n\nstdout\n\nstderr\n\nClosing any output stream requires flushing any data that has not yet been written to the stream. The flushing operation (manually handled by the fflush() function) can fail for several reasons. The output stream may be directed to a file in a filesystem with no remaining free space, or to a network socket that fails. Checking for the success of a fflush() operation is mandatory for a secure program, and hence checking the result of a fclose() operation is also required.\n\nfflush()\n\nfflush()\n\nfclose()\n\nConsequently, any program that sends data to stdout or stderr must take care to flush the data before it terminates. Failing to flush the data (with a call to fflush() or fclose() ), may cause the data to fail to be written and become lost.\n\nstdout\n\nstderr\n\nfflush()\n\nfclose()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example sends some data to standard output. If standard output is directed to a file and an error occurs while flushing the data (after program termination), then the output may be lost.",
          "code": "#include <stdio.h>\n \nint main(void) {\n  printf(\"Hello, world!\\n\");\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution explicitly closes stdout , and handles any errors that arise.",
          "code": "#include <stdio.h>\n \nint main(void) {\n  printf(\"Hello, world!\\n\");\n  if (fclose(stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( atexit() )",
          "pre_code_commentary": "This noncompliant code example closes standard output before exiting main() , but then tries to print to standard output in an exit handler.",
          "code": "#include <stdio.h>\n \nvoid cleanup(void) {\n  /* Do cleanup */\n\n  printf(\"All cleaned up!\\n\");\n}\n\nint main(void) {\n  atexit(cleanup);\n  printf(\"Doing important stuff\\n\");\n\n  /* Do important stuff */\n\n  if (fclose(stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( atexit() )",
          "pre_code_commentary": "This compliant solution uses fflush() instead of fclose() , and the exit handler also uses fflush() to flush its output:",
          "code": "#include <stdio.h>\n \nvoid cleanup(void) {\n  /* Do cleanup */\n\n  printf(\"All cleaned up!\\n\");\n  if (fflush(stdout) == EOF) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  atexit(cleanup);\n  printf(\"Doing important stuff\\n\");\n\n  /* Do important stuff */\n\n\n  if (fflush(stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to flush data buffered for standard output or standard error may result in lost data.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO24-C",
    "title": "Do not open a file that is already open",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO24-C.+Do+not+open+a+file+that+is+already+open",
    "description": "Opening a file that is already open has implementation-defined behavior , according to the C Standard, 7.21.3, paragraph 8 [ ISO/IEC 9899:2011 ]:\n\nFunctions that open additional (nontemporary) ﬁles require a file name, which is a string. The rules for composing valid ﬁle names are implementation-deﬁned. Whether the same file can be simultaneously open multiple times is also implementation-deﬁned.\n\nSome implementations do not allow multiple copies of the same file to be open at the same time. Consequently, portable code cannot depend on what will happen if this rule is violated. Even on implementations that do not outright fail to open an already-opened file, a TOCTOU (time-of-check, time-of-use) race condition exists in which the second open could operate on a different file from the first due to the file being moved or deleted (see FIO45-C. Avoid TOCTOU race conditions while accessing files for more details on TOCTOU race conditions).",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example logs the program's state at runtime:",
          "code": "#include <stdio.h>\n \nvoid do_stuff(void) {\n  FILE *logfile = fopen(\"log\", \"a\");\n  if (logfile == NULL) {\n    /* Handle error */\n  }\n\n  /* Write logs pertaining to do_stuff() */\n  fprintf(logfile, \"do_stuff\\n\");\n}\n\nint main(void) {\n  FILE *logfile = fopen(\"log\", \"a\");\n  if (logfile == NULL) {\n    /* Handle error */\n  }\n\n  /* Write logs pertaining to main() */\n  fprintf(logfile, \"main\\n\");\n\n  do_stuff();\n \n  if (fclose(logfile) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": "Because the file log is opened twice (once in main() and again in do_stuff() ), this program has implementation-defined behavior ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, a reference to the file pointer is passed as an argument to functions that need to perform operations on that file. This reference eliminates the need to open the same file multiple times.",
          "code": "#include <stdio.h>\n \nvoid do_stuff(FILE *logfile) {\n  /* Write logs pertaining to do_stuff() */\n  fprintf(logfile, \"do_stuff\\n\");\n}\n\nint main(void) {\n  FILE *logfile = fopen(\"log\", \"a\");\n  if (logfile == NULL) {\n    /* Handle error */\n  }\n\n  /* Write logs pertaining to main() */\n  fprintf(logfile, \"main\\n\");\n\n  do_stuff(logfile);\n \n  if (fclose(logfile) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Simultaneously opening a file multiple times can result in unexpected errors and nonportable behavior.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO30-C",
    "title": "Exclude user input from format strings",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings",
    "description": "Never call a formatted I/O function with a format string containing a tainted value .  An attacker who can fully or partially control the contents of a format string can crash a vulnerable process, view the contents of the stack, view memory content, or write to an arbitrary memory location. Consequently, the attacker can execute arbitrary code with the permissions of the vulnerable process [ Seacord 2013b ]. Formatted output functions are particularly dangerous because many programmers are unaware of their capabilities. For example, formatted output functions can be used to write an integer value to a specified address using the %n conversion specifier.\n\n%n",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The incorrect_password() function in this noncompliant code example is called during identification and authentication to display an error message if the specified user is not found or the password is incorrect. The function accepts the name of the user as a string referenced by user . This is an exemplar of untrusted data that originates from an unauthenticated user. The function constructs an error message that is then output to stderr using the C Standard fprintf() function.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  fprintf(stderr, msg);\n  free(msg);\n}\n",
          "explanation_after": "The incorrect_password() function calculates the size of the message, allocates dynamic storage, and then constructs the message in the allocated memory using the snprintf() function. The addition operations are not checked for integer overflow because the string referenced by user is known to have a length of 256 or less. Because the %s characters are replaced by the string referenced by user in the call to snprintf() , the resulting string needs 1 byte less than is allocated. The snprintf() function is commonly used for messages that are displayed in multiple locations or messages that are difficult to build. However, the resulting code contains a format-string vulnerability because the msg includes untrusted user input and is passed as the format-string argument in the call to fprintf() ."
        },
        "compliant": {
          "heading": "Compliant Solution ( fputs() )",
          "pre_code_commentary": "This compliant solution fixes the problem by replacing the fprintf() call with a call to fputs() , which outputs msg directly to stderr without evaluating its contents:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  fputs(msg, stderr);\n  free(msg);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The incorrect_password() function in this noncompliant code example is called during identification and authentication to display an error message if the specified user is not found or the password is incorrect. The function accepts the name of the user as a string referenced by user . This is an exemplar of untrusted data that originates from an unauthenticated user. The function constructs an error message that is then output to stderr using the C Standard fprintf() function.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  fprintf(stderr, msg);\n  free(msg);\n}\n",
          "explanation_after": "The incorrect_password() function calculates the size of the message, allocates dynamic storage, and then constructs the message in the allocated memory using the snprintf() function. The addition operations are not checked for integer overflow because the string referenced by user is known to have a length of 256 or less. Because the %s characters are replaced by the string referenced by user in the call to snprintf() , the resulting string needs 1 byte less than is allocated. The snprintf() function is commonly used for messages that are displayed in multiple locations or messages that are difficult to build. However, the resulting code contains a format-string vulnerability because the msg includes untrusted user input and is passed as the format-string argument in the call to fprintf() ."
        },
        "compliant": {
          "heading": "Compliant Solution ( fprintf() )",
          "pre_code_commentary": "This compliant solution passes the untrusted user input as one of the variadic arguments to fprintf() and not as part of the format string, eliminating the possibility of a format-string vulnerability:",
          "code": "#include <stdio.h>\n \nvoid incorrect_password(const char *user) {\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  fprintf(stderr, msg_format, user);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "This noncompliant code example is similar to the first noncompliant code example but uses the POSIX function syslog() [ IEEE Std 1003.1:2013 ] instead of the fprintf() function. The syslog() function is also susceptible to format-string vulnerabilities.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n \nvoid incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  syslog(LOG_INFO, msg);\n  free(msg);\n}\n",
          "explanation_after": "The syslog() function first appeared in BSD 4.2 and is supported by Linux and other modern UNIX implementations. It is not available on Windows systems."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution passes the untrusted user input as one of the variadic arguments to syslog() instead of including it in the format string:",
          "code": "#include <syslog.h>\n \nvoid incorrect_password(const char *user) {\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  syslog(LOG_INFO, msg_format, user);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to exclude user input from format specifiers may allow an attacker to crash a vulnerable process, view the contents of the stack, view memory content, or write to an arbitrary memory location and consequently execute arbitrary code with the permissions of the vulnerable process.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "FIO32-C",
    "title": "Do not perform operations on devices that are only appropriate for files",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO32-C.+Do+not+perform+operations+on+devices+that+are+only+appropriate+for+files",
    "description": "File names on many operating systems, including Windows and UNIX, may be used to access special files , which are actually devices. Reserved Microsoft Windows device names include AUX , CON , PRN , COM1 , and LPT1 or paths using the \\\\.\\ device namespace. Device files on UNIX systems are used to apply access rights and to direct operations on the files to the appropriate device drivers.\n\nAUX\n\nCON\n\nPRN\n\nCOM1\n\nLPT1\n\n\\\\.\\\n\nPerforming operations on device files that are intended for ordinary character or binary files can result in crashes and denial-of-service attacks . For example, when Windows attempts to interpret the device name as a file resource, it performs an invalid resource access that usually results in a crash [ Howard 2002 ].\n\nDevice files in UNIX can be a security risk when an attacker can access them in an unauthorized way. For example, if attackers can read or write to the /dev/kmem device, they may be able to alter the priority, UID, or other attributes of their process or simply crash the system. Similarly, access to disk devices, tape devices, network devices, and terminals being used by other processes can lead to problems [ Garfinkel 1996 ].\n\n/dev/kmem\n\nOn Linux, it is possible to lock certain applications by attempting to open devices rather than files. Consider the following example:\n\n/dev/mouse\n/dev/console\n/dev/tty0\n/dev/zero\n\n/dev/mouse\n/dev/console\n/dev/tty0\n/dev/zero\n\nA Web browser that failed to check for these devices would allow an attacker to create a website with image tags such as <IMG src=\"file:///dev/mouse\"> that would lock the user's mouse [ Howard 2002 ].\n\n<IMG src=\"file:///dev/mouse\">",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the user can specify a locked device or a FIFO (first-in, first-out) file name, which can cause the program to hang on the call to fopen() :",
          "code": "#include <stdio.h>\n \nvoid func(const char *file_name) {\n  FILE *file;\n  if ((file = fopen(file_name, \"wb\")) == NULL) {\n    /* Handle error */\n  }\n\n  /* Operate on the file */\n\n  if (fclose(file) == EOF) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "POSIX defines the O_NONBLOCK flag to open() , which ensures that delayed operations on a file do not hang the program [ IEEE Std 1003.1:2013 ].\n\nWhen opening a FIFO with O_RDONLY or O_WRONLY set: If O_NONBLOCK is set, an open() for reading-only returns without delay. An open() for writing-only returns an error if no process currently has the file open for reading. If O_NONBLOCK is clear, an open() for reading-only blocks the calling thread until a thread opens the file for writing. An open() for writing-only blocks the calling thread until a thread opens the file for reading. When opening a block special or character special file that supports nonblocking opens: If O_NONBLOCK is set, the open() function returns without blocking for the device to be ready or available; subsequent behavior is device-specific. If O_NONBLOCK is clear, the open() function blocks the calling thread until the device is ready or available before returning. Otherwise, the behavior of O_NONBLOCK is unspecified.\n\nOnce the file is open, programmers can use the POSIX lstat() and fstat() functions to obtain information about a file and the S_ISREG() macro to determine if the file is a regular file.\n\nBecause the behavior of O_NONBLOCK on subsequent calls to read() or write() is unspecified , it is advisable to disable the flag after it has been determined that the file in question is not a special device.\n\nWhen available (Linux 2.1.126+, FreeBSD, Solaris 10, POSIX.1-2008), the O_NOFOLLOW flag should also be used. (See POS01-C. Check for the existence of links when dealing with files .) When O_NOFOLLOW is not available, symbolic link checks should use the method from POS35-C. Avoid race conditions while checking for the existence of a symbolic link .",
          "code": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#ifdef O_NOFOLLOW\n  #define OPEN_FLAGS O_NOFOLLOW | O_NONBLOCK\n#else\n  #define OPEN_FLAGS O_NONBLOCK\n#endif\n\nvoid func(const char *file_name) {\n  struct stat orig_st;\n  struct stat open_st;\n  int fd;\n  int flags;\n\n  if ((lstat(file_name, &orig_st) != 0) ||\n      (!S_ISREG(orig_st.st_mode))) {\n    /* Handle error */\n  }\n\n  /* Race window */\n\n  fd = open(file_name, OPEN_FLAGS | O_WRONLY);\n  if (fd == -1) {\n    /* Handle error */\n  }\n\n  if (fstat(fd, &open_st) != 0) {\n    /* Handle error */\n  }\n\n  if ((orig_st.st_mode != open_st.st_mode) ||\n      (orig_st.st_ino  != open_st.st_ino) ||\n      (orig_st.st_dev  != open_st.st_dev)) {\n    /* The file was tampered with */\n  }\n\n  /* \n   * Optional: drop the O_NONBLOCK now that we are sure\n   * this is a good file.\n   */\n  if ((flags = fcntl(fd, F_GETFL)) == -1) {\n    /* Handle error */\n  }\n\n  if (fcntl(fd, F_SETFL, flags & ~O_NONBLOCK) == -1) {\n    /* Handle error */\n  }\n\n  /* Operate on the file */\n\n  if (close(fd) == -1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "This code contains an intractable TOCTOU (time-of-check, time-of-use) race condition under which an attacker can alter the file referenced by file_name following the call to lstat() but before the call to open() . The switch will be discovered after the file is opened, but opening the file cannot be prevented in the case where this action itself causes undesired behavior. (See FIO45-C. Avoid TOCTOU race conditions while accessing files for more information about TOCTOU race conditions.)\n\nEssentially, an attacker can switch out a file for one of the file types shown in the following table with the specified effect.\n\nType\n\nNote on Effect\n\nAnother regular file\n\nThe fstat() verification fails.\n\nFIFO\n\nEither open() returns -1 and sets errno to ENXIO , or open() succeeds and the fstat() verification fails.\n\nSymbolic link\n\nopen() returns -1 if O_NOFOLLOW is available; otherwise, the fstat() verification fails.\n\nSpecial device\n\nUsually the fstat() verification fails on st_mode . This can still be a problem if the device is one for which just opening (or closing) it causes a side effect. If st_mode compares equal, then the device is one that, after opening, appears to be a regular file. It would then fail the fstat() verification on st_dev and st_ino (unless it happens to be the same file, as can happen with /dev/fd/* on Solaris, but this would not be a problem).\n\nTo be compliant with this rule and to prevent this TOCTOU race condition, file_name must refer to a file in a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory .)"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "This noncompliant code example uses the GetFileType() function to attempt to prevent opening a special file:",
          "code": "#include <Windows.h>\n \nvoid func(const TCHAR *file_name) {\n  HANDLE hFile = CreateFile(\n    file_name,\n    GENERIC_READ | GENERIC_WRITE, 0, \n    NULL, OPEN_EXISTING,\n    FILE_ATTRIBUTE_NORMAL, NULL\n  );\n  if (hFile == INVALID_HANDLE_VALUE) {\n    /* Handle error */\n  } else if (GetFileType(hFile) != FILE_TYPE_DISK) {\n    /* Handle error */\n    CloseHandle(hFile);\n  } else {\n    /* Operate on the file */\n    CloseHandle(hFile);\n  }\n}",
          "explanation_after": "Although tempting, the Win32 GetFileType() function is dangerous in this case. If the file name given identifies a named pipe that is currently blocking on a read request, the call to GetFileType() will block until the read request completes. This provides an effective attack vector for a denial-of-service attack on the application. Furthermore, the act of opening a file handle may cause side effects, such as line states being set to their default voltage when opening a serial device."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "Microsoft documents a list of reserved identifiers that represent devices and have a device namespace to be used specifically by devices [ MSDN ]. In this compliant solution, the isReservedName() function can be used to determine if a specified path refers to a device. Care must be taken to avoid a TOCTOU race condition when first testing a path name using the isReservedName() function and then later operating on that path name.",
          "code": "#include <ctype.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic bool isReservedName(const char *path) {\n  /* This list of reserved names comes from MSDN */\n  static const char *reserved[] = {\n    \"nul\", \"con\", \"prn\", \"aux\", \"com1\", \"com2\", \"com3\",\n    \"com4\", \"com5\", \"com6\", \"com7\", \"com8\", \"com9\",\n    \"lpt1\", \"lpt2\", \"lpt3\", \"lpt4\", \"lpt5\", \"lpt6\",\n    \"lpt7\", \"lpt8\", \"lpt9\"\n  };\n  bool ret = false;\n\n/*\n * First, check to see if this is a device namespace, which\n * always starts with \\\\.\\, because device namespaces are not\n * valid file paths.\n */\n\n  if (!path || 0 == strncmp(path, \"\\\\\\\\.\\\\\", 4)) {\n    return true;\n  }\n\n  /* Compare against the list of ancient reserved names */\n  for (size_t i = 0; !ret &&\n       i < sizeof(reserved) / sizeof(*reserved); ++i) {\n   /*\n    * Because Windows uses a case-insensitive file system, operate on\n    * a lowercase version of the given filename. Note: This ignores\n    * globalization issues and assumes ASCII characters.\n    */\n    if (0 == _stricmp(path, reserved[i])) {\n      ret = true;\n    }\n  }\n  return ret;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Allowing operations that are appropriate only for regular files to be performed on devices can result in denial-of-service attacks or more serious exploits depending on the platform.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO34-C",
    "title": "Distinguish between characters read from a file and EOF or WEOF",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO34-C.+Distinguish+between+characters+read+from+a+file+and+EOF+or+WEOF",
    "description": "The EOF macro represents a negative value that is used to indicate that the file is exhausted and no data remains when reading data from a file. EOF is an example of an in-band error indicator . In-band error indicators are problematic to work with, and the creation of new in-band-error indicators is discouraged by ERR02-C. Avoid in-band error indicators .\n\nEOF\n\nEOF\n\nThe byte I/O functions fgetc() , getc() , and getchar() all read a character from a stream and return it as an int. (See STR00-C. Represent characters using an appropriate type .) If the stream is at the end of the file, the end-of-file indicator for the stream is set and the function returns EOF . If a read error occurs, the error indicator for the stream is set and the function returns EOF . If these functions succeed, they cast the character returned into an unsigned char .\n\nfgetc()\n\ngetc()\n\ngetchar()\n\nint.\n\nEOF\n\nEOF\n\nunsigned char\n\nBecause EOF is negative, it should not match any unsigned character value. However, this is only true for implementations where the int type is wider than char . On an implementation where int and char have the same width, a character-reading function can read and return a valid character that has the same bit-pattern as EOF . This could occur, for example, if an attacker inserted a value that looked like EOF into the file or data stream to alter the behavior of the program.\n\nEOF\n\nint\n\nchar\n\nint\n\nchar\n\nEOF\n\nEOF\n\nThe C Standard requires only that the int type be able to represent a maximum value of +32767 and that a char type be no larger than an int . Although uncommon, this situation can result in the integer constant expression EOF being indistinguishable from a valid character; that is, (int)(unsigned char)65535 == -1 . Consequently, failing to use feof() and ferror() to detect end-of-file and file errors can result in incorrectly identifying the EOF character on rare implementations where sizeof(int) == sizeof(char) .\n\nint\n\nchar\n\nint\n\nEOF\n\n(int)(unsigned char)65535 == -1\n\nfeof()\n\nferror()\n\nEOF\n\nsizeof(int) == sizeof(char)\n\nThis problem is much more common when reading wide characters. The fgetwc() , getwc() , and getwchar() functions return a value of type wint_t . This value can represent the next wide character read, or it can represent WEOF , which indicates end-of-file for wide character streams. On most implementations, the wchar_t type has the same width as wint_t , and these functions can return a character indistinguishable from WEOF .\n\nfgetwc()\n\ngetwc()\n\ngetwchar()\n\nwint_t\n\nWEOF\n\nwchar_t\n\nwint_t\n\nWEOF\n\nIn the UTF-16 character set, 0xFFFF is guaranteed not to be a character, which allows WEOF to be represented as the value -1 . Similarly, all UTF-32 characters are positive when viewed as a signed 32-bit integer. All widely used character sets are designed with at least one value that does not represent a character. Consequently, it would require a custom character set designed without consideration of the C programming language for this problem to occur with wide characters or with ordinary characters that are as wide as int .\n\n0xFFFF\n\nWEOF\n\n-1\n\nint\n\nThe C Standard feof() and ferror() functions are not subject to the problems associated with character and integer sizes and should be used to verify end-of-file and file errors for susceptible implementations [ Kettlewell 2002 ]. Calling both functions on each iteration of a loop adds significant overhead, so a good strategy is to temporarily trust EOF and WEOF within the loop but verify them with feof() and ferror() following the loop.\n\nfeof()\n\nferror()\n\nEOF\n\nWEOF\n\nfeof()\n\nferror()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example loops while the character c is not EOF :",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  int c;\n \n  do {\n    c = getchar();\n  } while (c != EOF);\n}\n",
          "explanation_after": "Although EOF is guaranteed to be negative and distinct from the value of any unsigned character, it is not guaranteed to be different from any such value when converted to an int . Consequently, when int has the same width as char , this loop may terminate prematurely."
        },
        "compliant": {
          "heading": "Compliant Solution (Portable)",
          "pre_code_commentary": "This compliant solution uses feof() and ferror() to test whether the EOF was an actual character or a real EOF because of end-of-file or errors:",
          "code": "#include <stdio.h>\n\nvoid func(void) {\n  int c;\n\n  do {\n    c = getchar();\n  } while (c != EOF || (!feof(stdin) && !ferror(stdin)));\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Nonportable)",
          "pre_code_commentary": "This noncompliant code example uses an assertion to ensure that the code is executed only on architectures where int is wider than char and EOF is guaranteed not to be a valid character value. However, this code example is noncompliant because the variable c is declared as a char rather than an int , making it possible for a valid character value to compare equal to the value of the EOF macro when char is signed because of sign extension:",
          "code": "#include <assert.h>\n#include <limits.h>\n#include <stdio.h>\n\nvoid func(void) {\n  char c;\n  static_assert(UCHAR_MAX < UINT_MAX, \"FIO34-C violation\");\n\n  do {\n    c = getchar();\n  } while (c != EOF);\n}\n",
          "explanation_after": "Assuming that a char is a signed 8-bit type and an int is a 32-bit type, if getchar() returns the character value '\\xff (decimal 255), it will be interpreted as EOF because this value is sign-extended to 0xFFFFFFFF (the value of EOF ) to perform the comparison. (See STR34-C. Cast characters to unsigned char before converting to larger integer sizes .)"
        },
        "compliant": {
          "heading": "Compliant Solution (Nonportable)",
          "pre_code_commentary": "This compliant solution declares c to be an int . Consequently, the loop will terminate only when the file is exhausted.",
          "code": "#include <assert.h>\n#include <stdio.h>\n#include <limits.h>\n\nvoid func(void) {\n  int c;\n  static_assert(UCHAR_MAX < UINT_MAX, \"FIO34-C violation\");\n\n  do {\n    c = getchar();\n  } while (c != EOF);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Wide Characters)",
          "pre_code_commentary": "In this noncompliant example, the result of the call to the C standard library function getwc() is stored into a variable of type wchar_t and is subsequently compared with WEOF :",
          "code": "#include <stddef.h>\n#include <stdio.h>\n#include <wchar.h>\n\nenum { BUFFER_SIZE = 32 };\n\nvoid g(void) {\n  wchar_t buf[BUFFER_SIZE];\n  wchar_t wc;\n  size_t i = 0;\n\n  while ((wc = getwc(stdin)) != L'\\n' && wc != WEOF) {\n    if (i < (BUFFER_SIZE - 1)) {\n      buf[i++] = wc;\n    }\n  }\n  buf[i] = L'\\0';\n}\n",
          "explanation_after": "This code suffers from two problems. First, the value returned by getwc() is immediately converted to wchar_t before being compared with WEOF . Second, there is no check to ensure that wint_t is wider than wchar_t . Both of these problems make it possible for an attacker to terminate the loop prematurely by supplying the wide-character value matching WEOF in the file."
        },
        "compliant": {
          "heading": "Compliant Solution (Portable)",
          "pre_code_commentary": "This compliant solution declares wc to be a wint_t to match the integer type returned by getwc() . Furthermore, it does not rely on WEOF to determine end-of-file definitively.",
          "code": "#include <stddef.h>\n#include <stdio.h>\n#include <wchar.h>\n \nenum {BUFFER_SIZE = 32 }\n\nvoid g(void) {\n  wchar_t buf[BUFFER_SIZE];\n  wint_t wc;\n  size_t i = 0;\n  \n  while ((wc = getwc(stdin)) != L'\\n' && wc != WEOF) {\n    if (i < BUFFER_SIZE - 1) {\n      buf[i++] = wc;\n    }\n  }\n\n  if (feof(stdin) || ferror(stdin)) {\n   buf[i] = L'\\0';\n  } else {\n    /* Received a wide character that resembles WEOF; handle error */\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrectly assuming characters from a file cannot match EOF or WEOF has resulted in significant vulnerabilities, including command injection attacks. (See the *CA-1996-22 advisory.)",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "FIO37-C",
    "title": "Do not assume that fgets() or fgetws() returns a nonempty string when successful",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO37-C.+Do+not+assume+that+fgets%28%29+or+fgetws%28%29+returns+a+nonempty+string+when+successful",
    "description": "Errors can occur when incorrect assumptions are made about the type of data being read. These assumptions may be violated, for example, when binary data has been read from a file instead of text from a user's terminal or the output of a process is piped to stdin. (See FIO14-C. Understand the difference between text mode and binary mode with file streams .) On some systems, it may also be possible to input a null byte (as well as other binary codes) from the keyboard.\n\nstdin.\n\nSubclause 7.23.7.2 of the C Standard paragraph 3 [ ISO/IEC 9899:2024 ] says,\n\nThe fgets function returns s if successful. If end-of-file is encountered and no characters have been read into the array, the contents of the array remain unchanged and a null pointer is returned. If a read error occurs during the operation, the members of the array have unspecified values and a null pointer is returned.\n\nThe wide-character function fgetws() has the same behavior. Therefore, if fgets() or fgetws() returns a non-null pointer, it is safe to assume that the array contains data. However, it is erroneous to assume that the array contains a nonempty string because the data may contain null characters.\n\nfgetws()\n\nfgets()\n\nfgetws()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to remove the trailing newline ( \\n ) from an input line. The fgets() function is typically used to read a newline-terminated line of input from a stream. It takes a size parameter for the destination buffer and copies, at most, size - 1 characters from a stream to a character array.",
          "code": "#include <stdio.h>\n#include <string.h>\n \nenum { BUFFER_SIZE = 1024 };\n\nvoid func(void) {\n  char buf[BUFFER_SIZE];\n\n  if (fgets(buf, sizeof(buf), stdin) == NULL) {\n    /* Handle error */\n  }\n  buf[strlen(buf) - 1] = '\\0';\n}",
          "explanation_after": "The strlen() function computes the length of a string by determining the number of characters that precede the terminating null character. A problem occurs if the first character read from the input by fgets() happens to be a null character. This may occur, for example, if a binary data file is read by the fgets() call [ Lai 2006 ]. If the first character in buf is a null character, strlen(buf) returns 0, the expression strlen(buf) - 1 wraps around to a large positive value, and a write-outside-array-bounds error occurs."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses strchr() to replace the newline character in the string if it exists:",
          "code": "#include <stdio.h>\n#include <string.h>\n \nenum { BUFFER_SIZE = 1024 };\n\nvoid func(void) {\n  char buf[BUFFER_SIZE];\n  char *p;\n\n  if (fgets(buf, sizeof(buf), stdin)) {\n    p = strchr(buf, '\\n');\n    if (p) {\n      *p = '\\0';\n    }\n  } else {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrectly assuming that character data has been read can result in an out-of-bounds memory write or other flawed logic.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "FIO38-C",
    "title": "Do not copy a FILE object",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO38-C.+Do+not+copy+a+FILE+object",
    "description": "According to the C Standard, 7.23.3, paragraph 6 [ ISO/IEC 9899:2024 ],\n\nThe address of the FILE object used to control a stream may be significant; a copy of a FILE object is not required to serve in place of the original.\n\nFILE\n\nFILE\n\nConsequently, do not copy a FILE object.\n\nFILE",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example can fail because a by-value copy of stdout is being used in the call to fputs() :",
          "code": "#include <stdio.h>\n \nint main(void) {\n  FILE my_stdout = *stdout;\n  if (fputs(\"Hello, World!\\n\", &my_stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": "When compiled under Microsoft Visual Studio 2013 and run on Windows, this noncompliant example results in an \"access violation\" at runtime."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, a copy of the stdout pointer to the FILE object is used in the call to fputs() :",
          "code": "#include <stdio.h>\n \nint main(void) {\n  FILE *my_stdout = stdout;\n  if (fputs(\"Hello, World!\\n\", my_stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using a copy of a FILE object in place of the original may result in a crash, which can be used in a denial-of-service attack .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO39-C",
    "title": "Do not alternately input and output from a stream without an intervening flush or positioning call",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO39-C.+Do+not+alternately+input+and+output+from+a+stream+without+an+intervening+flush+or+positioning+call",
    "description": "The C Standard, 7.23.5.3, paragraph 7 [ ISO/IEC 9899:2024 ], places the following restrictions on update streams:\n\nWhen a file is opened with update mode . . ., both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the fflush function or to a file positioning function ( fseek , fsetpos , or rewind ), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations.\n\nfflush\n\nfseek\n\nfsetpos\n\nrewind\n\nThe following scenarios can result in undefined behavior . (See undefined behavior 156 .)\n\nReceiving input from a stream directly following an output to that stream without an intervening call to fflush() , fseek() , fsetpos() , or rewind() if the file is not at end-of-file Outputting to a stream after receiving input from that stream without a call to fseek() , fsetpos() , or rewind() if the file is not at end-of-file\n\nfflush()\n\nfseek()\n\nfsetpos()\n\nrewind()\n\nfseek()\n\nfsetpos()\n\nrewind()\n\nConsequently, a call to fseek() , fflush() , or fsetpos() is necessary between input and output to the same stream. See ERR07-C. Prefer functions that support error checking over equivalent functions that don't for more information on why fseek() is preferred over rewind() .\n\nfseek()\n\nfflush()\n\nfsetpos()\n\nfseek()\n\nrewind()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example appends data to a file and then reads from the same file:",
          "code": "#include <stdio.h>\n \nenum { BUFFERSIZE = 32 };\n\nextern void initialize_data(char *data, size_t size);\n \nvoid func(const char *file_name) {\n  char data[BUFFERSIZE];\n  char append_data[BUFFERSIZE];\n  FILE *file;\n\n  file = fopen(file_name, \"a+\");\n  if (file == NULL) {\n    /* Handle error */\n  }\n \n  initialize_data(append_data, BUFFERSIZE);\n\n  if (fwrite(append_data, 1, BUFFERSIZE, file) != BUFFERSIZE) {\n    /* Handle error */\n  }\n  if (fread(data, 1, BUFFERSIZE, file) < BUFFERSIZE) {\n    /* Handle there not being data */\n  }\n\n  if (fclose(file) == EOF) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "Because there is no intervening flush or positioning call between the calls to fread() and fwrite() , the behavior is undefined ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, fseek() is called between the output and input, eliminating the undefined behavior 156 :",
          "code": "#include <stdio.h>\n \nenum { BUFFERSIZE = 32 };\nextern void initialize_data(char *data, size_t size);\n \nvoid func(const char *file_name) {\n  char data[BUFFERSIZE];\n  char append_data[BUFFERSIZE];\n  FILE *file;\n\n  file = fopen(file_name, \"a+\");\n  if (file == NULL) {\n    /* Handle error */\n  }\n\n  initialize_data(append_data, BUFFERSIZE);\n  if (fwrite(append_data, BUFFERSIZE, 1, file) != BUFFERSIZE) {\n    /* Handle error */\n  }\n\n  if (fseek(file, 0L, SEEK_SET) != 0) {\n    /* Handle error */\n  }\n\n  if (fread(data, BUFFERSIZE, 1, file) != 0) {\n    /* Handle there not being data */\n  }\n\n  if (fclose(file) == EOF) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Alternately inputting and outputting from a stream without an intervening flush or positioning call is undefined behavior 156 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FIO40-C",
    "title": "Reset strings on fgets()  or fgetws() failure",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO40-C.+Reset+strings+on+fgets%28%29++or+fgetws%28%29+failure",
    "description": "If either of the C Standard fgets() or fgetws() functions fail, the contents of the array being written is indeterminate . (See undefined behavior 175 .)  It is necessary to reset the string to a known value to avoid errors on subsequent string manipulation functions.\n\nfgets()\n\nfgetws()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, an error flag is set if fgets() fails. However, buf is not reset and has indeterminate contents:",
          "code": "#include <stdio.h>\n \nenum { BUFFER_SIZE = 1024 };\nvoid func(FILE *file) {\n  char buf[BUFFER_SIZE];\n\n  if (fgets(buf, sizeof(buf), file) == NULL) {\n    /* Set error flag and continue */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, buf is set to an empty string if fgets() fails. The equivalent solution for fgetws() would set buf to an empty wide string.",
          "code": "#include <stdio.h>\n \nenum { BUFFER_SIZE = 1024 };\n\nvoid func(FILE *file) {\n  char buf[BUFFER_SIZE];\n\n  if (fgets(buf, sizeof(buf), file) == NULL) {\n    /* Set error flag and continue */\n    *buf = '\\0';\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Making invalid assumptions about the contents of an array modified by fgets() or fgetws() can result in undefined behavior 175 and abnormal program termination .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FIO41-C",
    "title": "Do not call getc(), putc(), getwc(), or putwc() with a stream argument that has side effects",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO41-C.+Do+not+call+getc%28%29%2C+putc%28%29%2C+getwc%28%29%2C+or+putwc%28%29+with+a+stream+argument+that+has+side+effects",
    "description": "Do not invoke getc() or putc() or their wide-character analogues getwc() and putwc() with a stream argument that has side effects. The stream argument passed to these macros may be evaluated more than once if these functions are implemented as unsafe macros. (See PRE31-C. Avoid side effects in arguments to unsafe macros for more information.)\n\ngetc()\n\nputc()\n\ngetwc()\n\nputwc()\n\nThis rule does not apply to the character argument in putc() or the wide-character argument in putwc() , which is guaranteed to be evaluated exactly once.\n\nputc()\n\nputwc()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( getc() )",
          "pre_code_commentary": "This noncompliant code example calls the getc() function with an expression as the stream argument. If getc() is implemented as a macro, the file may be opened multiple times. (See FIO24-C. Do not open a file that is already open .)",
          "code": "#include <stdio.h>\n \nvoid func(const char *file_name) {\n  FILE *fptr;\n\n  int c = getc(fptr = fopen(file_name, \"r\"));\n  if (feof(fptr) || ferror(fptr)) {\n    /* Handle error */\n  }\n\n  if (fclose(fptr) == EOF) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "This noncompliant code example also violates ERR33-C. Detect and handle standard library errors because the value returned by fopen() is not checked for errors."
        },
        "compliant": {
          "heading": "Compliant Solution ( getc() )",
          "pre_code_commentary": "In this compliant solution, fopen() is called before getc() and its return value is checked for errors:",
          "code": "#include <stdio.h>\n \nvoid func(const char *file_name) {\n  int c;\n  FILE *fptr;\n\n  fptr = fopen(file_name, \"r\");\n  if (fptr == NULL) {\n    /* Handle error */\n  }\n\n  c = getc(fptr);\n  if (c == EOF) {\n    /* Handle error */\n  }\n\n  if (fclose(fptr) == EOF) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( putc() )",
          "pre_code_commentary": "In this noncompliant example, putc() is called with an expression as the stream argument. If putc() is implemented as a macro, this expression might be evaluated multiple times.",
          "code": "#include <stdio.h>\n \nvoid func(const char *file_name) {\n  FILE *fptr = NULL;\n  int c = 'a';\n \n  while (c <= 'z') {\n    if (putc(c++, fptr ? fptr :\n         (fptr = fopen(file_name, \"w\"))) == EOF) {\n      /* Handle error */\n    }\n  }\n\n  if (fclose(fptr) == EOF) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "This noncompliant code example might appear safe even if the putc() macro evaluates its stream argument multiple times, as the ternary conditional expression ostensibly prevents multiple calls to fopen() . However, the assignment to fptr and the evaluation of fptr as the controlling expression of the ternary conditional expression can take place between the same sequence points, resulting in undefined behavior 34 (a violation of EXP30-C. Do not depend on the order of evaluation for side effects ). This code also violates ERR33-C. Detect and handle standard library errors because it fails to check the return value from fopen() ."
        },
        "compliant": {
          "heading": "Compliant Solution ( putc() )",
          "pre_code_commentary": "In this compliant solution, the stream argument to putc() no longer has side effects:",
          "code": "#include <stdio.h>\n \nvoid func(const char *file_name) {\n  int c = 'a'; \n  FILE *fptr = fopen(file_name, \"w\");\n \n  if (fptr == NULL) {\n    /* Handle error */\n  }\n\n  while (c <= 'z') {\n    if (putc(c++, fptr) == EOF) {\n      /* Handle error */\n    }\n  }\n\n  if (fclose(fptr) == EOF) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "The expression c++ is perfectly safe because putc() guarantees to evaluate its character argument exactly once.\n\nNOTE: The output of this compliant solution differs depending on the character set. For example, when run on a machine using an ASCII-derived code set such as ISO-8859 or Unicode, this solution will print out the 26 lowercase letters of the English alphabet. However, if run with an EBCDIC-based code set, such as Codepage 037 or Codepage 285, punctuation marks or symbols may be output between the letters."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using an expression that has side effects as the stream argument to getc() , putc() , or getwc() can result in unexpected behavior and abnormal program termination .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO42-C",
    "title": "Close files when they are no longer needed",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO42-C.+Close+files+when+they+are+no+longer+needed",
    "description": "A call to the fopen() or freopen() function must be matched with a call to fclose() before the lifetime of the last pointer that stores the return value of the call has ended or before normal program termination, whichever occurs first.\n\nfopen()\n\nfreopen()\n\nfclose()\n\nIn general, this rule should also be applied to other functions with open and close resources, such as the POSIX open() and close() functions, or the Microsoft Windows CreateFile() and CloseHandle() functions.\n\nopen()\n\nclose()\n\nCreateFile()\n\nCloseHandle()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code example is noncompliant because the file opened by the call to fopen() is not closed before function func() returns:",
          "code": "#include <stdio.h>\n \nint func(const char *filename) {\n  FILE *f = fopen(filename, \"r\"); \n  if (NULL == f) {\n    return -1;\n  }\n  /* ... */\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the file pointed to by f is closed before returning to the caller:",
          "code": "#include <stdio.h>\n \nint func(const char *filename) {\n  FILE *f = fopen(filename, \"r\"); \n  if (NULL == f) {\n    return -1;\n  }\n  /* ... */\n  if (fclose(f) == EOF) {\n    return -1;\n  }\n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( exit() )",
          "pre_code_commentary": "This code example is noncompliant because the resource allocated by the call to fopen() is not closed before the program terminates.  Although exit() closes the file, the program has no way of determining if an error occurs while flushing or closing the file.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n  \nint main(void) {\n  FILE *f = fopen(filename, \"w\"); \n  if (NULL == f) {\n    exit(EXIT_FAILURE);\n  }\n  /* ... */\n  exit(EXIT_SUCCESS);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( exit() )",
          "pre_code_commentary": "In this compliant solution, the program closes f explicitly before calling exit() , allowing any error that occurs when flushing or closing the file to be handled appropriately:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n  FILE *f = fopen(filename, \"w\"); \n  if (NULL == f) {\n    /* Handle error */\n  }\n  /* ... */\n  if (fclose(f) == EOF) {\n    /* Handle error */\n  }\n  exit(EXIT_SUCCESS);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "This code example is noncompliant because the resource allocated by the call to open() is not closed before function func() returns:",
          "code": "#include <stdio.h>\n#include <fcntl.h>\n \nint func(const char *filename) {\n  int fd = open(filename, O_RDONLY, S_IRUSR);\n  if (-1 == fd) {\n    return -1;\n  }\n  /* ... */\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "In this compliant solution, fd is closed before returning to the caller:",
          "code": "#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n \nint func(const char *filename) {\n  int fd = open(filename, O_RDONLY, S_IRUSR);\n  if (-1 == fd) {\n    return -1\n  }\n  /* ... */\n  if (-1 == close(fd)) {\n    return -1;\n  }\n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "In this noncompliant code example, the file opened by the Microsoft Windows CreateFile() function is not closed before func() returns:",
          "code": "#include <Windows.h>\n\nint func(LPCTSTR filename) {\n  HANDLE hFile = CreateFile(filename, GENERIC_READ, 0, NULL,\n                            OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, NULL);\n  if (INVALID_HANDLE_VALUE == hFile) {\n    return -1;\n  }\n  /* ... */\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "In this compliant solution, hFile is closed by invoking the CloseHandle() function before returning to the caller:",
          "code": "#include <Windows.h>\n \nint func(LPCTSTR filename) {\n  HANDLE hFile = CreateFile(filename, GENERIC_READ, 0, NULL,\n                            OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, NULL);\n  if (INVALID_HANDLE_VALUE == hFile) {\n    return -1;\n  } \n  /* ... */ \n  if (!CloseHandle(hFile)) {\n    return -1;\n  }\n \n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to properly close files may allow an attacker to exhaust system resources and can increase the risk that data written into in-memory file buffers will not be flushed in the event of abnormal program termination .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO45-C",
    "title": "Avoid TOCTOU race conditions while accessing files",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files",
    "description": "A TOCTOU (time-of-check, time-of-use) race condition is possible when two or more concurrent processes are operating on a shared file system [ Seacord 2013b ]. Typically, the first access is a check to verify some attribute of the file, followed by a call to use the file. An attacker can alter the file between the two accesses, or replace the file with a symbolic or hard link to a different file. These TOCTOU conditions can be exploited when a program performs two or more file operations on the same file name or path name.\n\nA program that performs two or more file operations on a single file name or path name creates a race window between the two file operations. This race window comes from the assumption that the file name or path name refers to the same resource both times. If an attacker can modify the file, remove it, or replace it with a different file, then this assumption will not hold.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "If an existing file is opened for writing with the w mode argument, the file's previous contents (if any) are destroyed. This noncompliant code example tries to prevent an existing file from being overwritten by first opening it for reading before opening it for writing. An attacker can exploit the race window between the two calls to fopen() to overwrite an existing file.",
          "code": "#include <stdio.h>\n\nvoid open_some_file(const char *file) {\n  FILE *f = fopen(file, \"r\");\n  if (NULL != f) {\n    /* File exists, handle error */\n  } else {\n    f = fopen(file, \"w\");\n    if (NULL == f) {\n      /* Handle error */\n    }\n \n    /* Write to file */\n    if (fclose(f) == EOF) {\n      /* Handle error */\n    }\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution invokes fopen() at a single location and uses the x mode of fopen() , which was added in C11. This mode causes fopen() to fail if the file exists. This check and subsequent open is performed without creating a race window. The x mode provides exclusive access to the file only if the host environment provides this support.",
          "code": "#include <stdio.h>\n\nvoid open_some_file(const char *file) {\n  FILE *f = fopen(file, \"wx\");\n  if (NULL == f) {\n    /* Handle error */\n  }\n  /* Write to file */\n  if (fclose(f) == EOF) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "If an existing file is opened for writing with the w mode argument, the file's previous contents (if any) are destroyed. This noncompliant code example tries to prevent an existing file from being overwritten by first opening it for reading before opening it for writing. An attacker can exploit the race window between the two calls to fopen() to overwrite an existing file.",
          "code": "#include <stdio.h>\n\nvoid open_some_file(const char *file) {\n  FILE *f = fopen(file, \"r\");\n  if (NULL != f) {\n    /* File exists, handle error */\n  } else {\n    f = fopen(file, \"w\");\n    if (NULL == f) {\n      /* Handle error */\n    }\n \n    /* Write to file */\n    if (fclose(f) == EOF) {\n      /* Handle error */\n    }\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution uses the O_CREAT and O_EXCL flags of POSIX's open() function. These flags cause open() to fail if the file exists.",
          "code": "#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nvoid open_some_file(const char *file) {\n  int fd = open(file, O_CREAT | O_EXCL | O_WRONLY);\n  if (-1 != fd) {\n    FILE *f = fdopen(fd, \"w\");\n    if (NULL != f) {\n      /* Write to file */\n\n      if (fclose(f) == EOF) {\n        /* Handle error */\n      }\n    } else {\n      if (close(fd) == -1) {\n        /* Handle error */\n      }\n    }\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "TOCTOU race conditions can result in unexpected behavior , including privilege escalation.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FIO46-C",
    "title": "Do not access a closed file",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO46-C.+Do+not+access+a+closed+file",
    "description": "Using the value of a pointer to a FILE object after the associated file is closed is undefined behavior . (See undefined behavior 153 .) Programs that close the standard streams (especially stdout but also stderr and stdin ) must be careful not to use these streams in subsequent function calls, particularly those that implicitly operate on them (such as printf() , perror() , and getc() ).\n\nFILE\n\nstdout\n\nstderr\n\nstdin\n\nprintf()\n\nperror()\n\ngetc()\n\nThis rule can be generalized to other file representations.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the stdout stream is used after it is closed:",
          "code": "#include <stdio.h>\n \nint close_stdout(void) {\n  if (fclose(stdout) == EOF) {\n    return -1;\n  }\n \n  printf(\"stdout successfully closed.\\n\");\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, stdout is not used again after it is closed. This must remain true for the remainder of the program, or stdout must be assigned the address of an open file object.",
          "code": "#include <stdio.h>\n \nint close_stdout(void) {\n  if (fclose(stdout) == EOF) {\n    return -1;\n  }\n\n  fputs(\"stdout successfully closed.\", stderr);\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using the value of a pointer to a FILE object after the associated file is closed is undefined behavior 153 .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO47-C",
    "title": "Use valid format strings",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FIO47-C.+Use+valid+format+strings",
    "description": "The formatted output functions ( fprintf() and related functions) convert, format, and print their arguments under control of a format string. The C Standard, 7.23.6.1, paragraph 3 [ ISO/IEC 9899:2024 ], specifies\n\nfprintf()\n\nThe format shall be a multibyte character sequence, beginning and ending in its initial shift state. The format is composed of zero or more directives: ordinary multibyte characters (not % ), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments, converting them, if applicable, according to the corresponding conversion specifier, and then writing the result to the output stream.\n\nEach conversion specification is introduced by the % character followed (in order) by\n\n%\n\nZero or more flags (in any order), which modify the meaning of the conversion specification An optional minimum field width An optional precision that gives the minimum number of digits, the maximum number of digits, or the maximum number of bytes, etc. depending on the conversion specifier An optional length modifier that specifies the size of the argument A conversion specifier character that indicates the type of conversion to be applied\n\nCommon mistakes in creating format strings include\n\nProviding an incorrect number of arguments for the format string Using invalid conversion specifiers Using a flag character that is incompatible with the conversion specifier Using a length modifier that is incompatible with the conversion specifier Mismatching the argument type and conversion specifier Using an argument of type other than int for width or precision\n\nint\n\nThe following table summarizes the compliance of various conversion specifications. The first column contains one or more conversion specifier characters. The next four columns consider the combination of the specifier characters with the various flags (the apostrophe [ ' ], - , + , the space character, # , and 0 ). The next eight columns consider the combination of the specifier characters with the various length modifiers ( h , hh , l , ll , j , z , t , and L ).\n\n'\n\n-\n\n+\n\n#\n\n0\n\nh\n\nhh\n\nl\n\nll\n\nj\n\nz\n\nt\n\nL\n\nValid combinations are marked with a type name; arguments matched with the conversion specification are interpreted as that type. For example, an argument matched with the specifier %hd is interpreted as a short , so short appears in the cell where d and h intersect. The last column denotes the expected types of arguments matched with the original specifier characters.\n\n%hd\n\nshort\n\nshort\n\nd\n\nh\n\nValid and meaningful combinations are marked by the symbol (save for the length modifier columns, as described previously). Valid combinations that have no effect are labeled N/E . Using a combination marked by the symbol, using a specification not represented in the table, or using an argument of an unexpected type is undefined behavior . (See undefined behaviors 158 , 160 , 162 , 163 , 166 , and 167 .)\n\nConversion Specifier Character ' XSI - + SPACE # 0 h hh l ll j z t L Argument Type d , i short signed char long long long intmax_t size_t ptrdiff_t Signed integer o unsigned short unsigned char unsigned long unsigned long long uintmax_t size_t ptrdiff_t Unsigned integer u unsigned short unsigned char unsigned long unsigned long long uintmax_t size_t ptrdiff_t Unsigned integer x , X unsigned short unsigned char unsigned long unsigned long long uintmax_t size_t ptrdiff_t Unsigned integer f , F N/E N/E long double double or long double e , E N/E N/E long double double or long double g , G N/E N/E long double double or long double a , A N/E N/E long double double or long double c wint_t int or wint_t s NTWS NTBS or NTWS p void* n short* char* long* long long* intmax_t* size_t* ptrdiff_t* Pointer to integer C XSI wint_t S XSI NTWS % None\n\n'\n\n-\n\nh\n\nhh\n\nl\n\nll\n\nj\n\nz\n\nt\n\nL\n\nd\n\ni\n\nshort\n\nsigned char\n\nlong\n\nlong long\n\nintmax_t\n\nsize_t\n\nptrdiff_t\n\no\n\nunsigned \n\nshort\n\nunsigned \nchar\n\nunsigned \n\nunsigned \nlong\n\nunsigned \n\nunsigned \n\nunsigned \nlong long\n\nunsigned \n\nunsigned \n\nuintmax_t\n\nsize_t\n\nptrdiff_t\n\nu\n\nunsigned short\n\nunsigned\n  char\n\nunsigned\n\nunsigned \nlong\n\nunsigned \n\nunsigned \n\nunsigned \nlong long\n\nunsigned \n\nunsigned \n\nuintmax_t\n\nsize_t\n\nptrdiff_t\n\nx\n\nX\n\nunsigned short\n\nunsigned \nchar\n\nunsigned \n\nunsigned \nlong\n\nunsigned \n\nunsigned \n\nunsigned \nlong long\n\nunsigned \n\nunsigned \n\nuintmax_t\n\nsize_t\n\nptrdiff_t\n\nf\n\nF\n\nlong double\n\ndouble\n\nlong double\n\ne\n\nE\n\nlong double\n\ndouble\n\nlong double\n\ng\n\nG\n\nlong double\n\ndouble\n\nlong double\n\na\n\nA\n\nlong double\n\ndouble\n\nlong double\n\nc\n\nwint_t\n\nint\n\nwint_t\n\ns\n\np\n\nvoid*\n\nn\n\nshort*\n\nchar*\n\nlong*\n\nlong long*\n\nintmax_t*\n\nsize_t*\n\nptrdiff_t*\n\nC\n\nwint_t\n\nS\n\n%\n\nSPACE: The space ( \" \" ) character N/E : No effect NTBS: char* argument pointing to a null-terminated character string NTWS: wchar_t* argument pointing to a null-terminated wide character string XSI: ISO/IEC 9945-2003 XSI extension\n\n\" \"\n\nchar*\n\nwchar_t*\n\nThe formatted input functions ( fscanf() and related functions) use similarly specified format strings and impose similar restrictions on their format strings and arguments.\n\nfscanf()\n\nDo not supply an unknown or invalid conversion specification or an invalid combination of flag character, precision, length modifier, or conversion specifier to a formatted IO function. Likewise, do not provide a number or type of argument that does not match the argument type of the conversion specifier used in the format string.\n\nFormat strings are usually string literals specified at the call site, but they need not be. However, they should not contain tainted values . (See FIO30-C. Exclude user input from format strings for more information.)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Mismatches between arguments and conversion specifications may result in undefined behavior 163 . Compilers may diagnose type mismatches in formatted output function invocations. In this noncompliant code example, the error_type argument to printf() is incorrectly matched with the s specifier rather than with the d specifier. Likewise, the error_msg argument is incorrectly matched with the d specifier instead of the s specifier. These usages result in undefined behavior 163 . One possible result of this invocation is that printf() will interpret the error_type argument as a pointer and try to read a string from the address that error_type contains, possibly resulting in an access violation.",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  const char *error_msg = \"Resource not available to user.\";\n  int error_type = 3;\n  /* ... */\n  printf(\"Error (type %s): %d\\n\", error_type, error_msg);\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution ensures that the arguments to the printf() function match their respective conversion specifications:",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  const char *error_msg = \"Resource not available to user.\";\n  int error_type = 3;\n  /* ... */\n  printf(\"Error (type %d): %s\\n\", error_type, error_msg);\n\n  /* ... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrectly specified format strings can result in memory corruption or abnormal program termination .",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FLP00-C",
    "title": "Understand the limitations of floating-point numbers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP00-C.+Understand+the+limitations+of+floating-point+numbers",
    "description": "The C programming language provides the ability to use floating-point numbers for calculations. The C Standard specifies requirements on a conforming implementation for floating-point numbers but makes few guarantees about the specific underlying floating-point representation because of the existence of competing floating-point systems.\n\nBy definition, a floating-point number is of finite precision and, regardless of the underlying implementation, is prone to errors associated with rounding. (See FLP01-C. Take care in rearranging floating-point expressions and FLP02-C. Avoid using floating-point numbers when precise computation is needed .)\n\nThe most common floating-point system is specified by the IEEE 754 standard. An older floating-point system is the IBM floating-point representation (sometimes called IBM/370). Each of these systems has different precisions and ranges of representable values. As a result, they do not represent all of the same values, are not binary compatible, and have different associated error rates.\n\nBecause of a lack of guarantees on the specifics of the underlying floating-point system, no assumptions can be made about either precision or range. Even if code is not intended to be portable, the chosen compiler's behavior must be well understood at all compiler optimization levels.\n\nHere is a simple illustration of precision limitations. The following code prints the decimal representation of 1/3 to 50 decimal places. Ideally, it would print 50 numeral 3s:\n\n#include <stdio.h>\n\nint main(void) {\n  float f = 1.0f / 3.0f;\n  printf(\"Float is %.50f\\n\", f);\n  return 0;\n}\n\n#include <stdio.h>\n\nint main(void) {\n  float f = 1.0f / 3.0f;\n  printf(\"Float is %.50f\\n\", f);\n  return 0;\n}\n\nOn 64-bit Linux, with GCC 4.1, it produces\n\nFloat is 0.33333334326744079589843750000000000000000000000000\n\nFloat is 0.33333334326744079589843750000000000000000000000000\n\nOn 64-bit Windows, with Microsoft Visual Studio 2012, it produces\n\nFloat is 0.33333334326744080000000000000000000000000000000000\n\nFloat is 0.33333334326744080000000000000000000000000000000000\n\nAdditionally, compilers may treat floating-point variables differently under different levels of optimization [ Gough 2005 ]:\n\ndouble a = 3.0;\ndouble b = 7.0;\ndouble c = a / b;\n\nif (c == a / b) {\n  printf(\"Comparison succeeds\\n\");\n} else {\n  printf(\"Unexpected result\\n\");\n}\n\ndouble a = 3.0;\ndouble b = 7.0;\ndouble c = a / b;\n\nif (c == a / b) {\n  printf(\"Comparison succeeds\\n\");\n} else {\n  printf(\"Unexpected result\\n\");\n}\n\nWhen compiled on an IA-32 Linux machine with GCC 3.4.4 at optimization level 1 or higher, or on an IA-64 Windows machine with Microsoft Visual Studio 2012 in Debug or Release mode, this code prints\n\nComparison succeeds\n\nComparison succeeds\n\nOn an IA-32 Linux machine with GCC 3.4.4 with optimization turned off, this code prints\n\nUnexpected result\n\nUnexpected result\n\nThe reason for this behavior is that Linux uses the internal extended precision mode of the x87 floating-point unit (FPU) on IA-32 machines for increased accuracy during computation. When the result is stored into memory by the assignment to c , the FPU automatically rounds the result to fit into a double . The value read back from memory now compares unequally to the internal representation, which has extended precision. Windows does not use the extended precision mode, so all computation is done with double precision, and there are no differences in precision between values stored in memory and those internal to the FPU. For GCC, compiling at optimization level 1 or higher eliminates the unnecessary store into memory, so all computation happens within the FPU with extended precision [ Gough 2005 ].\n\nc\n\ndouble\n\nThe standard constant __FLT_EPSILON__ can be used to evaluate if two floating-point values are close enough to be considered equivalent given the granularity of floating-point operations for a given implementation. __FLT_EPSILON__ represents the difference between 1 and the least value greater than 1 that is representable as a float. The granularity of a floating-point operation is determined by multiplying the operand with the larger absolute value by __FLT_EPSILON__ .\n\n__FLT_EPSILON__\n\n__FLT_EPSILON__\n\n__FLT_EPSILON__\n\n#include <math.h>\nfloat RelDif(float a, float b) {\n  float c = fabsf(a);\n  float d = fabsf(b);\n\n  d = fmaxf(c, d);\n\n  return d == 0.0f ? 0.0f : fabsf(a - b) / d;\n}\n\n/* ... */\n\nfloat a = 3.0f;\nfloat b = 7.0f;\nfloat c = a / b;\n\nif (RelDif(c, a / b) <= __FLT_EPSILON__) {\n  puts(\"Comparison succeeds\");\n} else {\n  puts(\"Unexpected result\");\n}\n\n#include <math.h>\nfloat RelDif(float a, float b) {\n  float c = fabsf(a);\n  float d = fabsf(b);\n\n  d = fmaxf(c, d);\n\n  return d == 0.0f ? 0.0f : fabsf(a - b) / d;\n}\n\n/* ... */\n\nfloat a = 3.0f;\nfloat b = 7.0f;\nfloat c = a / b;\n\nif (RelDif(c, a / b) <= __FLT_EPSILON__) {\n  puts(\"Comparison succeeds\");\n} else {\n  puts(\"Unexpected result\");\n}\n\nOn all tested platforms, this code prints\n\nComparison succeeds\n\nComparison succeeds\n\nFor double precision and long double precision floating-point values, use a similar approach using the __DBL_EPSILON__ and __LDBL_EPSILON__ constants, respectively.\n\ndouble\n\nlong double\n\n__DBL_EPSILON__\n\n__LDBL_EPSILON__\n\nConsider using numerical analysis to properly understand the numerical properties of the problem.",
    "examples": null,
    "risk_assessment": {
      "explanation": "Failing to understand the limitations of floating-point numbers can result in unexpected computational results and exceptional conditions, possibly resulting in a violation of data integrity.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP01-C",
    "title": "Take care in rearranging floating-point expressions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP01-C.+Take+care+in+rearranging+floating-point+expressions",
    "description": "Be careful when rearranging floating-point expressions to ensure the greatest accuracy of the result.\n\nSubclause 5.1.2.3, paragraph 14, of the C Standard [ ISO/IEC 9899:2011 ], states:\n\nRearrangement for floating-point expressions is often restricted because of limitations in precision as well as range. The implementation cannot generally apply the mathematical associative rules for addition or multiplication, nor the distributive rule, because of roundoff error, even in the absence of overflow and underflow. Likewise, implementations cannot generally replace decimal constants to rearrange expressions. In the following fragment, rearrangements suggested by mathematical rules for real numbers are often not valid. double x, y, z;\n/* ... */\nx = (x * y) * z; /* not equivalent to x *= y * z; */\nz = (x - y) + y ; /* not equivalent to z = x; */\nz = x + x * y; /* not equivalent to z = x * (1.0 + y); */\ny = x / 5.0; /* not equivalent to y = x * 0.2; */\n\ndouble x, y, z;\n/* ... */\nx = (x * y) * z; /* not equivalent to x *= y * z; */\nz = (x - y) + y ; /* not equivalent to z = x; */\nz = x + x * y; /* not equivalent to z = x * (1.0 + y); */\ny = x / 5.0; /* not equivalent to y = x * 0.2; */",
    "examples": null,
    "risk_assessment": {
      "explanation": "Failure to understand the limitations in precision of floating-point-represented numbers and their implications on the arrangement of expressions can cause unexpected arithmetic results.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP02-C",
    "title": "Avoid using floating-point numbers when precise computation is needed",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP02-C.+Avoid+using+floating-point+numbers+when+precise+computation+is+needed",
    "description": "Computers can represent only a finite number of digits. It is therefore impossible to precisely represent repeating binary-representation values such as 1/3 or 1/5 with the most common floating-point representation: binary floating point.\n\nWhen precise computation is necessary, use alternative representations that can accurately represent the values. For example, if you are performing arithmetic on decimal values and need an exact decimal rounding, represent the values in binary-coded decimal instead of using floating-point values. Another option is decimal floating-point arithmetic, as specified by ANSI/IEEE 754-2007. ISO/IEC WG14 has drafted a proposal to add support for decimal floating-point arithmetic to the C language [ ISO/IEC DTR 24732 ].\n\nWhen precise computation is necessary, carefully and methodically estimate the maximum cumulative error of the computations, regardless of whether decimal or binary is used, to ensure that the resulting error is within tolerances. Consider using numerical analysis to properly understand the problem. An introduction can be found in David Goldberg's \"What Every Computer Scientist Should Know about Floating-Point Arithmetic\" [ Goldberg 1991 ].",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example takes the mean of 10 identical numbers and checks to see if the mean matches this number. It should match because the 10 numbers are all 10.1 . Yet, because of the imprecision of floating-point arithmetic, the computed mean does not match this number.",
          "code": "#include <stdio.h>\n\n/* Returns the mean value of the array */\nfloat mean(float array[], int size) {\n  float total = 0.0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n    total += array[i];\n    printf(\"array[%zu] = %f and total is %f\\n\", i, array[i], total);\n  }\n  if (size != 0)\n    return total / size;\n  else\n    return 0.0;\n}\n\nenum { array_size = 10 };\nfloat array_value = 10.1;\n\nint main(void) {\n  float array[array_size];\n  float avg;\n  size_t i;\n  for (i = 0; i < array_size; i++) {\n    array[i] = array_value;\n  }\n\n  avg = mean( array, array_size);\n  printf(\"mean is %f\\n\", avg);\n  if (avg == array[0]) {\n    printf(\"array[0] is the mean\\n\");\n  } else {\n    printf(\"array[0] is not the mean\\n\");\n  }\n  return 0;\n}\n",
          "explanation_after": "On a 64-bit Linux machine using GCC 4.1, this program yields the following output:"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The noncompliant code can be fixed by replacing the floating-point numbers with integers for the internal additions. Floats are used only when printing results and when doing the division to compute the mean.",
          "code": "#include <stdio.h>\n\n/* Returns the mean value of the array */\nfloat mean(int array[], int size) {\n  int total = 0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n    total += array[i];\n    printf(\"array[%zu] = %f and total is %f\\n\", i, array[i] / 100.0, total / 100.0);\n  }\n  if (size != 0)\n    return ((float) total) / size;\n  else\n    return 0.0;\n}\n\nenum {array_size = 10};\nint array_value = 1010;\n\nint main(void) {\n  int array[array_size];\n  float avg;\n  size_t i;\n  for (i = 0; i < array_size; i++) {\n    array[i] = array_value;\n  }\n\n  avg = mean(array, array_size);\n  printf(\"mean is %f\\n\", avg / 100.0);\n  if (avg == array[0]) {\n    printf(\"array[0] is the mean\\n\");\n  } else {\n    printf(\"array[0] is not the mean\\n\");\n  }\n  return 0;\n}\n",
          "explanation_after": "On a 64-bit Linux machine using GCC 4.1, this program yields the following expected output:"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using a representation other than floating point may allow for more accurate results.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP03-C",
    "title": "Detect and handle floating-point errors",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP03-C.+Detect+and+handle+floating-point+errors",
    "description": "Errors during floating-point operations are often neglected by programmers who instead focus on validating operands before an operation. Errors that occur during floating-point operations are admittedly difficult to determine and diagnose, but the benefits of doing so often outweigh the costs. This recommendation suggests ways to capture errors during floating-point operations.\n\nThe following code exhibits undefined behavior:\n\nint j = 0;\nint iResult = 1 / j;\n\nint j = 0;\nint iResult = 1 / j;\n\nOn most implementations, integer division by zero is a terminal error, commonly printing a diagnostic message and aborting the program:\n\ndouble x = 0.0;\ndouble dResult = 1 / x;\n\ndouble x = 0.0;\ndouble dResult = 1 / x;\n\nFloating-point division by zero also results in undefined behavior , although most implementations do not treat it as a terminal error. If additional precautions are not taken, it results in a silent error.\n\nThe most portable way to determine if a floating-point exceptional condition has occurred is to use the floating-point exception facilities provided by C in fenv.h .\n\nfenv.h\n\nHowever, the C floating-point exception functions are not without problems. The following caveats exist regarding the interaction between floating-point exceptions and conversions:\n\nConversion from floating-point to integer may cause an \"invalid\" floating-point exception. If this occurs, the value of that integer is undefined and should not be used. Most implementations fail to raise \"invalid\" for conversions from any negative or \"large\" positive floating-point values to unsigned integer types or to signed char . (See tflt2int.c .) When a noninteger floating-point value is converted to an integer, the \"inexact\" floating-point exception is raised.\n\nsigned char\n\nFor information regarding floating-point number conversions, see FLP34-C. Ensure that floating-point conversions are within range of the new type .\n\nThe C Standard does not require all implementations to support floating-point exceptions. Each exception macro in fenv.h is defined if, and only if, the corresponding exception is supported. Only implementations that use IEC 60559 (formerly IEEE-754) floating-point arithmetic are required to support all five exceptions defined by C (see the C Standard, subclause 7.6.2 [ ISO/IEC 9899:2011 ]). Nevertheless, these functions are the most portable solution for handling floating-point exceptions.\n\nfenv.h\n\nA less portable but potentially more secure solution is to use the capabilities provided by the underlying implementation. If this approach is taken, the caveats of that system must be well understood. The following table provides a starting point for some common operating systems:\n\nOperating System How to Handle Floating-Point Errors Linux Solaris 10 AIX 5.3 HP-UX 11.31 Mac OS X 10.5 Use the C floating-point exception functions Windows Use either the C floating-point exception functions or structured exception handling through _fpieee_flt [ MSDN ]\n\n_fpieee_flt",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, floating-point operations are performed without checking for errors. Note that range checking has been intentionally omitted because the intent is to detect errors following the floating-point operation.",
          "code": "void fpOper_noErrorChecking(void) {\n  /* ... */\n  double a = 1e-40, b, c = 0.1;\n  float x = 0, y;\n  /* Inexact and underflows */\n  y = a;\n  /* Divide-by-zero operation */\n  b = y / x;\n  /* Inexact (loss of precision) */\n  c = sin(30) * a;\n  /* ... */\n}\n",
          "explanation_after": "However, exceptional conditions (as indicated by the comments) occur that may lead to unexpected arithmetic results."
        },
        "compliant": {
          "heading": "Compliant Solution (C)",
          "pre_code_commentary": "This compliant solution uses C Standard functions to handle floating-point errors:",
          "code": "#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\n\nvoid fpOper_fenv(void) {\n  double a = 1e-40, b, c = 0.1;\n  float x = 0, y;\n  int fpeRaised;\n  /* ... */\n\n  feclearexcept(FE_ALL_EXCEPT);\n  /* Store a into y is inexact and underflows: */\n  y = a;\n  fpeRaised = fetestexcept(FE_ALL_EXCEPT);\n  /* fpeRaised has FE_INEXACT and FE_UNDERFLOW */\n\n  feclearexcept(FE_ALL_EXCEPT);\n\n  /* Divide-by-zero operation */\n  b = y / x;\n  fpeRaised = fetestexcept(FE_ALL_EXCEPT);\n  /* fpeRaised has FE_DIVBYZERO */\n\n  feclearexcept(FE_ALL_EXCEPT);\n\n  c = sin(30) * a;\n  fpeRaised = fetestexcept(FE_ALL_EXCEPT);\n  /* fpeRaised has FE_INEXACT */\n\n  feclearexcept(FE_ALL_EXCEPT);\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, floating-point operations are performed without checking for errors. Note that range checking has been intentionally omitted because the intent is to detect errors following the floating-point operation.",
          "code": "void fpOper_noErrorChecking(void) {\n  /* ... */\n  double a = 1e-40, b, c = 0.1;\n  float x = 0, y;\n  /* Inexact and underflows */\n  y = a;\n  /* Divide-by-zero operation */\n  b = y / x;\n  /* Inexact (loss of precision) */\n  c = sin(30) * a;\n  /* ... */\n}\n",
          "explanation_after": "However, exceptional conditions (as indicated by the comments) occur that may lead to unexpected arithmetic results."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "Microsoft Visual Studio 2008 and earlier versions do not support C functions to handle floating-point errors. Windows provides an alternative method using _statusfp() , _statusfp2() , and _clearfp() .",
          "code": "void fpOper_usingStatus(void) {\n  /* ... */\n  double a = 1e-40, b, c;\n  float x = 0, y;\n  unsigned int rv = _clearfp();\n\n  /* Store into y is inexact and underflows: */\n  y = a;\n  rv = _clearfp();  /* rv has _SW_INEXACT and _SW_UNDERFLOW */\n\n  /* Zero-divide */\n  b = y / x; rv = _clearfp(); /* rv has _SW_ZERODIVIDE */\n\n  /* Inexact */\n  c = sin(30) * a; rv = _clearfp(); /* rv has _SW_INEXACT */\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, floating-point operations are performed without checking for errors. Note that range checking has been intentionally omitted because the intent is to detect errors following the floating-point operation.",
          "code": "void fpOper_noErrorChecking(void) {\n  /* ... */\n  double a = 1e-40, b, c = 0.1;\n  float x = 0, y;\n  /* Inexact and underflows */\n  y = a;\n  /* Divide-by-zero operation */\n  b = y / x;\n  /* Inexact (loss of precision) */\n  c = sin(30) * a;\n  /* ... */\n}\n",
          "explanation_after": "However, exceptional conditions (as indicated by the comments) occur that may lead to unexpected arithmetic results."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows SEH)",
          "pre_code_commentary": "Microsoft Visual Studio 2008 also uses structured exception handling (SEH) to handle floating-point operations. SEH provides more information about the error and allows the programmer to change the results of the floating-point operation that caused the error condition.",
          "code": "void fp_usingSEH(void) {\n  /* ... */\n  double a = 1e-40, b, c = 0.1;\n  float x = 0, y;\n  unsigned int rv ;\n\n  unmask_fpsr();\n\n  _try {\n    /* Store into y is inexact and underflows: */\n    y = a;\n\n    /* Divide-by-zero operation */\n    b = y / x;\n\n    /* Inexact */\n    c = sin(30) * a;\n  }\n\n  _except (_fpieee_flt(\n             GetExceptionCode(),\n             GetExceptionInformation(),\n             fpieee_handler)) {\n  {\n  printf (\"fpieee_handler: EXCEPTION_EXECUTE_HANDLER\");\n  }\n\n  /* ... */\n}\n\nvoid unmask_fpsr(void) {\n  unsigned int u;\n  unsigned int control_word;\n  _controlfp_s(&control_word, 0, 0);\n  u = control_word & ~(_EM_INVALID\n                     | _EM_DENORMAL\n                     | _EM_ZERODIVIDE\n                     | _EM_OVERFLOW\n                     | _EM_UNDERFLOW\n                     | _EM_INEXACT);\n  _controlfp_s( &control_word, u, _MCW_EM);\n  return ;\n}\n\nint fpieee_handler(_FPIEEE_RECORD *ieee) {\n  /* ... */\n\n  switch (ieee->RoundingMode) {\n    case _FpRoundNearest:\n      /* ... */\n      break;\n\n      /*\n       * Other RMs include _FpRoundMinusInfinity,\n       * _FpRoundPlusInfinity, _FpRoundChopped.\n       */\n\n      /* ... */\n    }\n\n  switch (ieee->Precision) {\n    case _FpPrecision24:\n      /* ... */\n      break;\n\n      /* Other Ps include _FpPrecision53 */\n      /* ... */\n    }\n\n   switch (ieee->Operation) {\n     case _FpCodeAdd:\n       /* ... */\n       break;\n\n       /* \n        * Other Ops include _FpCodeSubtract, _FpCodeMultiply,\n        * _FpCodeDivide, _FpCodeSquareRoot, _FpCodeCompare,\n        * _FpCodeConvert, _FpCodeConvertTrunc.\n        */\n       /* ... */\n    }\n\n  /* \n   * Process the bitmap ieee->Cause.\n   * Process the bitmap ieee->Enable.\n   * Process the bitmap ieee->Status.\n   * Process the Operand ieee->Operand1, \n   * evaluate format and Value.\n   * Process the Operand ieee->Operand2, \n   * evaluate format and Value.\n   * Process the Result ieee->Result, \n   * evaluate format and Value.\n   * The result should be set according to the operation \n   * specified in ieee->Cause and the result formatted as \n   * specified in ieee->Result.\n   */\n\n  /* ... */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Undetected floating-point errors may result in lower program efficiency, inaccurate results, or software vulnerabilities . Most processors stall for a significant duration when an operation incurs a NaN (not a number) value.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP04-C",
    "title": "Check floating-point inputs for exceptional values",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP04-C.+Check+floating-point+inputs+for+exceptional+values",
    "description": "Floating-point numbers can take on two classes of exceptional values; infinity and NaN (not-a-number). These values are returned as the result of exceptional or otherwise unresolvable floating-point operations. (See also FLP32-C. Prevent or detect domain and range errors in math functions .) Additionally, they can be directly input by a user by scanf or similar functions. Failure to detect and handle such values can result in undefined behavior .\n\nscanf\n\nNaN values are particularly problematic because the expression NaN == NaN (for every possible value of NaN) returns false. Any comparisons made with NaN as one of the arguments returns false, and all arithmetic functions on NaNs simply propagate them through the code. Hence, a NaN entered in one location in the code and not properly handled could potentially cause problems in other, more distant sections.\n\nFormatted-input functions such as scanf will accept the values INF , INFINITY , or NAN (case insensitive) as valid inputs for the %f format specification, allowing malicious users to feed them directly to a program. Programs should therefore check to ensure that all input floating-point values (especially those controlled by the user) have neither of these values if doing so would be inappropriate. The <math.h> library provides two macros for this purpose: isinf and isnan .\n\nscanf\n\nINF\n\nINFINITY\n\nNAN\n\n%f\n\n<math.h>\n\nisinf\n\nisnan",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example accepts user data without first validating it:",
          "code": "float currentBalance; /* User's cash balance */\nvoid doDeposit() {\n  float val;\n\n  scanf(\"%f\", &val);\n\n  if(val >= MAX_VALUE - currentBalance) {\n    /* Handle range error */\n  }\n\n  currentBalance += val;\n}\n",
          "explanation_after": "This can be a problem if an invalid value is entered for val and subsequently used for calculations or as control values. The user could, for example, input the strings \"INF\" , \"INFINITY\" , or \"NAN\" (case insensitive) on the command line, which would be parsed by scanf into the floating-point representations of infinity and NaN. All subsequent calculations using these values would be invalid, possibly crashing the program and enabling a denial-of-service attack .\n\nHere, for example, entering \"nan\" for val would force currentBalance to also equal \"nan\" , corrupting its value. If this value is used elsewhere for calculations, every resulting value would also be a NaN, possibly destroying important data.\n\nThe following code was run on 32-bit GNU Linux using the GCC 3.4.6 compiler. On this platform, FLT_MAX has the value 340282346638528859811704183484516925440.000000.\n\nThe following table shows the value of currentBalance returned for various arguments:\n\nInput\n\ncurrentBalance\n\n25\n\n25.00000\n\ninfinity\n\ninf\n\n-infinity\n\n-inf\n\nNaN\n\n1e9999\n\n-1e9999\n\nAs this example demonstrates, the user can enter the exceptional values infinity and NaN , as well as force a float's value to be infinite, by entering out-of-range floats. These entries subsequently corrupt the value of currentBalance . So by entering exceptional floats, an attacker can corrupt the program data, possibly leading to a crash."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution first validates the input float before using it. The value is tested to ensure that it is neither an infinity nor a NaN.",
          "code": "float currentBalance; /* User's cash balance */\n\nvoid doDeposit() {\n  float val;\n\n  scanf(\"%f\", &val);\n  if (isinf(val)) {\n    /* Handle infinity error */\n  }\n  if (isnan(val)) {\n    /* Handle NaN error */\n  }\n  if (val >= MAX_VALUE - currentBalance) {\n    /* Handle range error */\n  }\n\n  currentBalance += val;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Inappropriate floating-point inputs can result in invalid calculations and unexpected results, possibly leading to crashing and providing a denial-of-service opportunity.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP05-C",
    "title": "Do not use denormalized numbers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP05-C.+Do+not+use+denormalized+numbers",
    "description": "Most implementations of C use the IEEE 754 standard for floating-point representation. In this representation, floats are encoded using 1 sign bit, 8 exponent bits, and 23 mantissa bits. Doubles are encoded and used exactly the same way, except they use 1 sign bit, 11 exponent bits, and 52 mantissa bits. These bits encode the values of s , the sign; M , the significand; and E , the exponent. Floating-point numbers are then calculated as (−1) s * M * 2 E .\n\nOrdinarily, all of the mantissa bits are used to express significant figures, in addition to a leading 1, which is implied and therefore left out. Consequently, floats ordinarily have 24 significant bits of precision, and doubles ordinarily have 53 significant bits of precision. Such numbers are called normalized numbers . All floating-point numbers are limited in the sense that they have fixed precision. See FLP00-C. Understand the limitations of floating-point numbers .\n\nMantissa bits are used to express extremely small numbers that are too small to encode normally because of the lack of available exponent bits. Using mantissa bits extends the possible range of exponents. Because these bits no longer function as significant bits of precision, the total precision of extremely small numbers is less than usual. Such numbers are called denormalized, and they are more limited than normalized numbers. However, even using normalized numbers where precision is required can pose a risk. See FLP02-C. Avoid using floating-point numbers when precise computation is needed for more information.\n\nDenormalized numbers can severely impair the precision of floating-point numbers and should not be used.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code attempts to reduce a floating-point number to a denormalized value and then restore the value. This operation is imprecise.",
          "code": "#include <stdio.h>\nfloat x = 1/3.0;\nprintf(\"Original    : %e\\n\", x);\nx = x * 7e-45;\nprintf(\"Denormalized: %e\\n\", x);\nx = x / 7e-45;\nprintf(\"Restored    : %e\\n\", x);\n",
          "explanation_after": "This code produces the following output on implementations that use IEEE 754 floats:"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Do not allow code to produce denormalized numbers. If floats are producing denormalized numbers, use doubles instead.",
          "code": "#include <stdio.h>\ndouble x = 1/3.0;\nprintf(\"Original    : %e\\n\", x);\nx = x * 7e-45;\nprintf(\"Denormalized: %e\\n\", x);\nx = x / 7e-45;\nprintf(\"Restored    : %e\\n\", x);\n",
          "explanation_after": "If using doubles also produces denormalized numbers, using long doubles may or may not help. (On some implementations, long double has the same exponent range as double.) If using long doubles produces denormalized numbers, some other solution must be found.\n\nDenormalized numbers can also be troublesome because some functions have implementation-defined behavior when used with denormalized values. For example, using the %a or $%A conversion specifier in a format string can produce implementation-defined results when applied to denormalized numbers.\n\nSubclause 7.21.6.1, paragraph 8, of the C Standard [ ISO/IEC 9899:2011 ], states:\n\nA double argument representing a floating-point number is converted in the style [-]0 x h.hhhh p ± d , where there is one hexadecimal digit (which is nonzero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point character.\n\nRelying on the %a and %A specifiers to produce values without a leading zero is error prone.\n\nOn a 32-bit Linux machine using GCC 4.3.2, this code produces the following output:"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Floating-point numbers are an approximation; using subnormal floating-point number are a worse approximation.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP06-C",
    "title": "Convert integers to floating point for floating-point operations",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP06-C.+Convert+integers+to+floating+point+for+floating-point+operations",
    "description": "Using integer arithmetic to calculate a value for assignment to a floating-point variable may lead to loss of information. This problem can be avoided by converting one of the integers in the expression to a floating type.\n\nWhen converting integers to floating-point values, and vice versa, it is important to carry out proper range checks to avoid undefined behavior (see FLP34-C. Ensure that floating-point conversions are within range of the new type ).",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the division and multiplication operations take place on integers and are then converted to floating point. Consequently, floating-point variables d , e , and f are not initialized correctly because the operations take place before the values are converted to floating-point values. The results are truncated to the nearest integer or may overflow.",
          "code": "void func(void) {\n  short a = 533;\n  int b = 6789;\n  long c = 466438237;\n\n  float d = a / 7; /* d is 76.0 */\n  double e = b / 30; /* e is 226.0 */\n  double f = c * 789; /* f may be negative due to overflow */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Floating-Point Literal)",
          "pre_code_commentary": "In this compliant solution, the decimal error in initialization is eliminated by ensuring that at least one of the operands to the division operation is floating point:",
          "code": "void func(void) {\n  short a = 533;\n  int b = 6789;\n  long c = 466438237;\n\n  float d = a / 7.0f; /* d is 76.14286 */\n  double e = b / 30.; /* e is 226.3 */\n  double f = (double)c * 789; /* f is 368019768993.0 */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the division and multiplication operations take place on integers and are then converted to floating point. Consequently, floating-point variables d , e , and f are not initialized correctly because the operations take place before the values are converted to floating-point values. The results are truncated to the nearest integer or may overflow.",
          "code": "void func(void) {\n  short a = 533;\n  int b = 6789;\n  long c = 466438237;\n\n  float d = a / 7; /* d is 76.0 */\n  double e = b / 30; /* e is 226.0 */\n  double f = c * 789; /* f may be negative due to overflow */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Conversion)",
          "pre_code_commentary": "In this compliant solution, the decimal error in initialization is eliminated by first storing the integer in the floating-point variable and then performing the arithmetic operation. This practice ensures that at least one of the operands is a floating-point number and that the subsequent arithmetic operation is performed on floating-point operands.",
          "code": "void func(void) {\n  short a = 533;\n  int b = 6789;\n  long c = 466438237;\n\n  float d = a;\n  double e = b;\n  double f = c;\n\n  d /= 7; /* d is 76.14286 */\n  e /= 30; /* e is 226.3 */\n  f *= 789; /* f is 368019768993.0 */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Improper conversions between integers and floating-point values may yield unexpected results, especially loss of precision. Additionally, these unexpected results may actually involve overflow, or undefined behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP07-C",
    "title": "Cast the return value of a function that returns a floating-point type",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP07-C.+Cast+the+return+value+of+a+function+that+returns+a+floating-point+type",
    "description": "Cast the return value of a function that returns a floating point type to ensure predictable program execution.\n\nSubclause 6.8.6.4, paragraph 3, of the C Standard [ ISO/IEC 9899:2011 ] states:\n\nIf a return statement with an expression is executed, the value of the expression is returned to the caller as the value of the function call expression. If the expression has a type different from the return type of the function in which it appears, the value is converted as if by assignment to an object having the return type of the function.\n\nThis paragraph is annotated (footnote 160) as follows:\n\nThe return statement is not an assignment. The overlap restriction of subclause 6.5.16.1 does not apply to the case of function return. The representation of floating-point values may have wider range or precision than implied by the type; a cast may be used to remove this extra range and precision.\n\nConversion as if by assignment to the type of the function is required if the return expression has a different type than the function but not if the return expression has a wider value only because of wide evaluation. This allows seemingly inconsistent and confusing behavior. Consider the following code as an example:\n\nfloat f(float x) {\n  return x * 0.1f;\n}\n\nfloat g(float x) {\n  return x * 0.1;\n}\n\nfloat f(float x) {\n  return x * 0.1f;\n}\n\nfloat g(float x) {\n  return x * 0.1;\n}\n\nFunction f() is allowed to return a value wider than float , but function g() (which uses the wider constant) is not.\n\nf()\n\nfloat\n\ng()\n\nAlthough the standard does not require narrowing return expressions of the same type as the function, it does not clearly state what is allowed. Is it allowed to narrow the result? Is it allowed to narrow the result sometimes but not always? Is it allowed to partially narrow the result (for example, if the application binary interface [ABI] returns floats in double format, but a float function has a float return expression evaluated to wider than double)? An aggressive implementation could argue yes€ to all these questions, though the resulting behavior would complicate debugging and error analysis.\n\nFootnote 160 in the C Standard says a cast may be used to remove extra range and precision from the return expression. This means that a predictable program must have casts on all function calls that return floating-point values (except where the function directly feeds an operator-like assignment that implies the conversion). With type-generic math (tgmath.h) , the programmer has to reason through the tgmath.h resolution rules to determine which casts to apply. These are significant obstacles to writing predictable code.\n\n(tgmath.h)\n\ntgmath.h\n\nThe C Standard, subclause F.6 [ ISO/IEC 9899:2011 ], states:\n\nIf the return expression is evaluated in a floating-point format different from the return type, the expression is converted as if by assignment 362 to the return type of the function and the resulting value is returned to the caller. 362) Assignment removes any extra range and precision.\n\nThis applies only to implementations that conforms to the optional Annex F, \"IEC 60559 Floating-Point Arithmetic.\"  The macro __STDC_IEC_559__ can be used to determine whether an implementation conforms to Annex F.\n\n__STDC_IEC_559__",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example fails to cast the result of the expression in the return statement and thereby guarantee that the range or precision is no wider than expected. The uncertainty in this example is introduced by the constant 0.1f . This constant may be stored with a range or precision that is greater than that of float . Consequently, the result of x * 0.1f may also have a range or precision greater than that of float . As described previously, this range or precision may not be reduced to that of a float , so the caller of calcPercentage() may receive a value that is more precise than expected. This may lead to inconsistent program execution across different platforms.",
          "code": "float calc_percentage(float value) {\n  return value * 0.1f;\n}\n\nvoid float_routine(void) {\n  float value = 99.0f;\n  long double percentage;\n\n  percentage = calc_percentage(value);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (within the Function)",
          "pre_code_commentary": "This compliant solution casts the value of the expression in the return statement. It forces the return value to have the expected range and precision, as described in subclause 5.2.4.2.2, paragraph 9, of the C Standard [ ISO/IEC 9899:2011 ].",
          "code": "float calc_percentage(float value) {\n  return (float)(value * 0.1f);\n}\n\nvoid float_routine(void) {\n  float value = 99.0f;\n  long double percentage;\n\n  percentage = calc_percentage(value);\n}\n",
          "explanation_after": "Forcing the range and precision inside the calcPercentage() function is a good way to fix the problem once without having to apply fixes in multiple locations (every time calcPercentage() is called)."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example fails to cast the result of the expression in the return statement and thereby guarantee that the range or precision is no wider than expected. The uncertainty in this example is introduced by the constant 0.1f . This constant may be stored with a range or precision that is greater than that of float . Consequently, the result of x * 0.1f may also have a range or precision greater than that of float . As described previously, this range or precision may not be reduced to that of a float , so the caller of calcPercentage() may receive a value that is more precise than expected. This may lead to inconsistent program execution across different platforms.",
          "code": "float calc_percentage(float value) {\n  return value * 0.1f;\n}\n\nvoid float_routine(void) {\n  float value = 99.0f;\n  long double percentage;\n\n  percentage = calc_percentage(value);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Outside the Function)",
          "pre_code_commentary": "Source code to the called function may not always be available. This compliant solution casts the return value of the calcPercentage() function to float to force the correct range and precision when the source of the called function cannot be modified.",
          "code": "void float_routine(void) {\n  float value = 99.0f;\n  long double percentage;\n\n  percentage = (float) calc_percentage(value);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to follow this guideline can lead to inconsistent results across different platforms.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP30-C",
    "title": "Do not use floating-point variables as loop counters",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP30-C.+Do+not+use+floating-point+variables+as+loop+counters",
    "description": "Because floating-point numbers represent real numbers, it is often mistakenly assumed that they can represent any simple fraction exactly. Floating-point numbers are subject to representational limitations just as integers are, and binary floating-point numbers cannot represent all real numbers exactly, even if they can be represented in a small number of decimal digits.\n\nIn addition, because floating-point numbers can represent large values, it is often mistakenly assumed that they can represent all significant digits of those values. To gain a large dynamic range, floating-point numbers maintain a fixed number of precision bits (also called the significand) and an exponent, which limit the number of significant digits they can represent.\n\nDifferent implementations have different precision limitations, and to keep code portable, floating-point variables must not be used as the loop induction variable. See Goldberg's work for an introduction to this topic [ Goldberg 1991 ].\n\nFor the purpose of this rule, a loop counter is an induction variable that is used as an operand of a comparison expression that is used as the controlling expression of a do , while , or for loop. An induction variable is a variable that gets increased or decreased by a fixed amount on every iteration of a loop [ Aho 1986 ]. Furthermore, the change to the variable must occur directly in the loop body (rather than inside a function executed within the loop).\n\ndo\n\nwhile\n\nfor",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a floating-point variable is used as a loop counter. The decimal number 0.1 is a repeating fraction in binary and cannot be exactly represented as a binary floating-point number. Depending on the implementation, the loop may iterate 9 or 10 times.",
          "code": "void func(void) {\n  for (float x = 0.1f; x <= 1.0f; x += 0.1f) {\n    /* Loop may iterate 9 or 10 times */\n  }\n}",
          "explanation_after": "For example, when compiled with GCC or Microsoft Visual Studio 2013 and executed on an x86 processor, the loop is evaluated only nine times."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the loop counter is an integer from which the floating-point value is derived:",
          "code": "#include <stddef.h>\n \nvoid func(void) {\n  for (size_t count = 1; count <= 10; ++count) {\n    float x = count / 10.0f;\n    /* Loop iterates exactly 10 times */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a floating-point loop counter is incremented by an amount that is too small to change its value given its precision:",
          "code": "void func(void) {\n  for (float x = 100000001.0f; x <= 100000010.0f; x += 1.0f) {\n    /* Loop may not terminate */\n  }\n}",
          "explanation_after": "On many implementations, this produces an infinite loop."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the loop counter is an integer from which the floating-point value is derived. The variable x is assigned a computed value to reduce compounded rounding errors that are present in the noncompliant code example.",
          "code": "void func(void) {\n  for (size_t count = 1; count <= 10; ++count) {\n    float x = 100000000.0f + (count * 1.0f);\n    /* Loop iterates exactly 10 times */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The use of floating-point variables as loop counters can result in unexpected behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FLP32-C",
    "title": "Prevent or detect domain and range errors in math functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP32-C.+Prevent+or+detect+domain+and+range+errors+in+math+functions",
    "description": "The C Standard, 7.12.1 [ ISO/IEC 9899:2024 ], defines three types of errors that relate specifically to math functions in <math.h> .  Paragraph 2 states\n\n<math.h>\n\nA domain error occurs if an input argument is outside the domain over which the mathematical function is defined.\n\nParagraph 3 states\n\nA pole error (also known as a singularity or infinitary) occurs if the mathematical function has an exact infinite result as the finite input argument(s) are approached in the limit.\n\nParagraph 4 states\n\na range error occurs if and only if the result overflows or underflows\n\nAn example of a domain error is the square root of a negative number, such as sqrt(-1.0) , which has no meaning in real arithmetic. Contrastingly, 10 raised to the 1-millionth power, pow(10., 1e6) , cannot be represented in many floating-point implementations because of the limited range of the type double and consequently constitutes a range error. In both cases, the function will return some value, but the value returned is not the correct result of the computation. An example of a pole error is log(0.0) , which results in negative infinity.\n\nsqrt(-1.0)\n\npow(10., 1e6)\n\ndouble\n\nlog(0.0)\n\nProgrammers can prevent domain and pole errors by carefully bounds-checking the arguments before calling mathematical functions and taking alternative action if the bounds are violated.\n\nRange errors usually cannot be prevented because they are dependent on the implementation of floating-point numbers as well as on the function being applied. Instead of preventing range errors, programmers should attempt to detect them and take alternative action if a range error occurs.\n\nThe following table lists the double forms of standard mathematical functions, along with checks that should be performed to ensure a proper input domain, and indicates whether they can also result in range or pole errors, as reported by the C Standard. Both float and long double forms of these functions also exist but are omitted from the table for brevity. If a function has a specific domain over which it is defined, the programmer must check its input values. The programmer must also check for range errors where they might occur. The standard math functions not listed in this table, such as fabs() , have no domain restrictions and cannot result in range or pole errors.\n\ndouble\n\nfloat\n\nlong double\n\nfabs()\n\nFunction Domain Range Pole acos(x) -1 <= x && x <= 1 No No asin(x) -1 <= x && x <= 1 Yes No atan(x) None Yes No atan2(y, x) None No No acosh(x) x >= 1 Yes No asinh(x) None Yes No atanh(x) -1 < x && x < 1 Yes Yes cosh(x) , sinh(x) None Yes No exp(x) , exp2(x) , expm1(x) None Yes No ldexp(x, exp) None Yes No log(x) , log10(x) , log2(x) x >= 0 No Yes log1p(x) x >= -1 No Yes ilogb(x) x != 0 && !isinf(x) && !isnan(x) Yes No logb(x) x != 0 Yes Yes scalbn(x, n) , scalbln(x, n) None Yes No hypot(x, y) None Yes No pow(x,y) x > 0 || (x == 0 && y > 0) || ( x < 0 && y is an integer) Yes Yes sqrt(x) x >= 0 No No erf(x) None Yes No erfc(x) None Yes No lgamma(x) , tgamma(x) x != 0 && ! ( x < 0 && x is an integer) Yes Yes lrint(x) , lround(x) None Yes No fmod(x, y) , remainder(x, y) , remquo(x, y, quo) y != 0 Yes No nextafter(x, y) , nexttoward(x, y) None Yes No fdim(x,y) None Yes No fma(x,y,z) None Yes No\n\nacos(x)\n\n-1 <= x && x <= 1\n\nasin(x)\n\n-1 <= x && x <= 1\n\natan(x)\n\natan2(y, x)\n\nNone\n\nacosh(x)\n\nx >= 1\n\nasinh(x)\n\natanh(x)\n\n-1 < x && x < 1\n\ncosh(x)\n\nsinh(x)\n\nexp(x)\n\nexp2(x)\n\nexpm1(x)\n\nldexp(x, exp)\n\nlog(x)\n\nlog10(x)\n\nlog2(x)\n\nx >= 0\n\nlog1p(x)\n\nx >= -1\n\nilogb(x)\n\nx != 0 && !isinf(x) && !isnan(x)\n\nlogb(x)\n\nx != 0\n\nscalbn(x, n)\n\nscalbln(x, n)\n\nhypot(x, y)\n\npow(x,y)\n\nx > 0 || (x == 0 && y > 0) ||\n\nx < 0 && y\n\nsqrt(x)\n\nx >= 0\n\nerf(x)\n\nerfc(x)\n\nlgamma(x)\n\ntgamma(x)\n\nx != 0 &&\n\n!\n\nx < 0 && x\n\nlrint(x)\n\nlround(x)\n\nfmod(x, y)\n\nremainder(x, y)\n\nremquo(x, y, quo)\n\ny != 0\n\nnextafter(x, y)\n\nnexttoward(x, y)\n\nfdim(x,y)\n\nfma(x,y,z)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( sqrt() )",
          "pre_code_commentary": "This noncompliant code example determines the square root of x :",
          "code": "#include <math.h>\n \nvoid func(double x) {\n  double result;\n  result = sqrt(x);\n}",
          "explanation_after": "However, this code may produce a domain error if x is negative."
        },
        "compliant": {
          "heading": "Compliant Solution ( sqrt() )",
          "pre_code_commentary": "Because this function has domain errors but no range errors, bounds checking can be used to prevent domain errors:",
          "code": "#include <math.h>\n \nvoid func(double x) {\n  double result;\n\n  if (isless(x, 0.0)) {\n    /* Handle domain error */\n  }\n\n  result = sqrt(x);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( sinh() , Range Errors)",
          "pre_code_commentary": "This noncompliant code example determines the hyperbolic sine of x :",
          "code": "#include <math.h>\n \nvoid func(double x) {\n  double result;\n  result = sinh(x);\n}",
          "explanation_after": "This code may produce a range error if x has a very large magnitude."
        },
        "compliant": {
          "heading": "Compliant Solution ( sinh() , Range Errors)",
          "pre_code_commentary": "Because this function has no domain errors but may have range errors, the programmer must detect a range error and act accordingly:",
          "code": "#include <math.h>\n#include <fenv.h>\n#include <errno.h>\n \nvoid func(double x) { \n  double result;\n  {\n    #pragma STDC FENV_ACCESS ON\n    if (math_errhandling & MATH_ERREXCEPT) {\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    errno = 0;\n\n    result = sinh(x);\n\n    if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n      /* Handle range error */\n    } else if ((math_errhandling & MATH_ERREXCEPT) &&\n               fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n      /* Handle range error */\n    }\n  }\n \n  /* Use result... */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( pow() )",
          "pre_code_commentary": "This noncompliant code example raises x to the power of y :",
          "code": "#include <math.h>\n \nvoid func(double x, double y) {\n  double result;\n  result = pow(x, y);\n}",
          "explanation_after": "This code may produce a domain error if x is negative and y is not an integer value or if x is 0 and y is 0. A domain error or pole error may occur if x is 0 and y is negative, and a range error may occur if the result cannot be represented as a double ."
        },
        "compliant": {
          "heading": "Compliant Solution ( pow() )",
          "pre_code_commentary": "Because the pow() function can produce domain errors, pole errors, and range errors, the programmer must first check that x and y lie within the proper domain and do not generate a pole error and then detect whether a range error occurs and act accordingly:",
          "code": "#include <math.h>\n#include <fenv.h>\n#include <errno.h>\n \nvoid func(double x, double y) {\n  double result;\n\n  if (((x == 0.0f) && islessequal(y, 0.0)) || isless(x, 0.0)) {\n    /* Handle domain or pole error */\n  }\n\n  {\n    #pragma STDC FENV_ACCESS ON\n    if (math_errhandling & MATH_ERREXCEPT) {\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    errno = 0;\n\n    result = pow(x, y);\n \n    if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n      /* Handle range error */\n    } else if ((math_errhandling & MATH_ERREXCEPT) &&\n               fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n      /* Handle range error */\n    }\n  }\n\n  /* Use result... */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( asin() , Subnormal Number)",
          "pre_code_commentary": "This noncompliant code example determines the inverse sine of x :",
          "code": "#include <math.h>\n \nvoid func(float x) {\n  float result = asin(x);\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( asin() , Subnormal Number)",
          "pre_code_commentary": "Because this function has no domain errors but may have range errors, the programmer must detect a range error and act accordingly:",
          "code": "#include <math.h>\n#include <fenv.h>\n#include <errno.h>\nvoid func(float x) { \n  float result;\n\n  {\n    #pragma STDC FENV_ACCESS ON\n    if (math_errhandling & MATH_ERREXCEPT) {\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    errno = 0;\n\n    result = asin(x);\n\n    if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n      /* Handle range error */\n    } else if ((math_errhandling & MATH_ERREXCEPT) &&\n               fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n      /* Handle range error */\n    }\n  }\n\n  /* Use result... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to prevent or detect domain and range errors in math functions may cause unexpected results.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "FLP34-C",
    "title": "Ensure that floating-point conversions are within range of the new type",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP34-C.+Ensure+that+floating-point+conversions+are+within+range+of+the+new+type",
    "description": "If a floating-point value is to be converted to a floating-point value of a smaller range and precision or to an integer type, or if an integer type is to be converted to a floating-point type, the value must be representable in the destination type.\n\nThe C Standard, 6.3.1.4, paragraph 2 [ ISO/IEC 9899:2024 ], says,\n\nWhen a finite value of decimal floating type is converted to an integer type other than bool , the fractional part is discarded (i.e. the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the \"invalid\" floating-point exception shall be raised and the result of the conversion is unspecified.\n\nParagraph 2 of the same subclause says,\n\nWhen a value of integer type is converted to a standard floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined .\n\nAnd subclause 6.3.1.5, paragraph 1+2, says,\n\nWhen a value of real floating type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged. When a value of real floating type is converted to a standard floating type, if the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined .\n\nSee undefined behaviors 16 and 17 .\n\nThis rule does not apply to demotions of floating-point types on implementations that support signed infinity, such as IEEE 754, as all values are within range.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( float to int )",
          "pre_code_commentary": "This noncompliant code example leads to undefined behavior 16 if the integral part of f_a cannot be represented as an integer:",
          "code": "void func(float f_a) {\n  int i_a;\n \n  /* Undefined if the integral part of f_a cannot be represented. */\n  i_a = f_a;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( float to int )",
          "pre_code_commentary": "This compliant solution tests to ensure that the float value will fit within the int variable before performing the assignment.",
          "code": "#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n \nextern size_t popcount(uintmax_t); /* See INT35-C */\n#define PRECISION(umax_value) popcount(umax_value)\n \nvoid func(float f_a) {\n  int i_a;\n \n  if (isnan(f_a) ||\n      PRECISION(INT_MAX) < log2f(fabsf(f_a)) ||\n      (f_a != 0.0F && fabsf(f_a) < FLT_MIN)) {\n    /* Handle error */\n  } else {\n    i_a = f_a;\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Narrowing Conversion)",
          "pre_code_commentary": "This noncompliant code example attempts to perform conversions that may result in truncating values outside the range of the destination types:",
          "code": "void func(double d_a, long double big_d) {\n  double d_b = (float)big_d;\n  float f_a = (float)d_a;\n  float f_b = (float)big_d;\n}\n",
          "explanation_after": "As a result of these conversions, it is possible that d_a is outside the range of values that can be represented by a float or that big_d is outside the range of values that can be represented as either a float or a double . If this is the case, the result is undefined behavior 17 on implementations that do not support Annex F, \"IEC 60559 Floating-Point Arithmetic.\""
        },
        "compliant": {
          "heading": "Compliant Solution (Narrowing Conversion)",
          "pre_code_commentary": "This compliant solution checks whether the values to be stored can be represented in the new type:",
          "code": "#include <float.h>\n#include <math.h>\n \nvoid func(double d_a, long double big_d) {\n  double d_b;\n  float f_a;\n  float f_b;\n\n  if (d_a != 0.0 &&\n      (isnan(d_a) ||\n       isgreater(fabs(d_a), FLT_MAX) ||\n       isless(fabs(d_a), FLT_MIN))) {\n    /* Handle error */\n  } else {\n    f_a = (float)d_a;\n  }\n  if (big_d != 0.0 &&\n      (isnan(big_d) ||\n       isgreater(fabs(big_d), FLT_MAX) ||\n       isless(fabs(big_d), FLT_MIN))) {\n    /* Handle error */\n  } else {\n    f_b = (float)big_d;\n  }\n  if (big_d != 0.0 &&\n      (isnan(big_d) ||\n       isgreater(fabs(big_d), DBL_MAX) ||\n       isless(fabs(big_d), DBL_MIN))) {\n    /* Handle error */\n  } else {\n    d_b = (double)big_d;\n  }  \n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Converting a floating-point value to a floating-point value of a smaller range and precision or to an integer type, or converting an integer type to a floating-point type, can result in a value that is not representable in the destination type and is undefined behavior on implementations that do not support Annex F.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP36-C",
    "title": "Preserve precision when converting integral values to floating-point type",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP36-C.+Preserve+precision+when+converting+integral+values+to+floating-point+type",
    "description": "Narrower arithmetic types can be cast to wider types without any effect on the magnitude of numeric values. However, whereas integer types represent exact values, floating-point types have limited precision. The C Standard, 6.3.1.4 paragraph 3 [ ISO/IEC 9899:2024 ], states\n\nWhen a value of integer type is converted to a standard floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined . Results of some implicit conversions may be represented in greater range and precision than that required by the new type (see 6.3.1.8 and 6.8.7.5).\n\nConversion from integral types to floating-point types without sufficient precision can lead to loss of precision (loss of least significant bits). No runtime exception occurs despite the loss.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, a large value of type long int is converted to a value of type float without ensuring it is representable in the type:",
          "code": "#include <stdio.h>\n\nint main(void) {\n  long int big = 1234567890L;\n  float approx = big;\n  printf(\"%ld\\n\", (big - (long int)approx));\n  return 0;\n}\n",
          "explanation_after": "For most floating-point hardware, the value closest to 1234567890 that is representable in type float is 1234567844 ; consequently, this program prints the value -46 ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution replaces the type float with a double . Furthermore, it uses an assertion to guarantee that the double type can represent any long int without loss of precision. (See INT35-C. Use correct integer precisions and MSC11-C. Incorporate diagnostic tests using assertions .)",
          "code": "#include <assert.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n\nextern size_t popcount(uintmax_t); /* See INT35-C */\n#define PRECISION(umax_value) popcount(umax_value) \n\nint main(void) {\n  assert(PRECISION(LONG_MAX) <= DBL_MANT_DIG * log2(FLT_RADIX));\n  long int big = 1234567890L;\n  double approx = big;\n  printf(\"%ld\\n\", (big - (long int)approx));\n  return 0;\n}\n",
          "explanation_after": "On the same implementation, this program prints 0 , implying that the integer value 1234567890 is representable in type double without change."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Conversion from integral types to floating-point types without sufficient precision can lead to loss of precision (loss of least significant bits).",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP37-C",
    "title": "Do not use object representations to compare floating-point values",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/FLP37-C.+Do+not+use+object+representations+to+compare+floating-point+values",
    "description": "The object representation for floating-point values is implementation defined. However, an implementation that defines the __STDC_IEC_559__ macro shall conform to the IEC 60559 floating-point standard and uses what is frequently referred to as IEEE 754 floating-point arithmetic [ ISO/IEC 9899:2024 ] . The floating-point object representation used by IEC 60559 is one of the most common floating-point object representations in use today.\n\n__STDC_IEC_559__\n\nAll floating-point object representations use specific bit patterns to encode the value of the floating-point number being represented. However, equivalence of floating-point values is not encoded solely by the bit pattern used to represent the value. For instance, if the floating-point format supports negative zero values (as IEC 60559 does), the values -0.0 and 0.0 are equivalent and will compare as equal, but the bit patterns used in the object representation are not identical. Similarly, if two floating-point values are both (the same) NaN, they will not compare as equal, despite the bit patterns being identical, because they are not equivalent.\n\n-0.0\n\n0.0\n\nDo not compare floating-point object representations directly, such as by calling memcmp() or its moral equivalents. Instead, the equality operators ( == and != ) should be used to determine if two floating-point values are equivalent.\n\nmemcmp()\n\n==\n\n!=",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, memcmp() is used to compare two structures for equality. However, since the structure contains a floating-point object, this code may not behave as the programmer intended.",
          "code": "#include <stdbool.h>\n#include <string.h>\n \nstruct S {\n  int i;\n  float f;\n};\n \nbool are_equal(const struct S *s1, const struct S *s2) {\n  if (!s1 && !s2)\n    return true;\n  else if (!s1 || !s2)\n    return false;\n  return 0 == memcmp(s1, s2, sizeof(struct S));\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the structure members are compared individually:",
          "code": "#include <stdbool.h>\n#include <string.h>\n \nstruct S {\n  int i;\n  float f;\n};\n \nbool are_equal(const struct S *s1, const struct S *s2) {\n  if (!s1 && !s2)\n    return true;\n  else if (!s1 || !s2)\n    return false;\n  return s1->i == s2->i &&\n         s1->f == s2->f;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using the object representation of a floating-point value for comparisons can lead to incorrect equality results, which can lead to unexpected behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT01-C",
    "title": "Use size_t or rsize_t for all integer values representing the size of an object",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT01-C.+Use+size_t+or+rsize_t+for+all+integer+values+representing+the+size+of+an+object",
    "description": "The size_t type is the unsigned integer type of the result of the sizeof operator. Variables of type size_t are guaranteed to be of sufficient precision to represent the size of an object. The limit of size_t is specified by the SIZE_MAX macro.\n\nsize_t\n\nsizeof\n\nsize_t\n\nsize_t\n\nSIZE_MAX\n\nThe type size_t generally covers the entire address space. The C Standard, Annex K (normative), \"Bounds-checking interfaces,\" introduces a new type, rsize_t , defined to be size_t but explicitly used to hold the size of a single object [ Meyers 2004 ]. In code that documents this purpose by using the type rsize_t , the size of an object can be checked to verify that it is no larger than RSIZE_MAX , the maximum size of a normal single object, which provides additional input validation for library functions. See VOID STR07-C. Use the bounds-checking interfaces for string manipulation for additional discussion of C11 Annex K.\n\nsize_t\n\nrsize_t\n\nsize_t\n\nrsize_t\n\nRSIZE_MAX\n\nAny variable that is used to represent the size of an object, including integer values used as sizes, indices, loop counters, and lengths, should be declared rsize_t , if available. Otherwise, it should be declared size_t .\n\nrsize_t\n\nsize_t",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the dynamically allocated buffer referenced by p overflows for values of n > INT_MAX :",
          "code": "char *copy(size_t n, const char *c_str) {\n  int i;\n  char *p;\n\n  if (n == 0) {\n    /* Handle unreasonable object size error */\n  }\n  p = (char *)malloc(n);\n  if (p == NULL) {\n    return NULL; /* Indicate malloc failure */\n  }\n  for ( i = 0; i < n; ++i ) {\n    p[i] = *c_str++;\n  }\n  return p;\n}\n\n/* ... */\n\nchar c_str[] = \"hi there\";\nchar *p = copy(sizeof(c_str), c_str);\n",
          "explanation_after": "Signed integer overflow causes undefined behavior . The following are two possible conditions under which this code constitutes a serious vulnerability :\n\nThe unsigned n may contain a value greater than INT_MAX . Assuming quiet wraparound on signed overflow, the loop executes n times because the comparison i < n is an unsigned comparison. Once i is incremented beyond INT_MAX , i takes on negative values starting with (INT_MIN) . Consequently, the memory locations referenced by p[i] precede the memory referenced by p , and a write outside array bounds occurs.\n\nFor values of n where 0 < n <= INT_MAX , the loop executes n times, as expected.\n\nFor values of n where INT_MAX < n <= (size_t)INT_MIN , the loop executes INT_MAX times. Once i becomes negative, the loop stops, and i remains in the range 0 through INT_MAX .\n\nFor values of n where (size_t)INT_MIN < n <= SIZE_MAX , i wraps and takes the values INT_MIN to INT_MIN + (n - (size_t)INT_MIN - 1) . Execution of the loop overwrites memory from p[INT_MIN] through p[INT_MIN + (n - (size_t)INT_MIN - 1)] ."
        },
        "compliant": {
          "heading": "Compliant Solution (C11, Annex K)",
          "pre_code_commentary": "Declaring i to be of type rsize_t eliminates the possible integer overflow condition (in this example). Also, the argument n is changed to be of type rsize_t to document additional validation in the form of a check against RSIZE_MAX :",
          "code": "char *copy(rsize_t n, const char *c_str) {\n  rsize_t i;\n  char *p;\n\n  if (n == 0 || n > RSIZE_MAX) {\n    /* Handle unreasonable object size error */\n  }\n  p = (char *)malloc(n);\n  if (p == NULL) {\n    return NULL;  /* Indicate malloc failure */\n  }\n  for (i = 0; i < n; ++i) {\n    p[i] = *c_str++;\n  }\n  return p;\n}\n\n/* ... */\n\nchar c_str[] = \"hi there\";\nchar *p = copy(sizeof(c_str), c_str);\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the value of length is read from a network connection and passed as an argument to a wrapper to malloc() to allocate the appropriate data block. Provided that the size of an unsigned long is equal to the size of an unsigned int , and both sizes are equal to or smaller than the size of size_t , this code runs as expected. However, if the size of an unsigned long is greater than the size of an unsigned int , the value stored in length may be truncated when passed as an argument to alloc() .  Both read functions return zero on success and nonzero on failure.",
          "code": "void *alloc(unsigned int blocksize) {\n  return malloc(blocksize);\n}\n\nint read_counted_string(int fd) {\n  unsigned long length;\n  unsigned char *data;\n\n  if (read_integer_from_network(fd, &length)) {\n    return -1;\n  }\n\n  data = (unsigned char*)alloc(length+1);\n  if (data == NULL) {\n    return -1;  /* Indicate failure */\n  }\n\n  if (read_network_data(fd, data, length)) {\n    free(data);\n    return -1;\n  }\n  data[length] = '\\0';\n\n  /* ... */\n  free( data);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (C11, Annex K)",
          "pre_code_commentary": "Declaring both length and the blocksize argument to alloc() as rsize_t eliminates the possibility of truncation. This compliant solution assumes that read_integer_from_network() and read_network_data() can also be modified to accept a length argument of type pointer to rsize_t and rsize_t , respectively. If these functions are part of an external library that cannot be updated, care must be taken when casting length into an unsigned long to ensure that integer truncation does not occur.",
          "code": "void *alloc(rsize_t blocksize) {\n  if (blocksize == 0 || blocksize > RSIZE_MAX) {\n    return NULL;  /* Indicate failure */\n  }\n  return malloc(blocksize);\n}\n\nint read_counted_string(int fd) {\n  rsize_t length;\n  unsigned char *data;\n\n  if (read_integer_from_network(fd, &length)) {\n    return -1;\n  }\n\n  data = (unsigned char*)alloc(length+1);\n  if (data == NULL) {\n    return -1; /* Indicate failure */\n  }\n\n  if (read_network_data(fd, data, length)) {\n    free(data);\n    return -1;\n  }\n  data[length] = '\\0';\n\n  /* ... */\n  free( data);\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The improper calculation or manipulation of an object's size can result in exploitable vulnerabilities .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "INT02-C",
    "title": "Understand integer conversion rules",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT02-C.+Understand+integer+conversion+rules",
    "description": "Conversions can occur explicitly as the result of a cast or implicitly as required by an operation. Although conversions are generally required for the correct execution of a program, they can also lead to lost or misinterpreted data. Conversion of an operand value to a compatible type causes no change to the value or the representation.\n\nThe C integer conversion rules define how C compilers handle conversions. These rules include integer promotions , integer conversion rank , and the usual arithmetic conversions . The intent of the rules is to ensure that the conversions result in the same numerical values and that these values minimize surprises in the rest of the computation. Prestandard C usually preferred to preserve signedness of the type.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Comparison)",
          "pre_code_commentary": "The programmer must be careful when performing operations on mixed types. This noncompliant code example shows an idiosyncrasy of integer promotions:",
          "code": "int si = -1;\nunsigned int ui = 1;\nprintf(\"%d\\n\", si < ui);\n",
          "explanation_after": "In this example, the comparison operator operates on a signed int and an unsigned int . By the conversion rules, si is converted to an unsigned int . Because −1 cannot be represented as an unsigned int value, the −1 is converted to UINT_MAX in accordance with the C Standard, subclause 6.3.1.3, paragraph 2 [ ISO/IEC 9899:2011 ]:\n\nOtherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.\n\nConsequently, the program prints 0 because UINT_MAX is not less than 1."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The noncompliant code example can be modified to produce the intuitive result by forcing the comparison to be performed using signed int values:",
          "code": "int si = -1;\nunsigned ui = 1;\nprintf(\"%d\\n\", si < (int)ui);\n",
          "explanation_after": "This program prints 1 as expected. Note that (int)ui is correct in this case only because the value of ui is known to be representable as an int . If it were not known, the compliant solution would need to be written as"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example demonstrates how performing bitwise operations on integer types smaller than int may have unexpected results:",
          "code": "uint8_t port = 0x5a;\nuint8_t result_8 = ( ~port ) >> 4;\n",
          "explanation_after": "In this example, a bitwise complement of port is first computed and then shifted 4 bits to the right. If both of these operations are performed on an 8-bit unsigned integer, then result_8 will have the value 0x0a . However, port is first promoted to a signed int , with the following results (on a typical architecture where type int is 32 bits wide):\n\nExpression\n\nType\n\nValue\n\nNotes\n\nport\n\nuint8_t\n\n0x5a\n\n~port\n\nint\n\n0xffffffa5\n\n~port >> 4\n\n0x0ffffffa\n\nWhether or not value is negative is implementation-defined\n\nresult_8\n\n0xfa"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the bitwise complement of port is converted back to 8 bits. Consequently, result_8 is assigned the expected value of 0x0aU .",
          "code": "uint8_t port = 0x5a;\nuint8_t result_8 = (uint8_t) (~port) >> 4;\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this example, a character is iterated from 0 to CHAR_MAX . However, on a platform where char is signed (such as 32-bit x86), max is set to 0x80 while i increments from 0x79 to {{0xffffff80} (aka -127):",
          "code": "#include <limits.h>\n\nunsigned char max = CHAR_MAX + 1;\nfor (char i = 0; i < max; ++i) {\n  printf(\"i=0x%08x max=0x%08x\\n\", i, max);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "There are several ways to rectify this example. One way is to treat both chars as unsigned, which prevents wraparound:",
          "code": "#include <limits.h>\n\nunsigned char max = CHAR_MAX + 1;\nfor (unsigned char i = 0; i < max; ++i) {\n  printf(\"i=0x%08x max=0x%08x\\n\", i, max);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example, adapted from the Cryptography Services blog , demonstrates how signed overflow can occur even when it seems that only unsigned types are in use:",
          "code": "unsigned short x = 45000, y = 50000;\nunsigned int z = x * y;",
          "explanation_after": "On implementations where short is 16 bits wide and int is 32 bits wide, the program results in undefined behavior due to signed overflow. This is because the unsigned short s become signed when they are automatically promoted to integer, and their mathematical product (2250000000) is greater than the largest signed 32-bit integer (2 31 - 1, which is 2147483647)."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, by manually casting one of the operands to unsigned int , the multiplication will be unsigned and so will not result in undefined behavior:",
          "code": "unsigned short x = 45000, y = 50000;\nunsigned int z = x * (unsigned int)y;",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Misunderstanding integer conversion rules can lead to errors, which in turn can lead to exploitable vulnerabilities . The major risks occur when narrowing the type (which requires a specific cast or assignment), converting from unsigned to signed, or converting from negative to unsigned.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT04-C",
    "title": "Enforce limits on integer values originating from tainted sources",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT04-C.+Enforce+limits+on+integer+values+originating+from+tainted+sources",
    "description": "All integer values originating from tainted sources should be evaluated to determine if they have identifiable upper and lower bounds. If so, these limits should be enforced by the interface. Restricting the input of excessively large or small integers helps prevent overflow, truncation, and other type range errors. Furthermore, it is easier to find and correct input problems than it is to trace internal errors back to faulty inputs.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, length is the value of a user-defined (and thus potentially untrusted) environment variable whose value is used to determine the size of a dynamically allocated array, table . In compliance with INT30-C. Ensure that unsigned integer operations do not wrap , the code prevents unsigned integer wrapping but does not impose any upper bound on the size of the array, making it possible for the user to cause the program to use an excessive amount of memory.",
          "code": "char** create_table(void) {\n  const char* const lenstr = getenv(\"TABLE_SIZE\");\n  const size_t length = lenstr ? strtoul(lenstr, NULL, 10) : 0;\n\n  if (length > SIZE_MAX / sizeof(char *))\n    return NULL;   /* Indicate error to caller */\n\n  const size_t table_size = length * sizeof(char *);\n  char** const table = (char **)malloc(table_size);\n\n  if (table == NULL)\n    return NULL;   /* Indicate error to caller */\n\n  /* Initialize table... */\n  return table;\n}\n",
          "explanation_after": "Because length is user controlled, the value can result in a large block of memory being allocated or can cause the call to malloc() to fail. Depending on how error handling is implemented, it may result in a denial-of-service attack or other error."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution defines the acceptable range for length as [1, MAX_TABLE_LENGTH] . The length parameter is declared as size_t , which is unsigned by definition. Consequently, it is not necessary to check length for negative values (see INT01-C. Use size_t or rsize_t for all integer values representing the size of an object ).",
          "code": "enum { MAX_TABLE_LENGTH = 256 };\n\nchar** create_table(void) {\n  const char* const lenstr = getenv(\"TABLE_SIZE\");\n  const size_t length = lenstr ? strtoul(lenstr, NULL, 10) : 0;\n\n  if (length == 0 || length > MAX_TABLE_LENGTH)\n    return NULL;   /* Indicate error to caller */\n\n  const size_t table_size = length * sizeof(char *);\n  char** const table = (char **)malloc(table_size);\n\n  if (table == NULL)\n    return NULL;   /* Indicate error to caller */\n\n  /* Initialize table... */\n  return table;\n}\n",
          "explanation_after": "The test for length == 0 ensures that a nonzero number of bytes is allocated. (See MEM04-C. Beware of zero-length allocations .)"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, the tainted integer color_index is used in pointer arithmetic to index into the array table:",
          "code": "const char *table[] = { \"black\", \"white\", \"blue\", \"green\" };\n \nconst char *set_background_color(void) {\n  int color_index;\n  GET_TAINTED_INTEGER(int, color_index);\n \n  const char *color = table[color_index];  /* Violation */\n \n  /* ... */\n  return color;\n} ",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution defines the acceptable range for color_index as [1, MAX_COLOR_INDEX] :",
          "code": "enum { MAX_COLOR_INDEX = 3 };\n \nconst char *table[] = { \"black\", \"white\", \"blue\", \"green\" };\n \nconst char *set_background_color(void) {\n  int color_index;\n  GET_TAINTED_INTEGER(int, color_index);\n\n\n  if (color_index < 0 || colo_index > MAX_COLOR_INDEX)\n    return NULL;   /* Indicate error to caller */ \n\n  const char *color = table[color_index]; \n \n  /* ... */\n  return color;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Heartbleed)",
          "pre_code_commentary": "CERT vulnerability 720951 describes a vulnerability in OpenSSL versions 1.0.1 through 1.0.1f, popularly known as \"Heartbleed.\" This vulnerability allows an attacker to steal information that under normal conditions would be protected by Secure Socket Layer/Transport Layer Security (SSL/TLS) encryption.\n\nDespite the seriousness of the vulnerability, Heartbleed is the result of a common programming error and an apparent lack of awareness of secure coding principles. Following is the vulnerable code:",
          "code": "int dtls1_process_heartbeat(SSL *s) {          \n  unsigned char *p = &s->s3->rrec.data[0], *pl;\n  unsigned short hbtype;\n  unsigned int payload;\n  unsigned int padding = 16; /* Use minimum padding */\n\n  /* Read type and payload length first */\n  hbtype = *p++;\n  n2s(p, payload);\n  pl = p;\n\n  /* ... More code ... */\n\n  if (hbtype == TLS1_HB_REQUEST) {\n    unsigned char *buffer, *bp;\n    int r;\n\n    /* Allocate memory for the response, size is 1 byte\n     * message type, plus 2 bytes payload length, plus\n     * payload, plus padding\n     */\n    buffer = OPENSSL_malloc(1 + 2 + payload + padding);\n    bp = buffer;\n\n    /* Enter response type, length and copy payload */\n    *bp++ = TLS1_HB_RESPONSE;\n    s2n(payload, bp);\n    memcpy(bp, pl, payload);\n\n    /* ... More code ... */\n  }\n  /* ... More code ... */\n}",
          "explanation_after": "This code processes a \"heartbeat\" packet from a client. As specified in RFC 6520 , when the program receives a heartbeat packet, it must echo the packet's data back to the client. In addition to the data, the packet contains a length field that conventionally indicates the number of bytes in the packet data, but there is nothing to prevent a malicious packet from lying about its data length.\n\nThe p pointer, along with payload and p1 , contain data from a packet. The code allocates a buffer sufficient to contain payload bytes, with some overhead, then copies payload bytes starting at p1 into this buffer and sends it to the client. Notably absent from this code are any checks that the payload integer variable extracted from the heartbeat packet corresponds to the size of the packet data. Because the client can specify an arbitrary value of payload , an attacker can cause the server to read and return the contents of memory beyond the end of the packet data, which violates INT04-C. Enforce limits on integer values originating from tainted sources . The resulting call to memcpy() can then copy the contents of memory past the end of the packet data and the packet itself, potentially exposing sensitive data to the attacker. This call to memcpy() violates ARR38-C. Guarantee that library functions do not form invalid pointers . A version of ARR38-C also appears in ISO/IEC TS 17961:2013 , \"Forming invalid pointers by library functions [libptr].\" This rule would require a conforming analyzer to diagnose the Heartbleed vulnerability.\n\nOpenSSL version 1.0.1g contains the following patch, which guarantees that payload is within a valid range. The range is limited by the size of the input record.\n\nFailing to enforce the limits on integer values can result in a denial-of-service attack, unauthorized disclosure of information, or to run arbitrary code .\n\nRecommendation\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nINT04-C\n\nHigh\n\nProbable\n\nYes\n\nNo\n\nP12\n\nL1\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\nIO.TAINT.SIZE LANG.MEM.TBA IO.TAINT.ADDR IO.UT.HOST IO.UT.PORT\n\n(general)\n\nTainted allocation size Tainted buffer access Tainted network address Untrusted Network Host Untrusted Network Port\n\nCodeSonar will track the tainted value, along with any limits applied to it, and flag any problems caused by underconstraint. Warnings of a wide range of classes may be triggered, including tainted allocation size, buffer overrun, and division by zero\n\n2025.2\n\nDF2794, DF2804, DF2854, DF2859, DF2864, DF2894, DF2899, DF2904, DF2909, DF2914, DF2924, DF2944, DF2949, DF2954, DF2956, DF2959\n\nCERT_C-INT04-a CERT_C-INT04-b CERT_C-INT04-c\n\nAvoid potential integer overflow/underflow on tainted data Avoid buffer read overflow from tainted data Avoid buffer write overflow from tainted data\n\nR2024b\n\nCERT C: Rec. INT04-C\n\nChecks for:\n\nArray access with tainted index Loop bounded with tainted value Memory allocation with tainted size Tainted size of variable length array\n\nRec. partially supported.\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website .\n\nRelated Guidelines"
        },
        "compliant": {
          "heading": "Compliant Solution (Heartbleed)",
          "pre_code_commentary": "OpenSSL version 1.0.1g contains the following patch, which guarantees that payload is within a valid range. The range is limited by the size of the input record.",
          "code": "int dtls1_process_heartbeat(SSL *s) {          \n  unsigned char *p = &s->s3->rrec.data[0], *pl;\n  unsigned short hbtype;\n  unsigned int payload;\n  unsigned int padding = 16; /* Use minimum padding */\n\n  /* ... More code ... */\n\n  /* Read type and payload length first */\n  if (1 + 2 + 16 > s->s3->rrec.length)\n    return 0; /* silently discard */\n  hbtype = *p++;\n  n2s(p, payload);\n  if (1 + 2 + payload + 16 > s->s3->rrec.length)\n    return 0; /* silently discard per RFC 6520 */\n  pl = p;\n\n  /* ... More code ... */\n\n  if (hbtype == TLS1_HB_REQUEST) {\n    unsigned char *buffer, *bp;\n    int r;\n\n    /* Allocate memory for the response, size is 1 byte\n     * message type, plus 2 bytes payload length, plus\n     * payload, plus padding\n     */\n    buffer = OPENSSL_malloc(1 + 2 + payload + padding);\n    bp = buffer;\n    /* Enter response type, length and copy payload */\n    *bp++ = TLS1_HB_RESPONSE;\n    s2n(payload, bp);\n    memcpy(bp, pl, payload);\n    /* ... More code ... */\n  }\n  /* ... More code ... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "INT05-C",
    "title": "Do not use input functions to convert character data if they cannot handle all possible inputs",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT05-C.+Do+not+use+input+functions+to+convert+character+data+if+they+cannot+handle+all+possible+inputs",
    "description": "Do not use functions that input characters and convert them to integers if the functions cannot handle all possible inputs. For example, formatted input functions such as scanf() , fscanf() , vscanf() , and vfscanf() can be used to read string data from stdin or (in the cases of fscanf() and vfscanf() ) other input streams. These functions work fine for valid integer values but lack robust error handling for invalid values.\n\nscanf()\n\nfscanf()\n\nvscanf()\n\nvfscanf()\n\nstdin\n\nfscanf()\n\nvfscanf()\n\nAlternatively, input character data as a null-terminated byte string and convert to an integer value using strtol() or a related function. (See ERR34-C. Detect errors when converting a string to a number .)\n\nstrtol()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example uses the scanf() function to read a string from stdin and convert it to a long . The scanf() and fscanf() functions have undefined behavior if the value of the result of this operation cannot be represented as an integer.",
          "code": "long num_long;\n\nif (scanf(\"%ld\", &num_long) != 1) {\n  /* Handle error */\n}\n",
          "explanation_after": "In general, do not use scanf() to parse integers or floating-point numbers from input strings because the input could contain numbers not representable by the argument type."
        },
        "compliant": {
          "heading": "Compliant Solution (Linux)",
          "pre_code_commentary": "This compliant example uses the Linux scanf() implementation's built-in error handling to validate input. On Linux platforms, scanf() sets errno to ERANGE if the result of integer conversion cannot be represented within the size specified by the format string [ Linux 2008 ]. Note that this solution is platform dependent, so it should be used only where portability is not a concern.",
          "code": "long num_long;\nerrno = 0;\n\nif (scanf(\"%ld\", &num_long) != 1) {\n  /* Handle error */\n}\nelse if (ERANGE == errno) {\n  if (puts(\"number out of range\\n\") == EOF) {\n      /* Handle error */\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example uses the scanf() function to read a string from stdin and convert it to a long . The scanf() and fscanf() functions have undefined behavior if the value of the result of this operation cannot be represented as an integer.",
          "code": "long num_long;\n\nif (scanf(\"%ld\", &num_long) != 1) {\n  /* Handle error */\n}\n",
          "explanation_after": "In general, do not use scanf() to parse integers or floating-point numbers from input strings because the input could contain numbers not representable by the argument type."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant example uses fgets() to input a string and strtol() to convert the string to an integer. Error checking is provided to make sure the value is a valid integer in the range of long .",
          "code": "char buff[25];\nchar *end_ptr;\nlong num_long;\n\nif (fgets(buff, sizeof(buff), stdin) == NULL) {\n  if (puts(\"EOF or read error\\n\") == EOF) {\n    /* Handle error */\n  }\n} else {\n  errno = 0;\n\n  num_long = strtol(buff, &end_ptr, 10);\n\n  if (ERANGE == errno) {\n    if (puts(\"number out of range\\n\") == EOF) {\n      /* Handle error */\n    }\n  }\n  else if (end_ptr == buff) {\n    if (puts(\"not valid numeric input\\n\") == EOF) {\n      /* Handle error */\n    }\n  }\n  else if ('\\n' != *end_ptr && '\\0' != *end_ptr) {\n    if (puts(\"extra characters on input line\\n\") == EOF) {\n      /* Handle error */\n    }\n  }\n}\n",
          "explanation_after": "Note that this solution treats any trailing characters, including whitespace characters, as an error condition."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Although it is relatively rare for a violation of this recommendation to result in a security vulnerability , it can easily result in lost or misinterpreted data.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "INT07-C",
    "title": "Use only explicitly signed or unsigned char type for numeric values",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT07-C.+Use+only+explicitly+signed+or+unsigned+char+type+for+numeric+values",
    "description": "The three types char , signed char , and unsigned char are collectively called the character types . Compilers have the latitude to define char to have the same range, representation, and behavior as either signed char or unsigned char . Irrespective of the choice made, char is a separate type from the other two and is not compatible with either.\n\nchar\n\nsigned char\n\nunsigned char\n\nchar\n\nsigned char\n\nunsigned char\n\nchar\n\nUse only signed char and unsigned char types for the storage and use of numeric values because it is the only portable way to guarantee the signedness of the character types (see STR00-C. Represent characters using an appropriate type for more information on representing characters).\n\nsigned char\n\nunsigned char",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the char -type variable c may be signed or unsigned. Assuming 8-bit, two's complement character types, this code may print out either i/c = 5 (unsigned) or i/c = -17 (signed). It is much more difficult to reason about the correctness of a program without knowing if these integers are signed or unsigned.",
          "code": "char c = 200;\nint i = 1000;\nprintf(\"i/c = %d\\n\", i/c);\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the variable c is declared as unsigned char . The subsequent division operation is now independent of the signedness of char and consequently has a predictable result.",
          "code": "unsigned char c = 200;\nint i = 1000;\nprintf(\"i/c = %d\\n\", i/c);\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "This is a subtle error that results in a disturbingly broad range of potentially severe vulnerabilities . At the very least, this error can lead to unexpected numerical results on different platforms. Unexpected arithmetic values when applied to arrays or pointers can yield buffer overflows or other invalid memory access.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "INT08-C",
    "title": "Verify that all integer values are in range",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT08-C.+Verify+that+all+integer+values+are+in+range",
    "description": "Integer operations must result in an integer value within the range of the integer type (that is, the resulting value is the same as the result produced by unlimited-range integers). Frequently, the range is more restrictive depending on the use of the integer value, for example, as an index. Integer values can be verified by code review or by static analysis .\n\nInteger overflow is undefined behavior , so a compiled program can do anything, including go off to play the Game of Life. Furthermore, a compiler may perform optimizations that assume an overflow will never occur, which can easily yield unexpected results. Compilers can optimize away if statements that check whether an overflow occurred. See MSC15-C. Do not depend on undefined behavior for an example.\n\nif\n\nVerifiably in-range operations are often preferable to treating out-of-range values as an error condition because the handling of these errors has been repeatedly shown to cause denial-of-service problems in actual applications. The quintessential example is the failure of the Ariane 5 launcher, which occurred because of an improperly handled conversion error that resulted in the processor being shut down [ Lions 1996 ].\n\nA program that detects an integer overflow to be imminent may do one of two things: (1) signal some sort of error condition or (2) produce an integer result that is within the range of representable integers on that system. Some situations can be handled by an error condition, where an overflow causes a change in control flow (such as the system complaining about bad input and requesting alternative input from the user). Others are better handled by the latter option because it allows the computation to proceed and generate an integer result, thereby avoiding a denial-of-service attack. However, when continuing to produce an integer result in the face of overflow, the question of what integer result to return to the user must be considered.\n\nThe saturation and modwrap algorithms and the technique of restricted range usage, defined in the following subsections, produce integer results that are always within a defined range. This range is between the integer values MIN and MAX (inclusive), where MIN and MAX are two representable integers with MIN < MAX .\n\nMIN\n\nMAX\n\nMIN\n\nMAX\n\nMIN < MAX",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, i + 1 will overflow on a 16-bit machine. The C Standard allows signed integers to overflow and produce incorrect results. Compilers can take advantage of this to produce faster code by assuming an overflow will not occur. As a result, the if statement that is intended to catch an overflow might be optimized away.",
          "code": "int i = /* Expression that evaluates to the value 32767 */;\n/* ... */\nif (i + 1 <= i) {\n  /* Handle overflow */\n}\n/* Expression involving i + 1 */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Using a long instead of an int is guaranteed to accommodate the computed value:",
          "code": "long i = /* Expression that evaluates to the value 32767 */;\n/* ... */\n/* No test is necessary; i is known not to overflow */\n/* Expression involving i + 1 */\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Out-of-range integer values can result in reading from or writing to arbitrary memory locations and the execution of arbitrary code.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT09-C",
    "title": "Ensure enumeration constants map to unique values",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT09-C.+Ensure+enumeration+constants+map+to+unique+values",
    "description": "A C enumeration defines a type with a finite set of values represented by identifiers known as enumeration constants , or enumerators. An enumerator is a constant integer expression whose value is representable as an int . Although the language allows multiple enumerators of the same type to have the same value, it is a common expectation that all enumerators of the same type have distinct values. However, defining two or more enumerators of the same type to have the same value can lead to some nonobvious errors.\n\nint",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, two enumerators of type Color are assigned explicit values. It may not be obvious to the programmer that yellow and indigo have been declared to be identical values (6), as are green and violet (7). Probably the least dangerous error that can result from such a definition is attempting to use the enumerators as labels of a switch statement. Because all labels in a switch statement are required to be unique, the following code violates this semantic constraint and is required to be diagnosed by a conforming compiler:",
          "code": "enum Color { red=4, orange, yellow, green, blue, indigo=6, violet };\n\nconst char* color_name(enum Color col) {\n  switch (col) {\n  case red: return \"red\";\n  case orange: return \"orange\";\n  case yellow: return \"yellow\";\n  case green: return \"green\";\n  case blue: return \"blue\";\n  case indigo: return \"indigo\";   /* Error: duplicate label (yellow) */\n  case violet: return \"violet\";   /* Error: duplicate label (green) */\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "To prevent the error discussed of the noncompliant code example, enumeration type declarations must take one of the following forms:\n\nProvide no explicit integer assignments, as in this example:",
          "code": "enum Color { red, orange, yellow, green, blue, indigo, violet };\n",
          "explanation_after": "Assign a value to the first member only (the rest are then sequential), as in this example:\n\nAssign a value to all members so any equivalence is explicit, as in this example:\n\nIt is also advisable to provide a comment explaining why multiple enumeration type members are being assigned the same value so that future maintainers do not mistakenly identify this form as an error.\n\nOf these three options, providing no explicit integer assignments is the simplest and consequently the preferred approach unless the first enumerator must have a nonzero value."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to ensure that constants within an enumeration have unique values can result in unexpected results.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT12-C",
    "title": "Do not make assumptions about the type of a plain int bit-field when used in an expression",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT12-C.+Do+not+make+assumptions+about+the+type+of+a+plain+int+bit-field+when+used+in+an+expression",
    "description": "Bit-fields can be used to allow flags or other integer values with small ranges to be packed together to save storage space.\n\nIt is implementation-defined whether the specifier int designates the same type as signed int or the same type as unsigned int for bit-fields. According to the C Standard [ ISO/IEC 9899:2011 ], C integer promotions also require that \"if an int can represent all values of the original type (as restricted by the width, for a bit-field), the value is converted to an int ; otherwise, it is converted to an unsigned int .\"\n\nint\n\nsigned int\n\nunsigned int\n\nint\n\nint\n\nunsigned int\n\nThis issue is similar to the signedness of plain char , discussed in INT07-C. Use only explicitly signed or unsigned char type for numeric values . A plain int bit-field that is treated as unsigned will promote to int as long as its field width is less than that of int because int can hold all values of the original type. This behavior is the same as that of a plain char treated as unsigned. However, a plain int bit-field treated as unsigned will promote to unsigned int if its field width is the same as that of int . This difference makes a plain int bit-field even trickier than a plain char .\n\nchar\n\nint\n\nint\n\nint\n\nint\n\nchar\n\nint\n\nunsigned int\n\nint\n\nint\n\nchar\n\nBit-field types other than _Bool , int , signed int , and unsigned int are implementation-defined. They still obey the integer promotions quoted previously when the specified width is at least as narrow as CHAR_BIT*sizeof(int) , but wider bit-fields are not portable.\n\n_Bool\n\nint\n\nsigned int\n\nunsigned int\n\nCHAR_BIT*sizeof(int)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code depends on implementation-defined behavior . It prints either -1 or 255 , depending on whether a plain int bit-field is signed or unsigned.",
          "code": "struct {\n  int a: 8;\n} bits = {255};\n\nint main(void) {\n  printf(\"bits.a = %d.\\n\", bits.a);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses an unsigned int bit-field and does not depend on implementation-defined behavior:",
          "code": "struct {\n  unsigned int a: 8;\n} bits = {255};\n\nint main(void) {\n  printf(\"bits.a = %d.\\n\", bits.a);\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Making invalid assumptions about the type of a bit-field or its layout can result in unexpected program flow.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT13-C",
    "title": "Use bitwise operators only on unsigned operands",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT13-C.+Use+bitwise+operators+only+on+unsigned+operands",
    "description": "Bitwise operators include the complement operator ~ , bitwise shift operators >> and << , bitwise AND operator & , bitwise exclusive OR operator ^ , bitwise inclusive OR operator | and compound assignment operators >>=, <<=, &=, ^= and |=. Bitwise operators should be used only with unsigned integer operands, as the results of bitwise operations on signed integers are implementation-defined .\n\n~\n\n>>\n\n<<\n\n&\n\n^\n\n|\n\nThe C11 standard, section 6.5, paragraph 4 [ ISO/IEC 9899:2011 ] , states:\n\nSome operators (the unary operator ~ , and the binary operators <<, >>, &, ^, and |, collectively described as bitwise operators) shall have operands that have integral type. These operators return values that depend on the internal representations of integers, and thus have implementation-defined and undefined aspects for signed types.\n\nFurthermore, the bitwise shift operators << and >> are undefined under many circumstances, and are implementation-defined for signed integers for more circumstances; see rule INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand for more information.\n\n>>\n\nImplementation details\n\nThe Microsoft C compiler documentation says that:\n\nBitwise operations on signed integers work the same as bitwise operations on unsigned integers.\n\nOn-line GCC documentation about the implementation of bitwise operations on signed integers says:\n\nBitwise operators act on the representation of the value including both the sign and value bits, where the sign bit is considered immediately above the highest-value value bit.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Right Shift)",
          "pre_code_commentary": "The right-shift operation may be implemented as either an arithmetic (signed) shift or a logical (unsigned) shift. If E1 in the expression E1 >> E2 has a signed type and a negative value, the resulting value is implementation-defined. Also, a bitwise shift can result in undefined behavior . (See INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand .)\n\nThis noncompliant code example can result in an error condition on implementations in which an arithmetic shift is performed, and the sign bit is propagated as the number is shifted [ Dowd 2006 ]:",
          "code": "int rc = 0;\nint stringify = 0x80000000;\nchar buf[sizeof(\"256\")];\nrc = snprintf(buf, sizeof(buf), \"%u\", stringify >> 24);\nif (rc == -1 || rc >= sizeof(buf)) {\n  /* Handle error */\n}\n",
          "explanation_after": "In this example, stringify >> 24 evaluates to 0xFFFFFF80 , or 4,294,967,168. When converted to a string, the resulting value \"4294967168\" is too large to store in buf and is truncated by snprintf() .\n\nIf this code had been implemented using sprintf() instead of snprintf() , this noncompliant code example would have resulted in a buffer overflow."
        },
        "compliant": {
          "heading": "Compliant Solution (Right Shift)",
          "pre_code_commentary": "In this compliant solution, stringify is declared as an unsigned integer. The value of the result of the right-shift operation is the integral part of the quotient of stringify / 2 ^ 24 :",
          "code": "int rc = 0;\nunsigned int stringify = 0x80000000;\nchar buf[sizeof(\"256\")];\nrc = snprintf(buf, sizeof(buf), \"%u\", stringify >> 24);\nif (rc == -1 || rc >= sizeof(buf)) {\n  /* Handle error */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Performing bitwise operations on signed numbers can lead to buffer overflows and the execution of arbitrary code by an attacker in some cases, unexpected or implementation-defined behavior in others.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "INT14-C",
    "title": "Avoid performing bitwise and arithmetic operations on the same data",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT14-C.+Avoid+performing+bitwise+and+arithmetic+operations+on+the+same+data",
    "description": "Avoid performing bitwise and arithmetic operations on the same data. In particular, bitwise operations are frequently performed on arithmetic values as a form of premature optimization. Bitwise operators include the unary operator ~ and the binary operators << , >> , & , ^ , and | . Although such operations are valid and will compile, they can reduce code readability. Declaring a variable as containing a numeric value or a bitmap makes the programmer's intentions clearer and the code more maintainable.\n\n~\n\n<<\n\n>>\n\n&\n\n^\n\n|\n\nBitmapped types may be defined to further separate bit collections from numeric types. Doing so may make it easier to verify that bitwise operations are performed only on variables that represent bitmaps.\n\ntypedef uint32_t bitmap32_t;\nbitmap32_t x = 0x000007f3;\n\nx = (x << 2) | 3; /* Shifts in two 1-bits from the right */\n\ntypedef uint32_t bitmap32_t;\nbitmap32_t x = 0x000007f3;\n\nx = (x << 2) | 3; /* Shifts in two 1-bits from the right */\n\nThe typedef name uintN_t designates an unsigned integer type with width N . Consequently, uint32_t denotes an unsigned integer type with a width of exactly 32 bits. Bitmaps should be declared as unsigned. See INT13-C. Use bitwise operators only on unsigned operands .\n\ntypedef\n\nuintN_t\n\nN\n\nuint32_t\n\nLeft- and right-shift operators are often employed to multiply or divide a number by a power of 2. However, using shift operators to represent multiplication or division is an optimization that renders the code less portable and less readable. Furthermore, most compilers routinely optimize multiplications and divisions by constant powers of 2 with bit-shift operations, and they are more familiar with the implementation details of the current platform.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Left Shift)",
          "pre_code_commentary": "In this noncompliant code example, both bit manipulation and arithmetic manipulation are performed on the integer x . The result is a (prematurely) optimized statement that assigns 5x + 1 to x for implementations where integers are represented as two's complement values.",
          "code": "int compute(int x) {\n  int y = x << 2;\n  x += y + 1;\n  return x;\n}\n// ...\n \nint x = compute(50);",
          "explanation_after": "Although this is a valid manipulation, the result of the shift depends on the underlying representation of the integer type and is consequently implementation-defined . Additionally, the readability of the code is reduced."
        },
        "compliant": {
          "heading": "Compliant Solution (Left Shift)",
          "pre_code_commentary": "In this compliant solution, the assignment statement is modified to reflect the arithmetic nature of x , resulting in a clearer indication of the programmer's intentions:",
          "code": "int compute(int x) {\n  return 5 * x + 1;\n}\n// ...\n \nint x = compute(50);\n",
          "explanation_after": "A reviewer may now recognize that the operation should also be checked for wrapping. This might not have been apparent in the original, noncompliant code example."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Right Shift)",
          "pre_code_commentary": "In this noncompliant code example, the programmer prematurely optimizes code by replacing a division with a right shift:",
          "code": "int compute(int x) {\n  x >>= 2;\n  return x;\n}\n// ...\n \nint x = compute(-50);\n",
          "explanation_after": "Although this code is likely to perform the division correctly, it is not guaranteed to. If x has a signed type and a negative value, the operation is implementation-defined and can be implemented as either an arithmetic shift or a logical shift. In the event of a logical shift, if the integer is represented in either one's complement or two's complement form, the most significant bit (which controls the sign for both representations) will be set to 0, causing a once negative number to become a possibly very large, positive number. For more details, see INT13-C. Use bitwise operators only on unsigned operands .\n\nFor example, if the internal representation of x is 0xFFFF FFCE (two's complement), an arithmetic shift results in 0xFFFF FFF3 (−13 in two's complement), whereas a logical shift results in 0x3FFF FFF3 (1,073,741,811 in two's complement)."
        },
        "compliant": {
          "heading": "Compliant Solution (Right Shift)",
          "pre_code_commentary": "In this compliant solution, the right shift is replaced by division:",
          "code": "int compute(int x) {\n  return x / 4;\n}\n// ...\n \nint x = compute(-50);\n",
          "explanation_after": "The resulting value is now more likely to be consistent with the programmer's expectations."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Performing bit manipulation and arithmetic operations on the same variable obscures the programmer's intentions and reduces readability. It also makes it more difficult for a security auditor or maintainer to determine which checks must be performed to eliminate security flaws and ensure data integrity.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT15-C",
    "title": "Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT15-C.+Use+intmax_t+or+uintmax_t+for+formatted+IO+on+programmer-defined+integer+types",
    "description": "Few programmers consider the issues around formatted I/O and type definitions. A programmer-defined integer type might be any type supported by the implementation , even a type larger than unsigned long long . For example, given an implementation that supports 128-bit unsigned integers and provides a uint_fast128_t type, a programmer may define the following type:\n\nunsigned long long\n\nuint_fast128_t\n\ntypedef uint_fast128_t mytypedef_t;\n\ntypedef uint_fast128_t mytypedef_t;\n\nFurthermore, the definition of programmer-defined types may change, which creates a problem when these types are used with formatted output functions, such as printf() , and formatted input functions, such as scanf() . (See FIO47-C. Use valid format strings .)\n\nprintf()\n\nscanf()\n\nThe C intmax_t and uintmax_t types can represent any value representable by any other integer types of the same signedness. (See INT00-C. Understand the data model used by your implementation(s) .) This capability allows conversion between programmer-defined integer types (of the same signedness) and intmax_t and uintmax_t :\n\nintmax_t\n\nuintmax_t\n\nintmax_t\n\nuintmax_t\n\nmytypedef_t x;\nuintmax_t temp;\n\ntemp = x; /* Always secure if mytypedef_t is unsigned*/\n\n/* ... Change the value of temp ... */\n\nif (temp <= MYTYPEDEF_MAX) {\n  x = temp;\n}\n\nmytypedef_t x;\nuintmax_t temp;\n\ntemp = x; /* Always secure if mytypedef_t is unsigned*/\n\n/* ... Change the value of temp ... */\n\nif (temp <= MYTYPEDEF_MAX) {\n  x = temp;\n}\n\nFormatted I/O functions can be used to input and output greatest-width integer typed values. The j length modifier in a format string indicates that the following d , i , o , u , x , X , or n conversion specifier will apply to an argument with type intmax_t or uintmax_t . C also specifies the z length modifier for use with arguments of type size_t and the t length modifier for arguments of type ptrdiff_t .\n\nj\n\nd\n\ni\n\no\n\nu\n\nx\n\nX\n\nn\n\nintmax_t\n\nuintmax_t\n\nz\n\nsize_t\n\nt\n\nptrdiff_t\n\nIn addition to programmer-defined types, there is no requirement that an implementation provide format-length modifiers for implementation-defined integer types. For example, a machine with an implementation-defined 48-bit integer type may not provide format-length modifiers for the type. Such a machine still must have a 64-bit long long , with intmax_t being at least that large.\n\nlong long\n\nintmax_t",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( printf() )",
          "pre_code_commentary": "This noncompliant code example prints the value of x as an unsigned long long value even though the value is of a programmer-defined integer type:",
          "code": "#include <stdio.h>\n\nmytypedef_t x;\n\n/* ... */\n\nprintf(\"%llu\", (unsigned long long) x); \n",
          "explanation_after": "There is no guarantee that this code prints the correct value of x , as x may be too large to represent as an unsigned long long ."
        },
        "compliant": {
          "heading": "Compliant Solution ( printf() )",
          "pre_code_commentary": "The C intmax_t and uintmax_t can be safely used to perform formatted I/O with programmer-defined integer types by converting signed programmer-defined integer types to intmax_t and unsigned programmer-defined integer types to uintmax_t , then outputting these values using the j length modifier. Similarly, programmer-defined integer types can be input to variables of intmax_t or uintmax_t (whichever matches the signedness of the programmer-defined integer type) and then converted to programmer-defined integer types using appropriate range checks.\n\nThis compliant solution guarantees that the correct value of x is printed, regardless of its length, provided that mytypedef_t is an unsigned type:",
          "code": "#include <stdio.h>\n#include <inttypes.h>\n\nmytypedef_t x;\n\n/* ... */\n\nprintf(\"%ju\", (uintmax_t) x);\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( printf() )",
          "pre_code_commentary": "This noncompliant code example prints the value of x as an unsigned long long value even though the value is of a programmer-defined integer type:",
          "code": "#include <stdio.h>\n\nmytypedef_t x;\n\n/* ... */\n\nprintf(\"%llu\", (unsigned long long) x); \n",
          "explanation_after": "There is no guarantee that this code prints the correct value of x , as x may be too large to represent as an unsigned long long ."
        },
        "compliant": {
          "heading": "Compliant Solution (Microsoft printf() )",
          "pre_code_commentary": "Visual Studio 2012 and earlier versions do not support the standard j length modifier and do not have a nonstandard analog. Consequently, the programmer must hard code the knowledge that intmax_t is int64_t and uintmax_t is uint64_t for Microsoft Visual Studio versions.",
          "code": "#include <stdio.h>\n#include <inttypes.h>\n\nmytypedef_t x;\n\n/* ... */\n\n#ifdef _MSC_VER\n  printf(\"%llu\", (uintmax_t) x);\n#else\n  printf(\"%ju\", (uintmax_t) x);\n#endif  ",
          "explanation_after": "A feature request has been submitted to Microsoft to add support for the j length modifier to a future release of Microsoft Visual Studio."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( scanf() )",
          "pre_code_commentary": "This noncompliant code example reads an unsigned long long value from standard input and stores the result in x , which is of a programmer-defined integer type:",
          "code": "#include <stdio.h>\n\nmytypedef_t x;\n/* ... */\nif (scanf(\"%llu\", &x) != 1) {\n  /* Handle error */\n}\n",
          "explanation_after": "This noncompliant code example can result in a buffer overflow if the size of mytypedef_t is smaller than unsigned long long , or it might result in an incorrect value if the size of mytypedef_t is larger than unsigned long long .  Moreover, scanf() lacks the error checking capabilities of alternative conversion routines, such as strtol() . For more information, see INT06-C. Use strtol() or a related function to convert a string token to an integer ."
        },
        "compliant": {
          "heading": "Compliant Solution ( strtoumax() )",
          "pre_code_commentary": "This compliant solution guarantees that a correct value in the range of mytypedef_t is read, or an error condition is detected, assuming the value of MYTYPEDEF_MAX is correct as the largest value representable by mytypedef_t :  The strtoumax() function is used instead of scanf() as it provides enhanced error checking functionality.  The fgets() function is used to read input from stdin .",
          "code": "#include <stdio.h>\n#include <inttypes.h>\n#include <errno.h> \n\nmytypedef_t x;\nuintmax_t temp;\n\n/* ... */\nif (fgets(buff, sizeof(buff), stdin) == NULL) {\n  if (puts(\"EOF or read error\\n\") == EOF) {\n    /* Handle error */\n  }\n} else {\n  /* Check for errors in the conversion */\n  errno = 0;\n  temp = strtoumax(buff, &end_ptr, 10);\n  if (ERANGE == errno) {\n    if (puts(\"number out of range\\n\") == EOF) {\n      /* Handle error */\n    } \n  } else if (end_ptr == buff) {\n    if (puts(\"not valid numeric input\\n\") == EOF) {\n      /* Handle error */\n    }\n  } else if ('\\n' != *end_ptr && '\\0' != *end_ptr) {\n    if (puts(\"extra characters on input line\\n\") == EOF) {\n      /* Handle error */\n    }\n  }\n  \n  /* No conversion errors, attempt to store the converted value into x */\n  if (temp > MYTYPEDEF_MAX) {\n    /* Handle error */\n  } else {\n    x = temp;\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to use an appropriate conversion specifier when inputting or outputting programmer-defined integer types can result in buffer overflow and lost or misinterpreted data.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "INT16-C",
    "title": "Do not make assumptions about representation of signed integers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT16-C.+Do+not+make+assumptions+about+representation+of+signed+integers",
    "description": "Although many common implementations use a two's complement representation of signed integers, the C Standard declares such use as implementation-defined and allows all of the following representations:\n\nSign and magnitude Two's complement One's complement\n\nThis is a specific example of MSC14-C. Do not introduce unnecessary platform dependencies .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "One way to check whether a number is even or odd is to examine the least significant bit, but the results will be inconsistent. Specifically, this example gives unexpected behavior on all one's complement implementations:",
          "code": "int value;\n\nif (scanf(\"%d\", &value) == 1) {\n  if (value & 0x1 != 0) {\n    /* Take action if value is odd */\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The same thing can be achieved compliantly using the modulo operator:",
          "code": "int value;\n\nif (scanf(\"%d\", &value) == 1) {\n  if (value % 2 != 0) {\n    /* Take action if value is odd */\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "One way to check whether a number is even or odd is to examine the least significant bit, but the results will be inconsistent. Specifically, this example gives unexpected behavior on all one's complement implementations:",
          "code": "int value;\n\nif (scanf(\"%d\", &value) == 1) {\n  if (value & 0x1 != 0) {\n    /* Take action if value is odd */\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Using bitwise operators is safe on unsigned integers:",
          "code": "unsigned int value;\n\nif (scanf(\"%u\", &value) == 1) {\n  if (value & 0x1 != 0) {\n    /* Take action if value is odd */\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrect assumptions about integer representation can lead to execution of unintended code branches and other unexpected behavior.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT17-C",
    "title": "Define integer constants in an implementation-independent manner",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT17-C.+Define+integer+constants+in+an+implementation-independent+manner",
    "description": "Integer constants are often used as masks or specific bit values. Frequently, these constants are expressed in hexadecimal form to indicate to the programmer how the data might be represented in the machine. However, hexadecimal integer constants are frequently used in a nonportable manner.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this pedagogical noncompliant code example, the flipbits() function complements the value stored in x by performing a bitwise exclusive OR against a mask with all bits set to 1. For implementations where unsigned long is represented by a 32-bit value, each bit of x is correctly complemented.",
          "code": "/* (Incorrect) Set all bits in mask to 1 */\nconst unsigned long mask = 0xFFFFFFFF;\n\nunsigned long flipbits(unsigned long x) {\n  return x ^ mask;\n}\n",
          "explanation_after": "However, on implementations where values of type unsigned long are represented by greater than 32 bits, mask will have leading 0s. For example, on implementations where values of type unsigned long are 64 bits long, mask is assigned the value 0x00000000FFFFFFFF . Consequently, only the lower-order bits of x are complemented."
        },
        "compliant": {
          "heading": "Compliant Solution (−1)",
          "pre_code_commentary": "In this compliant solution, the integer constant -1 is used to set all bits in mask to 1. The integer constant -1 is of type signed int . Because -1 cannot be represented by a variable of type unsigned long , it is converted to a representable number according to the rule in subclause 6.3.1.3, paragraph 2, of the C Standard [ ISO/IEC 9899:2011 ]:\n\n[If the value can't be represented by the new type and] if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.\n\n\"One more than the maximum value that can be represented in the new type,\" ULONG_MAX + 1 , is added to -1 , resulting in a right-side value of ULONG_MAX . The representation of ULONG_MAX is guaranteed to have all bits set to 1 by subclause 6.2.6.2, paragraph 1:\n\nFor unsigned integer types other than unsigned char , the bits of the object representation shall be divided into two groups: value bits and padding bits (there need not be any of the latter). If there are N valuebits, each bit shall represent a different power of 2 between 1 and 2 N − 1 , so that objects of that type shall be capable of representing values from 0 to 2 N − 1 using a pure binary representation ; this shall be known as the value representation. The values of any padding bits are unspecified.\n\nBy the same reasoning, -1 is suitable for setting all bits to one of any unsigned integer variable. Subclause 6.2.6.1, paragraph 3, guarantees the same results for unsigned char :\n\nValues stored in unsigned bit-fields and objects of type unsigned char shall be represented using a pure binary notation .",
          "code": "/* (Correct) Set all bits in mask to 1 */\nconst unsigned long mask = -1;\n\nunsigned long flipbits(unsigned long x) {\n  return x ^ mask;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a programmer attempts to set the most significant bit:",
          "code": "const unsigned long mask = 0x80000000;\nunsigned long x;\n\n/* Initialize x */\n\nx |= mask;\n",
          "explanation_after": "This code has the desired effect for implementations where unsigned long has a precision of 32 bits but not for implementations where unsigned long has a precision of 64 bits."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "A portable (and safer) way of setting the high-order bit is to use a shift expression, as in this compliant solution:",
          "code": "const unsigned long mask = ~(ULONG_MAX >> 1);\nunsigned long x;\n\n/* Initialize x */\n\nx |= mask;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Vulnerabilities are frequently introduced while porting code. A buffer overflow vulnerability may result, for example, if an incorrectly defined integer constant is used to determine the size of a buffer. It is always best to write portable code, especially when there is no performance overhead for doing so.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT18-C",
    "title": "Evaluate integer expressions in a larger size before comparing or assigning to that size",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT18-C.+Evaluate+integer+expressions+in+a+larger+size+before+comparing+or+assigning+to+that+size",
    "description": "If an integer expression involving an operation is compared to or assigned to a larger integer size, that integer expression should be evaluated in that larger size by explicitly casting one of the operands.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code example is noncompliant on systems where size_t is an unsigned 32-bit value and long long is a 64-bit value. In this example, the programmer tests for wrapping by comparing SIZE_MAX to length + BLOCK_HEADER_SIZE . Because length is declared as size_t , the addition is performed as a 32-bit operation and can result in wrapping. The comparison with SIZE_MAX will always test false. If any wrapping occurs, malloc() will allocate insufficient space for mBlock , which can lead to a subsequent buffer overflow.",
          "code": "#include <stdlib.h>\n#include <stdint.h>  /* For SIZE_MAX */\n \nenum { BLOCK_HEADER_SIZE = 16 };\n\nvoid *AllocateBlock(size_t length) {\n  struct memBlock *mBlock;\n\n  if (length + BLOCK_HEADER_SIZE > (unsigned long long)SIZE_MAX)\n    return NULL;\n  mBlock = (struct memBlock *)malloc(\n    length + BLOCK_HEADER_SIZE\n  );\n  if (!mBlock) { return NULL; }\n  /* Fill in block header and return data portion */\n\n  return mBlock;\n}\n",
          "explanation_after": "Some compilers will diagnose this condition."
        },
        "compliant": {
          "heading": "Compliant Solution (Upcast)",
          "pre_code_commentary": "In this compliant solution, the length operand is upcast to unsigned long long , ensuring that the addition takes place in this size:",
          "code": "#include <stdlib.h>\n#include <stdint.h>\n\n\nenum { BLOCK_HEADER_SIZE = 16 };\n \nvoid *AllocateBlock(size_t length) {\n  struct memBlock *mBlock;\n\n  if ((unsigned long long)length + BLOCK_HEADER_SIZE > SIZE_MAX) {\n    return NULL;\n  }\n  mBlock = (struct memBlock *)malloc(\n    length + BLOCK_HEADER_SIZE\n  );\n  if (!mBlock) { return NULL; }\n  /* Fill in block header and return data portion */\n\n  return mBlock;\n}\n",
          "explanation_after": "This test for wrapping is effective only when the sizeof(unsigned long long) > sizeof(size_t) . If both size_t and unsigned long long types are represented as 64-bit unsigned values, the result of the addition operation may not be representable as an unsigned long long value."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code example is noncompliant on systems where size_t is an unsigned 32-bit value and long long is a 64-bit value. In this example, the programmer tests for wrapping by comparing SIZE_MAX to length + BLOCK_HEADER_SIZE . Because length is declared as size_t , the addition is performed as a 32-bit operation and can result in wrapping. The comparison with SIZE_MAX will always test false. If any wrapping occurs, malloc() will allocate insufficient space for mBlock , which can lead to a subsequent buffer overflow.",
          "code": "#include <stdlib.h>\n#include <stdint.h>  /* For SIZE_MAX */\n \nenum { BLOCK_HEADER_SIZE = 16 };\n\nvoid *AllocateBlock(size_t length) {\n  struct memBlock *mBlock;\n\n  if (length + BLOCK_HEADER_SIZE > (unsigned long long)SIZE_MAX)\n    return NULL;\n  mBlock = (struct memBlock *)malloc(\n    length + BLOCK_HEADER_SIZE\n  );\n  if (!mBlock) { return NULL; }\n  /* Fill in block header and return data portion */\n\n  return mBlock;\n}\n",
          "explanation_after": "Some compilers will diagnose this condition."
        },
        "compliant": {
          "heading": "Compliant Solution (Rearrange Expression)",
          "pre_code_commentary": "In this compliant solution, length is subtracted from SIZE_MAX , ensuring that wrapping cannot occur. See INT30-C. Ensure that unsigned integer operations do not wrap .",
          "code": "#include <stdlib.h>\n#include <stdint.h>\n \nenum { BLOCK_HEADER_SIZE = 16 };\n\nvoid *AllocateBlock(size_t length) {\n  struct memBlock *mBlock;\n\n  if (SIZE_MAX - length < BLOCK_HEADER_SIZE) return NULL;\n  mBlock = (struct memBlock *)malloc(\n    length + BLOCK_HEADER_SIZE\n  );\n  if (!mBlock) { return NULL; }\n  /* Fill in block header and return data portion */\n\n  return mBlock;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the programmer attempts to prevent wrapping by allocating an unsigned long long integer called alloc and assigning it the result from cBlocks * 16 :",
          "code": "#include <stdlib.h>\n#include <limits.h>\n \nvoid *AllocBlocks(size_t cBlocks) {\n  if (cBlocks == 0) { return NULL; }\n  unsigned long long alloc = cBlocks * 16;\n  return (alloc < UINT_MAX) ? malloc(cBlocks * 16) : NULL;\n}\n",
          "explanation_after": "Two problems occur in this noncompliant code example. The first problem is that this code assumes an implementation where unsigned long long has at least 4 more bits than size_t . The second problem, assuming an implementation where size_t is a 32-bit value and unsigned long long is represented by a 64-bit value, is that to be compliant with C, multiplying two 32-bit numbers in this context must yield a 32-bit result. Any wrapping resulting from this multiplication will remain undetected by this code, and the expression alloc < UINT_MAX will always be true."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the cBlocks operand is upcast to unsigned long long , ensuring that the multiplication takes place in this size:",
          "code": "#include <stdlib.h>\n#include <assert.h>\n#include <limits.h>\n \nstatic_assert(\n  CHAR_BIT * sizeof(unsigned long long) >= \n  CHAR_BIT * sizeof(size_t) + 4, \n  \"Unable to detect wrapping after multiplication\"\n);\n\nvoid *AllocBlocks(size_t cBlocks) {\n  if (cBlocks == 0) return NULL;\n  unsigned long long alloc = (unsigned long long)cBlocks * 16;\n  return (alloc < UINT_MAX) ? malloc(cBlocks * 16) : NULL;\n}\n",
          "explanation_after": "Note that this code does not prevent wrapping unless the unsigned long long type is at least 4 bits larger than size_t ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( size_t )",
          "pre_code_commentary": "The mbstowcs() function converts a multibyte string to a wide character string, returning the number of characters converted. If an invalid multibyte character is encountered, mbstowcs() returns (size_t)(-1) . Depending on how size_t is implemented, comparing the return value of mbstowcs() to signed integer literal -1 may not evaluate as expected.",
          "code": "#include <stdlib.h>\n \nvoid func(wchar_t *pwcs, const char *restrict s, size_t n) {\n  size_t count_modified = mbstowcs(pwcs, s, n);\n  if (count_modified == -1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( size_t )",
          "pre_code_commentary": "To ensure the comparison is properly performed, the return value of mbstowcs() should be compared against -1 cast to type size_t :",
          "code": "#include <stdlib.h>\n \nvoid func(wchar_t *pwcs, const char *restrict s, size_t n) {\n  size_t count_modified = mbstowcs(pwcs, s, n);\n  if (count_modified == (size_t)-1) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to cast integers before comparing or assigning them to a larger integer size can result in software vulnerabilities that can allow the execution of arbitrary code by an attacker with the permissions of the vulnerable process.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "INT30-C",
    "title": "Ensure that unsigned integer operations do not wrap",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT30-C.+Ensure+that+unsigned+integer+operations+do+not+wrap",
    "description": "The C Standard, 6.2.5, paragraph 11 [ ISO/IEC 9899:2024 ], states\n\nA computation involving unsigned operands can never produce an overflow, because arithmetic for the unsigned type is performed modulo 2^ N .\n\nThis behavior is more informally called unsigned integer wrapping . Unsigned integer operations can wrap if the resulting value cannot be represented by the underlying representation of the integer. The following table indicates which operators can result in wrapping:\n\nOperator Wrap Operator Wrap Operator Wrap Operator Wrap + Yes -= Yes << Yes < No - Yes *= Yes >> No > No * Yes /= No & No >= No / No %= No | No <= No % No <<= Yes ^ No == No ++ Yes >>= No ~ No != No -- Yes &= No ! No && No = No |= No un + No || No += Yes ^= No un - Yes ?: No\n\n+\n\n-=\n\n<<\n\n<\n\n-\n\n*=\n\n>>\n\n>\n\n*\n\n/=\n\n&\n\n>=\n\n/\n\n%=\n\n|\n\n<=\n\n%\n\n<<=\n\n^\n\n==\n\n++\n\n>>=\n\n~\n\n!=\n\n--\n\n&=\n\n!\n\n&&\n\n=\n\n|=\n\nun +\n\n||\n\n+=\n\n^=\n\nun -\n\n?:\n\nThe following sections examine specific operations that are susceptible to unsigned integer wrap. When operating on integer types with less precision than int , integer promotions are applied. The usual arithmetic conversions may also be applied to (implicitly) convert operands to equivalent types before arithmetic operations are performed. Programmers should understand integer conversion rules before trying to implement secure arithmetic operations. (See INT02-C. Understand integer conversion rules .)\n\nint\n\nInteger values must not be allowed to wrap, especially if they are used in any of the following ways:\n\nInteger operands of any pointer arithmetic, including array indexing The assignment expression for the declaration of a variable length array The postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object Function arguments of type size_t or rsize_t (for example, an argument to a memory allocation function) In security-critical code\n\n[]\n\n[]\n\nsize_t\n\nrsize_t\n\nThe C Standard defines arithmetic on atomic integer types as read-modify-write operations with the same representation as regular integer types. As a result, wrapping of atomic unsigned integers is identical to regular unsigned integers and should also be prevented or detected.",
    "examples": null,
    "risk_assessment": {
      "explanation": "Integer wrap can lead to buffer overflows and the execution of arbitrary code by an attacker. Note that this rule is not automatically repairable in contrast to INT32-C. Ensure that operations on signed integers do not result in overflow . This is because integer wrapping is occasionally intended (see INT30-C-EX1 ), and repairing such wrapping would turn correct code into code that spuriously signals wraparound errors.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "INT31-C",
    "title": "Ensure that integer conversions do not result in lost or misinterpreted data",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT31-C.+Ensure+that+integer+conversions+do+not+result+in+lost+or+misinterpreted+data",
    "description": "Integer conversions, both implicit and explicit (using a cast), must be guaranteed not to result in lost or misinterpreted data. This rule is particularly true for integer values that originate from untrusted sources and are used in any of the following ways:\n\nInteger operands of any pointer arithmetic, including array indexing The assignment expression for the declaration of a variable length array The postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object Function arguments of type size_t or rsize_t (for example, an argument to a memory allocation function)\n\n[]\n\n[]\n\nsize_t\n\nrsize_t\n\nThis rule also applies to arguments passed to the following library functions that are converted to unsigned char :\n\nunsigned char\n\nmemset() memset_s() fprintf() and related functions (For the length modifier c , if no l length modifier is present, the int argument is converted to an unsigned char , and the resulting character is written.) fputc() ungetc() memchr()\n\nmemset()\n\nmemset_s()\n\nfprintf()\n\nc\n\nl\n\nint\n\nunsigned char\n\nfputc()\n\nungetc()\n\nmemchr()\n\nand to arguments to the following library functions that are converted to char :\n\nchar\n\nstrchr() strrchr() All of the functions listed in <ctype.h>\n\nstrchr()\n\nstrrchr()\n\n<ctype.h>\n\nThe only integer type conversions that are guaranteed to be safe for all data values and all possible conforming implementations are conversions of an integral value to a wider type of the same signedness.\n\nThe C Standard, subclause 6.3.1.3 [ ISO/IEC 9899:2024 ], says\n\nWhen a value with integer type is converted to another integer type other than _Bool , if the value can be represented by the new type, it is unchanged. Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type. Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.\n\n_Bool\n\nTypically, converting an integer to a smaller type results in truncation of the high-order bits.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Unsigned to Signed)",
          "pre_code_commentary": "Type range errors, including loss of data (truncation) and loss of sign (sign errors), can occur when converting from a value of an unsigned integer type to a value of a signed integer type. This noncompliant code example results in a truncation error on most implementations :",
          "code": "#include <limits.h>\n \nvoid func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  signed char sc;\n  sc = (signed char)u_a; /* Cast eliminates warning */\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Unsigned to Signed)",
          "pre_code_commentary": "Validate ranges when converting from an unsigned type to a signed type. This compliant solution can be used to convert a value of unsigned long int type to a value of signed char type:",
          "code": "#include <limits.h>\n \nvoid func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  signed char sc;\n  if (u_a <= SCHAR_MAX) {\n    sc = (signed char)u_a;  /* Cast eliminates warning */\n  } else {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Signed to Unsigned)",
          "pre_code_commentary": "Type range errors, including loss of data (truncation) and loss of sign (sign errors), can occur when converting from a value of a signed type to a value of an unsigned type. This noncompliant code example results in a negative number being misinterpreted as a large positive number.",
          "code": "#include <limits.h>\n\nvoid func(signed int si) {\n  /* Cast eliminates warning */\n  unsigned int ui = (unsigned int)si;\n\n  /* ... */\n}\n\n/* ... */\n\nfunc(INT_MIN);",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Signed to Unsigned)",
          "pre_code_commentary": "Validate ranges when converting from a signed type to an unsigned type. This compliant solution converts a value of a signed int type to a value of an unsigned int type:",
          "code": "#include <limits.h>\n\nvoid func(signed int si) {\n  unsigned int ui;\n  if (si < 0) {\n    /* Handle error */\n  } else {\n    ui = (unsigned int)si;  /* Cast eliminates warning */\n  }\n  /* ... */\n}\n/* ... */\n\nfunc(INT_MIN + 1);",
          "explanation_after": "Subclause 6.2.5, paragraph 11, of the C Standard [ ISO/IEC 9899:2024 ] provides the necessary guarantees to ensure this solution works on a conforming implementation :\n\nThe range of nonnegative values of a signed integer type is a subrange of the corresponding unsigned integer type, and the representation of the same value in each type is the same."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Signed, Loss of Precision)",
          "pre_code_commentary": "A loss of data (truncation) can occur when converting from a value of a signed integer type to a value of a signed type with less precision. This noncompliant code example results in a truncation error on most implementations :",
          "code": "#include <limits.h>\n\nvoid func(void) {\n  signed long int s_a = LONG_MAX;\n  signed char sc = (signed char)s_a; /* Cast eliminates warning */\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Signed, Loss of Precision)",
          "pre_code_commentary": "Validate ranges when converting from a signed type to a signed type with less precision. This compliant solution converts a value of a signed long int type to a value of a signed char type:",
          "code": "#include <limits.h>\n\nvoid func(void) {\n  signed long int s_a = LONG_MAX;\n  signed char sc;\n  if ((s_a < SCHAR_MIN) || (s_a > SCHAR_MAX)) {\n    /* Handle error */\n  } else {\n    sc = (signed char)s_a; /* Use cast to eliminate warning */\n  }\n  /* ... */\n}\n",
          "explanation_after": "Conversions from a value of a signed integer type to a value of a signed integer type with less precision requires that both the upper and lower bounds are checked."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Unsigned, Loss of Precision)",
          "pre_code_commentary": "A loss of data (truncation) can occur when converting from a value of an unsigned integer type to a value of an unsigned type with less precision. This noncompliant code example results in a truncation error on most implementations :",
          "code": "#include <limits.h>\n\nvoid func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  unsigned char uc = (unsigned char)u_a; /* Cast eliminates warning */\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Unsigned, Loss of Precision)",
          "pre_code_commentary": "Validate ranges when converting a value of an unsigned integer type to a value of an unsigned integer type with less precision. This compliant solution converts a value of an unsigned long int type to a value of an unsigned char type:",
          "code": "#include <limits.h>\n\nvoid func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  unsigned char uc;\n  if (u_a > UCHAR_MAX) {\n    /* Handle error */\n  } else {\n    uc = (unsigned char)u_a; /* Cast eliminates warning */\n  }\n  /* ... */\n}\n",
          "explanation_after": "Conversions from unsigned types with greater precision to unsigned types with less precision require only the upper bounds to be checked."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( time_t Return Value)",
          "pre_code_commentary": "The time() function returns the value (time_t)(-1) to indicate that the calendar time is not available. The C Standard requires that the time_t type is only a real type capable of representing time. (The integer and real floating types are collectively called real types.) It is left to the implementor to decide the best real type to use to represent time. If time_t is implemented as an unsigned integer type with less precision than a signed int , the return value of time() will never compare equal to the integer literal -1 .",
          "code": "#include <time.h>\n \nvoid func(void) {\n  time_t now = time(NULL);\n  if (now != -1) {\n    /* Continue processing */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( time_t Return Value)",
          "pre_code_commentary": "To ensure the comparison is properly performed, the return value of time() should be compared against -1 cast to type time_t :",
          "code": "#include <time.h>\n \nvoid func(void) {\n  time_t now = time(NULL);\n  if (now != (time_t)-1) {\n    /* Continue processing */\n  }\n}",
          "explanation_after": "This solution is in accordance with INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size . Note that (time_+t)-1 also complies with INT31-C-EX3 ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( memset() )",
          "pre_code_commentary": "For historical reasons, certain C Standard functions accept an argument of type int and convert it to either unsigned char or plain char . This conversion can result in unexpected behavior if the value cannot be represented in the smaller type. The second argument to memset() is an example; it indicates what byte to store in the range of memory indicated by the first and third arguments.  If the second argument is outside the range of a signed char or plain char , then its higher order bits will typically be truncated. Consequently, this noncompliant solution unexpectedly sets all elements in the array to 0, rather than 4096:",
          "code": "#include <string.h>\n#include <stddef.h>\n \nint *init_memory(int *array, size_t n) {\n  return memset(array, 4096, n); \n} ",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( memset() )",
          "pre_code_commentary": "In general, the memset() function should not be used to initialize an integer array unless it is to set or clear all the bits, as in this compliant solution:",
          "code": "#include <string.h>\n#include <stddef.h>\n\nint *init_memory(int *array, size_t n) {\n  return memset(array, 0, n); \n} ",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Integer truncation errors can lead to buffer overflows and the execution of arbitrary code by an attacker.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "INT32-C",
    "title": "Ensure that operations on signed integers do not result in overflow",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow",
    "description": "Signed integer overflow is undefined behavior 36 . Consequently, implementations have considerable latitude in how they deal with signed integer overflow. (See MSC15-C. Do not depend on undefined behavior .) An implementation that defines signed integer types as being modulo, for example, need not detect integer overflow. Implementations may also trap on signed arithmetic overflows, or simply assume that overflows will never happen and generate object code accordingly.  It is also possible for the same conforming implementation to emit code that exhibits different behavior in different contexts. For example, an implementation may determine that a signed integer loop control variable declared in a local scope cannot overflow and may emit efficient code on the basis of that determination, while the same implementation may determine that a global variable used in a similar context will wrap.\n\nFor these reasons, it is important to ensure that operations on signed integers do not result in overflow. Of particular importance are operations on signed integer values that originate from a tainted source and are used as\n\nInteger operands of any pointer arithmetic, including array indexing The assignment expression for the declaration of a variable length array The postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object Function arguments of type size_t or rsize_t (for example, an argument to a memory allocation function)\n\n[]\n\n[]\n\nsize_t\n\nrsize_t\n\nInteger operations will overflow if the resulting value cannot be represented by the underlying representation of the integer. The following table indicates which operations can result in overflow.\n\nOperator Overflow Operator Overflow Operator Overflow Operator Overflow + Yes -= Yes << Yes < No - Yes *= Yes >> No > No * Yes /= Yes & No >= No / Yes %= Yes | No <= No % Yes <<= Yes ^ No == No ++ Yes >>= No ~ No != No -- Yes &= No ! No && No = No |= No unary + No || No += Yes ^= No unary - Yes ?: No\n\n+\n\n-=\n\n<<\n\n<\n\n-\n\n*=\n\n>>\n\n>\n\n*\n\n/=\n\n&\n\n>=\n\n/\n\n%=\n\n|\n\n<=\n\n%\n\n<<=\n\n^\n\n==\n\n++\n\n>>=\n\n~\n\n!=\n\n--\n\n&=\n\n!\n\n&&\n\n=\n\n|=\n\nunary +\n\n||\n\n+=\n\n^=\n\nunary -\n\n?:\n\nThe following sections examine specific operations that are susceptible to integer overflow. When operating on integer types with less precision than int , integer promotions are applied. The usual arithmetic conversions may also be applied to (implicitly) convert operands to equivalent types before arithmetic operations are performed. Programmers should understand integer conversion rules before trying to implement secure arithmetic operations. (See INT02-C. Understand integer conversion rules .)\n\nint",
    "examples": null,
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "INT33-C",
    "title": "Ensure that division and remainder operations do not result in divide-by-zero errors",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT33-C.+Ensure+that+division+and+remainder+operations+do+not+result+in+divide-by-zero+errors",
    "description": "The C Standard identifies the following condition under which division and remainder operations result in undefined behavior (UB) :\n\nUB Description 41 The value of the second operand of the / or % operator is zero (6.5.5).\n\n/\n\n%\n\nEnsure that division and remainder operations do not result in divide-by-zero errors.",
    "examples": null,
    "risk_assessment": {
      "explanation": "A divide-by-zero error can result in abnormal program termination and denial of service.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "INT34-C",
    "title": "Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT34-C.+Do+not+shift+an+expression+by+a+negative+number+of+bits+or+by+greater+than+or+equal+to+the+number+of+bits+that+exist+in+the+operand",
    "description": "Bitwise shifts include left-shift operations of the form shift-expression << additive-expression and right-shift operations of the form shift-expression >> additive-expression . The standard integer promotions are first performed on the operands, each of which has an integer type. The type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined . (See undefined behavior 48 .)\n\n<<\n\n>>\n\nDo not shift an expression by a negative number of bits or by a number greater than or equal to the precision of the promoted left operand. The precision of an integer type is the number of bits it uses to represent values, excluding any sign and padding bits. For unsigned integer types, the width and the precision are the same; whereas for signed integer types, the width is one greater than the precision. This rule uses precision instead of width because, in almost every case, an attempt to shift by a number of bits greater than or equal to the precision of the operand indicates a bug (logic error). A logic error is different from overflow, in which there is simply a representational deficiency.  In general, shifts should be performed only on unsigned operands. (See INT13-C. Use bitwise operators only on unsigned operands .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Left Shift, Unsigned Type)",
          "pre_code_commentary": "The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. The following diagram illustrates the left-shift operation.\n\nAccording to the C Standard, if E1 has an unsigned type, the value of the result is E1 * 2 E2 , reduced modulo 1 more than the maximum value representable in the result type.\n\nThis noncompliant code example fails to ensure that the right operand is less than the precision of the promoted left operand:",
          "code": "void func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = ui_a << ui_b;\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Left Shift, Unsigned Type)",
          "pre_code_commentary": "This compliant solution eliminates the possibility of shifting by greater than or equal to the number of bits that exist in the precision of the left operand:",
          "code": "#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n\nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n \nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = 0;\n  if (ui_b >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  } else {\n    uresult = ui_a << ui_b;\n  }\n  /* ... */\n}",
          "explanation_after": "The PRECISION() macro and popcount() function provide the correct precision for any integer type. (See INT35-C. Use correct integer precisions .)\n\nModulo behavior resulting from left-shifting an unsigned integer type is permitted by exception INT30-EX3 to INT30-C. Ensure that unsigned integer operations do not wrap ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Left Shift, Signed Type)",
          "pre_code_commentary": "The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. If E1 has a signed type and nonnegative value, and E1 * 2 E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined (See undefined behavior 48 .).\n\nThis noncompliant code example fails to ensure that left and right operands have nonnegative values and that the right operand is less than the precision of the promoted left operand. This example does check for signed integer overflow in compliance with INT32-C. Ensure that operations on signed integers do not result in overflow .",
          "code": "#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n\nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if (si_a > (LONG_MAX >> si_b)) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}",
          "explanation_after": "Shift operators and other bitwise operators should be used only with unsigned integer operands in accordance with INT13-C. Use bitwise operators only on unsigned operands ."
        },
        "compliant": {
          "heading": "Compliant Solution (Left Shift, Signed Type)",
          "pre_code_commentary": "In addition to the check for overflow, this compliant solution ensures that both the left and right operands have nonnegative values and that the right operand is less than the precision of the promoted left operand:",
          "code": "#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX)) ||\n      (si_a > (LONG_MAX >> si_b))) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n",
          "explanation_after": "Noncompliant Code Example (Right Shift)\n\nThe result of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2 E2 . If E1 has a signed type and a negative value, the resulting value is implementation-defined and can be either an arithmetic (signed) shift\n\nor a logical (unsigned) shift\n\nThis noncompliant code example fails to test whether the right operand is greater than or equal to the precision of the promoted left operand, allowing undefined behavior (See undefined behavior 48 .):\n\nWhen working with signed operands, making assumptions about whether a right shift is implemented as an arithmetic (signed) shift or a logical (unsigned) shift can also lead to vulnerabilities . (See INT13-C. Use bitwise operators only on unsigned operands .)"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Left Shift, Signed Type)",
          "pre_code_commentary": "The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. If E1 has a signed type and nonnegative value, and E1 * 2 E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined (See undefined behavior 48 .).\n\nThis noncompliant code example fails to ensure that left and right operands have nonnegative values and that the right operand is less than the precision of the promoted left operand. This example does check for signed integer overflow in compliance with INT32-C. Ensure that operations on signed integers do not result in overflow .",
          "code": "#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n\nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if (si_a > (LONG_MAX >> si_b)) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}",
          "explanation_after": "Shift operators and other bitwise operators should be used only with unsigned integer operands in accordance with INT13-C. Use bitwise operators only on unsigned operands ."
        },
        "compliant": {
          "heading": "Compliant Solution (Right Shift)",
          "pre_code_commentary": "This compliant solution eliminates the possibility of shifting by greater than or equal to the number of bits that exist in the precision of the left operand:",
          "code": "#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n\nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n \nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = 0;\n  if (ui_b >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  } else {\n    uresult = ui_a >> ui_b;\n  }\n  /* ... */\n}",
          "explanation_after": "GCC has no options to handle shifts by negative amounts or by amounts outside the width of the type predictably or to trap on them; they are always treated as undefined. Processors may reduce the shift amount modulo the width of the type. For example, 32-bit right shifts are implemented using the following instruction on x86-32:\n\nThe sarl instruction takes a bit mask of the least significant 5 bits from %cl to produce a value in the range [0, 31] and then shift %eax that many bits:\n\nwhere %eax stores the least significant bits in the doubleword to be shifted, and %edx stores the most significant bits."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Although shifting a negative number of bits or shifting a number of bits greater than or equal to the width of the promoted left operand is undefined behavior in C, the risk is generally low because processors frequently reduce the shift amount modulo the width of the type.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT35-C",
    "title": "Use correct integer precisions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT35-C.+Use+correct+integer+precisions",
    "description": "Integer types in C have both a size and a precision . The size indicates the number of bytes used by an object and can be retrieved for any object or type using the sizeof operator.  The precision of an integer type is the number of bits it uses to represent values, excluding any sign and padding bits. Padding bits contribute to the integer's size, but not to its precision. Consequently, inferring the precision of an integer type from its size may result in too large a value, which can then lead to incorrect assumptions about the numeric range of these types.  Programmers should use correct integer precisions in their code, and in particular, should not use the sizeof operator to compute the precision of an integer type on architectures that use padding bits or in strictly conforming (that is, portable) programs. Noncompliant Code Example This noncompliant code example illustrates a function that produces 2 raised to the power of the function argument. To prevent undefined behavior (See undefined behavior 48 .) in compliance with INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand , the function ensures that the argument is less than the number of bits used to store a value of type unsigned int . #include <limits.h>\n \nunsigned int pow2(unsigned int exp) {\n  if (exp >= sizeof(unsigned int) * CHAR_BIT) {\n    /* Handle error */\n  }\n  return 1 << exp;\n} However, if this code runs on a platform where unsigned int has one or more padding bits, it can still result in values for exp that are too large. For example, on a platform that stores unsigned int in 64 bits, but uses only 48 bits to represent the value, a left shift of 56 bits would result in undefined behavior (See undefined behavior 48 .). Compliant Solution ( popcount() ) This compliant solution uses a popcount() function, which counts the number of bits set on any unsigned integer, allowing this code to determine the precision of any integer type, signed or unsigned. #include <stddef.h>\n#include <stdint.h>\n \n/* Returns the number of set bits */\nsize_t popcount(uintmax_t num) {\n  size_t precision = 0;\n  while (num != 0) {\n    if (num % 2 == 1) {\n      precision++;\n    }\n    num >>= 1;\n  }\n  return precision;\n}\n#define PRECISION(umax_value) popcount(umax_value) Implementations can replace the PRECISION() macro with a type-generic macro that returns an integer constant expression that is the precision of the specified type for that implementation. This return value can then be used anywhere an integer constant expression can be used, such as in a static assertion. (See DCL03-C. Use a static assertion to test the value of a constant expression .) The following type generic macro, for example, might be used for a specific implementation targeting the IA-32 architecture: #define PRECISION(value)  _Generic(value, \\\n  unsigned char : 8, \\\n  unsigned short: 16, \\\n  unsigned int : 32, \\\n  unsigned long : 32, \\\n  unsigned long long : 64, \\\n  signed char : 7, \\\n  signed short : 15, \\\n  signed int : 31, \\\n  signed long : 31, \\\n  signed long long : 63) The revised version of the pow2() function uses the PRECISION() macro to determine the precision of the unsigned type: #include <stddef.h>\n#include <stdint.h>\n#include <limits.h>\nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value)  \nunsigned int pow2(unsigned int exp) {\n  if (exp >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  }\n  return 1 << exp;\n} Implementation Details Some platforms, such as the Cray Linux Environment (CLE; supported on Cray XT CNL compute nodes), provide a _popcnt instruction that can substitute for the popcount() function. #define PRECISION(umax_value) _popcnt(umax_value) Compliant Solution (C23) The C23 standard provides various *_WIDTH macros that define the number of width bits for each integer type. This is effectively the size of the type (multiplied by 8) less the number of padding bits. The following compliant solution uses the UINT_WIDTH type to obtain the width of an un #include <limits.h>\n\nunsigned int pow2(unsigned int exp) {\n  if (exp >= UINT_WIDTH) {\n    /* Handle error */\n  }\n  return 1 << exp;\n} Risk Assessment Mistaking an integer's size for its precision can permit invalid precision arguments to operations such as bitwise shifts, resulting in undefined behavior.\n\n#include <limits.h>\n \nunsigned int pow2(unsigned int exp) {\n  if (exp >= sizeof(unsigned int) * CHAR_BIT) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}\n\n#include <stddef.h>\n#include <stdint.h>\n \n/* Returns the number of set bits */\nsize_t popcount(uintmax_t num) {\n  size_t precision = 0;\n  while (num != 0) {\n    if (num % 2 == 1) {\n      precision++;\n    }\n    num >>= 1;\n  }\n  return precision;\n}\n#define PRECISION(umax_value) popcount(umax_value) \n\n#define PRECISION(value)  _Generic(value, \\\n  unsigned char : 8, \\\n  unsigned short: 16, \\\n  unsigned int : 32, \\\n  unsigned long : 32, \\\n  unsigned long long : 64, \\\n  signed char : 7, \\\n  signed short : 15, \\\n  signed int : 31, \\\n  signed long : 31, \\\n  signed long long : 63)\n\n#include <stddef.h>\n#include <stdint.h>\n#include <limits.h>\nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value)  \nunsigned int pow2(unsigned int exp) {\n  if (exp >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}\n\n#define PRECISION(umax_value) _popcnt(umax_value)\n\n#include <limits.h>\n\nunsigned int pow2(unsigned int exp) {\n  if (exp >= UINT_WIDTH) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}\n\nsizeof\n\nsizeof\n\nunsigned int\n\nunsigned int\n\nexp\n\nunsigned int\n\npopcount()\n\npopcount()\n\nPRECISION()\n\npow2()\n\nPRECISION()\n\na _popcnt\n\npopcount()\n\n*_WIDTH\n\nUINT_WIDTH\n\nRule Severity Likelihood Detectable Repairable Priority Level INT35-C Low Unlikely No No P1 L3 Automated Detection Tool Version Checker Description Astrée 24.04 Supported: Astrée reports overflows due to insufficient precision. CodeSonar 9.1p0 LANG.ARITH.BIGSHIFT Shift Amount Exceeds Bit Width Cppcheck Premium 24.11.0 premium-cert-int35-c Helix QAC 2025.2 C0582 C++3115 Parasoft C/C++test 2024.2 CERT_C-INT35-a Use correct integer precisions when checking the right hand operand of the shift operator Polyspace Bug Finder R2024b CERT C: Rule INT35-C Checks for situations when integer precisions are exceeded (rule fully covered) Related Guidelines Key here (explains table format and definitions) Taxonomy Taxonomy item Relationship CWE 2.11 CWE-681 , Incorrect Conversion between Numeric Types 2017-10-30:MITRE: Unspecified Relationship 2018-10-18:CERT:Partial Overlap CERT-CWE Mapping Notes Key here for mapping notes CWE-190 and INT35-C Intersection( INT35-C, CWE-190) = Ø INT35-C used to map to CWE-190 but has been replaced with a new rule that has no overlap with CWE-190. CWE-681 and INT35-C Intersection(INT35-C, CWE-681) = due to incorrect use of integer precision, conversion from one data type to another causing data to be omitted or translated in a way that produces unexpected values CWE-681 - INT35-C = list2, where list2 = conversion from one data type to another causing data to be omitted or translated in a way that produces unexpected values , not involving incorrect use of integer precision INT35-C - CWE-681 = list1, where list1 = incorrect use of integer precision not related to conversion from one data type to another Bibliography [ Dowd 2006 ] Chapter 6, \"C Language Issues\" [ C99 Rationale 2003 ] 6.5.7, \"Bitwise Shift Operators\"",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example illustrates a function that produces 2 raised to the power of the function argument. To prevent undefined behavior (See undefined behavior 48 .) in compliance with INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand , the function ensures that the argument is less than the number of bits used to store a value of type unsigned int .",
          "code": "#include <limits.h>\n \nunsigned int pow2(unsigned int exp) {\n  if (exp >= sizeof(unsigned int) * CHAR_BIT) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}",
          "explanation_after": "However, if this code runs on a platform where unsigned int has one or more padding bits, it can still result in values for exp that are too large. For example, on a platform that stores unsigned int in 64 bits, but uses only 48 bits to represent the value, a left shift of 56 bits would result in undefined behavior (See undefined behavior 48 .)."
        },
        "compliant": {
          "heading": "Compliant Solution ( popcount() )",
          "pre_code_commentary": "This compliant solution uses a popcount() function, which counts the number of bits set on any unsigned integer, allowing this code to determine the precision of any integer type, signed or unsigned.",
          "code": "#include <stddef.h>\n#include <stdint.h>\n \n/* Returns the number of set bits */\nsize_t popcount(uintmax_t num) {\n  size_t precision = 0;\n  while (num != 0) {\n    if (num % 2 == 1) {\n      precision++;\n    }\n    num >>= 1;\n  }\n  return precision;\n}\n#define PRECISION(umax_value) popcount(umax_value) ",
          "explanation_after": "Implementations can replace the PRECISION() macro with a type-generic macro that returns an integer constant expression that is the precision of the specified type for that implementation. This return value can then be used anywhere an integer constant expression can be used, such as in a static assertion. (See DCL03-C. Use a static assertion to test the value of a constant expression .) The following type generic macro, for example, might be used for a specific implementation targeting the IA-32 architecture:\n\nThe revised version of the pow2() function uses the PRECISION() macro to determine the precision of the unsigned type:\n\nSome platforms, such as the Cray Linux Environment (CLE; supported on Cray XT CNL compute nodes), provide a _popcnt instruction that can substitute for the popcount() function."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example illustrates a function that produces 2 raised to the power of the function argument. To prevent undefined behavior (See undefined behavior 48 .) in compliance with INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand , the function ensures that the argument is less than the number of bits used to store a value of type unsigned int .",
          "code": "#include <limits.h>\n \nunsigned int pow2(unsigned int exp) {\n  if (exp >= sizeof(unsigned int) * CHAR_BIT) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}",
          "explanation_after": "However, if this code runs on a platform where unsigned int has one or more padding bits, it can still result in values for exp that are too large. For example, on a platform that stores unsigned int in 64 bits, but uses only 48 bits to represent the value, a left shift of 56 bits would result in undefined behavior (See undefined behavior 48 .)."
        },
        "compliant": {
          "heading": "Compliant Solution (C23)",
          "pre_code_commentary": "The C23 standard provides various *_WIDTH macros that define the number of width bits for each integer type. This is effectively the size of the type (multiplied by 8) less the number of padding bits. The following compliant solution uses the UINT_WIDTH type to obtain the width of an un",
          "code": "#include <limits.h>\n\nunsigned int pow2(unsigned int exp) {\n  if (exp >= UINT_WIDTH) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Mistaking an integer's size for its precision can permit invalid precision arguments to operations such as bitwise shifts, resulting in undefined behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT36-C",
    "title": "Converting a pointer to integer or integer to pointer",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/INT36-C.+Converting+a+pointer+to+integer+or+integer+to+pointer",
    "description": "Although programmers often use integers and pointers interchangeably in C, pointer-to-integer and integer-to-pointer conversions are implementation-defined .\n\nConversions between integers and pointers can have undesired consequences depending on the implementation .\n\nAccording to the C Standard, subclause 6.3.2.3 [ ISO/IEC 9899:2024 ],\n\nAn integer may be converted to any pointer type. Except as previously specified, the result is implementation-defined, might not be correctly aligned, might not point to an entity of the referenced type, and might be a trap representation.\n\nAny pointer type may be converted to an integer type. Except as previously specified, the result is implementation-defined. If the result cannot be represented in the integer type, the behavior is undefined. The result need not be in the range of values of any integer type.\n\nDo not convert an integer type to a pointer type if the resulting pointer is incorrectly aligned, does not point to an entity of the referenced type, or is a trap representation .\n\nDo not convert a pointer type to an integer type if the result cannot be represented in the integer type. (See undefined behavior 23 .)\n\nThe mapping between pointers and integers must be consistent with the addressing structure of the execution environment. Issues may arise, for example, on architectures that have a segmented memory model.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The size of a pointer can be greater than the size of an integer, such as in an implementation where pointers are 64 bits and unsigned integers are 32 bits. This code example is noncompliant on such implementations because the result of converting the 64-bit ptr cannot be represented in the 32-bit integer type:",
          "code": "void f(void) {\n  char *ptr;\n  /* ... */\n  unsigned int number = (unsigned int)ptr;\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Any valid pointer to void can be converted to intptr_t or uintptr_t and back with no change in value. (See INT36-EX2 .) The C Standard guarantees that a pointer to void may be converted to or from a pointer to any object type and back again and that the result must compare equal to the original pointer. Consequently, converting directly from a char * pointer to a uintptr_t , as in this compliant solution, is allowed on implementations that support the uintptr_t type.",
          "code": "#include <stdint.h>\n \nvoid f(void) {\n  char *ptr;\n  /* ... */\n  uintptr_t number = (uintptr_t)ptr;  \n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the pointer ptr is converted to an integer value. The high-order 9 bits of the number are used to hold a flag value, and the result is converted back into a pointer. This example is noncompliant on an implementation where pointers are 64 bits and unsigned integers are 32 bits because the result of converting the 64-bit ptr cannot be represented in the 32-bit integer type.",
          "code": "void func(unsigned int flag) {\n  char *ptr;\n  /* ... */\n  unsigned int number = (unsigned int)ptr;\n  number = (number & 0x7fffff) | (flag << 23);\n  ptr = (char *)number;\n}\n",
          "explanation_after": "A similar scheme was used in early versions of Emacs, limiting its portability and preventing the ability to edit files larger than 8MB."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses a struct to provide storage for both the pointer and the flag value. This solution is portable to machines of different word sizes, both smaller and larger than 32 bits, working even when pointers cannot be represented in any integer type.",
          "code": "struct ptrflag {\n  char *pointer;\n  unsigned int flag : 9;\n} ptrflag;\n \nvoid func(unsigned int flag) {\n  char *ptr;\n  /* ... */\n  ptrflag.pointer = ptr;\n  ptrflag.flag = flag;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "It is sometimes necessary to access memory at a specific location, requiring a literal integer to pointer conversion. In this noncompliant code, a pointer is set directly to an integer constant, where it is unknown whether the result will be as intended:",
          "code": "unsigned int *g(void) {\n  unsigned int *ptr = 0xdeadbeef;\n  /* ... */\n  return ptr;\n} ",
          "explanation_after": "The result of this assignment is implementation-defined , might not be correctly aligned, might not point to an entity of the referenced type, and might be a trap representation ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Unfortunately this code cannot be made safe while strictly conforming to ISO C.\n\nA particular platform (that is, hardware, operating system, compiler, and Standard C library) might guarantee that a memory address is correctly aligned for the pointer type, and actually contains a value for that type. A common practice is to use addresses that are known to point to hardware that provides valid values.",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Converting from pointer to integer or vice versa results in code that is not portable and may create unexpected pointers to invalid memory locations.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM00-C",
    "title": "Allocate and free memory in the same module, at the same level of abstraction",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM00-C.+Allocate+and+free+memory+in+the+same+module%2C+at+the+same+level+of+abstraction",
    "description": "Dynamic memory management is a common source of programming flaws that can lead to security vulnerabilities . Poor memory management can lead to security issues, such as heap-buffer overflows, dangling pointers, and double-free issues [ Seacord 2013 ]. From the programmer's perspective, memory management involves allocating memory, reading and writing to memory, and deallocating memory.\n\nAllocating and freeing memory in different modules and levels of abstraction may make it difficult to determine when and if a block of memory has been freed, leading to programming defects, such as memory leaks, double-free vulnerabilities , accessing freed memory, or writing to freed or unallocated memory.\n\nTo avoid these situations, memory should be allocated and freed at the same level of abstraction and, ideally, in the same code module. This includes the use of the following memory allocation and deallocation functions described in subclause 7.23.3 of the C Standard [ ISO/IEC 9899:2011 ]:\n\nvoid *malloc(size_t size);\n\nvoid *calloc(size_t nmemb, size_t size);\n\nvoid *realloc(void *ptr, size_t size);\n\nvoid *aligned_alloc(size_t alignment, size_t size);\n \nvoid free(void *ptr);\n\nvoid *malloc(size_t size);\n\nvoid *calloc(size_t nmemb, size_t size);\n\nvoid *realloc(void *ptr, size_t size);\n\nvoid *aligned_alloc(size_t alignment, size_t size);\n \nvoid free(void *ptr);\n\nFailing to follow this recommendation has led to real-world vulnerabilities. For example, freeing memory in different modules resulted in a vulnerability in MIT Kerberos 5 [ MIT 2004 ]. The MIT Kerberos 5 code in this case contained error-handling logic, which freed memory allocated by the ASN.1 decoders if pointers to the allocated memory were non-null. However, if a detectable error occurred, the ASN.1 decoders freed the memory that they had allocated. When some library functions received errors from the ASN.1 decoders, they also attempted to free the same memory, resulting in a double-free vulnerability.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example shows a double-free vulnerability resulting from memory being allocated and freed at differing levels of abstraction. In this example, memory for the list array is allocated in the process_list() function. The array is then passed to the verify_size() function that performs error checking on the size of the list. If the size of the list is below a minimum size, the memory allocated to the list is freed, and the function returns to the caller. The calling function then frees this same memory again, resulting in a double-free and potentially exploitable vulnerability.",
          "code": "enum { MIN_SIZE_ALLOWED = 32 };\n\nint verify_size(char *list, size_t size) {\n  if (size < MIN_SIZE_ALLOWED) {\n    /* Handle error condition */\n    free(list);\n    return -1;\n  }\n  return 0;\n}\n\nvoid process_list(size_t number) {\n  char *list = (char *)malloc(number);\n  if (list == NULL) {\n    /* Handle allocation error */\n  }\n\n  if (verify_size(list, number) == -1) {\n      free(list);\n      return;\n  }\n\n  /* Continue processing list */\n\n  free(list);\n}\n",
          "explanation_after": "The call to free memory in the verify_size() function takes place in a subroutine of the process_list() function, at a different level of abstraction from the allocation, resulting in a violation of this recommendation. The memory deallocation also occurs in error-handling code, which is frequently not as well tested as \"green paths\" through the code."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "To correct this problem, the error-handling code in verify_size() is modified so that it no longer frees list . This change ensures that list is freed only once, at the same level of abstraction, in the process_list() function.",
          "code": "enum { MIN_SIZE_ALLOWED = 32 };\n\nint verify_size(const char *list, size_t size) {\n  if (size < MIN_SIZE_ALLOWED) {\n    /* Handle error condition */\n    return -1;\n  }\n  return 0;\n}\n\nvoid process_list(size_t number) {\n  char *list = (char *)malloc(number);\n\n  if (list == NULL) {\n    /* Handle allocation error */\n  }\n\n  if (verify_size(list, number) == -1) {\n      free(list);\n      return;\n  }\n\n  /* Continue processing list */\n\n  free(list);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The mismanagement of memory can lead to freeing memory multiple times or writing to already freed memory. Both of these coding errors can result in an attacker executing arbitrary code with the permissions of the vulnerable process. Memory management errors can also lead to resource depletion and denial-of-service attacks .",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "MEM02-C",
    "title": "Immediately cast the result of a memory allocation function call into a pointer to the allocated type",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM02-C.+Immediately+cast+the+result+of+a+memory+allocation+function+call+into+a+pointer+to+the+allocated+type",
    "description": "An object of type void * is a generic data pointer. It can point to any data object. For any incomplete or object type T , C permits implicit conversion from T * to void * or from void * to T * .  C Standard memory allocation functions aligned_alloc() , malloc() , calloc() , and realloc() use void * to declare parameters and return types of functions designed to work for objects of different types.\n\nvoid *\n\nT\n\nT *\n\nvoid *\n\nvoid *\n\nT *\n\naligned_alloc()\n\nmalloc()\n\ncalloc()\n\nrealloc() \n\nvoid *\n\nFor example, the C library declares malloc() as\n\nmalloc()\n\nvoid *malloc(size_t);\n\nvoid *malloc(size_t);\n\nCalling malloc(s) allocates memory for an object whose size is s and returns either a null pointer or a pointer to the allocated memory. A program can implicitly convert the pointer that malloc() returns into a different pointer type.\n\nmalloc(s)\n\ns\n\nmalloc()\n\nBecause objects returned by the C Standard memory allocation functions are implicitly converted into any object type, we recommend casting the results of these functions into a pointer of the allocated type because it increases the chances that the compiler will catch and diagnose a mismatch between the intended type of the object and the actual type of the object.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The argument to malloc() can be any value of (unsigned) type size_t . If the program uses the allocated storage to represent an object (possibly an array) whose size is greater than the requested size, the behavior is undefined . The implicit pointer conversion lets this slip by without complaint from the compiler.\n\nConsider the following example:",
          "code": "#include <stdlib.h>\n\ntypedef struct gadget gadget;\nstruct gadget {\n  int i;\n  double d;\n};\n\ntypedef struct widget widget;\nstruct widget {\n  char c[10];\n  int i;\n  double d;\n};\n\nwidget *p;\n\n/* ... */\n\np = malloc(sizeof(gadget)); /* Imminent problem */\nif (p != NULL) {\n  p->i = 0;                 /* Undefined behavior */\n  p->d = 0.0;               /* Undefined behavior */\n}\n",
          "explanation_after": "An implementation may add padding to a gadget or widget so that sizeof(gadget) equals sizeof(widget) , but this is highly unlikely. More likely, sizeof(gadget) is less than sizeof(widget) . In that case,\n\nquietly assigns p to point to storage too small for a widget. The subsequent assignments to p->i and p->d will most likely produce memory overruns.\n\nCasting the result of malloc() to the appropriate pointer type enables the compiler to catch subsequent inadvertent pointer conversions. When allocating individual objects, the \"appropriate pointer type\" is a pointer to the type argument in the sizeof expression passed to malloc() .\n\nIn this code example, malloc() allocates space for a gadget , and the cast immediately converts the returned pointer to a gadget * :\n\nThis lets the compiler detect the invalid assignment because it attempts to convert a gadget * into a widget * ."
        },
        "compliant": {
          "heading": "Compliant Solution (Hand Coded)",
          "pre_code_commentary": "This compliant solution repeats the same type in the sizeof expression and the pointer cast:",
          "code": "widget *p;\n\n/* ... */\n\np = (widget *)malloc(sizeof(widget));\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The argument to malloc() can be any value of (unsigned) type size_t . If the program uses the allocated storage to represent an object (possibly an array) whose size is greater than the requested size, the behavior is undefined . The implicit pointer conversion lets this slip by without complaint from the compiler.\n\nConsider the following example:",
          "code": "#include <stdlib.h>\n\ntypedef struct gadget gadget;\nstruct gadget {\n  int i;\n  double d;\n};\n\ntypedef struct widget widget;\nstruct widget {\n  char c[10];\n  int i;\n  double d;\n};\n\nwidget *p;\n\n/* ... */\n\np = malloc(sizeof(gadget)); /* Imminent problem */\nif (p != NULL) {\n  p->i = 0;                 /* Undefined behavior */\n  p->d = 0.0;               /* Undefined behavior */\n}\n",
          "explanation_after": "An implementation may add padding to a gadget or widget so that sizeof(gadget) equals sizeof(widget) , but this is highly unlikely. More likely, sizeof(gadget) is less than sizeof(widget) . In that case,\n\nquietly assigns p to point to storage too small for a widget. The subsequent assignments to p->i and p->d will most likely produce memory overruns.\n\nCasting the result of malloc() to the appropriate pointer type enables the compiler to catch subsequent inadvertent pointer conversions. When allocating individual objects, the \"appropriate pointer type\" is a pointer to the type argument in the sizeof expression passed to malloc() .\n\nIn this code example, malloc() allocates space for a gadget , and the cast immediately converts the returned pointer to a gadget * :\n\nThis lets the compiler detect the invalid assignment because it attempts to convert a gadget * into a widget * ."
        },
        "compliant": {
          "heading": "Compliant Solution (Macros)",
          "pre_code_commentary": "Repeating the same type in the sizeof expression and the pointer cast is easy to do but still invites errors. Packaging the repetition in a macro, such as",
          "code": "#define MALLOC(type) ((type *)malloc(sizeof(type)))\n",
          "explanation_after": "further reduces the possibility of error.\n\nHere, the entire allocation expression (to the right of the assignment operator) allocates storage for a widget and returns a widget * . If p were not a widget * , the compiler would complain about the assignment.\n\nWhen allocating an array with N elements of type T , the appropriate type in the cast expression is still T * , but the argument to malloc() should be of the form N * sizeof(T) . Again, packaging this form as a macro, such as\n\nreduces the chance of error in an allocation expression.\n\nA small collection of macros can provide secure implementations for common uses for the standard memory allocation functions. The omission of a REALLOC() macro is intentional (see EXP39-C. Do not access a variable through a pointer of an incompatible type ).\n\nThe following is an example:\n\nIf one or more of the operands to the multiplication operations used in many of these macro definitions can be influenced by untrusted data, these operands should be checked for overflow before the macro is invoked (see INT32-C. Ensure that operations on signed integers do not result in overflow ).\n\nThe use of type-generic function-like macros is an allowed exception (PRE00-C-EX4) to PRE00-C. Prefer inline or static functions to function-like macros ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to cast the result of a memory allocation function call into a pointer to the allocated type can result in inadvertent pointer conversions. Code that follows this recommendation will compile and execute equally well in C++.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM03-C",
    "title": "Clear sensitive information stored in reusable resources",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM03-C.+Clear+sensitive+information+stored+in+reusable+resources",
    "description": "Sensitive data stored in reusable resources may be inadvertently leaked to a less privileged user or attacker if not properly cleared. Examples of reusable resources include\n\nDynamically allocated memory Statically allocated memory Automatically allocated (stack) memory Memory caches Disk Disk caches\n\nThe manner in which sensitive information can be properly cleared varies depending on the resource type and platform.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( free() )",
          "pre_code_commentary": "Dynamic memory managers are not required to clear freed memory and generally do not because of the additional runtime overhead. Furthermore, dynamic memory managers are free to reallocate this same memory. As a result, it is possible to accidentally leak sensitive information if it is not cleared before calling a function that frees dynamic memory. Programmers also cannot rely on memory being cleared during allocation.\n\nTo prevent information leakage, sensitive information must be cleared from dynamically allocated buffers before they are freed. Calling free() on a block of dynamic memory causes the space to be deallocated; that is, the memory block is made available for future allocation. However, the data stored in the block of memory to be recycled may be preserved. If this memory block contains sensitive information, that information may be unintentionally exposed.\n\nIn this noncompliant example, sensitive information stored in the dynamically allocated memory referenced by secret is copied to the dynamically allocated buffer, new_secret , which is processed and eventually deallocated by a call to free() . Because the memory is not cleared, it may be reallocated to another section of the program where the information stored in new_secret may be unintentionally leaked.",
          "code": "char *secret;\n/* Initialize secret to a null-terminated byte string, \n   of less than SIZE_MAX chars */\n\nsize_t size = strlen(secret);\nchar *new_secret;\nnew_secret = (char *)malloc(size+1);\nif (!new_secret) {\n  /* Handle error */\n}\nstrcpy(new_secret, secret);\n\n/* Process new_secret... */\n\nfree(new_secret);\nnew_secret = NULL;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "To prevent information leakage, dynamic memory containing sensitive information should be sanitized before being freed. Sanitization is commonly accomplished by clearing the allocated space (that is, filling the space with '\\0' characters).",
          "code": "char *secret;\n/* Initialize secret to a null-terminated byte string, \n   of less than SIZE_MAX chars */\n\nsize_t size = strlen(secret);\nchar *new_secret;\n/* Use calloc() to zero-out allocated space */\nnew_secret = (char *)calloc(size+1, sizeof(char));\nif (!new_secret) {\n  /* Handle error */\n}\nstrcpy(new_secret, secret);\n\n/* Process new_secret... */\n\n/* Sanitize memory */\nmemset_s(new_secret, '\\0', size);\nfree(new_secret);\nnew_secret = NULL;\n",
          "explanation_after": "The calloc() function ensures that the newly allocated memory has also been cleared. Because sizeof(char) is guaranteed to be 1, this solution does not need to check for a numeric overflow as a result of using calloc() . (See MEM07-C. Ensure that the arguments to calloc(), when multiplied, do not wrap .)\n\nSee MSC06-C. Beware of compiler optimizations for a definition and discussion of using the memset_s() function."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( realloc() )",
          "pre_code_commentary": "Reallocating memory using realloc() can have the same problem as freeing memory. The realloc() function deallocates the old object and returns a pointer to a new object. U sing realloc() to resize dynamic memory may inadvertently expose sensitive information, or it may allow heap inspection, as described in Fortify Taxonomy: Software Security Errors [ Fortify 2006 ] and NIST's Source Code Analysis Tool Functional Specification [ Black 2007 ].\n\nIn this example, when realloc() is called, it may allocate a new, larger object, copy the contents of secret to this new object, free() the original object, and assign the newly allocated object to secret . However, the contents of the original object may remain in memory.",
          "code": "char *secret;\n\n/* Initialize secret */\n\nsize_t secret_size = strlen(secret);\n/* ... */\nif (secret_size > SIZE_MAX/2) {\n   /* Handle error condition */\n}\nelse {\nsecret = (char *)realloc(secret, secret_size * 2);\n}\n",
          "explanation_after": "The secret_size is tested to ensure that the integer multiplication ( secret_size * 2 ) does not result in an integer overflow. (See INT30-C. Ensure that unsigned integer operations do not wrap .)"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "A compliant program cannot rely on realloc() because it is not possible to clear the memory before the call. Instead, a custom function must be used that operates similarly to realloc() but sanitizes sensitive information as heap-based buffers are resized. Again, sanitization is done by overwriting the space to be deallocated with '\\0' characters.",
          "code": "char *secret;\n\n/* Initialize secret */\n\nsize_t secret_size = strlen(secret);\nchar *temp_buff;\n/* ... */\nif (secret_size > SIZE_MAX/2) {\n   /* Handle error condition */\n}\n/* calloc() initializes memory to zero */\ntemp_buff = (char *)calloc(secret_size * 2, sizeof(char));\nif (temp_buff == NULL) {\n /* Handle error */\n}\n\nmemcpy(temp_buff, secret, secret_size);\n\n/* Sanitize the buffer */\nmemset((volatile char *)secret, '\\0', secret_size);\n\nfree(secret);\nsecret = temp_buff; /* Install the resized buffer */\ntemp_buff = NULL;\n",
          "explanation_after": "The calloc() function ensures that the newly allocated memory is also cleared. Because sizeof(char) is guaranteed to be 1, this solution does not need to check for a numeric overflow as a result of using calloc() . (See MEM07-C. Ensure that the arguments to calloc(), when multiplied, do not wrap .)"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "In practice, this type of security flaw can expose sensitive information to unintended parties. The Sun tarball vulnerability discussed in Secure Coding Principles & Practices: Designing and Implementing Secure Applications [ Graf 2003 ] and Sun Security Bulletin #00122 [ Sun 1993 ] shows a violation of this recommendation, leading to sensitive data being leaked. Attackers may also be able to leverage this defect to retrieve sensitive information using techniques such as heap inspection .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM04-C",
    "title": "Beware of zero-length allocations",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM04-C.+Beware+of+zero-length+allocations",
    "description": "When the requested size is 0, the behavior of the memory allocation functions malloc() , calloc() , and realloc() is implementation-defined . Subclause 7.22.3 of the C Standard [ ISO/IEC 9899:2011 ] states:\n\nmalloc()\n\ncalloc()\n\nrealloc()\n\nIf the size of the space requested is zero, the behavior is implementation-defined: either a null pointer is returned, or the behavior is as if the size were some nonzero value, except that the returned pointer shall not be used to access an object.\n\nIn addition, the amount of storage allocated by a successful call to the allocation function when 0 bytes was requested is unspecified . See unspecified behavior 41 in subclause J.1 of the C Standard.\n\nIn cases where the memory allocation functions return a non-null pointer, reading from or writing to the allocated memory area results in undefined behavior . Typically, the pointer refers to a zero-length block of memory consisting entirely of control structures. Overwriting these control structures damages the data structures used by the memory manager.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( malloc() )",
          "pre_code_commentary": "The result of calling malloc(0) to allocate 0 bytes is implementation-defined. In this example, a dynamic array of integers is allocated to store size elements. However, if size is 0, the call to malloc(size) may return a reference to a block of memory of size 0 instead of a null pointer. When (nonempty) data is copied to this location, a heap-buffer overflow occurs.",
          "code": "size_t size;\n\n/* Initialize size, possibly by user-controlled input */\n\nint *list = (int *)malloc(size);\nif (list == NULL) {\n  /* Handle allocation error */\n}\nelse {\n/* Continue processing list */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( malloc() )",
          "pre_code_commentary": "To ensure that 0 is never passed as a size argument to malloc() , size is checked to confirm it has a positive value:",
          "code": "size_t size;\n\n/* Initialize size, possibly by user-controlled input */\n\nif (size == 0) {\n  /* Handle error */\n}\nint *list = (int *)malloc(size);\nif (list == NULL) {\n  /* Handle allocation error */\n}\n/* Continue processing list */\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( realloc() )",
          "pre_code_commentary": "The realloc() function deallocates the old object and returns a pointer to a new object of a specified size. If memory for the new object cannot be allocated, the realloc() function does not deallocate the old object, and its value is unchanged. If the realloc() function returns NULL , failing to free the original memory will result in a memory leak. As a result, the following idiom is often recommended for reallocating memory:",
          "code": "size_t nsize = /* Some value, possibly user supplied */;\nchar *p2;\nchar *p = (char *)malloc(100);\nif (p == NULL) {\n  /* Handle error */\n}\n\n/* ... */\n\nif ((p2 = (char *)realloc(p, nsize)) == NULL) {\n  free(p);\n  p = NULL;\n  return NULL;\n}\np = p2;\n",
          "explanation_after": "However, this commonly recommended idiom has problems with zero-length allocations. If the value of nsize in this example is 0, the standard allows the option of either returning a null pointer or returning a pointer to an invalid (for example, zero-length) object. In cases where the realloc() function frees the memory but returns a null pointer, execution of the code results in a double-free vulnerability. If the realloc() function returns a non-null value, but the size was 0, the returned memory will be of size 0, and a heap overflow will occur if nonempty data is copied there.\n\nIf this noncompliant code is compiled with GCC 3.4.6 and linked with libc 2.3.4, invoking realloc(p, 0) returns a non-null pointer to a zero-sized object (the same as malloc(0) ). However, if the same code is compiled with either Microsoft Visual Studio or GCC 4.1.0 , realloc(p, 0) returns a null pointer, resulting in a double-free vulnerability."
        },
        "compliant": {
          "heading": "Compliant Solution ( realloc() )",
          "pre_code_commentary": "This compliant solution does not pass a size argument of zero to the realloc() function:",
          "code": "size_t nsize;\n/* Initialize nsize */\nchar *p2;\nchar *p = (char *)malloc(100);\nif (p == NULL) {\n  /* Handle error */\n}\n\n/* ... */\n\np2 = NULL;\nif (nsize != 0) {\n  p2 = (char *)realloc(p, nsize);\n}\nif (p2 == NULL) {\n  free(p);\n  p = NULL;\n  return NULL;\n}\np = p2;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Allocating 0 bytes can lead to abnormal program termination .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MEM05-C",
    "title": "Avoid large stack allocations",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM05-C.+Avoid+large+stack+allocations",
    "description": "Avoid excessive stack allocations, particularly in situations where the growth of the stack can be controlled or influenced by an attacker. See INT04-C. Enforce limits on integer values originating from tainted sources for more information on preventing attacker-controlled integers from exhausting memory.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The C Standard includes support for variable length arrays (VLAs). If the array length is derived from an untrusted data source, an attacker can cause the process to perform an excessive allocation on the stack.\n\nThis noncompliant code example temporarily stores data read from a source file into a buffer. The buffer is allocated on the stack as a VLA of size bufsize . If bufsize can be controlled by a malicious user, this code can be exploited to cause a denial-of-service attack :",
          "code": "int copy_file(FILE *src, FILE *dst, size_t bufsize) {\n  char buf[bufsize];\n\n  while (fgets(buf, bufsize, src)) {\n    if (fputs(buf, dst) == EOF) {\n      /* Handle error */\n    }\n  }\n\n  return 0;\n}\n",
          "explanation_after": "The BSD extension function alloca() behaves in a similar fashion to VLAs; its use is not recommended [ Loosemore 2007 ]."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution replaces the VLA with a call to malloc() . If malloc() fails, the return value can be checked to prevent the program from terminating abnormally.",
          "code": "int copy_file(FILE *src, FILE *dst, size_t bufsize) {\n  if (bufsize == 0) {\n    /* Handle error */\n  }\n  char *buf = (char *)malloc(bufsize);\n  if (!buf) {\n    /* Handle error */\n  }\n\n  while (fgets(buf, bufsize, src)) {\n    if (fputs(buf, dst) == EOF) {\n      /* Handle error */\n    }\n  }\n  /* ... */\n  free(buf);\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Recursion can also lead to large stack allocations. Recursive functions must ensure that they do not exhaust the stack as a result of excessive recursions.\n\nThis noncompliant implementation of the Fibonacci function uses recursion:",
          "code": "unsigned long fib1(unsigned int n) {\n  if (n == 0) {\n    return 0;\n  }\n  else if (n == 1 || n == 2) {\n    return 1;\n  }\n  else {\n    return fib1(n-1) + fib1(n-2);\n  }\n}\n",
          "explanation_after": "The amount of stack space needed grows linearly with respect to the parameter n . Large values of n have been shown to cause abnormal program termination ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This implementation of the Fibonacci functions eliminates the use of recursion:",
          "code": "unsigned long fib2(unsigned int n) {\n  if (n == 0) {\n    return 0;\n  }\n  else if (n == 1 || n == 2) {\n    return 1;\n  }\n\n  unsigned long prev = 1;\n  unsigned long cur = 1;\n\n  unsigned int i;\n\n  for (i = 3; i <= n; i++) {\n    unsigned long tmp = cur;\n    cur = cur + prev;\n    prev = tmp;\n  }\n\n  return cur;\n}\n",
          "explanation_after": "Because there is no recursion, the amount of stack space needed does not depend on the parameter n , greatly reducing the risk of stack overflow."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Program stacks are frequently used for convenient temporary storage because allocated memory is automatically freed when the function returns. Generally, the operating system grows the stack as needed. However, growing the stack can fail because of a lack of memory or a collision with other allocated areas of the address space (depending on the architecture). When the stack is exhausted, the operating system can terminate the program abnormally. This behavior can be exploited, and an attacker can cause a denial-of-service attack if he or she can control or influence the amount of stack memory allocated.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MEM06-C",
    "title": "Ensure that sensitive data is not written out to disk",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM06-C.+Ensure+that+sensitive+data+is+not+written+out+to+disk",
    "description": "Developers should take steps to prevent sensitive information such as passwords, cryptographic keys, and other secrets from being inadvertently leaked. Preventive measures include attempting to keep such data from being written to disk.\n\nTwo common mechanisms by which data is inadvertently written to disk are swapping and core dumps .\n\nMany general-purpose operating systems implement a virtual-memory-management technique called paging (also called swapping ) to transfer pages between main memory and an auxiliary store, such as a disk drive. This feature is typically implemented as a task running in the kernel of the operating system, and its operation is invisible to the running program.\n\nA core dump is the recorded state of process memory written to disk for later examination by a debugger. Core dumps are typically generated when a program has terminated abnormally , either through an error resulting in a crash or by receiving a signal that causes such a termination.\n\nThe POSIX standard system call for controlling resource limits, setrlimit() , can be used to disable the creation of core dumps, which prevents an attacker with the ability to halt the program from gaining access to sensitive data that might be contained in the dump.\n\nsetrlimit()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, sensitive information is supposedly stored in the dynamically allocated buffer, secret , which is processed and eventually cleared by a call to memset_s() . The memory page containing secret can be swapped out to disk. If the program crashes before the call to memset_s() completes, the information stored in secret may be stored in the core dump.",
          "code": "char *secret;\n\nsecret = (char *)malloc(size+1);\nif (!secret) {\n  /* Handle error */\n}\n\n/* Perform operations using secret... */\n\nmemset_s(secret, '\\0', size+1);\nfree(secret);\nsecret = NULL;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "To prevent the information from being written to a core dump, the size of core dumps that the program will generate should be set to 0 using setrlimit() :",
          "code": "#include <sys/resource.h>\n/* ... */\nstruct rlimit limit;\nlimit.rlim_cur = 0;\nlimit.rlim_max = 0;\nif (setrlimit(RLIMIT_CORE, &limit) != 0) {\n    /* Handle error */\n}\n\nchar *secret;\n\nsecret = (char *)malloc(size+1);\nif (!secret) {\n  /* Handle error */\n}\n\n/* Perform operations using secret... */\n\nmemset_s(secret, '\\0', size+1);\nfree(secret);\nsecret = NULL;\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, sensitive information is supposedly stored in the dynamically allocated buffer, secret , which is processed and eventually cleared by a call to memset_s() . The memory page containing secret can be swapped out to disk. If the program crashes before the call to memset_s() completes, the information stored in secret may be stored in the core dump.",
          "code": "char *secret;\n\nsecret = (char *)malloc(size+1);\nif (!secret) {\n  /* Handle error */\n}\n\n/* Perform operations using secret... */\n\nmemset_s(secret, '\\0', size+1);\nfree(secret);\nsecret = NULL;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Privileged Process, POSIX)",
          "pre_code_commentary": "The added security from using mlock() is limited. (See the sidebar by Nick Stoughton.)\n\nProcesses with elevated privileges can disable paging by locking memory in place using the POSIX mlock() function [ IEEE Std 1003.1:2013 ]. Disabling paging ensures that memory is never copied to the hard drive, where it may be retained indefinitely in nonvolatile storage.\n\nThis compliant solution not only disables the creation of core files but also ensures that the buffer is not swapped to hard disk:",
          "code": "#include <sys/resource.h>\n/* ... */\nstruct rlimit limit;\nlimit.rlim_cur = 0;\nlimit.rlim_max = 0;\nif (setrlimit(RLIMIT_CORE, &limit) != 0) {\n    /* Handle error */\n}\n\nlong pagesize = sysconf(_SC_PAGESIZE);\nif (pagesize == -1) {\n  /* Handle error */\n}\n\nchar *secret_buf;\nchar *secret;\n\nsecret_buf = (char *)malloc(size+1+pagesize);\nif (!secret_buf) {\n  /* Handle error */\n}\n\n/* mlock() may require that address be a multiple of PAGESIZE */\nsecret = (char *)((((intptr_t)secret_buf + pagesize - 1) / pagesize) * pagesize);\n\nif (mlock(secret, size+1) != 0) {\n    /* Handle error */\n}\n\n/* Perform operations using secret... */\n\nif (munlock(secret, size+1) != 0) {\n    /* Handle error */\n}\nsecret = NULL;\n\nmemset_s(secret_buf, '\\0', size+1+pagesize);\nfree(secret_buf);\nsecret_buf = NULL;\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, sensitive information is supposedly stored in the dynamically allocated buffer, secret , which is processed and eventually cleared by a call to memset_s() . The memory page containing secret can be swapped out to disk. If the program crashes before the call to memset_s() completes, the information stored in secret may be stored in the core dump.",
          "code": "char *secret;\n\nsecret = (char *)malloc(size+1);\nif (!secret) {\n  /* Handle error */\n}\n\n/* Perform operations using secret... */\n\nmemset_s(secret, '\\0', size+1);\nfree(secret);\nsecret = NULL;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "Windows processes can disable paging by locking memory in place using VirtualLock() [ MSDN ]:",
          "code": "char *secret;\n\nsecret = (char *)VirtualAlloc(0, size + 1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\nif (!secret) {\n  /* Handle error */\n}\n\nif (!VirtualLock(secret, size+1)) {\n    /* Handle error */\n}\n\n/* Perform operations using secret... */\n\nSecureZeroMemory(secret, size + 1);\nVirtualUnlock(secret, size + 1);\nVirtualFree(secret, 0, MEM_RELEASE);\nsecret = NULL;\n",
          "explanation_after": "Note that locking pages of memory on Windows may fail because the operating system allows the process to lock only a small number of pages. If an application requires additional locked pages, the SetProcessWorkingSetSize() API can be used to increase the application's minimum working set size. Locking pages has severe performance consequences and should be used sparingly."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Writing sensitive data to disk preserves it for future retrieval by an attacker, who may even be able to bypass the access restrictions of the operating system by using a disk maintenance program.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM07-C",
    "title": "Ensure that the arguments to calloc(), when multiplied, do not wrap",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM07-C.+Ensure+that+the+arguments+to+calloc%28%29%2C+when+multiplied%2C+do+not+wrap",
    "description": "Deprecated This guideline does not apply to code that need conform only to C23. Code that must conform to older versions of the C standard should still comply with this guideline.\n\nThe calloc() function takes two arguments: the number of elements to allocate and the storage size of those elements. Typically, calloc() implementations multiply these arguments to determine how much memory to allocate. Historically, some implementations failed to check whether out-of-bounds results silently wrapped [ RUS-CERT Advisory 2002-08:02 ]. If the result of multiplying the number of elements to allocate and the storage size wraps, less memory is allocated than was requested. As a result, it is necessary to ensure that these arguments, when multiplied, do not wrap.\n\ncalloc()\n\ncalloc()\n\nModern implementations of the C standard library should check for wrap. If the calloc() function implemented by the libraries used for a particular implementation properly handles unsigned integer wrapping (in conformance with INT30-C. Ensure that unsigned integer operations do not wrap ) when multiplying the number of elements to allocate and the storage size, that is sufficient to comply with this recommendation and no further action is required.\n\ncalloc()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, the user-defined function get_size() (not shown) is used to calculate the size requirements for a dynamic array of long int that is assigned to the variable num_elements . When calloc() is called to allocate the buffer, num_elements is multiplied by sizeof(long) to compute the overall size requirements. If the number of elements multiplied by the size cannot be represented as a size_t , then calloc() may allocate a buffer of insufficient size. When data is copied to that buffer, an overflow may occur.",
          "code": "size_t num_elements;\n\nlong *buffer = (long *)calloc(num_elements, sizeof(long));\nif (buffer == NULL) {\n  /* Handle error condition */\n}\n/* ... */\nfree(buffer);\nbuffer = NULL; \n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the two arguments num_elements and sizeof(long) are checked before the call to calloc() to determine if wrapping will occur:",
          "code": "long *buffer;\nsize_t num_elements;\n\nif (num_elements > SIZE_MAX/sizeof(long)) {\n  /* Handle error condition */\n}\nbuffer = (long *)calloc(num_elements, sizeof(long));\nif (buffer == NULL) {\n  /* Handle error condition */\n}\n",
          "explanation_after": "Note that the maximum amount of allocatable memory is typically limited to a value less than SIZE_MAX (the maximum value of size_t ). Always check the return value from a call to any memory allocation function in compliance with ERR33-C. Detect and handle standard library errors ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Unsigned integer wrapping in memory allocation functions can lead to buffer overflows that can be exploited by an attacker to execute arbitrary code with the permissions of the vulnerable process. Most implementations of calloc() now check to make sure silent wrapping does not occur, but it is not always safe to assume the version of calloc() being used is secure, particularly when using dynamically linked libraries.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MEM10-C",
    "title": "Define and use a pointer validation function",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM10-C.+Define+and+use+a+pointer+validation+function",
    "description": "Many functions accept pointers as arguments. If the function dereferences an invalid pointer (as in EXP34-C. Do not dereference null pointers ) or reads or writes to a pointer that does not refer to an object, the results are undefined . Typically, the program will terminate abnormally when an invalid pointer is dereferenced, but it is possible for an invalid pointer to be dereferenced and its memory changed without abnormal termination [ Jack 2007 ]. Such programs can be difficult to debug because of the difficulty in determining if a pointer is valid .\n\nOne way to eliminate invalid pointers is to define a function that accepts a pointer argument and indicates whether or not the pointer is valid for some definition of valid. For example, the following function declares any pointer to be valid except NULL :\n\nNULL\n\nint valid(void *ptr) {\n  return (ptr != NULL);\n}\n\nint valid(void *ptr) {\n  return (ptr != NULL);\n}\n\nSome platforms have platform-specific pointer validation tools.\n\nThe following code relies on the _etext address, defined by the loader as the first address following the program text on many platforms, including AIX, Linux, QNX, IRIX, and Solaris. It is not POSIX-compliant, nor is it available on Windows.\n\n_etext\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint valid(void *p) {\n  extern char _etext;\n  return (p != NULL) && ((char*) p > &_etext);\n}\n\nint global;\n\nint main(void) {\n  int local;\n\n  printf(\"pointer to local var valid? %d\\n\", valid(&local));\n  printf(\"pointer to static var valid? %d\\n\", valid(&global));\n  printf(\"pointer to function valid? %d\\n\", valid((void *)main));\n\n  int *p = (int *) malloc(sizeof(int));\n  printf(\"pointer to heap valid? %d\\n\", valid(p));\n  printf(\"pointer to end of allocated heap valid? %d\\n\", valid(++p));\n  free(--p);\n  printf(\"pointer to freed heap valid? %d\\n\", valid(p));\n  printf(\"null pointer valid? %d\\n\", valid(NULL));\n\n  return 0;\n}\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint valid(void *p) {\n  extern char _etext;\n  return (p != NULL) && ((char*) p > &_etext);\n}\n\nint global;\n\nint main(void) {\n  int local;\n\n  printf(\"pointer to local var valid? %d\\n\", valid(&local));\n  printf(\"pointer to static var valid? %d\\n\", valid(&global));\n  printf(\"pointer to function valid? %d\\n\", valid((void *)main));\n\n  int *p = (int *) malloc(sizeof(int));\n  printf(\"pointer to heap valid? %d\\n\", valid(p));\n  printf(\"pointer to end of allocated heap valid? %d\\n\", valid(++p));\n  free(--p);\n  printf(\"pointer to freed heap valid? %d\\n\", valid(p));\n  printf(\"null pointer valid? %d\\n\", valid(NULL));\n\n  return 0;\n}\n\nOn a Linux platform, this program produces the following output:\n\npointer to local var valid? 1\npointer to static var valid? 1\npointer to function valid? 0\npointer to heap valid? 1\npointer to end of allocated heap valid? 1\npointer to freed heap valid? 1\nnull pointer valid? 0\n\npointer to local var valid? 1\npointer to static var valid? 1\npointer to function valid? 0\npointer to heap valid? 1\npointer to end of allocated heap valid? 1\npointer to freed heap valid? 1\nnull pointer valid? 0\n\nThe valid() function does not guarantee validity; it only identifies null pointers and pointers to functions as invalid. However, it can be used to catch a substantial number of problems that might otherwise go undetected.\n\nvalid()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the incr() function increments the value referenced by its argument. It also ensures that its argument is not a null pointer. But the pointer could still be invalid, causing the function to corrupt memory or terminate abnormally.",
          "code": "void incr(int *intptr) {\n  if (intptr == NULL) {\n    /* Handle error */\n  }\n  (*intptr)++;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This incr() function can be improved by using the valid() function. The resulting implementation is less likely to dereference an invalid pointer or write to memory that is outside the bounds of a valid object.",
          "code": "void incr(int *intptr) {\n  if (!valid(intptr)) {\n    /* Handle error */\n  }\n  (*intptr)++;\n}\n",
          "explanation_after": "The valid() function can be implementation dependent and perform additional, platform-dependent checks when possible. In the worst case, the valid() function may only perform the same null-pointer check as the noncompliant code example. However, on platforms where additional pointer validation is possible, the use of a valid() function can provide checks."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "A pointer validation function can be used to detect and prevent operations from being performed on some invalid pointers.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM11-C",
    "title": "Do not assume infinite heap space",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM11-C.+Do+not+assume+infinite+heap+space",
    "description": "Memory is a limited resource and can be exhausted. Available memory is typically bounded by the sum of the amount of physical memory and the swap space allocated to the operating system by the administrator. For example, a system with 1GB of physical memory configured with 2GB of swap space may be able to allocate, at most, 3GB of heap space total to all running processes (minus the size of the operating system itself and the text and data segments of all running processes). Once all virtual memory has been allocated, requests for more memory will fail. As discussed in ERR33-C. Detect and handle standard library errors , programs that fail to check for and properly handle memory allocation failures will have undefined behavior and are likely to crash when heap space is exhausted. Heap exhaustion can result from\n\nA memory leak An infinite loop The program requiring more memory than is present by default in the heap Incorrect implementation of common data structures (for example, hash tables or vectors) Overall system memory being exhausted, possibly because of other processes The maximum size of a process's data segment being exceeded\n\nIf malloc() is unable to return the requested memory, it returns NULL instead.\n\nmalloc()\n\nNULL\n\nHowever, simply checking for and handling memory allocation failures may not be sufficient. Programs such as long-servers that manipulate large data sets need to be designed in a way that permits them to deliver their services when system resources, including the heap, are in short supply. Making use of additional storage devices, such as disk space or databases, is essential in such systems.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This example places no upper bound on the memory space required. As a result, the program can easily exhaust the heap. A heap error will be generated if the heap continues to be populated, even if there is no space available.",
          "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nenum {MAX_LENGTH=100};\n\ntypedef struct namelist_s {\n  char name[MAX_LENGTH];\n  struct namelist_s* next;\n} *namelist_t;\n\nint main() {\n  namelist_t names = NULL;\n  char new_name[MAX_LENGTH];\n\n  do {\n    /* \n     * Adding unknown number of records to a list;\n     * the user can enter as much data as he wants\n     * and exhaust the heap.\n     */\n    puts(\"To quit, enter \\\"quit\\\"\");\n    puts(\"Enter record:\");\n    fgets(new_name, MAX_LENGTH, stdin);\n    if (strcmp(new_name, \"quit\") != 0) {\n      /* \n       * Names continue to be added without bothering \n       * about the size on the heap.\n       */\n      unsigned int i = strlen(new_name) - 1;\n      if (new_name[i] == '\\n') new_name[i] = '\\0';\n      namelist_t new_entry = (namelist_t) malloc(sizeof( struct namelist_s));\n      if (new_entry == NULL) {\n        /* Handle error */\n      }\n      strcpy( new_entry->name, new_name);\n      new_entry->next = names;\n      names = new_entry;\n    }\n    puts(new_name);\n  } while (strcmp( new_name, \"quit\") != 0);\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "If the objects or data structures are large enough to potentially cause heap exhaustion, the programmer should consider using databases instead to ensure that records are written to the disk and that the data structure does not outgrow the heap.\n\nIn the previous noncompliant code example, the user can reuse a single long variable to store the input and write that value into a simple database containing a table User with a field userID along with any other required fields. This prevents the heap from being exhausted.",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "It is difficult to pinpoint violations of this recommendation because static analysis tools are currently unable to identify code that can lead to heap exhaustion. The heap size also varies for different runtime environments.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM12-C",
    "title": "Consider using a goto chain when leaving a function on error when using and releasing resources",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM12-C.+Consider+using+a+goto+chain+when+leaving+a+function+on+error+when+using+and+releasing+resources",
    "description": "Many functions require the allocation of multiple resources. Failing and returning somewhere in the middle of this function without freeing all of the allocated resources could produce a memory leak. It is a common error to forget to free one (or all) of the resources in this manner, so a goto chain is the simplest and cleanest way to organize exits while preserving the order of freed resources.\n\ngoto",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "In this noncompliant example, exit code is written for every instance in which the function can terminate prematurely. Notice how failing to close fin2 produces a resource leak, leaving an open file descriptor.\n\nPlease note that these examples assume errno_t and NOERR to be defined, as recommended in DCL09-C. Declare functions that return errno with a return type of errno_t . An equivalent compatible example would define errno_t as an int and NOERR as zero.\n\nThese examples also assume that errno is set if fopen() or malloc() fail. These are guaranteed by POSIX but not by C11. See ERR30-C. Take care when reading errno for more details.",
          "code": "typedef struct object {  /* Generic struct: contents don't matter */\n  int propertyA, propertyB, propertyC;\n} object_t;\n\nerrno_t do_something(void){\n  FILE *fin1, *fin2;\n  object_t *obj;\n  errno_t ret_val;\n  \n  fin1 = fopen(\"some_file\", \"r\");\n  if (fin1 == NULL) {\n    return errno;\n  }\n\n  fin2 = fopen(\"some_other_file\", \"r\");\n  if (fin2 == NULL) {\n    fclose(fin1);\n    return errno;\n  }\n\n  obj = malloc(sizeof(object_t));\n  if (obj == NULL) {\n    ret_val = errno;\n    fclose(fin1);\n    return ret_val;  /* Forgot to close fin2!! */\n  }\n\n  /* ... More code ... */\n\n  fclose(fin1);\n  fclose(fin2);\n  free(obj);\n  return NOERR;\n}\n",
          "explanation_after": "This is just a small example; in much larger examples, errors like this are even harder to detect."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX, Nested Ifs)",
          "pre_code_commentary": "This compliant solution uses nested if statements to properly close files and free memory in the case that any error occurs. When the number of resources to manage is small (3 in this example), nested if statements will be simpler than a goto chain.",
          "code": "/* ... Assume the same struct used previously ... */\n\nerrno_t do_something(void) {\n  FILE *fin1, *fin2;\n  object_t *obj;\n  errno_t ret_val = NOERR; /* Initially assume a successful return value */\n\n  if ((fin1 = fopen(\"some_file\", \"r\")) != NULL) {\n    if ((fin2 = fopen(\"some_other_file\", \"r\")) != NULL) {\n      if ((obj = malloc(sizeof(object_t))) != NULL) {\n\n        /* ... More code ... */\n\n        /* Clean-up & handle errors */\n        free(obj);\n      } else {\n        ret_val = errno;\n      }\n      fclose(fin2);\n    } else {\n      ret_val = errno;\n    }\n    fclose(fin1);\n  } else {\n    ret_val = errno;\n  }\n\n  return ret_val;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "In this noncompliant example, exit code is written for every instance in which the function can terminate prematurely. Notice how failing to close fin2 produces a resource leak, leaving an open file descriptor.\n\nPlease note that these examples assume errno_t and NOERR to be defined, as recommended in DCL09-C. Declare functions that return errno with a return type of errno_t . An equivalent compatible example would define errno_t as an int and NOERR as zero.\n\nThese examples also assume that errno is set if fopen() or malloc() fail. These are guaranteed by POSIX but not by C11. See ERR30-C. Take care when reading errno for more details.",
          "code": "typedef struct object {  /* Generic struct: contents don't matter */\n  int propertyA, propertyB, propertyC;\n} object_t;\n\nerrno_t do_something(void){\n  FILE *fin1, *fin2;\n  object_t *obj;\n  errno_t ret_val;\n  \n  fin1 = fopen(\"some_file\", \"r\");\n  if (fin1 == NULL) {\n    return errno;\n  }\n\n  fin2 = fopen(\"some_other_file\", \"r\");\n  if (fin2 == NULL) {\n    fclose(fin1);\n    return errno;\n  }\n\n  obj = malloc(sizeof(object_t));\n  if (obj == NULL) {\n    ret_val = errno;\n    fclose(fin1);\n    return ret_val;  /* Forgot to close fin2!! */\n  }\n\n  /* ... More code ... */\n\n  fclose(fin1);\n  fclose(fin2);\n  free(obj);\n  return NOERR;\n}\n",
          "explanation_after": "This is just a small example; in much larger examples, errors like this are even harder to detect."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX, Goto Chain)",
          "pre_code_commentary": "Occasionally, the number of resources to manage in one function will be too large to permit using nested ifs to manage them.\n\nIn this revised version, a goto chain replaces each individual return segment. If no error occurs, control flow falls through to the SUCCESS label, releases all of the resources, and returns NOERR . If an error occurs, the return value is set to errno , control flow jumps to the proper failure label, and the appropriate resources are released before returning.",
          "code": "/* ... Assume the same struct used previously ... */\n\nerrno_t do_something(void) {\n  FILE *fin1, *fin2;\n  object_t *obj;\n  errno_t ret_val = NOERR; /* Initially assume a successful return value */\n\n  fin1 = fopen(\"some_file\", \"r\");\n  if (fin1 == NULL) {\n    ret_val = errno;\n    goto FAIL_FIN1;\n  }\n\n  fin2 = fopen(\"some_other_file\", \"r\");\n  if (fin2 == NULL) {\n    ret_val = errno;\n    goto FAIL_FIN2;\n  }\n\n  obj = malloc(sizeof(object_t));\n  if (obj == NULL) {\n    ret_val = errno;\n    goto FAIL_OBJ;\n  }\n\n  /* ... More code ... */\n\nSUCCESS:     /* Clean up everything */\n  free(obj);\n\nFAIL_OBJ:   /* Otherwise, close only the resources we opened */\n  fclose(fin2);\n\nFAIL_FIN2:\n  fclose(fin1);\n\nFAIL_FIN1:\n  return ret_val;\n}\n",
          "explanation_after": "This method is beneficial because the code is cleaner, and the programmer does not need to rewrite similar code upon every function error.\n\nNote that this guideline does not advocate more general uses of goto, which is still considered harmful . The use of goto in these cases is specifically to transfer control within a single function body."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "In this noncompliant example, exit code is written for every instance in which the function can terminate prematurely. Notice how failing to close fin2 produces a resource leak, leaving an open file descriptor.\n\nPlease note that these examples assume errno_t and NOERR to be defined, as recommended in DCL09-C. Declare functions that return errno with a return type of errno_t . An equivalent compatible example would define errno_t as an int and NOERR as zero.\n\nThese examples also assume that errno is set if fopen() or malloc() fail. These are guaranteed by POSIX but not by C11. See ERR30-C. Take care when reading errno for more details.",
          "code": "typedef struct object {  /* Generic struct: contents don't matter */\n  int propertyA, propertyB, propertyC;\n} object_t;\n\nerrno_t do_something(void){\n  FILE *fin1, *fin2;\n  object_t *obj;\n  errno_t ret_val;\n  \n  fin1 = fopen(\"some_file\", \"r\");\n  if (fin1 == NULL) {\n    return errno;\n  }\n\n  fin2 = fopen(\"some_other_file\", \"r\");\n  if (fin2 == NULL) {\n    fclose(fin1);\n    return errno;\n  }\n\n  obj = malloc(sizeof(object_t));\n  if (obj == NULL) {\n    ret_val = errno;\n    fclose(fin1);\n    return ret_val;  /* Forgot to close fin2!! */\n  }\n\n  /* ... More code ... */\n\n  fclose(fin1);\n  fclose(fin2);\n  free(obj);\n  return NOERR;\n}\n",
          "explanation_after": "This is just a small example; in much larger examples, errors like this are even harder to detect."
        },
        "compliant": {
          "heading": "Compliant Solution ( copy_process() from Linux kernel)",
          "pre_code_commentary": "Some effective examples of goto chains are quite large. This compliant solution is an excerpt from the Linux kernel. This is the copy_process function from kernel/fork.c from version 2.6.29 of the kernel.\n\nThe function uses 17 goto labels (not all displayed here) to perform cleanup code should any internal function yield an error code. If no errors occur, the program returns a pointer to the new process p . If any error occurs, the program diverts control to a particular goto label, which performs cleanup for sections of the function that have currently been successfully executed but not for sections that have not yet been executed. Consequently, only resources that were successfully opened are actually closed.\n\nAll comments in this excerpt were added to indicate additional code in the kernel not displayed here.",
          "code": "static struct task_struct *copy_process(unsigned long clone_flags,\n\t\t\t\t\tunsigned long stack_start,\n\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\tunsigned long stack_size,\n\t\t\t\t\tint __user *child_tidptr,\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace)\n{\n  int retval;\n  struct task_struct *p;\n  int cgroup_callbacks_done = 0;\n\n  if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n    return ERR_PTR(-EINVAL);\n\n  /* ... */\n\n  retval = security_task_create(clone_flags);\n  if (retval)\n    goto fork_out;\n\n  retval = -ENOMEM;\n  p = dup_task_struct(current);\n  if (!p)\n    goto fork_out;\n\n  /* ... */\n\n  /* Copy all the process information */\n  if ((retval = copy_semundo(clone_flags, p)))\n    goto bad_fork_cleanup_audit;\n  if ((retval = copy_files(clone_flags, p)))\n    goto bad_fork_cleanup_semundo;\n  if ((retval = copy_fs(clone_flags, p)))\n    goto bad_fork_cleanup_files;\n  if ((retval = copy_sighand(clone_flags, p)))\n    goto bad_fork_cleanup_fs;\n  if ((retval = copy_signal(clone_flags, p)))\n    goto bad_fork_cleanup_sighand;\n  if ((retval = copy_mm(clone_flags, p)))\n    goto bad_fork_cleanup_signal;\n  if ((retval = copy_namespaces(clone_flags, p)))\n    goto bad_fork_cleanup_mm;\n  if ((retval = copy_io(clone_flags, p)))\n    goto bad_fork_cleanup_namespaces;\n  retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);\n  if (retval)\n    goto bad_fork_cleanup_io;\n\n  /* ... */\n\n  return p;\n\n  /* ... Cleanup code starts here ... */\n\nbad_fork_cleanup_io:\n  put_io_context(p->io_context);\nbad_fork_cleanup_namespaces:\n  exit_task_namespaces(p);\nbad_fork_cleanup_mm:\n  if (p->mm)\n    mmput(p->mm);\nbad_fork_cleanup_signal:\n  cleanup_signal(p);\nbad_fork_cleanup_sighand:\n  __cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n  exit_fs(p); /* Blocking */\nbad_fork_cleanup_files:\n  exit_files(p); /* Blocking */\nbad_fork_cleanup_semundo:\n  exit_sem(p);\nbad_fork_cleanup_audit:\n  audit_free(p);\n\n  /* ... More cleanup code ... */\n\nfork_out:\n  return ERR_PTR(retval);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to free allocated memory or close opened files results in a memory leak and possibly unexpected results.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM30-C",
    "title": "Do not access freed memory",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory",
    "description": "Evaluating a pointer—including dereferencing the pointer, using it as an operand of an arithmetic operation, type casting it, and using it as the right-hand side of an assignment—into memory that has been deallocated by a memory management function is undefined behavior 183 . Pointers to memory that has been deallocated are called dangling pointers . Accessing a dangling pointer can result in exploitable vulnerabilities .\n\nAccording to the C Standard, using the value of a pointer that refers to space deallocated by a call to the free() or realloc() function is undefined behavior. (See undefined behavior 183 .)\n\nfree()\n\nrealloc()\n\nReading a pointer to deallocated memory is undefined behavior 183 because the pointer value is indeterminate and might be a trap representation . Fetching a trap representation might perform a hardware trap (but is not required to).\n\nIt is at the memory manager's discretion when to reallocate or recycle the freed memory. When memory is freed, all pointers into it become invalid, and its contents might either be returned to the operating system, making the freed space inaccessible, or remain intact and accessible. As a result, the data at the freed location can appear to be valid but change unexpectedly. Consequently, memory must not be written to or read from once it is freed.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This example from Brian Kernighan and Dennis Ritchie [ Kernighan 1988 ] shows both the incorrect and correct techniques for freeing the memory associated with a linked list. In their (intentionally) incorrect example, p is freed before p->next is executed, so that p->next reads memory that has already been freed.",
          "code": "#include <stdlib.h>\n \nstruct node {\n  int value;\n  struct node *next;\n};\n \nvoid free_list(struct node *head) {\n  for (struct node *p = head; p != NULL; p = p->next) {\n    free(p);\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Kernighan and Ritchie correct this error by storing a reference to p->next in q before freeing p :",
          "code": "#include <stdlib.h>\n \nstruct node {\n  int value;\n  struct node *next;\n};\n \nvoid free_list(struct node *head) {\n  struct node *q;\n  for (struct node *p = head; p != NULL; p = q) {\n    q = p->next;\n    free(p);\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, buf is written to after it has been freed. Write-after-free vulnerabilities can be exploited to run arbitrary code with the permissions of the vulnerable process. Typically, allocations and frees are far removed, making it difficult to recognize and diagnose these problems.",
          "code": "#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n  char *return_val = 0;\n  const size_t bufsize = strlen(argv[0]) + 1;\n  char *buf = (char *)malloc(bufsize);\n  if (!buf) {\n    return EXIT_FAILURE;\n  }\n  /* ... */\n  free(buf);\n  /* ... */\n  strcpy(buf, argv[0]);\n  /* ... */\n  return EXIT_SUCCESS;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the memory is freed after its final use:",
          "code": "#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n  char *return_val = 0;\n  const size_t bufsize = strlen(argv[0]) + 1;\n  char *buf = (char *)malloc(bufsize);\n  if (!buf) {\n    return EXIT_FAILURE;\n  }\n  /* ... */\n  strcpy(buf, argv[0]);\n  /* ... */\n  free(buf);\n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, realloc() may free c_str1 when it returns a null pointer, resulting in c_str1 being freed twice.  The C Standards Committee's proposed response to Defect Report #400 makes it implementation-defined whether or not the old object is deallocated when size is zero and memory for the new object is not allocated. The current implementation of realloc() in the GNU C Library and Microsoft Visual Studio's Runtime Library will free c_str1 and return a null pointer for zero byte allocations.  Freeing a pointer twice can result in a potentially exploitable vulnerability commonly referred to as a double-free vulnerability [ Seacord 2013b ].",
          "code": "#include <stdlib.h>\n \nvoid f(char *c_str1, size_t size) {\n  char *c_str2 = (char *)realloc(c_str1, size);\n  if (c_str2 == NULL) {\n    free(c_str1);\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not pass a size argument of zero to the realloc() function, eliminating the possibility of c_str1 being freed twice:",
          "code": "#include <stdlib.h>\n \nvoid f(char *c_str1, size_t size) {\n  if (size != 0) {\n    char *c_str2 = (char *)realloc(c_str1, size); \n    if (c_str2 == NULL) {\n      free(c_str1); \n    }\n  }\n  else {\n    free(c_str1);\n  }\n \n}",
          "explanation_after": "If the intent of calling f() is to reduce the size of the object, then doing nothing when the size is zero would be unexpected; instead, this compliant solution frees the object."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example ( CVE-2009-1364 ) from libwmf version 0.2.8.4, the return value of gdRealloc (a simple wrapper around realloc() that reallocates space pointed to by im->clip->list ) is set to more . However, the value of im->clip->list is used directly afterwards in the code, and the C Standard specifies that if realloc() moves the area pointed to, then the original block is freed. An attacker can then execute arbitrary code by forcing a reallocation (with a sufficient im->clip->count ) and accessing freed memory [ xorl 2009 ].",
          "code": "void gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) {\n  gdClipRectanglePtr more;\n  if (im->clip == 0) {\n   /* ... */\n  }\n  if (im->clip->count == im->clip->max) {\n    more = gdRealloc (im->clip->list,(im->clip->max + 8) *\n                      sizeof (gdClipRectangle));\n    /*\n     * If the realloc fails, then we have not lost the\n     * im->clip->list value.\n     */\n    if (more == 0) return; \n    im->clip->max += 8;\n  }\n  im->clip->list[im->clip->count] = *rect;\n  im->clip->count++;\n\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution simply reassigns im->clip->list to the value of more after the call to realloc() :",
          "code": "void gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) {\n  gdClipRectanglePtr more;\n  if (im->clip == 0) {\n    /* ... */\n  }\n  if (im->clip->count == im->clip->max) {\n    more = gdRealloc (im->clip->list,(im->clip->max + 8) *\n                      sizeof (gdClipRectangle));\n    if (more == 0) return;\n    im->clip->max += 8;\n    im->clip->list = more;\n  }\n  im->clip->list[im->clip->count] = *rect;\n  im->clip->count++;\n\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Reading memory that has already been freed can lead to abnormal program termination and denial-of-service attacks. Writing memory that has already been freed can additionally lead to the execution of arbitrary code with the permissions of the vulnerable process.\n\nFreeing memory multiple times has similar consequences to accessing memory after it is freed. Reading a pointer to deallocated memory is undefined behavior 183 because the pointer value is indeterminate and might be a trap representation . When reading from or writing to freed memory does not cause a trap, it may corrupt the underlying data structures that manage the heap in a manner that can be exploited to execute arbitrary code. Alternatively, writing to memory after it has been freed might modify memory that has been reallocated.\n\nProgrammers should be wary when freeing memory in a loop or conditional statement; if coded incorrectly, these constructs can lead to double-free vulnerabilities. It is also a common error to misuse the realloc() function in a manner that results in double-free vulnerabilities. (See MEM04-C. Beware of zero-length allocations .)",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MEM31-C",
    "title": "Free dynamically allocated memory when no longer needed",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM31-C.+Free+dynamically+allocated+memory+when+no+longer+needed",
    "description": "Before the lifetime of the last pointer that stores the return value of a call to a standard memory allocation function has ended, it must be matched by a call to free() with that pointer value.\n\nfree()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, the object allocated by the call to malloc() is not freed before the end of the lifetime of the last pointer text_buffer referring to the object:",
          "code": "#include <stdlib.h>\n \nenum { BUFFER_SIZE = 32 };\n\nint f(void) {\n  char *text_buffer = (char *)malloc(BUFFER_SIZE); \n  if (text_buffer == NULL) {\n    return -1;\n  }\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the pointer is deallocated with a call to free() :",
          "code": "#include <stdlib.h>\n\nenum { BUFFER_SIZE = 32 };\n\nint f(void) {\n  char *text_buffer = (char *)malloc(BUFFER_SIZE); \n  if (text_buffer == NULL) {\n    return -1;\n  }\n \n  free(text_buffer);\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to free memory can result in the exhaustion of system memory resources, which can lead to a denial-of-service attack .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM33-C",
    "title": "Allocate and copy structures containing a flexible array member dynamically",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM33-C.++Allocate+and+copy+structures+containing+a+flexible+array+member+dynamically",
    "description": "The C Standard, 6.7.3.2, paragraph 20 [ ISO/IEC 9899:2024 ], says\n\nAs a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member . In most situations, the ﬂexible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply.\n\nThe following is an example of a structure that contains a flexible array member:\n\nstruct flex_array_struct {\n  int num;\n  int data[];\n};\n\nstruct flex_array_struct {\n  int num;\n  int data[];\n};\n\nThis definition means that when computing the size of such a structure, only the first member, num , is considered. Unless the appropriate size of the flexible array member has been explicitly added when allocating storage for an object of the struct , the result of accessing the member data of a variable of nonpointer type struct flex_array_struct is undefined . DCL38-C. Use the correct syntax when declaring a flexible array member describes the correct way to declare a struct with a flexible array member.\n\nnum\n\nstruct\n\ndata\n\nstruct flex_array_struct\n\nstruct\n\nTo avoid the potential for undefined behavior 59 , structures that contain a flexible array member should always be allocated dynamically. Flexible array structures must\n\nHave dynamic storage duration (be allocated via malloc() or another dynamic allocation function) Be dynamically copied using memcpy() or a similar function and not by assignment When used as an argument to a function, be passed by pointer and not copied by value\n\nmalloc()\n\nmemcpy()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Storage Duration)",
          "pre_code_commentary": "This noncompliant code example uses automatic storage for a structure containing a flexible array member:",
          "code": "#include <stddef.h>\n \nstruct flex_array_struct {\n  size_t num;\n  int data[];\n};\n \nvoid func(void) {\n  struct flex_array_struct flex_struct;\n  size_t array_size = 4;\n\n  /* Initialize structure */\n  flex_struct.num = array_size;\n\n  for (size_t i = 0; i < array_size; ++i) {\n    flex_struct.data[i] = 0;\n  }\n}",
          "explanation_after": "Because the memory for flex_struct is reserved on the stack, no space is reserved for the data member. Accessing the data member is undefined behavior 59 ."
        },
        "compliant": {
          "heading": "Compliant Solution (Storage Duration)",
          "pre_code_commentary": "This compliant solution dynamically allocates storage for flex_array_struct :",
          "code": "#include <stdlib.h>\n \nstruct flex_array_struct {\n  size_t num;\n  int data[];\n};\n \nvoid func(void) {\n  struct flex_array_struct *flex_struct;\n  size_t array_size = 4;\n\n  /* Dynamically allocate memory for the struct */\n  flex_struct = (struct flex_array_struct *)malloc(\n    sizeof(struct flex_array_struct)\n    + sizeof(int) * array_size);\n  if (flex_struct == NULL) {\n    /* Handle error */\n  }\n\n  /* Initialize structure */\n  flex_struct->num = array_size;\n\n  for (size_t i = 0; i < array_size; ++i) {\n    flex_struct->data[i] = 0;\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Copying)",
          "pre_code_commentary": "This noncompliant code example attempts to copy an instance of a structure containing a flexible array member ( struct flex_array_struct ) by assignment:",
          "code": "#include <stddef.h>\n \nstruct flex_array_struct {\n  size_t num;\n  int data[];\n};\n \nvoid func(struct flex_array_struct *struct_a,\n          struct flex_array_struct *struct_b) {\n  *struct_b = *struct_a;\n}",
          "explanation_after": "When the structure is copied, the size of the flexible array member is not considered, and only the first member of the structure, num , is copied, leaving the array contents untouched."
        },
        "compliant": {
          "heading": "Compliant Solution (Copying)",
          "pre_code_commentary": "This compliant solution uses memcpy() to properly copy the content of struct_a into struct_b :",
          "code": "#include <string.h>\n \nstruct flex_array_struct {\n  size_t num;\n  int data[];\n};\n \nvoid func(struct flex_array_struct *struct_a,\n          struct flex_array_struct *struct_b) {\n  if (struct_a->num > struct_b->num) {\n    /* Insufficient space; handle error */\n    return;\n  }\n  memcpy(struct_b, struct_a,\n         sizeof(struct flex_array_struct) + (sizeof(int)\n           * struct_a->num));\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Function Arguments)",
          "pre_code_commentary": "In this noncompliant code example, the flexible array structure is passed by value to a function that prints the array elements:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nstruct flex_array_struct {\n  size_t num;\n  int data[];\n};\n \nvoid print_array(struct flex_array_struct struct_p) {\n  puts(\"Array is: \");\n  for (size_t i = 0; i < struct_p.num; ++i) {\n    printf(\"%d \", struct_p.data[i]);\n  }\n  putchar('\\n');\n}\n\nvoid func(void) {\n  struct flex_array_struct *struct_p;\n  size_t array_size = 4;\n\n  /* Space is allocated for the struct */\n  struct_p = (struct flex_array_struct *)malloc(\n    sizeof(struct flex_array_struct)\n    + sizeof(int) * array_size);\n  if (struct_p == NULL) {\n    /* Handle error */\n  }\n  struct_p->num = array_size;\n\n  for (size_t i = 0; i < array_size; ++i) {\n    struct_p->data[i] = i;\n  }\n  print_array(*struct_p);\n}",
          "explanation_after": "Because the argument is passed by value, the size of the flexible array member is not considered when the structure is copied, and only the first member of the structure, num , is copied."
        },
        "compliant": {
          "heading": "Compliant Solution (Function Arguments)",
          "pre_code_commentary": "In this compliant solution, the structure is passed by reference and not by value:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nstruct flex_array_struct {\n  size_t num;\n  int data[];\n};\n \nvoid print_array(struct flex_array_struct *struct_p) {\n  puts(\"Array is: \");\n  for (size_t i = 0; i < struct_p->num; ++i) {\n    printf(\"%d \", struct_p->data[i]);\n  }\n  putchar('\\n');\n}\n\nvoid func(void) {\n  struct flex_array_struct *struct_p;\n  size_t array_size = 4;\n\n  /* Space is allocated for the struct and initialized... */\n\n  print_array(struct_p);\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to use structures with flexible array members correctly can result in undefined behavior 59 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM34-C",
    "title": "Only free memory allocated dynamically",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM34-C.+Only+free+memory+allocated+dynamically",
    "description": "The C Standard, Annex J (184) [ ISO/IEC 9899:2024 ], states that the behavior of a program is undefined when\n\nThe pointer argument to the free or realloc function does not match a pointer earlier returned by a memory management function, or the space has been deallocated by a call to free or realloc .\n\nfree\n\nrealloc\n\nfree\n\nrealloc\n\nSee also undefined behavior 184 .\n\nFreeing memory that is not allocated dynamically can result in heap corruption and other serious errors. Do not call free() on a pointer other than one returned by a standard memory allocation function, such as malloc() , calloc() , realloc() , or aligned_alloc() .\n\nfree()\n\nmalloc()\n\ncalloc()\n\nrealloc()\n\naligned_alloc()\n\nA similar situation arises when realloc() is supplied a pointer to non-dynamically allocated memory. The realloc() function is used to resize a block of dynamic memory. If realloc() is supplied a pointer to memory not allocated by a standard memory allocation function, the behavior is undefined . One consequence is that the program may terminate abnormally .\n\nrealloc()\n\nrealloc()\n\nrealloc()\n\nThis rule does not apply to null pointers. The C Standard guarantees that if free() is passed a null pointer, no action occurs.\n\nfree()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example sets c_str to reference either dynamically allocated memory or a statically allocated string literal depending on the value of argc . In either case, c_str is passed as an argument to free() . If anything other than dynamically allocated memory is referenced by c_str , the call to free(c_str) is erroneous.",
          "code": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n \nenum { MAX_ALLOCATION = 1000 };\n\nint main(int argc, const char *argv[]) {\n  char *c_str = NULL;\n  size_t len;\n\n  if (argc == 2) {\n    len = strlen(argv[1]) + 1;\n    if (len > MAX_ALLOCATION) {\n      /* Handle error */\n    }\n    c_str = (char *)malloc(len);\n    if (c_str == NULL) {\n      /* Handle error */\n    }\n    strcpy(c_str, argv[1]);\n  } else {\n    c_str = \"usage: $>a.exe [string]\";\n    printf(\"%s\\n\", c_str);\n  }\n  free(c_str);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution eliminates the possibility of c_str referencing memory that is not allocated dynamically when passed to free() :",
          "code": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n \nenum { MAX_ALLOCATION = 1000 };\n\nint main(int argc, const char *argv[]) {\n  char *c_str = NULL;\n  size_t len;\n\n  if (argc == 2) {\n    len = strlen(argv[1]) + 1;\n    if (len > MAX_ALLOCATION) {\n      /* Handle error */\n    }\n    c_str = (char *)malloc(len);\n    if (c_str == NULL) {\n      /* Handle error */\n    }\n    strcpy(c_str, argv[1]);\n  } else {\n    printf(\"%s\\n\", \"usage: $>a.exe [string]\");\n    return EXIT_FAILURE;\n  }\n  free(c_str);\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( realloc() )",
          "pre_code_commentary": "In this noncompliant example, the pointer parameter to realloc() , buf , does not refer to dynamically allocated memory:",
          "code": "#include <stdlib.h>\n \nenum { BUFSIZE = 256 };\n \nvoid f(void) {\n  char buf[BUFSIZE];\n  char *p = (char *)realloc(buf, 2 * BUFSIZE);\n  if (p == NULL) {\n    /* Handle error */\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( realloc() )",
          "pre_code_commentary": "In this compliant solution, buf refers to dynamically allocated memory:",
          "code": "#include <stdlib.h>\n \nenum { BUFSIZE = 256 };\n \nvoid f(void) {\n  char *buf = (char *)malloc(BUFSIZE * sizeof(char));\n  char *p = (char *)realloc(buf, 2 * BUFSIZE);\n  if (p == NULL) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "Note that realloc() will behave properly even if malloc() failed, because when given a null pointer, realloc() behaves like a call to malloc() ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The consequences of this error depend on the implementation , but they range from nothing to arbitrary code execution if that memory is reused by malloc() .",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MEM35-C",
    "title": "Allocate sufficient memory for an object",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MEM35-C.+Allocate+sufficient+memory+for+an+object",
    "description": "The types of integer expressions used as size arguments to malloc() , calloc() , realloc() , or aligned_alloc() must have sufficient range to represent the size of the objects to be stored. If size arguments are incorrect or can be manipulated by an attacker, then a buffer overflow may occur. Incorrect size arguments, inadequate range checking, integer overflow, or truncation can result in the allocation of an inadequately sized buffer.\n\nmalloc()\n\ncalloc()\n\nrealloc()\n\naligned_alloc()\n\nTypically, the amount of memory to allocate will be the size of the type of object to allocate. When allocating space for an array, the size of the object will be multiplied by the bounds of the array. When allocating space for a structure containing a flexible array member, the size of the array member must be added to the size of the structure. (See MEM33-C. Allocate and copy structures containing a flexible array member dynamically .) Use the correct type of the object when computing the size of memory to allocate.\n\nSTR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator is a specific instance of this rule.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Pointer)",
          "pre_code_commentary": "In this noncompliant code example, inadequate space is allocated for a struct tm object because the size of the pointer is being used to determine the size of the pointed-to object:",
          "code": "#include <stdlib.h>\n#include <time.h>\n \nstruct tm *make_tm(int year, int mon, int day, int hour,\n                   int min, int sec) {\n  struct tm *tmb;\n  tmb = (struct tm *)malloc(sizeof(tmb));\n  if (tmb == NULL) {\n    return NULL;\n  }\n  *tmb = (struct tm) {\n    .tm_sec = sec, .tm_min = min, .tm_hour = hour,\n    .tm_mday = day, .tm_mon = mon, .tm_year = year\n  };\n  return tmb;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Pointer)",
          "pre_code_commentary": "In this compliant solution, the correct amount of memory is allocated for the struct tm object. When allocating  space for a single object, passing the (dereferenced) pointer type to the sizeof operator is a simple way to allocate sufficient memory. Because the sizeof operator does not evaluate its operand, dereferencing an uninitialized or null pointer in this context is well-defined behavior.",
          "code": "#include <stdlib.h>\n#include <time.h>\n \nstruct tm *make_tm(int year, int mon, int day, int hour,\n                   int min, int sec) {\n  struct tm *tmb;\n  tmb = (struct tm *)malloc(sizeof(*tmb));\n  if (tmb == NULL) {\n    return NULL;\n  }\n  *tmb = (struct tm) {\n    .tm_sec = sec, .tm_min = min, .tm_hour = hour,\n    .tm_mday = day, .tm_mon = mon, .tm_year = year\n  };\n  return tmb;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Integer)",
          "pre_code_commentary": "In this noncompliant code example, an array of long is allocated and assigned to p . The code attempts to check for unsigned integer overflow in compliance with INT30-C. Ensure that unsigned integer operations do not wrap and also ensures that len is not equal to zero. (See MEM04-C. Beware of zero-length allocations .) However, because sizeof(int) is used to compute the size, and not sizeof(long) , an insufficient amount of memory can be allocated on implementations where sizeof(long) is larger than sizeof(int) , and filling the array can cause a heap buffer overflow.",
          "code": "#include <stdint.h>\n#include <stdlib.h>\n \nvoid function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(long)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(int));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Integer)",
          "pre_code_commentary": "This compliant solution uses sizeof(long) to correctly size the memory allocation:",
          "code": "#include <stdint.h>\n#include <stdlib.h>\n\nvoid function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(long)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(long));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Integer)",
          "pre_code_commentary": "In this noncompliant code example, an array of long is allocated and assigned to p . The code attempts to check for unsigned integer overflow in compliance with INT30-C. Ensure that unsigned integer operations do not wrap and also ensures that len is not equal to zero. (See MEM04-C. Beware of zero-length allocations .) However, because sizeof(int) is used to compute the size, and not sizeof(long) , an insufficient amount of memory can be allocated on implementations where sizeof(long) is larger than sizeof(int) , and filling the array can cause a heap buffer overflow.",
          "code": "#include <stdint.h>\n#include <stdlib.h>\n \nvoid function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(long)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(int));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Integer)",
          "pre_code_commentary": "Alternatively, sizeof(*p) can be used to properly size the allocation:",
          "code": "#include <stdint.h>\n#include <stdlib.h>\n \nvoid function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(*p)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(*p));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Providing invalid size arguments to memory allocation functions can lead to buffer overflows and the execution of arbitrary code with the permissions of the vulnerable process.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MSC00-C",
    "title": "Compile cleanly at high warning levels",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC00-C.+Compile+cleanly+at+high+warning+levels",
    "description": "Compile code using the highest warning level available for your compiler and eliminate warnings by modifying the code.\n\nAccording to the C Standard, subclause 5.1.1.3 [ ISO/IEC 9899:2011 ],\n\nA conforming implementation shall produce at least one diagnostic message (identified in an implementation-defined manner) if a preprocessing translation unit or translation unit contains a violation of any syntax rule or constraint, even if the behavior is also explicitly specified as undefined or implementation-defined. Diagnostic messages need not be produced in other circumstances.\n\nAssuming a conforming implementation , eliminating diagnostic messages will eliminate any syntactic or constraint violations.\n\nIf suitable source-code-checking tools are available, use them regularly.\n\nCompilers can produce diagnostic messages for correct code, as is permitted by C. It is usually preferable to rewrite code to eliminate compiler warnings, but if the code is correct, it is sufficient to provide a comment explaining why the warning message does not apply. Some compilers provide ways to suppress warnings, such as suitably formatted comments or pragmas, which can be used sparingly when the programmer understands the implications of the warning but has good reason to use the flagged construct anyway.\n\nDo not simply quiet warnings by adding type casts or other means. Instead, understand the reason for the warning and consider a better approach, such as using matching types and avoiding type casts whenever possible.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "Using the default warning specifier with #pragma warning resets the behavior of a warning to its default value, which may not be the same as its previous behavior.  Programmers commonly, but incorrectly, use the default warning specifier to restore previous warning messages after a message is temporarily disabled.",
          "code": "#pragma warning(disable:4705) \n#pragma warning(disable:4706) \n#pragma warning(disable:4707) \n/* Unnecessarily flagged code */\n#pragma warning(default:4705) \n#pragma warning(default:4706) \n#pragma warning(default:4707) \n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "Instead of using the default warning specifier, the current state of the warnings should be saved and then restored after the unnecessarily flagged code.",
          "code": "#pragma warning(push) \n#pragma warning(disable:4705) \n#pragma warning(disable:4706) \n#pragma warning(disable:4707) \n/* Unnecessarily flagged code */\n#pragma warning(pop) ",
          "explanation_after": "The pragma warning(push) stores the current warning state for every warning. The pragma warning(pop) pops the last warning state pushed onto the stack. Any changes made to the warning state between the push and pop are undone."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Eliminating violations of syntax rules and other constraints can eliminate serious software vulnerabilities that can lead to the execution of arbitrary code with the permissions of the vulnerable process.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC01-C",
    "title": "Strive for logical completeness",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC01-C.+Strive+for+logical+completeness",
    "description": "Software vulnerabilities can result when a programmer fails to consider all possible data states.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( if Chain)",
          "pre_code_commentary": "This noncompliant code example fails to test for conditions where a is neither b nor c . This behavior may be correct in this case, but failure to account for all the values of a can result in logic errors if a unexpectedly assumes a different value.",
          "code": "if (a == b) {\n  /* ... */\n}\nelse if (a == c) {\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( if Chain)",
          "pre_code_commentary": "This compliant solution explicitly checks for the unexpected condition and handles it appropriately:",
          "code": "if (a == b) {\n  /* ... */\n}\nelse if (a == c) {\n  /* ... */\n}\nelse {\n  /* Handle error condition */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( switch )",
          "pre_code_commentary": "This noncompliant code example fails to consider all possible cases. Failure to account for all valid values of type Color will result in a logic error. Because valid values of an enumerated type include all those of its underlying integer type, unless enumeration constants have been provided for all those values, the default label is appropriate and necessary.",
          "code": "typedef enum { Red, Green, Blue } Color;\nconst char* f(Color c) {\n  switch (c) {\n    case Red: return \"Red\";\n    case Green: return \"Green\";\n    case Blue: return \"Blue\";\n  }\n}\n\nvoid g() {\n  Color unknown = (Color)123;\n  puts(f(unknown));\n}\n",
          "explanation_after": "Microsoft Visual C++ .NET with /W4 does not warn when assigning an integer value to an enum type or when the switch statement does not contain all possible values of the enumeration."
        },
        "compliant": {
          "heading": "Compliant Solution ( switch )",
          "pre_code_commentary": "This compliant solution takes care to provide the default label to handle all valid values of type Color :",
          "code": "typedef enum { Red, Green, Blue } Color;\nconst char* f(Color c) {\n  switch (c) {\n    case Red: return \"Red\";\n    case Green: return \"Green\";\n    case Blue: return \"Blue\";\n    default: return \"Unknown color\";   /* Necessary */\n  }\n}\n",
          "explanation_after": "Note that adding a default case to a switch statement, even when all possible switch labels are specified, is an exception ( MSC07-C-EX1 ) to MSC07-C. Detect and remove dead code .\n\nAn alternative compliant solution to the noncompliant code example is to provide a return statement after the switch statement. Note, however, that this solution may not be appropriate in all situations.\n\nThis practice has been a subject of debate for some time, but a clear direction has emerged.\n\nOriginally, the consensus among those writing best practices was simply that each switch statement should have a default label. Eventually, emerging compilers and static analysis tools could verify that a switch on an enum type contained a case label for each enumeration value, but only if no default label existed. This led to a shift toward purposely leaving out the default label to allow static analysis. However, the resulting code was then vulnerable to enum variables being assigned int values outside the set of enum values.\n\nThese two practices have now been merged. A switch on an enum type should now contain a case label for each enum value but should also contain a default label for safety. This practice does not add difficulty to static analysis .\n\nExisting implementations are in transition, with some not yet analyzing switch statements with default labels. Developers must take extra care to check their own switch statements until the new practice becomes universal."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Zune 30)",
          "pre_code_commentary": "This noncompliant code example shows incomplete logic when converting dates. The code appeared in the Zune 30 media player, causing many players to lock up on December 30, 2008, at midnight PST. This noncompliant code example comes from the ConvertDays function in the real-time clock (RTC) routines for the MC13783 PMIC RTC. It takes the number of days since January 1, 1980, and computes the correct year and number of days since January 1 of the correct year.\n\nThe flaw in the code occurs when days has the value 366 because the loop never terminates. This bug manifested itself on the 366th day of 2008, which was the first leap year in which this code was active.",
          "code": "#define ORIGINYEAR 1980\nUINT32 days = /* Number of days since January 1, 1980 */\nint year = ORIGINYEAR;\n/* ... */\n\nwhile (days > 365) {\n  if (IsLeapYear(year)) {\n    if (days > 366) {\n      days -= 366;\n      year += 1;\n    }\n  }\n  else {\n    days -= 365;\n    year += 1;\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Zune 30)",
          "pre_code_commentary": "The following proposed rewrite is provided at http://winjade.net/2009/01/lesson-on-infinite-loops . The loop is guaranteed to exit, because days decreases for each iteration of the loop, unless the while condition fails and the loop terminates.",
          "code": "#define ORIGINYEAR 1980\nUINT32 days = /* Input parameter */\nint year = ORIGINYEAR;\n/* ... */\n\nint daysThisYear = (IsLeapYear(year) ? 366 : 365);\nwhile (days > daysThisYear) {\n  days -= daysThisYear;\n  year += 1;\n  daysThisYear = (IsLeapYear(year) ? 366 : 365);\n}\n",
          "explanation_after": "This compliant solution is for illustrative purposes and is not necessarily the solution implemented by Microsoft."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to account for all possibilities within a logic statement can lead to a corrupted running state, potentially resulting in unintentional information disclosure or abnormal termination .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC04-C",
    "title": "Use comments consistently and in a readable fashion",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC04-C.+Use+comments+consistently+and+in+a+readable+fashion",
    "description": null,
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Do not use the character sequence /* within a comment:",
          "code": "/* Comment with end comment marker unintentionally omitted\nsecurity_critical_function();\n/* Some other comment */\n",
          "explanation_after": "In this example, the call to the security-critical function is not executed. A reviewer examining this page could incorrectly assume that the code is executed.\n\nIf execution failure is the result of an accidental omission, it is useful to use an editor that provides syntax highlighting or formats the code to help identify issues like missing end-comment delimiters.\n\nBecause missing end delimiters are error prone and often viewed as a mistake, this approach is not recommended for commenting out code."
        },
        "compliant": {
          "heading": "Compliant Solution (Preprocessor)",
          "pre_code_commentary": "Instead of using /* and */ to comment out blocks of code, use conditional compilation (for example, #if , #ifdef , or #ifndef ):",
          "code": "#if 0  /*\n        * Use of critical security function no\n        * longer necessary.\n        */\nsecurity_critical_function();\n/* Some other comment */\n#endif\n",
          "explanation_after": "The text inside a block of code commented out using #if , #ifdef , or #ifndef must still consist of valid preprocessing tokens . This means that the characters \" and ' must each be paired just as in real C code, and the pairs must not cross line boundaries. In particular, an apostrophe within a contracted word looks like the beginning of a character constant. Consequently, natural-language comments and pseudocode should always be written between the comment delimiters /* and */ or following // ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Do not use the character sequence /* within a comment:",
          "code": "/* Comment with end comment marker unintentionally omitted\nsecurity_critical_function();\n/* Some other comment */\n",
          "explanation_after": "In this example, the call to the security-critical function is not executed. A reviewer examining this page could incorrectly assume that the code is executed.\n\nIf execution failure is the result of an accidental omission, it is useful to use an editor that provides syntax highlighting or formats the code to help identify issues like missing end-comment delimiters.\n\nBecause missing end delimiters are error prone and often viewed as a mistake, this approach is not recommended for commenting out code."
        },
        "compliant": {
          "heading": "Compliant Solution (Compiler)",
          "pre_code_commentary": "This compliant solution takes advantage of the compiler's ability to remove unreachable (dead) code. The code inside the if block must remain acceptable to the compiler. If other parts of the program, such as macros, types, or function prototypes, later change in a way that would cause syntax errors, the unexecuted code must be brought up to date to correct the problem. Then, if it is needed again in the future, the programmer need only remove the surrounding if statement and the NOTREACHED comment.\n\nThe NOTREACHED comment tells some compilers and static analysis tools not to complain about this unreachable code. It also serves as documentation.",
          "code": "if (0) {  /*\n           * Use of critical security function no\n           * longer necessary, for now.\n           */\n  /*NOTREACHED*/\n  security_critical_function();\n  /* Some other comment */\n}\n",
          "explanation_after": "This code is an instance of exception MSC07-C-EX2 to MSC07-C. Detect and remove dead code ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Following are some additional examples of comment styles that are confusing and should be avoided:",
          "code": "// */          /* Comment, not syntax error */\n\nf = g/**//h;   /* Equivalent to f = g / h; */\n\n//\\\ni();           /* Part of a two-line comment */\n\n/\\\n/ j();         /* Part of a two-line comment */\n\n\n/*//*/ l();    /* Equivalent to l(); */\n\nm = n//**/o\n+ p;           /* Equivalent to m = n + p; */\n\na = b //*divisor:*/c\n+d;            /*\n                * Interpreted as a = b/c + d; in c90\n                * compiler and a = b + d; in c99 compiler.\n                */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Use a consistent style of commenting:",
          "code": "/* Nice simple comment */\n\nint i; /* Counter */\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Confusion over which instructions are executed and which are not can lead to serious programming errors and vulnerabilities, including denial of service , abnormal program termination , and data integrity violation. This problem is mitigated by the use of interactive development environments (IDEs) and editors that use fonts, colors, or other mechanisms to differentiate between comments and code. However, the problem can still manifest, for example, when reviewing source code printed on a black-and-white printer.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC05-C",
    "title": "Do not manipulate time_t typed values directly",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC05-C.+Do+not+manipulate+time_t+typed+values+directly",
    "description": "The type time_t is specified as an \"arithmetic type capable of representing times.\" However, the way time is encoded within this arithmetic type by the function time() is unspecified . See unspecified behavior 48 in Annex J of the C Standard. Because the encoding is unspecified, there is no safe way to manually perform arithmetic on the type, and as a result, the values should not be modified directly.\n\ntime_t\n\ntime()\n\nNote that POSIX specifies that the time() function must return a value of type time_t , representing time in seconds since the Epoch. POSIX-conforming applications that are not intended to be portable to other environments therefore may safely perform arithmetic operations on time_t objects.\n\ntime()\n\ntime_t\n\ntime_t",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to execute do_work() multiple times until at least seconds_to_work has passed. However, because the encoding is not defined, there is no guarantee that adding start to seconds_to_work will result in adding seconds_to_work seconds.",
          "code": "int do_work(int seconds_to_work) {\n  time_t start = time(NULL);\n\n  if (start == (time_t)(-1)) {\n    /* Handle error */\n  }\n  while (time(NULL) < start + seconds_to_work) {\n    /* ... */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses difftime() to determine the difference between two time_t values. The difftime() function returns the number of seconds, from the second parameter until the first parameter and result, as a double .",
          "code": "int do_work(int seconds_to_work) {\n  time_t start = time(NULL);\n  time_t current = start;\n\n  if (start == (time_t)(-1)) {\n    /* Handle error */\n  }\n  while (difftime(current, start) < seconds_to_work) {\n    current = time(NULL);\n    if (current == (time_t)(-1)) {\n       /* Handle error */\n    }\n    /* ... */\n  }\n  return 0;\n}\n",
          "explanation_after": "Note that this loop still might not exit because the range of time_t might not be able to represent two times seconds_to_work apart."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using time_t incorrectly can lead to broken logic that can place a program in an infinite loop or cause an expected logic branch to not execute.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC06-C",
    "title": "Beware of compiler optimizations",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC06-C.+Beware+of+compiler+optimizations",
    "description": "Subclause 5.1.2.3 of the C Standard [ ISO/IEC 9899:2011 ] states:\n\nIn the abstract machine, all expressions are evaluated as specified by the semantics. An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object).\n\nThis clause gives compilers the leeway to remove code deemed unused or unneeded when building a program. Although this functionality is usually beneficial, sometimes the compiler removes code that it thinks is not needed but has been added for a specific (often security-related) purpose.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( memset() )",
          "pre_code_commentary": "An example of unexpected and unwanted compiler optimizations involves  overwriting the memory of a buffer that is used to store sensitive data. As a result, care must always be taken when dealing with sensitive data to ensure that operations on it always execute as intended. Some compiler optimization modes can remove code sections if the optimizer determines that doing so will not alter the behavior of the program. In this noncompliant code example, optimization may remove the call to memset() (which the programmer had hoped would clear sensitive memory) because the variable is not accessed following the write. Check compiler documentation for information about this compiler-specific behavior and which optimization levels can cause this behavior to occur.",
          "code": "void getPassword(void) {\n  char pwd[64];\n  if (GetPassword(pwd, sizeof(pwd))) {\n    /* Checking of password, secure operations, etc. */\n  }\n  memset(pwd, 0, sizeof(pwd));\n}\n",
          "explanation_after": "For all of the compliant solutions provided for this recommendation, it is strongly recommended that the programmer inspect the generated assembly code in the optimized release build to ensure that memory is actually cleared and none of the function calls are optimized out."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( Touching Memory )",
          "pre_code_commentary": "This noncompliant code example accesses the buffer again after the call to memset() . This technique prevents some compilers from optimizing out the call to memset() but does not work for all implementations . For example, the MIPSpro compiler and versions 3 and later of GCC cleverly nullify only the first byte and leave the rest intact. Check compiler documentation to guarantee this behavior for a specific platform.",
          "code": "void getPassword(void) {\n  char pwd[64];\n  if (retrievePassword(pwd, sizeof(pwd))) {\n    /* Checking of password, secure operations, etc. */\n  }\n  memset(pwd, 0, sizeof(pwd));\n  *(volatile char*)pwd= *(volatile char*)pwd;\n}\n",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "This noncompliant code example uses the ZeroMemory() function provided by many versions of the Microsoft Visual Studio compiler:",
          "code": "void getPassword(void) {\n  char pwd[64];\n  if (retrievePassword(pwd, sizeof(pwd))) {\n    /* Checking of password, secure operations, etc. */\n  }\n  ZeroMemory(pwd, sizeof(pwd));\n}\n",
          "explanation_after": "A call to ZeroMemory() may be optimized out in a similar manner to a call to memset() ."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "This compliant solution uses a SecureZeroMemory() function provided by many versions of the Microsoft Visual Studio compiler. The documentation for the SecureZeroMemory() function guarantees that the compiler does not optimize out this call when zeroing memory.",
          "code": "void getPassword(void) {\n  char pwd[64];\n  if (retrievePassword(pwd, sizeof(pwd))) {\n    /* Checking of password, secure operations, etc. */\n  }\n  SecureZeroMemory(pwd, sizeof(pwd));\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "This noncompliant code example uses the ZeroMemory() function provided by many versions of the Microsoft Visual Studio compiler:",
          "code": "void getPassword(void) {\n  char pwd[64];\n  if (retrievePassword(pwd, sizeof(pwd))) {\n    /* Checking of password, secure operations, etc. */\n  }\n  ZeroMemory(pwd, sizeof(pwd));\n}\n",
          "explanation_after": "A call to ZeroMemory() may be optimized out in a similar manner to a call to memset() ."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "The #pragma directives in this compliant solution instruct the compiler to avoid optimizing the enclosed code. This #pragma directive is supported on some versions of Microsoft Visual Studio and could be supported on other compilers. Check compiler documentation to ensure its availability and its optimization guarantees.",
          "code": "void getPassword(void) {\n  char pwd[64];\n  if (retrievePassword(pwd, sizeof(pwd))) {\n    /* Checking of password, secure operations, etc. */\n  }\n#pragma optimize(\"\", off)\n  memset(pwd, 0, sizeof(pwd));\n#pragma optimize(\"\", on)\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "This noncompliant code example uses the ZeroMemory() function provided by many versions of the Microsoft Visual Studio compiler:",
          "code": "void getPassword(void) {\n  char pwd[64];\n  if (retrievePassword(pwd, sizeof(pwd))) {\n    /* Checking of password, secure operations, etc. */\n  }\n  ZeroMemory(pwd, sizeof(pwd));\n}\n",
          "explanation_after": "A call to ZeroMemory() may be optimized out in a similar manner to a call to memset() ."
        },
        "compliant": {
          "heading": "Compliant Solution (C99)",
          "pre_code_commentary": "This compliant solution uses the volatile type qualifier to inform the compiler that the memory should be overwritten and that the call to the memset_s() function should not be optimized out. Unfortunately, this compliant solution may not be as efficient as possible because of the nature of the volatile type qualifier preventing the compiler from optimizing the code at all. Typically, some compilers are smart enough to replace calls to memset() with equivalent assembly instructions that are much more efficient than the memset() implementation. Implementing a memset_s() function as shown in the example may prevent the compiler from using the optimal assembly instructions and can result in less efficient code. Check compiler documentation and the assembly output from the compiler.",
          "code": "/* memset_s.c */\nerrno_t memset_s(void *v, rsize_t smax, int c, rsize_t n) {\n  if (v == NULL) return EINVAL;\n  if (smax > RSIZE_MAX) return EINVAL;\n  if (n > smax) return EINVAL;\n\n  volatile unsigned char *p = v;\n  while (smax-- && n--) {\n    *p++ = c;\n  }\n\n  return 0;\n}\n\n/* getPassword.c */\nextern errno_t memset_s(void *v, rsize_t smax, int c, rsize_t n);\n\nvoid getPassword(void) {\n  char pwd[64];\n\n  if (retrievePassword(pwd, sizeof(pwd))) {\n     /* Checking of password, secure operations, etc. */\n  }\n  if (memset_s(pwd, sizeof(pwd), 0, sizeof(pwd)) != 0) {\n    /* Handle error */\n  }\n}\n",
          "explanation_after": "However, note that both calling functions and accessing volatile -qualified objects can still be optimized out (while maintaining strict conformance to the standard), so this compliant solution still might not work in some cases.  The memset_s() function introduced in C11 is the preferred solution (see the following solution for more information).  If memset_s() function is not yet available on your implementation, this compliant solution is the best alternative, and can be discarded once supported by your implementation."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In rare cases, use of an empty infinite loop may be unavoidable. For example, an empty loop may be necessary on a platform that does not support sleep(3) or an equivalent function. Another example occurs in OS kernels. A task started before normal scheduler functionality is available may not have access to sleep(3) or an equivalent function. An empty infinite loop that does nothing within the loop body is a suboptimal solution because it consumes CPU cycles but performs no useful operations. An optimizing compiler can remove such a loop, which can lead to unexpected results. According to the C Standard, subclause 6.8.5, paragraph 6 [ ISO/IEC 9899:2011 ],\n\nAn iteration statement whose controlling expression is not a constant expression, that performs no input/output operations, does not access volatile objects, and performs no synchronization or atomic operations in its body, controlling expression, or (in the case of a for statement) its expression-3 , may be assumed by the implementation to terminate. 157 157) This is intended to allow compiler transformations, such as removal of empty loops, even when termination cannot be proven.\n\nThis noncompliant code example implements an idle task that continuously executes a loop without executing any instructions within the loop. An optimizing compiler could remove the while loop in the example.",
          "code": "static int always = 1;\nint main(void) {\n  while (always) { }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( while )",
          "pre_code_commentary": "To avoid the loop being optimized away, this compliant solution uses a constant expression (1) as the controlling expression in the while loop:",
          "code": "int main(void) {\n  while (1) { }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In rare cases, use of an empty infinite loop may be unavoidable. For example, an empty loop may be necessary on a platform that does not support sleep(3) or an equivalent function. Another example occurs in OS kernels. A task started before normal scheduler functionality is available may not have access to sleep(3) or an equivalent function. An empty infinite loop that does nothing within the loop body is a suboptimal solution because it consumes CPU cycles but performs no useful operations. An optimizing compiler can remove such a loop, which can lead to unexpected results. According to the C Standard, subclause 6.8.5, paragraph 6 [ ISO/IEC 9899:2011 ],\n\nAn iteration statement whose controlling expression is not a constant expression, that performs no input/output operations, does not access volatile objects, and performs no synchronization or atomic operations in its body, controlling expression, or (in the case of a for statement) its expression-3 , may be assumed by the implementation to terminate. 157 157) This is intended to allow compiler transformations, such as removal of empty loops, even when termination cannot be proven.\n\nThis noncompliant code example implements an idle task that continuously executes a loop without executing any instructions within the loop. An optimizing compiler could remove the while loop in the example.",
          "code": "static int always = 1;\nint main(void) {\n  while (always) { }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( for)",
          "pre_code_commentary": "According to the C Standard, subclause 6.8.5.3, paragraph 2, omitting the expression-2 from a for loop will replace that expression with a nonzero constant.",
          "code": "int main(void) {\n  for (;;) { }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "If the compiler optimizes out memory-clearing code, an attacker can gain access to sensitive data.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "MSC07-C",
    "title": "Detect and remove dead code",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC07-C.+Detect+and+remove+dead+code",
    "description": "Deprecated This rule has been deprecated.  It has been merged with: MSC12-C. Detect and remove code that has no effect or is never executed 10/07/2014 -- Version 2.0\n\nCode that is never executed is known as dead code . Typically, the presence of dead code indicates that a logic error has occurred as a result of changes to a program or the program's environment. Dead code is usually optimized out of a program during compilation. However, to improve readability and ensure that logic errors are resolved, dead code should be identified, understood, and eliminated.\n\nThis recommendation is related to MSC12-C. Detect and remove code that has no effect or is never executed .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example demonstrates how dead code can be introduced into a program [ Fortify 2006 ]. The second conditional statement, if (s) , will never evaluate true because it requires that s not be assigned NULL , and the only path where s can be assigned a non-null value ends with a return statement.",
          "code": "int func(int condition) {\n    char *s = NULL;\n    if (condition) {\n        s = (char *)malloc(10);\n        if (s == NULL) {\n           /* Handle Error */\n        }\n        /* Process s */\n        return 0;\n    }\n    /* ... */\n    if (s) {\n        /* This code is never reached */\n    }\n    return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Remediation of dead code requires the programmer to determine why the code is never executed and then to resolve the situation appropriately. To correct the preceding noncompliant code, the return is removed from the body of the first conditional statement.",
          "code": "int func(int condition) {\n    char *s = NULL;\n    if (condition) {\n        s = (char *)malloc(10);\n        if (s == NULL) {\n           /* Handle error */\n        }\n        /* Process s */\n    }\n    /* ... */\n    if (s) {\n        /* This code is now reachable */\n    }\n    return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this example, the strlen() function is used to limit the number of times the function s_loop() will iterate. The conditional statement inside the loop evaluates to true when the current character in the string is the null terminator. However, because strlen() returns the number of characters that precede the null terminator, the conditional statement never evaluates true.",
          "code": "int s_loop(char *s) {\n    size_t i;\n    size_t len = strlen(s);\n    for (i=0; i < len; i++) {\n        /* ... */\n\t  if (s[i] == '\\0') {\n\t    /* This code is never reached */\n      }\n    }\n    return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Removing the dead code depends on the intent of the programmer. Assuming the intent is to flag and process the last character before the null terminator, the conditional is adjusted to correctly determine if the i refers to the index of the last character before the null terminator.",
          "code": "int s_loop(char *s) {\n    size_t i;\n    size_t len = strlen(s);\n    for (i=0; i < len; i++) {\n        /* ... */\n\t  if (s[i+1] == '\\0') {\n\t    /* This code is now reached */\n      }\n    }\n    return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The presence of dead code may indicate logic errors that can lead to unintended program behavior. The ways in which dead code can be introduced into a program and the effort required to remove it can be complex. As a result, resolving dead code can be an in-depth process requiring significant analysis.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC09-C",
    "title": "Character encoding: Use subset of ASCII for safety",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC09-C.+Character+encoding%3A+Use+subset+of+ASCII+for+safety",
    "description": "According to subclause 5.2.1 of the C Standard [ ISO/IEC 9899:2011 ],\n\nTwo sets of characters and their associated collating sequences shall be defined: the set in which source files are written (the source character set ), and the set interpreted in the execution environment (the execution character set ). Each set is further divided into a basic character set , whose contents are given by this subclause, and a set of zero or more locale-specific members (which are not members of the basic character set) called extended characters . The combined set is also called the extended character set . The values of the members of the execution character set are implementation-defined .\n\nThere are several national variants of ASCII. As a result, the original ASCII is often called US-ASCII. ISO/IEC 646-1991 defines a character set, similar to US-ASCII, but with code positions corresponding to US-ASCII characters @[]{| } as national use positions [ ISO/IEC 646-1991 ]. It also gives some liberties with particular characters (e.g., #$^`~ ).  In ISO/IEC 646-1991, several national variants of ASCII are defined, assigning different letters and symbols to the national use positions. Consequently, the characters that appear in those positions, including those in US-ASCII, are less portable in international data transfer. Because of the national variants, some characters are less portable than others: they might be transferred or interpreted incorrectly.\n\n@[]{|\n\n#$^`~\n\nIn addition to the letters of the English alphabet (A through Z and a through z), the digits (0 through 9), and the space, only the following characters are portable:\n\n% & + , - . : = _\n\n% & + , - . : = _\n\nWhen naming files, variables, and other objects, only these characters should be considered for use. This recommendation is related to STR02-C. Sanitize data passed to complex subsystems .\n\nFile Names\n\nFile names containing particular characters can be troublesome and can cause unexpected behavior leading to potential vulnerabilities . If a program allows the user to specify a file name in the creation or renaming of a file, certain checks should be made to disallow the following characters and patterns:\n\nLeading dashes—Leading dashes can cause problems when programs are called with the file name as a parameter because the first character or characters of the file name might be interpreted as an option switch. Control characters, such as newlines, carriage returns, and escape—Control characters in a file name can cause unexpected results from shell scripts and in logging. Spaces—Spaces can cause problems with scripts and when double quotes are not used to surround the file name. Invalid character encodings—Character encodings can be a huge issue. (See MSC10-C. Character encoding: UTF8-related issues .) Any characters other than letters, numbers, and punctuation designated here as portable—Other special characters are included in this recommendation because they are commonly used as separators, and having them in a file name can cause unexpected and potentially insecure behavior.\n\nAlso, many of the punctuation characters are not unconditionally safe for file names even of they are portably available.\n\nMost of these characters or patterns are primarily a problem to scripts or automated parsing, but because they are not commonly used, it is best to disallow their use to reduce potential problems. Interoperability concerns also exist because different operating systems handle file names of this sort in different ways.\n\nAs a result of the influence of MS-DOS, file names of the form xxxxxxxx.xxx , where x denotes an alphanumeric character, are generally supported by modern systems. On some platforms, file names are case sensitive, and on other platforms, they are case insensitive. VU#439395 is an example of a vulnerability resulting from a failure to deal appropriately with case-sensitivity issues [ VU#439395 ].\n\nxxxxxxxx.xxx\n\nx",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (File Name 1)",
          "pre_code_commentary": "In this noncompliant code example, unsafe characters are used as part of a file name:",
          "code": "#include <fcntl.h>\n#include <sys/stat.h>\n\nint main(void) {\n   char *file_name = \"\\xe5ngstr\\xf6m\";\n   mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\n\n   int fd = open(file_name, O_CREAT | O_EXCL | O_WRONLY, mode);\n   if (fd == -1) {\n      /* Handle error */\n   }\n}\n",
          "explanation_after": "An implementation is free to define its own mapping of the \"nonsafe\" characters. For example, when run on Red Hat Enterprise Linux 7.5, this noncompliant code example resulted in the following file name being revealed by the ls command:"
        },
        "compliant": {
          "heading": "Compliant Solution (File Name 1)",
          "pre_code_commentary": "Use a descriptive file name containing only the subset of ASCII previously described:",
          "code": "#include <fcntl.h>\n#include <sys/stat.h>\n\nint main(void) {\n   char *file_name = \"name.ext\";\n   mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\n\n   int fd = open(file_name, O_CREAT | O_EXCL | O_WRONLY, mode);\n   if (fd == -1) {\n      /* Handle error */\n   }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (File Name 2)",
          "pre_code_commentary": "This noncompliant code example is derived from FIO30-C. Exclude user input from format strings , except that a newline is removed on the assumption that fgets() will include it:",
          "code": "char myFilename[1000];\nconst char elimNewLn[] = \"\\n\";\n\nfgets(myFilename, sizeof(myFilename)-1, stdin);\nmyFilename[sizeof(myFilename)-1] = '\\0';\nmyFilename[strcspn(myFilename, elimNewLn)] = '\\0';\n",
          "explanation_after": "No checks are performed on the file name to prevent troublesome characters. If an attacker knew this code was in a program used to create or rename files that would later be used in a script or automated process of some sort, he or she could choose particular characters in the output file name to confuse the later process for malicious purposes."
        },
        "compliant": {
          "heading": "Compliant Solution (File Name 2)",
          "pre_code_commentary": "In this compliant solution, the program rejects file names that violate the guidelines for selecting safe characters:",
          "code": "char myFilename[1000];\nconst char elimNewln[] = \"\\n\";\nconst char badChars[] = \"-\\n\\r ,;'\\\\<\\\"\";\ndo {\n  fgets(myFilename, sizeof(myFilename)-1, stdin);\n  myFilename[sizeof(myFilename)-1] ='\\0';\n  myFilename[strcspn(myFilename, elimNewln)]='\\0';\n} while ( (strcspn(myFilename, badChars))\n           < (strlen(myFilename)));\n",
          "explanation_after": "Similarly, you must validate all file names originating from untrusted sources to ensure they contain only safe characters."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to use only the subset of ASCII that is guaranteed to work can result in misinterpreted data.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC10-C",
    "title": "Character encoding: UTF8-related issues",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC10-C.+Character+encoding%3A+UTF8-related+issues",
    "description": "UTF-8 is a variable-width encoding for Unicode. UTF-8 uses 1 to 4 bytes per character, depending on the Unicode symbol. UTF-8 has the following properties:\n\nThe classical US-ASCII characters (0 to 0x7f) encode as themselves, so files and strings that are encoded with ASCII values have the same encoding under both ASCII and UTF-8. It is easy to convert between UTF-8 and UCS-2 and UCS-4 fixed-width representations of characters. The lexicographic sorting order of UCS-4 strings is preserved. All possible 2^21 UCS codes can be encoded using UTF-8.\n\nGenerally, programs should validate UTF-8 data before performing other checks. The following table lists the well-formed UTF-8 byte sequences.\n\nBits of code point First code point Last code point Bytes in sequence Byte 1 Byte 2 Byte 3 Byte 4 7 U+0000 U+007F 1 0xxxxxxx 11 U+0080 U+07FF 2 110xxxxx 10xxxxxx 16 U+0800 U+FFFF 3 1110xxxx 10xxxxxx 10xxxxxx 21 U+10000 U+1FFFFF 4 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n0xxxxxxx\n\n110xxxxx\n\n10xxxxxx\n\n1110xxxx\n\n10xxxxxx\n\n10xxxxxx\n\n11110xxx\n\n10xxxxxx\n\n10xxxxxx\n\n10xxxxxx\n\nAlthough UTF-8 originated from the Plan 9 developers [ Pike 1993 ], Plan 9's own support covers only the low 16-bit range. In general, many \"Unicode\" systems support only the low 16-bit range, not the full 21-bit ISO 10646 code space [ ISO/IEC 10646:2012 ].",
    "examples": null,
    "risk_assessment": {
      "explanation": "Failing to properly handle UTF8-encoded data can result in a data integrity violation or denial-of-service attack .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC11-C",
    "title": "Incorporate diagnostic tests using assertions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC11-C.+Incorporate+diagnostic+tests+using+assertions",
    "description": "Incorporate diagnostic tests into your program using, for example, the assert() macro.\n\nassert()\n\nThe assert macro expands to a void expression:\n\nassert\n\n#include <assert.h>\nvoid assert(scalar expression);\n\n#include <assert.h>\nvoid assert(scalar expression);\n\nWhen it is executed, if expression (which must have a scalar type) is false, the assert macro outputs information about the failed assertion (including the text of the argument, the name of the source file, the source line number, and the name of the enclosing function) on the standard error stream, in an implementation-defined format, and calls the abort() function.\n\nexpression\n\nassert\n\nabort()\n\nIn the following example, the test for integer wrap was omitted for the unsigned multiplication on the assumption that MAX_TABLE_SIZE * sizeof(char *) cannot exceed SIZE_MAX . Although we know this is true, it cannot do any harm to codify this assumption.\n\nMAX_TABLE_SIZE * sizeof(char *)\n\nSIZE_MAX\n\nassert(size <= SIZE_MAX/sizeof(char *));\ntable_size = size * sizeof(char *);\n\nassert(size <= SIZE_MAX/sizeof(char *));\ntable_size = size * sizeof(char *);\n\nAssertions are primarily intended for use during debugging and are generally turned off before code is deployed by defining the NDEBUG macro (typically as a flag passed to the compiler). Consequently, assertions should be used to protect against incorrect programmer assumptions and not for runtime error checking.\n\nNDEBUG\n\nAssertions should never be used to verify the absence of runtime (as opposed to logic) errors, such as\n\nInvalid user input (including command-line arguments and environment variables) File errors (for example, errors opening, reading or writing files) Network errors (including network protocol errors) Out-of-memory conditions (for example, malloc() or similar failures) System resource exhaustion (for example, out-of-file descriptors, processes, threads) System call errors (for example, errors executing files, locking or unlocking mutexes) Invalid permissions (for example, file, memory, user)\n\nmalloc()\n\nCode that protects against a buffer overflow, for example, cannot be implemented as an assertion because this code must be presented in the deployed executable.\n\nIn particular, assertions are generally unsuitable for server programs or embedded systems in deployment. A failed assertion can lead to a denial-of-service attack if triggered by a malicious user, such as size being derived, in some way, from client input. In such situations, a soft failure mode, such as writing to a log file and rejecting the request, is more appropriate.\n\nsize\n\nif (size > SIZE_MAX / sizeof(char *)) {\n  fprintf(log_file, \"%s: size %zu exceeds %zu bytes\\n\",\n          __FILE__, size, SIZE_MAX / sizeof(char *));\n  size = SIZE_MAX / sizeof(char *);\n}\ntable_size = size * sizeof(char *);\n\nif (size > SIZE_MAX / sizeof(char *)) {\n  fprintf(log_file, \"%s: size %zu exceeds %zu bytes\\n\",\n          __FILE__, size, SIZE_MAX / sizeof(char *));\n  size = SIZE_MAX / sizeof(char *);\n}\ntable_size = size * sizeof(char *);",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( malloc() )",
          "pre_code_commentary": "This noncompliant code example uses the assert() macro to verify that memory allocation succeeded. Because memory availability depends on the overall state of the system and can become exhausted at any point during a process lifetime, a robust program must be prepared to gracefully handle and recover from its exhaustion. Consequently, using the assert() macro to verify that a memory allocation succeeded would be inappropriate because doing so might lead to an abrupt termination of the process, opening the possibility of a denial-of-service attack. See also MEM11-C. Do not assume infinite heap space and void MEM32-C. Detect and handle memory allocation errors .",
          "code": "char *dupstring(const char *c_str) {\n  size_t len;\n  char *dup;\n\n  len = strlen(c_str);\n  dup = (char *)malloc(len + 1);\n  assert(NULL != dup);\n\n  memcpy(dup, c_str, len + 1);\n  return dup;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( malloc() )",
          "pre_code_commentary": "This compliant solution demonstrates how to detect and handle possible memory exhaustion:",
          "code": "char *dupstring(const char *c_str) {\n  size_t len;\n  char *dup;\n\n  len = strlen(c_str);\n  dup = (char*)malloc(len + 1);\n  /* Detect and handle memory allocation error */\n  if (NULL == dup) {\n      return NULL; \n  }\n\n  memcpy(dup, c_str, len + 1);\n  return dup;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Assertions are a valuable diagnostic tool for finding and eliminating software defects that may result in vulnerabilities . The absence of assertions, however, does not mean that code is incorrect.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC12-C",
    "title": "Detect and remove code that has no effect or is never executed",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC12-C.+Detect+and+remove+code+that+has+no+effect+or+is+never+executed",
    "description": "Code that has no effect or is never executed (that is, dead or unreachable code) is typically the result of a coding error and can cause unexpected behavior . Such code is usually optimized out of a program during compilation. However, to improve readability and ensure that logic errors are resolved, it should be identified, understood, and eliminated.\n\nStatements or expressions that have no effect should be identified and removed from code. Most modern compilers, in many cases, can warn about code that has no effect or is never executed. (See MSC00-C. Compile cleanly at high warning levels .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example demonstrates how dead code can be introduced into a program [ Fortify 2006 ]. The second conditional statement, if (s) , will never evaluate true because it requires that s not be assigned NULL , and the only path where s can be assigned a non-null value ends with a return statement.",
          "code": "int func(int condition) {\n    char *s = NULL;\n    if (condition) {\n        s = (char *)malloc(10);\n        if (s == NULL) {\n           /* Handle Error */\n        }\n        /* Process s */\n        return 0;\n    }\n    /* Code that doesn't touch s */\n    if (s) {\n        /* This code is unreachable */\n    }\n    return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Remediation of dead code requires the programmer to determine why the code is never executed and then to resolve the situation appropriately. To correct the preceding noncompliant code, the return is removed from the body of the first conditional statement.",
          "code": "int func(int condition) {\n    char *s = NULL;\n    if (condition) {\n        s = (char *)malloc(10);\n        if (s == NULL) {\n           /* Handle error */\n        }\n        /* Process s */\n    }\n    /* Code that doesn't touch s */\n    if (s) {\n        /* This code is now reachable */\n    }\n    return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this example, the strlen() function is used to limit the number of times the function s_loop() will iterate. The conditional statement inside the loop evaluates to true when the current character in the string is the null terminator. However, because strlen() returns the number of characters that precede the null terminator, the conditional statement never evaluates true.",
          "code": "int s_loop(char *s) {\n    size_t i;\n    size_t len = strlen(s);\n    for (i=0; i < len; i++) {\n        /* Code that doesn't change s, i, or len */\n\t  if (s[i] == '\\0') {\n\t    /* This code is never reached */\n      }\n    }\n    return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Removing the dead code depends on the intent of the programmer. Assuming the intent is to flag and process the last character before the null terminator, the conditional is adjusted to correctly determine if the i refers to the index of the last character before the null terminator.",
          "code": "int s_loop(char *s) {\n    size_t i;\n    size_t len = strlen(s);\n    for (i=0; i < len; i++) {\n        /* Code that doesn't change s, i, or len */\n\t  if (s[i+1] == '\\0') {\n\t    /* This code is now reached */\n      }\n    }\n    return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Assignment)",
          "pre_code_commentary": "In this noncompliant code example, the comparison of a to b has no effect:",
          "code": "int a;\nint b;\n/* ... */\na == b;\n",
          "explanation_after": "This code is likely a case of the programmer mistakenly using the equals operator == instead of the assignment operator = ."
        },
        "compliant": {
          "heading": "Compliant Solution (Assignment)",
          "pre_code_commentary": "The assignment of b to a is now properly performed:",
          "code": "int a;\nint b;\n/* ... */\na = b;\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Dereference)",
          "pre_code_commentary": "In this example, a pointer increment and then a dereference occur, but the dereference has no effect:",
          "code": "int *p;\n/* ... */\n*p++;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Dereference)",
          "pre_code_commentary": "Correcting this example depends on the intent of the programmer. For example, if dereferencing p was a mistake, then p should not be dereferenced.",
          "code": "int *p;\n/* ... */\n++p;\n",
          "explanation_after": "If the intent was to increment the value referred to by p , then parentheses can be used to ensure p is dereferenced and then incremented. (See EXP00-C. Use parentheses for precedence of operation .)\n\nAnother possibility is that p is being used to reference a memory-mapped device. In this case, the variable p should be declared as volatile ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (if/else if)",
          "pre_code_commentary": "A chain of if/else if statements is evaluated from top to bottom. At most, only one branch of the chain will be executed: the first one with a condition that evaluates to true. Consequently, duplicating a condition in a sequence of if/else if statements automatically leads to dead code.",
          "code": "if (param == 1)\n   openWindow();\n else if (param == 2)\n   closeWindow();\n else if (param == 1) /* Duplicated condition */\n   moveWindowToTheBackground();\n",
          "explanation_after": "Note that duplicating a condition violates this guideline only if the duplicate conditions always behave similarly...see a compliant solution below for a condition that is textually a duplicate but behaves differently."
        },
        "compliant": {
          "heading": "Compliant Solution (if/else if)",
          "pre_code_commentary": "In this compliant solution, the third conditional expression has been corrected.",
          "code": "if (param == 1)\n   openWindow();\n else if (param == 2)\n   closeWindow();\n else if (param == 3)\n   moveWindowToTheBackground();\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (if/else if)",
          "pre_code_commentary": "A chain of if/else if statements is evaluated from top to bottom. At most, only one branch of the chain will be executed: the first one with a condition that evaluates to true. Consequently, duplicating a condition in a sequence of if/else if statements automatically leads to dead code.",
          "code": "if (param == 1)\n   openWindow();\n else if (param == 2)\n   closeWindow();\n else if (param == 1) /* Duplicated condition */\n   moveWindowToTheBackground();\n",
          "explanation_after": "Note that duplicating a condition violates this guideline only if the duplicate conditions always behave similarly...see a compliant solution below for a condition that is textually a duplicate but behaves differently."
        },
        "compliant": {
          "heading": "Compliant Solution (Conditional Side-Effects)",
          "pre_code_commentary": "This code does not violate this recommendation, because even though the conditions are textually identical, they have different side effects, because the getc() function advances the stream marker.",
          "code": "if (getc() == ':')\n   readMoreInput();\n else if (getc() == ':')\n   readMoreInput();\n else if (getc() == ':')\n   readMoreInput();\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (logical operators)",
          "pre_code_commentary": "Using the same subexpression on either side of a logical operator is almost always a mistake.  In this noncompliant code example, the rightmost subexpression of the controlling expression of each if statement has no effect.",
          "code": "if (a == b && a == b) { // if the first one is true, the second one is too\n  do_x();\n}\nif (a == c || a == c ) { // if the first one is true, the second one is too\n  do_w();\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (logical operators)",
          "pre_code_commentary": "In this compliant solution, the rightmost subexpression of the controlling expression of each if statement has been removed.",
          "code": "if (a == b) { \n  do_x();\n}\nif (a == c) { \n  do_w();\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Unconditional Jump)",
          "pre_code_commentary": "Unconditional jump statements typically has no effect.",
          "code": "#include <stdio.h>\n \nfor (int i = 0; i < 10; ++i) {\n  printf(\"i is %d\", i);\n  continue;  // this is meaningless; the loop would continue anyway\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Unconditional Jump)",
          "pre_code_commentary": "The continue statement has been removed from this compliant solution.",
          "code": "#include <stdio.h>\n \nfor (int i = 0; i < 10; ++i) {\n   printf(\"i is %d\", i); \n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The presence of code that has no effect or is never executed can indicate logic errors that may result in unexpected behavior and vulnerabilities . Such code can be introduced into programs in a variety of ways and eliminating it can require significant analysis.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC13-C",
    "title": "Detect and remove unused values",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC13-C.+Detect+and+remove+unused+values",
    "description": "The presence of unused values may indicate significant logic errors. To prevent such errors, unused values should be identified and removed from code.\n\nThis recommendation is a specific case of MSC12-C. Detect and remove code that has no effect or is never executed .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this example, p2 is assigned the value returned by bar() , but that value is never used. Note this example assumes that foo() and bar() return valid pointers (see DCL30-C. Declare objects with appropriate storage durations ).",
          "code": "int *p1;\nint *p2;\np1 = foo();\np2 = bar();\n\nif (baz()) {\n  return p1;\n}\nelse {\n  p2 = p1;\n}\nreturn p2;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This example can be corrected in many different ways, depending on the intent of the programmer. In this compliant solution, p2 is found to be extraneous. The calls to bar() and baz() can be removed if they do not produce any side effects.",
          "code": "int *p1 = foo();\n\n/* Removable if bar() does not produce any side effects */\n(void)bar();\n\n/* Removable if baz() does not produce any side effects */\n(void)baz();\nreturn p1;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Unused values may indicate significant logic errors.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC14-C",
    "title": "Do not introduce unnecessary platform dependencies",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC14-C.+Do+not+introduce+unnecessary+platform+dependencies",
    "description": "Platform dependencies may be introduced to improve performance on a particular platform. This can be a dangerous practice, particularly if these dependencies are not appropriately documented during development and addressed during porting. Platform dependencies that have no performance or other benefits should consequently be avoided because they may introduce errors during porting.\n\nThe C Standard identifies four different kinds of nonportable behavior. Each section of Annex J of the C Standard enumerates distinct instances of behaviors of each kind.\n\nNonportable Behavior Definition Annex J Section Unspecified behavior Behavior for which the standard provides two or more possibilities and imposes no further requirements on which is chosen in any instance. J.1 Undefined behavior Behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which the standard imposes no requirements. An example of undefined behavior is the behavior on signed integer overflow. J.2 Implementation-defined behavior Unspecified behavior whereby each implementation documents how the choice is made. J.3 Locale-specific behavior Behavior that depends on local conventions of nationality, culture, and language that each implementation documents. J.4\n\nAn example of undefined behavior is passing a null char* pointer as an argument to the printf function corresponding to the %s format specification. Although some implementations (such as the GNU C Library ) provide well-defined semantics for this case, others do not, causing programs that rely on this behavior to fail abnormally.\n\nchar*\n\nprintf\n\n%s\n\nAn example of unspecified behavior is the order in which the arguments to a function are evaluated.\n\nAn example of implementation-defined behavior is the propagation of the high-order bit when a signed integer is shifted right.\n\nMost legitimate platform dependencies can and should be isolated in separate modules that expose portable, platform-agnostic interfaces to platform-specific implementations. Portable applications that cannot avoid relying on platform-specific details should always provide a generic, portable, standards-based solution as a fallback mechanism for the platform-specific alternative. That way, such an application can be more easily ported to new platforms without an excessive risk of security flaws caused by assumptions that do not hold in the new environment.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example uses the complement operator in the test for integer overflow. It assumes both numbers are nonnegative:",
          "code": "signed int si;\nsigned int si2;\nsigned int sum;\n\nif (si < 0 || si2 < 0) {\n  /* Handle error condition */\n}\nif (~si < si2) {\n  /* Handle error condition */\n}\nsum = si + si2;\n",
          "explanation_after": "This code assumes that the implementation uses two's complement representation. This assumption is commonly true but is not guaranteed by the standard.\n\nThis code sample also violates INT14-C. Avoid performing bitwise and arithmetic operations on the same data ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution implements a strictly conforming test for overflow:",
          "code": "unsigned int si;\nunsigned int si2;\nunsigned int sum;\n\nif (si < 0 || si2 < 0) {\n  /* Handle error condition */\n}\nif (INT_MAX - si < si2) {\n  /* Handle error condition */\n}\nsum = si + si2;\n",
          "explanation_after": "If the noncompliant form of this test is truly faster, talk to your compiler vendor because, if these tests are equivalent, optimization should occur. If both forms have the same performance, prefer the portable form."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( strerror_r )",
          "pre_code_commentary": "The GNU libc implementation of strerror_r declares the function to return char* , in conflict with the POSIX specification. This noncompliant code example relies on this return type to pass the return value as an argument to the %s formatting directive to fprintf . The behavior of the example will be undefined on a platform that declares the return type of strerror_r() to be int , in accordance with POSIX.",
          "code": "void f() {\n  char buf[BUFSIZ];\n  fprintf(stderr, \"Error: %s\\n\",\n          strerror_r(errno, buf, sizeof buf));\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( strerror_r )",
          "pre_code_commentary": "The compliant solution disables the nonconforming declaration of strerror_r() by explicitly requesting POSIX conformance before including the <string.h> header that declares the function and handles the function's failure by copying the \"Unknown error\" string into the buffer.\n\nNote that the function assigns the result of the call to strerror_r() to a variable of type int . This assignment is a defense-in-depth strategy guarding against inadvertently invoking strerror_r() that returns char* : a conforming compiler is required to issue a diagnostic for the ill-formed conversion from char* to int .",
          "code": "#define _XOPEN_SOURCE 600\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\nvoid f() {\n  char buf[BUFSIZ];\n  int result;\n\n  result = strerror_r(errno, buf, sizeof buf);\n\n  if (0 != result) {\n    strcpy(buf, \"Unknown error\");\n  }\n  fprintf(stderr, \"Error: %s\\n\", buf);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Unnecessary platform dependencies are, by definition, unnecessary. Avoiding these dependencies can eliminate porting errors resulting from invalidated assumptions.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC15-C",
    "title": "Do not depend on undefined behavior",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC15-C.+Do+not+depend+on+undefined+behavior",
    "description": "The C Standard, subclause 3.5.3 [ ISO/IEC 9899:2024 ], defines undefined behavior as\n\nbehavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which this document imposes no requirements\n\nSubclause 4 explains how the standard identifies undefined behavior (see also undefined behavior 1 of Annex J).\n\nIf a \"shall\" or \"shall not\" requirement that appears outside of a constraint or runtime-constraint is violated, the behavior is undefined. Undefined behavior is otherwise indicated in this document by the words \"undefined behavior\" or by the omission of any explicit definition of behavior. There is no difference in emphasis among these three; they all describe \"behavior that is undefined\".\n\nAnnex J, subclause J.2, \"Undefined behavior,\" enumerates the circumstances under which the behavior of a program is undefined. This list is duplicated on the CC. Undefined Behavior page.\n\nBehavior can be classified as undefined by the C standards committee for the following reasons:\n\nTo give the implementor license not to catch certain program errors that are difficult to diagnose To avoid defining obscure corner cases that would favor one implementation strategy over another To identify areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior\n\nConforming implementations can deal with undefined behavior in a variety of fashions, such as ignoring the situation completely, with unpredictable results; translating or executing the program in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message); or terminating a translation or execution (with the issuance of a diagnostic message). Because compilers are not obligated to generate code for undefined behavior, these behaviors are candidates for optimization. By assuming that undefined behaviors will not occur, compilers can generate code with better performance characteristics.\n\nIncreasingly, compiler writers are taking advantage of undefined behaviors in the C programming languages to improve optimizations. These optimizations frequently interfere with the ability of developers to perform cause-effect analysis on their source code—that is, to analyze the dependence of downstream results on prior results. Consequently, these optimizations are eliminating causality in software and are increasing the probability of software faults, defects, and vulnerabilities .\n\nAll of this puts the onus on the programmer to develop code that is free from undefined behaviors, with or without the help of the compiler.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "An example of undefined behavior in C is the behavior on signed integer overflow (see also INT32-C. Ensure that operations on signed integers do not result in overflow ). This noncompliant code example depends on this behavior to catch the overflow:",
          "code": "#include <assert.h>\n#include <limits.h>\n#include <stdio.h>\n \nint foo(int a) {\n  assert(a + 100 > a);\n  printf(\"%d %d\\n\", a + 100, a);\n  return a;\n}\n\nint main(void) {\n  foo(100);\n  foo(INT_MAX);\n  return 0;\n}\n",
          "explanation_after": "This code checks for signed integer overflow by testing whether a + 100 > a . This test cannot evaluate to false unless an integer overflow occurs. However, because a conforming implementation is not required to generate code for undefined behavior, and signed integer overflow is undefined behavior, this code may be compiled out. For example, GCC 4.1.1 optimizes out the assertion for all optimization levels, and GCC 4.2.3 optimizes out the assertion for programs compiled with -O2 -level optimization and higher.\n\nOn some platforms, the integer overflow causes the program to terminate (before it has an opportunity to test)."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not depend on undefined behavior:",
          "code": "#include <assert.h>\n#include <limits.h>\n#include <stdio.h>\n\nint foo(int a) {\n  assert(a < (INT_MAX - 100));\n  printf(\"%d %d\\n\", a + 100, a);\n  return a;\n}\n\nint main(void) {\n  foo(100);\n  foo(INT_MAX);\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Although it is rare that the entire application can be strictly conforming , the goal should be that almost all the code is allowed for a strictly conforming program (which among other things means that it avoids undefined behavior ), with the implementation-dependent parts confined to modules that the programmer knows are needed to adapt to the platform when it changes.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MSC17-C",
    "title": "Finish every set of statements associated with a case label with a break statement",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC17-C.+Finish+every+set+of+statements+associated+with+a+case+label+with+a+break+statement",
    "description": "A switch statement consists of several case labels, plus a default label. The default label is optional but recommended. (See MSC01-C. Strive for logical completeness .) A series of statements following a case label conventionally ends with a break statement; if omitted, control flow falls through to the next case in the switch statement block. Because the break statement is not required, omitting it does not produce compiler diagnostics. If the omission was unintentional, it can result in an unexpected control flow.\n\nswitch\n\nbreak\n\nswitch\n\nbreak",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the case where widget_type is WE_W lacks a break statement. Consequently, statements that should be executed only when widget_type is WE_X are executed even when widget_type is WE_W .",
          "code": "enum WidgetEnum { WE_W, WE_X, WE_Y, WE_Z } widget_type;\nwidget_type = WE_X;\n\nswitch (widget_type) {\n  case WE_W:\n    /* ... */\n  case WE_X:\n    /* ... */\n    break;\n  case WE_Y: \n  case WE_Z:\n    /* ... */\n    break;\n  default: /* Can't happen */\n\t /* Handle error condition */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, each sequence of statements following a case label ends with a break statement:",
          "code": "enum WidgetEnum { WE_W, WE_X, WE_Y, WE_Z } widget_type;\nwidget_type = WE_X;\n\nswitch (widget_type) {\n  case WE_W:\n    /* ... */\n    break;\n  case WE_X:\n    /* ... */\n    break;\n  case WE_Y: \n  case WE_Z:\n    /* ... */\n    break;\n  default: /* Can't happen */\n\t /* Handle error condition */\n}\n",
          "explanation_after": "A break statement is not required following the case where widget_type is WE_Y because there are no statements before the next case label, indicating that both WE_Y and WE_Z should be handled in the same fashion.\n\nA break statement is not required following the default case because it would not affect the control flow."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to include break statements leads to unexpected control flow.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "MSC18-C",
    "title": "Be careful while handling sensitive data, such as passwords, in program code",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC18-C.+Be+careful+while+handling+sensitive+data%2C+such+as+passwords%2C+in+program+code",
    "description": "Many applications need to handle sensitive data either in memory or on disk. If this sensitive data is not protected properly, it might lead to loss of secrecy or integrity of the data. It is very difficult (or expensive) to completely secure all the sensitive data. Users tend to use the same passwords everywhere. So even if your program is a simple game that stores the user's profile information and requires the user to enter a password, the user might choose the same password he or she uses for an online bank account for your game program. Now the user's bank account is only as secure as your program enables it to be.\n\nThere are simple steps you can take to secure sensitive data in your programs.\n\nPrefer the system's authentication dialog (or any other mechanism provided by the OS) for authentication to privileged services.\n\nIf you are accessing some privileged service already installed on the system, most likely that service will have some mechanism to take a password from the user. Before asking the user for a user name and password from your application, check if the service itself authenticates the user in some way. If so, let the service handle the authentication because doing so would at least not increase the footprint of the sensitive data.\n\nDo not hard code sensitive data in programs.\n\nSee MSC41-C. Never hard code sensitive information for details.\n\nDisable memory dumps.\n\nMemory dumps are automatically created when your program crashes. They can contain information stored in any part of program memory. Therefore, memory dumps should be disabled before an application is shipped to users. See MEM06-C. Ensure that sensitive data is not written out to disk for details.\n\nDo not store sensitive data beyond its time of use in a program.\n\nSensitive data that is stored in memory can get written to disk when a page is swapped out of the physical memory. (See next point for details about keeping sensitive data on disk.) You may be able to \"lock\" your data to keep it from swapping out. Your program will generally need administrative privileges to do so successfully, but it never hurts to try. See MEM06-C. Ensure that sensitive data is not written out to disk for details.\n\nDo not store sensitive data in plaintext (either on disk or in memory).\n\nSee MEM06-C. Ensure that sensitive data is not written out to disk .\n\nWhile using a password, consider storing its hash instead of plaintext. Use the hash for comparisons and other purposes. The following code [ Viega 2001 ] illustrates:\n\nint validate(char *username) {\n  char *password;\n  char *checksum;\n  password = read_password();\n  checksum = compute_checksum(password);\n  erase(password);  /* Securely erase password */\n  return !strcmp(checksum, get_stored_checksum(username));\n}\n\nint validate(char *username) {\n  char *password;\n  char *checksum;\n  password = read_password();\n  checksum = compute_checksum(password);\n  erase(password);  /* Securely erase password */\n  return !strcmp(checksum, get_stored_checksum(username));\n}\n\nIf you must store sensitive data, encrypt it first.\n\nIf encrypting or hashing sensitive data, do not implement your own encryption functions (or library). Use proven secure crypto libraries, which have been extensively tested for security. If using standard crypto libraries, be aware that they have certain requirements (documented with the library) for the key sizes and other properties. Choose keys that satisfy these conditions. Do not store the encryption keys (you can derive the key from the hash of the user's password or any other cryptographic mechanism, provided the above condition holds). If the key is to be stored, store it securely.\n\nSecurely erase sensitive data from disk and memory.\n\nBe aware of compiler optimization when erasing memory. (See MSC06-C. Beware of compiler optimizations .) Use secure erase methods specified in U.S. Department of Defense Standard 5220 [ DOD 5220 ] or Peter Gutmann's paper [ Gutmann 1996 ].",
    "examples": null,
    "risk_assessment": {
      "explanation": "If sensitive data is not handled correctly in a program, an attacker can gain access to it.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC19-C",
    "title": "For functions that return an array, prefer returning an empty array over a null value",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC19-C.+For+functions+that+return+an+array%2C+prefer+returning+an+empty+array+over+a+null+value",
    "description": "Many functions have the option of returning a pointer to an object or returning NULL if a valid pointer cannot be produced. Some functions return arrays, which appear like a pointer to an object. However, if a function has the option of returning an array or indicating that a valid array is not possible, it should not return NULL . Instead, the function should return an empty array. Often, code that calls a function that returns an array intends merely to iterate over the array elements. In this case, the calling code need not change—iterating over the elements works correctly even if the returned array is empty, so the calling code need not check the return value for NULL .\n\nNULL\n\nNULL\n\nNULL\n\nThis situation is complicated by the fact that C does not keep track of the length of an array. However, two popular methods have emerged to emulate this behavior. The first is to wrap the array in a struct with an integer storing the length. The second is to place a sentinel value at the end of the data in the array. This second approach is most commonly manifested in null-terminated byte strings (NTBSs).",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Struct)",
          "pre_code_commentary": "In this noncompliant code example, an inventory system keeps track of the total number of different items (denoted length ). Each item is given an index in the array, and the value for that index is the stock of that item. Adding a new item increases length in the struct. Stocking more of an item increases the value for that item's index. For example, if 5 books and 2 erasers are in stock, the inventory would be stockOfItem[0] = 5 and stockOfItem[1] = 2 , assuming books are index 0 and erasers are index 1.\n\nThe problem arises in this setup when no items are being stocked. getStock would recognize that length = 0 and would return NULL . In this noncompliant code example, erroneous behavior results from getStock returning NULL while main neglects to check for such a value. It results in an abnormal program termination after returning to the main function.",
          "code": "#include <stdio.h>\nenum { INV_SIZE=20 };\n\ntypedef struct {\n  size_t stockOfItem[INV_SIZE];\n  size_t length;\n} Inventory;\n\nsize_t *getStock(Inventory iv);\n\nint main(void) {\n  Inventory iv;\n  size_t *item;\n\n  iv.length = 0;\n\n  /*\n   * Other code that might modify the inventory but still\n   * leave no items in it upon completion.\n   */\n\n  item = getStock(iv);\n\n  printf(\"Stock of first item in inventory: %zd\\n\", item[0]);\n  \n  return 0;\n}\n\nsize_t *getStock(Inventory iv) {\n  if (iv.length == 0) {\n    return NULL;\n  }\n  else {\n    return iv.stockOfItem;\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution eliminates the NULL return and returns the item array, even if it is zero-length. The main function can effectively handle this situation without exhibiting erroneous behavior. Since the array lives on the stack, it must prevent returning a value in the stack frame (as mandated by DCL30-C. Declare objects with appropriate storage durations ). So the getStack() function also takes a pointer to Inventory , so that it can return a pointer to its contents safely.",
          "code": "#include <stdio.h>\n\nenum { INV_SIZE=20 };\n\ntypedef struct {\n  size_t stockOfItem[INV_SIZE];\n  size_t length;\n} Inventory;\n\nsize_t *getStock(Inventory* iv);\n\nint main(void) {\n  Inventory iv;\n  size_t *item;\n\n  iv.length = 0;\n\n  /*\n   * Other code that might modify the inventory but still\n   * leave no items in it upon completion.\n   */\n\n  item = getStock(&iv);\n\n  if (iv.length != 0) {\n    printf(\"Stock of first item in inventory: %zd\\n\", item[0]);\n  }\n\n  return 0;\n}\n\nsize_t *getStock(Inventory* iv) {\n  return iv->stockOfItem;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Sentinel Value)",
          "pre_code_commentary": "This noncompliant code example implements an inventory system similar to the one described previously. However, instead of storing the length of the array in a struct, a sentinel value of FINAL_ITEM is used. The value for the index following the last item is set as FINAL_ITEM . It is assumed that out-of-stock items (assigned value 0) are removed from the array, and the contents of later items are shifted to lower indexes.\n\nThe following code attempts to return an array of the items in stock, sorted by the amount of each item in stock. The arraySort function incorrectly returns NULL instead of a pointer to an empty array when no items are in stock. The null return is improperly handled by the main function, which is attempting to print out the returned array, and an abnormal program termination results.",
          "code": "#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nenum { FINAL_ITEM=SIZE_MAX, INV_SIZE=20 };\n\nsize_t *arraySort(size_t *array);\n\nint main(void) {\n  size_t i;\n  size_t stockOfItem[INV_SIZE];\n  size_t *sortedArray;\n\n  /* Other code that might use stockarray but leaves it empty */\n\n  sortedArray = arraySort(stockOfItem);\n  \n  for (i = 0; sortedArray[i] != FINAL_ITEM; i++) {\n\tprintf(\"Item stock: %zd\", sortedArray[i]);\n  }\n  \n  return 0;\n}\n\n/* Create new sorted array */\nsize_t *arraySort(size_t *array) {\n  size_t i;\n  size_t *sortedArray;\n\n  for(i = 0; array[i] != FINAL_ITEM; i++);\n  \n  if (i == 0) {\n    return NULL;\n  }\n\n  sortedArray = (size_t*) malloc(sizeof(size_t)*i);\n  if (sortedArray == NULL) {\n    /* Handle memory error */\n  }\n\n  /* Add sorted data to array */\n\n  return sortedArray;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Sentinel Value)",
          "pre_code_commentary": "This compliant solution correctly returns an empty array in the sortedArray function. If the size of the array is 0, then sortedArray allocates an array of size 1 and fills it with the sentinel value. It can then successfully return that array to the caller function.",
          "code": "#include <stdio.h>\n#include <stdint.h>\n#include <malloc.h>\n\nenum { FINAL_ITEM=SIZE_MAX, INV_SIZE=20 };\n\nsize_t *arraySort(size_t *array);\n\nint main(void) {\n  size_t i;\n  size_t stockOfItem[INV_SIZE];\n  size_t *sortedArray;\n\n\n  /* Other code that might use stockarray but leaves it empty */\n\n  sortedArray = arraySort(stockOfItem);\n  \n  for (i = 0; sortedArray[i] != FINAL_ITEM; i++) {\n    printf(\"Item stock: %zd\", sortedArray[i]);\n  }\n  \n  return 0;\n}\n\n/* Create new sorted array */\nsize_t *arraySort(size_t *array) {\n  size_t i;\n  size_t *sortedArray;\n\n  for(i = 0; array[i] != FINAL_ITEM; i++);\n\n  if (i == 0) {\n    size_t *emptyArray = (size_t*) malloc(sizeof(size_t));\n    if(emptyArray == NULL) {\n      /* Handle memory error */\n    }\n    emptyArray[0] = FINAL_ITEM;\n    return emptyArray;\n  }\n  \n  sortedArray = (size_t*) malloc(sizeof(size_t)*i);\n  if (sortedArray == NULL) {\n    /* Handle memory error */\n  }\n\n  /* Add sorted data to array */\n\n  return sortedArray;\n }\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Returning NULL rather than a zero-length array can lead to vulnerabilities when the client code does not handle NULL properly. Abnormal program termination can result when the calling function performs operations on NULL .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC20-C",
    "title": "Do not use a switch statement to transfer control into a complex block",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC20-C.+Do+not+use+a+switch+statement+to+transfer+control+into+a+complex+block",
    "description": "A switch statement can be mixed with a block of code by starting the block in one case label, then having another case label within the block. The block can be pictured as spanning more than one case statement.\n\nswitch\n\nSubclause 6.8.4.2, paragraph 2, of the C Standard [ ISO/IEC 9899:2011 ] says,\n\nIf a switch statement has an associated case or default label within the scope of an identifier with a variably modified type, the entire switch statement shall be within the scope of that identifier. 154\n\nFootnote 154 says:\n\nThat is, the declaration either precedes the switch statement, or it follows the last case or default label associated with the switch that is in the block containing the declaration.\n\nNote that the standard does not disallow jumping via goto or switch into loops that do not involve variably modified type identifiers. Consequently, loops and other blocks can be freely intermixed with switch statements. Unfortunately, such intermixing creates code that is, at best, confusing and unclear in what it does, which can cause undesirable behavior.\n\ngoto\n\nswitch\n\nswitch\n\nThe examples here fall under the exception MSC17-C-EX2 in MSC17-C. Finish every set of statements associated with a case label with a break statement .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This example shows the use of the switch statement to jump into a for loop:",
          "code": "int f(int i) {\n  int j=0;\n  switch (i) {\n    case 1:\n      for(j=0;j<10;j++) {\n      /* No break; process case 2 as well */\n    case 2: /* switch jumps inside the for block */\n        j++;\n      /* No break; process case 3 as well */\n    case 3:\n        j++;\n      }\n      break;\n  default:\n    /* Default action */\n    break;\n  }\n  return j;\n}\n",
          "explanation_after": "When i = 1 , the entire for loop is executed. When i = 2 , two increments to j are made before the loop starts. When i = 3 , one increment to j is made before the loop starts. The default case is no loop. Consequently, the function has the following behavior:\n\ni\n\nf(i)\n\n1\n\n12\n\n2\n\n3\n\n11\n\nOther values\n\n0"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution separates the switch and for blocks:",
          "code": "int f(int i) {\n  int j=0;\n  switch (i) {\n    case 1:\n      /* No break; process case 2 as well */\n    case 2:\n      j++;\n      /* No break; process case 3 as well */\n    case 3:\n      j++;\n      break;\n    default:\n      /* Default action */\n      return j;\n  }\n  for(j++;j<10;j++) {\n    j+=2;\n  }\n  return j;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Duff's Device)",
          "pre_code_commentary": "Duff's device is a curious optimization applied to code intended to perform a serial copy. That is, it copies a series of bytes into one memory output in turn. A simple code to do this would be as follows:",
          "code": "size_t count; /* Must be nonzero */\nchar *to;     /* Output destination */\nchar *from;   /* Points to count bytes to copy */\n\ndo {\n  *to = *from++;     /*\n                      * Note that the \"to\" pointer \n                      * is NOT incremented.\n                      */\n} while (--count > 0);\n",
          "explanation_after": "However, this code might be unacceptably slow because the while condition is performed count times. The classic code for Duff's device unrolls this loop to minimize the number of comparisons performed:\n\nIn this code, the first iteration of the loop is subject to the switch statement, so it performs count % 8 assignments. Each subsequent iteration of the loop performs 8 assignments. (Being outside the loop, the switch statement is ignored.) Consequently, this code performs count assignments, but only n comparisons, so it is usually faster.\n\nThe code is widely considered to be valid C and C++ and is supported by all compliant compilers. When describing Duff's device, the creator [ Duff 1988 ] noted,\n\nMany people . . . have said that the worst feature of C is that switches don't break automatically before each case label. This code forms some sort of argument in that debate, but I'm not sure whether it's for or against."
        },
        "compliant": {
          "heading": "Compliant Solution (Duff's Device)",
          "pre_code_commentary": "This is an alternative implementation of Duff's device, which separates the switch statement and loop:",
          "code": "int n = (count + 7) / 8;\nswitch (count % 8) {\n  case 0: *to = *from++; /* Fall through */\n  case 7: *to = *from++; /* Fall through */\n  case 6: *to = *from++; /* Fall through */\n  case 5: *to = *from++; /* Fall through */\n  case 4: *to = *from++; /* Fall through */\n  case 3: *to = *from++; /* Fall through */\n  case 2: *to = *from++; /* Fall through */\n  case 1: *to = *from++; /* Fall through */\n}\nwhile (--n > 0) {\n  *to = *from++;\n  *to = *from++;\n  *to = *from++;\n  *to = *from++;\n  *to = *from++;\n  *to = *from++;\n  *to = *from++;\n  *to = *from++;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MSC21-C",
    "title": "Use robust loop termination conditions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC21-C.+Use+robust+loop+termination+conditions",
    "description": "C defines < , > , <= , and >= to be relational operators , and it defines == and != to be equality operators .\n\n<\n\n>\n\n<=\n\n>=\n\n==\n\n!=\n\nIf a for or while statement uses a loop counter, than it is safer to use a relational operator (such as < ) to terminate the loop than to use an equality operator (such as != ).\n\nfor\n\nwhile\n\n<\n\n!=",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Equality Operators)",
          "pre_code_commentary": "This noncompliant code example appears to have five iterations, but in fact, the loop never terminates:",
          "code": "size_t i;\nfor (i = 1; i != 10; i += 2) {\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Relational Operators)",
          "pre_code_commentary": "Using the relational operator <= instead of an equality operator guarantees loop termination:",
          "code": "size_t i;\nfor (i = 1; i <= 10; i += 2 ) {\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Equality Operators)",
          "pre_code_commentary": "It is also important to ensure termination of loops where the start and end values are variables that might not be properly ordered. The following function assumes that begin < end ; if this is not the case, the loop will never terminate:",
          "code": "void f(size_t begin, size_t end) {\n  size_t i;\n  for (i = begin; i != end; ++i) {\n    /* ... */\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Relational Operators)",
          "pre_code_commentary": "Again, using a relational operator instead of equivalence guarantees loop termination. If begin >= end , the loop never executes its body.",
          "code": "void f(size_t begin, size_t end) {\n  size_t i;\n  for (i = begin; i < end; ++i) {\n    /* ... */\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Boundary Conditions)",
          "pre_code_commentary": "Numerical comparison operators do not always ensure loop termination when comparing against the minimum or maximum representable value of a type, such as SIZE_MAX :",
          "code": "void f(size_t begin, size_t step) {\n  size_t i;\n  for (i = begin; i <= SIZE_MAX; i += step) {\n    /* ... */\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Boundary Conditions)",
          "pre_code_commentary": "A compliant solution is to compare against the difference between the maximum representable value of a type and the increment:",
          "code": "void f(size_t begin, size_t step) {\n  if (0 < step) {\n    size_t i;\n    for (i = begin; i <= SIZE_MAX - step; i += step) {\n      /* ... */\n    }\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Testing for exact values runs the risk of a loop terminating much longer than expected or never terminating at all.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC22-C",
    "title": "Use the setjmp(), longjmp() facility securely",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC22-C.+Use+the+setjmp%28%29%2C+longjmp%28%29+facility+securely",
    "description": "The setjmp() macro should be invoked from only one of the contexts listed in subclause 7.13.2.1 of the C Standard [ ISO/IEC 9899:2024 ]. Invoking setjmp() outside of one of these contexts results in undefined behavior . (See undefined behavior 125 .)\n\nsetjmp()\n\nsetjmp()\n\nAfter invoking longjmp() , non-volatile-qualified local objects should not be accessed if their values could have changed since the invocation of setjmp() . Their value in this case is considered indeterminate , and accessing them is undefined behavior. (See undefined behaviors 127 and 10 .)\n\nlongjmp()\n\nsetjmp()\n\nThe longjmp() function should never be used to return control to a function that has terminated execution. (See undefined behavior 126 .)\n\nlongjmp()\n\nSignal masks, floating-point status flags, and the state of open files are not saved by the setjmp() function. If signal masks need to be saved, the POSIX sigsetjmp() function should be used.\n\nsetjmp()\n\nsigsetjmp()\n\nThis recommendation is related to SIG30-C. Call only asynchronous-safe functions within signal handlers and ENV32-C. All exit handlers must return normally .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example calls setjmp() in an assignment statement, resulting in undefined behavior :",
          "code": "jmp_buf buf;\n\nvoid f(void) {\n  int i = setjmp(buf);\n  if (i == 0) {\n    g();\n  } else {\n    /* longjmp was invoked */\n  }\n}\n\nvoid g(void) {\n  /* ... */\n  longjmp(buf, 1);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Placing the call to setjmp() in the if statement and, optionally, comparing it with a constant integer removes the undefined behavior, as shown in this compliant solution:",
          "code": "jmp_buf buf;\n\nvoid f(void) {\n  if (setjmp(buf) == 0) {\n    g();\n  } else {\n    /* longjmp was invoked */\n  }\n}\n\nvoid g(void) {\n  /* ... */\n  longjmp(buf, 1);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Any attempt to invoke the longjmp() function to transfer control to a function that has completed execution results in undefined behavior :",
          "code": "#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nstatic jmp_buf buf;\nstatic void bad(void);\n\nstatic void g(void) {\n  if (setjmp(buf) == 0) {\n    printf(\"setjmp() invoked\\n\");\n  } else {\n    printf(\"longjmp() invoked\\n\");\n  }\n}\n\nstatic void f(void) {\n  g();\n}\n\nstatic void setup(void) {\n  f();\n}\n\nvoid do_stuff(void) {\n  void (*b)(void) = bad;\n  /* ... */\n  longjmp(buf, 1);\n}\n\nstatic void bad(void) {\n  printf(\"Should not be called!\\n\");\n  exit(1);\n}\n\nint main(void) {\n  setup();\n  do_stuff();\n}",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The longjmp() function should be used only when the function containing the corresponding setjmp() is guaranteed not to have completed execution, as in the following example:",
          "code": "#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nstatic jmp_buf buf;\nstatic void bad(void);\n\nvoid do_stuff(void) {\n  void (*b)(void) = bad;\n  /* ... */\n  longjmp(buf, 1);\n}\n\nstatic void bad(void) {\n  printf(\"Should not be called!\\n\");\n  exit(1);\n}\n\nint main(void) {\n  if (setjmp(buf) == 0) {\n    printf(\"setjmp() invoked\\n\");\n  } else {\n    printf(\"longjmp() invoked\\n\");\n  }\n  do_stuff();\n} ",
          "explanation_after": "There is no risk of overwriting a return address because the stack frame of main() (the function that invoked setjmp() ) is still on the stack; so when do_stuff() is invoked, the two stack frames will not overlap."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, non-volatile-qualified objects local to the function that invoked the corresponding setjmp() have indeterminate values after longjmp() is executed if their value has been changed since the invocation of setjmp() :",
          "code": "jmp_buf buf;\n\nvoid f(void) {\n  int i = 0;\n  if (setjmp(buf) != 0) {\n    printf(\"%i\\n\", i);\n    /* ... */\n  }\n  i = 2;\n  g();\n}\n\nvoid g(void) {\n  /* ... */\n  longjmp(buf, 1);\n}\n",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "If an object local to the function that invoked setjmp() needs to be accessed after longjmp() returns control to the function, the object should be volatile-qualified:",
          "code": "jmp_buf buf;\n\nvoid f(void) {\n  volatile int i = 0;\n  if (setjmp(buf) != 0) {\n    printf(\"%i\\n\", i);\n    /* ... */\n  }\n  i = 2;\n  g();\n}\n\nvoid g(void) {\n  /* ... */\n  longjmp(buf, 1);\n}\n",
          "explanation_after": "This will now correctly print 2 regardless of optimization level."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC23-C",
    "title": "Beware of vendor-specific library and language differences",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC23-C.+Beware+of+vendor-specific+library+and+language+differences",
    "description": "When compiling with a specific vendor's implementation of the C language, and related libraries, be aware that, unfortunately, standards conformance can differ from vendor to vendor. Be certain to read your vendor's documentation to reduce the likelihood of accidentally relying on implementation-specific behavior or deviations.",
    "examples": null,
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC24-C",
    "title": "Do not use deprecated or obsolescent functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC24-C.+Do+not+use+deprecated+or+obsolescent+functions",
    "description": "Do not use deprecated or obsolescent functions when more secure equivalent functions are available. Deprecated functions are defined by the C Standard. Obsolescent functions are defined by this recommendation.\n\nDeprecated Functions\n\nThe gets() function was deprecated by Technical Corrigendum 3 to C99 and eliminated from C11.  The Annex K gets_s() function is a recommended alternative to gets() .\n\ngets()\n\ngets_s()\n\ngets()\n\nObsolescent Functions\n\nFunctions in the first column of the following table are hereby defined to be obsolescent functions . To remediate invocations of obsolescent functions, an application might use inline coding that, in all respects, conforms to this guideline, or an alternative library that, in all respects, conforms to this guideline, or alternative non-obsolescent functions .\n\nObsolescent Function Recommended Alternative Rationale asctime() asctime_s () Non-reentrant atof () strtod () No error detection atoi () strtol () No error detection atol () strtol () No error detection atoll () strtoll () No error detection ctime () ctime_s () Non-reentrant fopen () fopen_s () No exclusive access to file freopen () freopen_s () No exclusive access to file rewind () fseek () No error detection setbuf () setvbuf () No error detection\n\nasctime()\n\nasctime_s\n()\n\n()\n\natof\n()\n\n()\n\nstrtod\n()\n\n()\n\natoi\n()\n\n()\n\nstrtol\n()\n\n()\n\natol\n()\n\n()\n\nstrtol\n()\n\n()\n\natoll\n()\n\n()\n\nstrtoll\n()\n\n()\n\nctime\n()\n\n()\n\nctime_s\n()\n\n()\n\nfopen\n()\n\n()\n\nfopen_s\n()\n\n()\n\nfreopen\n()\n\n()\n\nfreopen_s\n()\n\n()\n\nrewind\n()\n\n()\n\nfseek\n()\n\n()\n\nsetbuf\n()\n\n()\n\nsetvbuf\n()\n\n()\n\nThe atof () , atoi () , atol () , and atoll () functions are obsolescent because the strtod () , strtof () , strtol () , strtold () , strtoll () , strtoul () , and strtoull () functions can emulate their usage and have more robust error handling capabilities. See INT05-C. Do not use input functions to convert character data if they cannot handle all possible inputs .\n\natof\n()\n, atoi\n()\n, atol\n()\n\n()\n\n()\n\n()\n\natoll\n()\n\n()\n\nstrtod\n()\n, strtof\n()\n, strtol\n()\n, strtold\n()\n, strtoll\n()\n, strtoul\n\n()\n\n()\n\n()\n\n()\n\n()\n\n()\n\nstrtoull\n()\n\n()\n\nThe fopen () and freopen () functions are obsolescent because the fopen_s () and freopen_s () functions can emulate their usage and improve security by protecting the file from unauthorized access by setting its file protection and opening the file with exclusive access [ ISO/IEC WG14 N1173 ].\n\nfopen\n()\n\n()\n\nfreopen\n()\n\n()\n\nfopen_s\n()\n\n()\n\nfreopen_s\n()\n\n()\n\nThe setbuf () function is obsolescent because setbuf () does not return a value and can be emulated using setvbuf () . See ERR07-C. Prefer functions that support error checking over equivalent functions that don't .\n\nsetbuf\n()\n\n()\n\nsetbuf\n()\n\n()\n\nsetvbuf\n()\n\n()\n\nThe rewind () function is obsolescent because rewind () does not return a value and can be emulated using fseek () . See ERR07-C. Prefer functions that support error checking over equivalent functions that don't .\n\nrewind\n()\n\n()\n\nrewind\n()\n\n()\n\nfseek\n()\n\n()\n\nThe asctime () and ctime () functions are obsolescent because they use non-reentrant static buffers and can be emulated using asctime_s () and ctime_s () .\n\nasctime\n()\n\n()\n\nctime\n()\n\n()\n\nasctime_s\n()\n\n()\n\nctime_s\n()\n\n()\n\nUnchecked Obsolescent Functions\n\nIf you are using platforms that support Annex K, then functions in the first column of the following table are hereby defined to be obsolescent functions, with functions in the second column being the recommended alternatives from Annex K.\n\nObsolescent Function Recommended Alternative bsearch() bsearch_s() fprintf() fprintf_s() fscanf() fscanf_s() fwprintf() fwprintf_s() fwscanf() fwscanf_s() getenv() getenv_s() gmtime() gmtime_s() localtime() localtime_s() mbsrtowcs() mbsrtowcs_s() mbstowcs() mbstowcs_s() memcpy() memcpy_s() memmove() memmove_s() printf() printf_s() qsort() qsort_s() scanf() scanf_s() snprintf() snprintf_s() sprintf() sprintf_s() sscanf() sscanf_s() strcat() strcat_s() strcpy() strcpy_s() strerror() strerror_s() strlen() strnlen_s() strncat() strncat_s() strncpy() strncpy_s() strtok() strtok_s() swprintf() swprintf_s() swscanf() swscanf_s() vfprintf() vfprintf_s() vfscanf() vfscanf_s() vfwprintf() vfwprintf_s() vfwscanf() vfwscanf_s() vprintf() vprintf_s() vscanf() vscanf_s() vsnprintf() vsnprintf_s() vsprintf() vsprintf_s() vsscanf() vsscanf_s() vswprintf() vswprintf_s() vswscanf() vswscanf_s() vwprintf() vwprintf_s() vwscanf() vwscanf_s() wcrtomb() wcrtomb_s() wcscat() wcscat_s() wcscpy() wcscpy_s() wcslen() wcsnlen_s() wcsncat() wcsncat_s() wcsncpy() wcsncpy_s() wcsrtombs() wcsrtombs_s() wcstok() wcstok_s() wcstombs() wcstombs_s() wctomb() wctomb_s() wmemcpy() wmemcpy_s() wmemmove() wmemmove_s() wprintf() wprintf_s() wscanf() wscanf_s()\n\nFor information on the tmpfile() and tmpfile_s() functions, see FIO21-C. Do not create temporary files in shared directories . For information on the memset() and memset_s() functions, see MSC06-C. Beware of compiler optimizations .\n\ntmpfile()\n\ntmpfile_s()\n\nmemset()\n\nmemset_s()\n\nTo remediate invocations of obsolescent functions, an application might use any of the following recommended functions from ISO/IEC TR 24731-2, Extensions to the C Library—Part II: Dynamic Allocation Functions [ ISO/IEC TR 24731-2 ]:\n\nasprintf aswprintf fmemopen fscanf fwscanf getdelim getline getwdelim getwline open_memstream open_wmemstream strdup strndup\n\nasprintf\n\naswprintf\n\nfmemopen\n\nfscanf\n\nfwscanf\n\ngetdelim\n\ngetline\n\ngetwdelim\n\ngetwline\n\nopen_memstream\n\nopen_wmemstream\n\nstrdup\n\nstrndup",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the obsolescent functions strcat() and strcpy() are used:",
          "code": "#include <string.h>\n#include <stdio.h>\n \nenum { BUFSIZE = 32 };\nvoid complain(const char *msg) {\n\n  static const char prefix[] = \"Error: \";\n  static const char suffix[] = \"\\n\";\n  char buf[BUFSIZE];\n\n  strcpy(buf, prefix);\n  strcat(buf, msg);\n  strcat(buf, suffix);\n  fputs(buf, stderr);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, strcat() and strcpy() are replaced by strcat_s() and strcpy_s() :",
          "code": "#define __STDC_WANT_LIB_EXT1__\n#include <string.h>\n#include <stdio.h>\n \nenum { BUFFERSIZE = 256 };\n\nvoid complain(const char *msg) {\n  static const char prefix[] = \"Error: \";\n  static const char suffix[] = \"\\n\";\n  char buf[BUFFERSIZE];\n\n  strcpy_s(buf, BUFFERSIZE, prefix);\n  strcat_s(buf, BUFFERSIZE, msg);\n  strcat_s(buf, BUFFERSIZE, suffix);\n  fputs(buf, stderr);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The deprecated and obsolescent functions enumerated in this guideline are commonly associated with software vulnerabilities .",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "MSC25-C",
    "title": "Do not use insecure or weak cryptographic algorithms",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC25-C.+Do+not+use+insecure+or+weak+cryptographic+algorithms",
    "description": "This rule is a stub.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example shows an example where ...",
          "code": null,
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, ...",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using insecure or weak cryptographic algorithms is not a good idea.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC30-C",
    "title": "Do not use the rand() function for generating pseudorandom numbers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC30-C.+Do+not+use+the+rand%28%29+function+for+generating+pseudorandom+numbers",
    "description": "Pseudorandom number generators use mathematical algorithms to produce a sequence of numbers with good statistical properties, but the numbers produced are not genuinely random.\n\nThe C Standard rand() function makes no guarantees as to the quality of the random sequence produced. The numbers generated by some implementations of rand() have a comparatively short cycle and the numbers can be predictable. Applications that have strong pseudorandom number requirements must use a generator that is known to be sufficient for their needs.\n\nrand()\n\nrand()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The following noncompliant code generates an ID with a numeric part produced by calling the rand() function. The IDs produced are predictable and have limited randomness.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nenum { len = 12 };\n \nvoid func(void) {\n  /*\n   * id will hold the ID, starting with the characters\n   *  \"ID\" followed by a random integer.\n   */\n  char id[len];  \n  int r;\n  int num;\n  /* ... */\n  r = rand();  /* Generate a random integer */\n  num = snprintf(id, len, \"ID%-d\", r);  /* Generate the ID */\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution replaces the rand() function with the POSIX random() function:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nenum { len = 12 }; \n\nvoid func(void) {\n  /*\n   * id will hold the ID, starting with the characters\n   *  \"ID\" followed by a random integer.\n   */\n  char id[len];  \n  int r;\n  int num;\n  /* ... */\n  struct timespec ts;\n  if (timespec_get(&ts, TIME_UTC) == 0) {\n    /* Handle error */\n  }\n  srandom(ts.tv_nsec ^ ts.tv_sec);  /* Seed the PRNG */\n  /* ... */\n  r = random();  /* Generate a random integer */\n  num = snprintf(id, len, \"ID%-d\", r);  /* Generate the ID */\n  /* ... */\n}",
          "explanation_after": "The POSIX random() function is a better pseudorandom number generator. Although on some platforms the low dozen bits generated by rand() go through a cyclic pattern, all the bits generated by random() are usable. The rand48 family of functions provides another alternative for pseudorandom numbers.\n\nAlthough not specified by POSIX, arc4random() is another possibility for systems that support it. The arc4random(3) manual page [ OpenBSD ] states\n\n... provides higher quality of data than those described in rand(3), random(3), and drand48(3).\n\nTo achieve the best random numbers possible, an implementation -specific function must be used. When unpredictability is crucial and speed is not an issue, as in the creation of strong cryptographic keys, use a true entropy source, such as /dev/random , or a hardware device capable of generating random numbers. The /dev/random device can block for a long time if there are not enough events going on to generate sufficient entropy."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The following noncompliant code generates an ID with a numeric part produced by calling the rand() function. The IDs produced are predictable and have limited randomness.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nenum { len = 12 };\n \nvoid func(void) {\n  /*\n   * id will hold the ID, starting with the characters\n   *  \"ID\" followed by a random integer.\n   */\n  char id[len];  \n  int r;\n  int num;\n  /* ... */\n  r = rand();  /* Generate a random integer */\n  num = snprintf(id, len, \"ID%-d\", r);  /* Generate the ID */\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "On Windows platforms, the BCryptGenRandom() function can be used to generate cryptographically strong random numbers. The Microsoft Developer Network BCryptGenRandom() reference [ MSDN ] states:\n\nThe default random number provider implements an algorithm for generating random numbers that complies with the NIST SP800-90 standard, specifically the CTR_DRBG portion of that standard.",
          "code": "#include <Windows.h>\n#include <bcrypt.h>\n#include <stdio.h>\n\n#pragma comment(lib, \"Bcrypt\")\n\nvoid func(void) {\n  BCRYPT_ALG_HANDLE Prov;\n  int Buffer;\n  if (!BCRYPT_SUCCESS(\n          BCryptOpenAlgorithmProvider(&Prov, BCRYPT_RNG_ALGORITHM,\n                                      NULL, 0))) {\n    /* handle error */\n  }\n  if (!BCRYPT_SUCCESS(BCryptGenRandom(Prov, (PUCHAR) (&Buffer),\n                                      sizeof(Buffer), 0))) {\n    /* handle error */\n  }\n  printf(\"Random number: %d\\n\", Buffer);\n  BCryptCloseAlgorithmProvider(Prov, 0);\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The use of the rand() function can result in predictable random numbers.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC32-C",
    "title": "Properly seed pseudorandom number generators",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC32-C.+Properly+seed+pseudorandom+number+generators",
    "description": "A pseudorandom number generator (PRNG) is a deterministic algorithm capable of generating sequences of numbers that approximate the properties of random numbers. Each sequence is completely determined by the initial state of the PRNG and the algorithm for changing the state. Most PRNGs make it possible to set the initial state, also called the seed state . Setting the initial state is called seeding the PRNG.\n\nCalling a PRNG in the same initial state, either without seeding it explicitly or by seeding it with the same value, results in generating the same sequence of random numbers in different runs of the program. Consider a PRNG function that is seeded with some initial seed value and is consecutively called to produce a sequence of random numbers, S . If the PRNG is subsequently seeded with the same initial seed value, then it will generate the same sequence S .\n\nS\n\nS\n\nAs a result, after the first run of an improperly seeded PRNG, an attacker can predict the sequence of random numbers that will be generated in the future runs. Improperly seeding or failing to seed the PRNG can lead to vulnerabilities , especially in security protocols.\n\nThe solution is to ensure that the PRNG is always properly seeded. A properly seeded PRNG will generate a different sequence of random numbers each time it is run.\n\nNot all random number generators can be seeded. True random number generators that rely on hardware to produce completely unpredictable results do not need to be and cannot be seeded. Some high-quality PRNGs, such as the /dev/random device on some UNIX systems, also cannot be seeded. This rule applies only to algorithmic pseudorandom number generators that can be seeded.\n\n/dev/random",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "This noncompliant code example generates a sequence of 10 pseudorandom numbers using the random() function. When random() is not seeded, it behaves like rand() , producing the same sequence of random numbers each time any program that uses it is run.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nvoid func(void) {\n  for (unsigned int i = 0; i < 10; ++i) {\n    /* Always generates the same sequence */\n    printf(\"%ld, \", random());\n  }\n}",
          "explanation_after": "The output is as follows:"
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "Call srandom() before invoking random() to seed the random sequence generated by random() . This compliant solution produces different random number sequences each time the function is called, depending on the resolution of the system clock:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n \nvoid func(void) {\n  struct timespec ts;\n  if (timespec_get(&ts, TIME_UTC) == 0) {\n    /* Handle error */\n  } else {\n    srandom(ts.tv_nsec ^ ts.tv_sec);\n    for (unsigned int i = 0; i < 10; ++i) {\n      /* Generates different sequences at different runs */\n      printf(\"%ld, \", random());\n    }\n  }\n}\n",
          "explanation_after": "The output is as follows:\n\nThis may not be sufficiently random for concurrent execution, which may lead to correlated generated series in different threads. Depending on the application and the desired level of security, a programmer may choose alternative ways to seed PRNGs. In general, hardware is more capable than software of generating real random numbers (for example, by sampling the thermal noise of a diode)."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "This noncompliant code example generates a sequence of 10 pseudorandom numbers using the random() function. When random() is not seeded, it behaves like rand() , producing the same sequence of random numbers each time any program that uses it is run.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nvoid func(void) {\n  for (unsigned int i = 0; i < 10; ++i) {\n    /* Always generates the same sequence */\n    printf(\"%ld, \", random());\n  }\n}",
          "explanation_after": "The output is as follows:"
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "The BCryptGenRandom() function does not run the risk of not being properly seeded because its arguments serve as seeders:",
          "code": "#include <stdio.h>\n#include <Windows.h>\n#include <Bcrypt.h>\n#include <Ntstatus.h>\n#include <Wincrypt.h>\n\nvoid func(void) {\n  BCRYPT_ALG_HANDLE hAlgorithm = NULL;\n  long rand_buf;\n  PUCHAR pbBuffer = (PUCHAR) &rand_buf;\n  ULONG cbBuffer = sizeof(rand_buf);\n  ULONG dwFlags = BCRYPT_USE_SYSTEM_PREFERRED_RNG;\n  NTSTATUS status;\n  for (unsigned int i = 0; i < 10; ++i) {\n    status = BCryptGenRandom(hAlgorithm, pbBuffer, cbBuffer, dwFlags);\n    if (status == STATUS_SUCCESS) {\n      printf(\"%ld, \", rand_buf);\n    } else {\n      /* Handle Error */\n    }\n  }\n}\n",
          "explanation_after": "The output is as follows:"
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "MSC33-C",
    "title": "Do not pass invalid data to the asctime() function",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC33-C.+Do+not+pass+invalid+data+to+the+asctime%28%29+function",
    "description": "The C Standard, 7.29.3.1 [ ISO/IEC 9899:2024 ], provides the following sample implementation of the asctime() function:\n\nasctime()\n\nchar *asctime(const struct tm *timeptr) {\n  static const char wday_name[7][3] = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n  };\n  static const char mon_name[12][3] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n  };\n  static char result[26];\n  sprintf(\n    result, \n    \"%.3s %.3s%3d %.2d:%.2d:%.2d %d\\n\",\n    wday_name[timeptr->tm_wday],\n    mon_name[timeptr->tm_mon],\n    timeptr->tm_mday, timeptr->tm_hour,\n    timeptr->tm_min, timeptr->tm_sec,\n    1900 + timeptr->tm_year\n  );\n  return result;\n}\n\nchar *asctime(const struct tm *timeptr) {\n  static const char wday_name[7][3] = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n  };\n  static const char mon_name[12][3] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n  };\n  static char result[26];\n  sprintf(\n    result, \n    \"%.3s %.3s%3d %.2d:%.2d:%.2d %d\\n\",\n    wday_name[timeptr->tm_wday],\n    mon_name[timeptr->tm_mon],\n    timeptr->tm_mday, timeptr->tm_hour,\n    timeptr->tm_min, timeptr->tm_sec,\n    1900 + timeptr->tm_year\n  );\n  return result;\n}\n\nThis function is supposed to output a character string of 26 characters at most, including the terminating null character. If we count the length indicated by the format directives, we arrive at 25. Taking into account the terminating null character, the array size of the string appears sufficient.\n\nHowever, this implementation assumes that the values of the struct tm data are within normal ranges and does nothing to enforce the range limit. If any of the values print more characters than expected, the sprintf() function may overflow the result array. For example, if tm_year has the value 12345, then 27 characters (including the terminating null character) are printed, resulting in a buffer overflow.\n\nstruct tm\n\nsprintf()\n\nresult\n\ntm_year\n\n12345,\n\nThe POSIX ® Base Specifications [ IEEE Std 1003.1:2013 ] says the following about the asctime() and asctime_r() functions:\n\nasctime()\n\nasctime_r()\n\nThese functions are included only for compatibility with older implementations. They have undefined behavior if the resulting string would be too long, so the use of these functions should be discouraged. On implementations that do not detect output string length overflow, it is possible to overflow the output buffers in such a way as to cause applications to fail, or possible system security violations. Also, these functions do not support localized date and time formats. To avoid these problems, applications should use strftime() to generate strings from broken-down times.\n\nstrftime()\n\nThe asctime() function appears in the list of obsolescent functions in MSC24-C. Do not use deprecated or obsolescent functions .\n\nasctime()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example invokes the asctime() function with potentially unsanitized data:",
          "code": "#include <time.h>\n \nvoid func(struct tm *time_tm) {\n  char *time = asctime(time_tm);\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( strftime() )",
          "pre_code_commentary": "The strftime() function allows the programmer to specify a more rigorous format and also to specify the maximum size of the resulting time string:",
          "code": "#include <time.h>\n\nenum { maxsize = 26 };\n \nvoid func(struct tm *time) {\n  char s[maxsize];\n  /* Current time representation for locale */\n  const char *format = \"%c\";\n\n  size_t size = strftime(s, maxsize, format, time);\n}",
          "explanation_after": "This call has the same effects as asctime() but also ensures that no more than maxsize characters are printed, preventing buffer overflow."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "On implementations that do not detect output-string-length overflow, it is possible to overflow the output buffers.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MSC37-C",
    "title": "Ensure that control never reaches the end of a non-void function",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC37-C.+Ensure+that+control+never+reaches+the+end+of+a+non-void+function",
    "description": "If control reaches the closing curly brace ( } ) of a non- void function without evaluating a return statement, using the return value of the function call is undefined behavior. (See undefined behavior 86 .)\n\n}\n\nvoid\n\nreturn",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, control reaches the end of the checkpass() function when the two strings passed to strcmp() are not equal, resulting in undefined behavior. Many compilers will generate code for the checkpass() function, returning various values along the execution path where no return statement is defined.",
          "code": "#include <string.h>\n#include <stdio.h>\n \nint checkpass(const char *password) {\n  if (strcmp(password, \"pass\") == 0) {\n    return 1;\n  }\n}\n\nvoid func(const char *userinput) {\n  if (checkpass(userinput)) {\n    printf(\"Success\\n\");\n  }\n}",
          "explanation_after": "This error is frequently diagnosed by compilers. (See MSC00-C. Compile cleanly at high warning levels .)"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution ensures that the checkpass() function always returns a value:",
          "code": "#include <string.h>\n#include <stdio.h>\n \nint checkpass(const char *password) {\n  if (strcmp(password, \"pass\") == 0) {\n    return 1;\n  }\n  return 0;\n}\n\nvoid func(const char *userinput) {\n  if (checkpass(userinput)) {\n    printf(\"Success!\\n\");\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, control reaches the end of the getlen() function when input does not contain the integer delim . Because the potentially undefined return value of getlen() is later used as an index into an array, a buffer overflow may occur.",
          "code": "#include <stddef.h>\n \nsize_t getlen(const int *input, size_t maxlen, int delim) {\n  for (size_t i = 0; i < maxlen; ++i) {\n    if (input[i] == delim) {\n      return i;\n    }\n  }\n}\n \nvoid func(int userdata) {\n  size_t i;\n  int data[] = { 1, 1, 1 };\n  i = getlen(data, sizeof(data), 0);\n  data[i] = userdata;\n}",
          "explanation_after": "Violating this rule can have unexpected consequences, as in the following example:\n\nWhen this program is compiled with -Wall on most versions of the GCC compiler, the following warning is generated:\n\nNone of the inputs to the function equal the delimiter, so when run with GCC 5.3 on Linux, control reaches the end of the getlen() function, which is undefined behavior and in this test returns 3 , causing an out-of-bounds write to the data array."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution changes the interface of getlen() to store the result in a user-provided pointer and returns a status indicator to report success or failure. The best method for handling this type of error is specific to the application and the type of error. (See ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy for more on error handling.)",
          "code": "#include <stddef.h>\n \nint getlen(const int *input, size_t maxlen, int delim,\n           size_t *result) {\n  if (result == NULL) {\n    return -1;\n  }\n  for (size_t i = 0; i < maxlen; ++i) {\n    if (input[i] == delim) {\n      *result = i;\n      return 0;\n    }\n  }\n  return -1;\n}\n\nvoid func(int userdata) {\n  size_t i;\n  int data[] = {1, 1, 1};\n  if (getlen(data, sizeof(data), 0, &i) != 0) {\n    /* Handle error */\n  } else {\n    data[i] = userdata;\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using the return value from a non- void function where control reaches the end of the function without evaluating a return statement can lead to buffer overflow vulnerabilities as well as other unexpected program behaviors .",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MSC38-C",
    "title": "Do not treat a predefined identifier as an object if it might only be implemented as a macro",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC38-C.+Do+not+treat+a+predefined+identifier+as+an+object+if+it+might+only+be+implemented+as+a+macro",
    "description": "The C Standard, 7.1.4 paragraph 1, [ ISO/IEC 9899:2024 ] states\n\nAny function declared in a header may be additionally implemented as a function-like macro defined in the header, so if a library function is declared explicitly when its header is included, one of the techniques shown later in the next subclause can be used to ensure the declaration is not affected by such a macro. Any macro definition of a function can be suppressed locally by enclosing the name of the function in parentheses, because the name is then not followed by the left parenthesis that indicates expansion of a macro function name. For the same syntactic reason, it is permitted to take the address of a library function even if it is also defined as a macro. 220) The use of #undef to remove any macro definition will also ensure that an actual function is referred to. 220) This means that an implementation is required to provide an actual function for each library function, even if it also provides a macro for that function.\n\nHowever, the C Standard enumerates specific exceptions in which the behavior of accessing an object or function expanded to be a standard library macro definition is undefined . The macros are assert , errno , math_errhandling , setjmp , va_arg , va_copy , va_end , and va_start . These cases are described by undefined behaviors 138 , 139 , 140 , 141 , and 143 . Programmers must not suppress these macros to access the underlying object or function.\n\nassert\n\nerrno\n\nmath_errhandling\n\nsetjmp\n\nva_arg\n\nva_copy\n\nva_end\n\nva_start",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( assert )",
          "pre_code_commentary": "In this noncompliant code example, the standard assert() macro is suppressed in an attempt to pass it as a function pointer to the execute_handler() function. Attempting to suppress the assert() macro is undefined behavior .",
          "code": "#include <assert.h>\n \ntypedef void (*handler_type)(int);\n \nvoid execute_handler(handler_type handler, int value) {\n  handler(value);\n}\n \nvoid func(int e) {\n  execute_handler(&(assert), e < 0);\n} ",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( assert )",
          "pre_code_commentary": "In this compliant solution, the assert() macro is wrapped in a helper function, removing the undefined behavior :",
          "code": "#include <assert.h>\n \ntypedef void (*handler_type)(int);\n \nvoid execute_handler(handler_type handler, int value) {\n  handler(value);\n}\n \nstatic void assert_handler(int value) {\n  assert(value);\n}\n \nvoid func(int e) {\n  execute_handler(&assert_handler, e < 0);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Redefining errno )",
          "pre_code_commentary": "Legacy code is apt to include an incorrect declaration, such as the following in this noncompliant code example:",
          "code": "extern int errno;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Declaring errno )",
          "pre_code_commentary": "This compliant solution demonstrates the correct way to declare errno by including the header <errno.h> :",
          "code": "#include <errno.h>\n",
          "explanation_after": "C-conforming implementations are required to declare errno in <errno.h> , although some historic implementations failed to do so."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Accessing objects or functions underlying the specific macros enumerated in this rule is undefined behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC39-C",
    "title": "Do not call va_arg() on a va_list that has an indeterminate value",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC39-C.+Do+not+call+va_arg%28%29+on+a+va_list+that+has+an+indeterminate+value",
    "description": "Variadic functions access their variable arguments by using va_start() to initialize an object of type va_list , iteratively invoking the va_arg() macro, and finally calling va_end() . The va_list may be passed as an argument to another function, but calling va_arg() within that function causes the va_list to have an indeterminate value in the calling function. As a result, attempting to read variable arguments without reinitializing the va_list can have unexpected behavior . According to the C Standard, 7.16, paragraph 3 [ ISO/IEC 9899:2024 ],\n\nva_start()\n\nva_list\n\nva_arg()\n\nva_end()\n\nva_list\n\nva_arg()\n\nva_list\n\nva_list\n\nIf access to the varying arguments is desired, the called function shall declare an object (generally referred to as ap in this subclause) having type va_list. The object ap may be passed as an argument to another function; if that function invokes the va_arg macro with parameter ap, the representation of ap in the calling function is indeterminate and shall be passed to the va_end macro prior to any further reference to ap. 295) A pointer to a va _ list can be created and passed to another function, in which case the original function can make further use of the original list after the other function returns.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to check that none of its variable arguments are zero by passing a va_list to helper function contains_zero() . After the call to contains_zero() , the value of ap is indeterminate .",
          "code": "#include <stdarg.h>\n#include <stdio.h>\n \nint contains_zero(size_t count, va_list ap) {\n  for (size_t i = 1; i < count; ++i) {\n    if (va_arg(ap, double) == 0.0) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint print_reciprocals(size_t count, ...) {\n  va_list ap;  \n  va_start(ap, count);\n\n  if (contains_zero(count, ap)) {\n    va_end(ap);\n    return 1;\n  }\n\n  for (size_t i = 0; i < count; ++i) {\n    printf(\"%f \", 1.0 / va_arg(ap, double));\n  }\n\n  va_end(ap);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution modifies contains_zero() to take a pointer to a va_list . It then uses the va_copy macro to make a copy of the list, traverses the copy, and cleans it up. Consequently, the print_reciprocals() function is free to traverse the original va_list .",
          "code": "#include <stdarg.h>\n#include <stdio.h>\n \nint contains_zero(size_t count, va_list *ap) {\n  va_list ap1;\n  va_copy(ap1, *ap);\n  for (size_t i = 1; i < count; ++i) {\n    if (va_arg(ap1, double) == 0.0) {\n      return 1;\n    }\n  }\n  va_end(ap1);\n  return 0;\n}\n \nint print_reciprocals(size_t count, ...) {\n  int status;\n  va_list ap;\n  va_start(ap, count);\n \n  if (contains_zero(count, &ap)) {\n    printf(\"0 in arguments!\\n\");\n    status = 1;\n  } else {\n    for (size_t i = 0; i < count; i++) {\n      printf(\"%f \", 1.0 / va_arg(ap, double));\n    }\n    printf(\"\\n\");\n    status = 0;\n  }\n \n  va_end(ap);\n  return status;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Reading variable arguments using a va_list that has an indeterminate value can have unexpected results.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC40-C",
    "title": "Do not violate constraints",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC40-C.+Do+not+violate+constraints",
    "description": "According to the C Standard, 3.8 [ ISO/IEC 9899:2011 ], a constraint is a \"restriction, either syntactic or semantic, by which the exposition of language elements is to be interpreted.\"  Despite the similarity of the terms, a runtime constraint is not a kind of constraint.\n\nViolating any shall statement within a constraint clause in the C Standard requires an implementation to issue a diagnostic message, the C Standard, 5.1.1.3 [ ISO/IEC 9899:2011 ] states\n\nA conforming implementation shall produce at least one diagnostic message (identified in an implementation-defined manner) if a preprocessing translation unit or translation unit contains a violation of any syntax rule or constraint, even if the behavior is also explicitly specified as undefined or implementation-defined. Diagnostic messages need not be produced in other circumstances.\n\nThe C Standard further explains in a footnote\n\nThe intent is that an implementation should identify the nature of, and where possible localize, each violation. Of course, an implementation is free to produce any number of diagnostics as long as a valid program is still correctly translated. It may also successfully translate an invalid program.\n\nAny constraint violation is a violation of this rule because it can result in an invalid program.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Inline, Internal Linkage)",
          "pre_code_commentary": "The C Standard, 6.7.4, paragraph 3 [ ISO/IEC 9899:2011 ], states\n\nAn inline definition of a function with external linkage shall not contain a definition of a modifiable object with static or thread storage duration, and shall not contain a reference to an identifier with internal linkage.\n\nThe motivation behind this constraint lies in the semantics of inline definitions. Paragraph 7 of subclause 6.7.4 reads, in part:\n\nAn inline definition provides an alternative to an external definition, which a translator may use to implement any call to the function in the same translation unit. It is unspecified whether a call to the function uses the inline definition or the external definition.\n\nThat is, if a function has an external and inline definition, implementations are free to choose which definition to invoke (two distinct invocations of the function may call different definitions, one the external definition, the other the inline definition). Therefore, issues can arise when these definitions reference internally linked objects or mutable objects with static or thread storage duration.\n\nThis noncompliant code example refers to a static variable with file scope and internal linkage from within an external inline function:",
          "code": "static int I = 12;\nextern inline void func(int a) {\n  int b = a * I;\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Inline, Internal Linkage)",
          "pre_code_commentary": "This compliant solution omits the static qualifier;  consequently,  the variable I has external linkage by default:",
          "code": "int I = 12;\nextern inline void func(int a) {\n  int b = a * I;\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (inline, Modifiable Static)",
          "pre_code_commentary": "This noncompliant code example defines a modifiable static variable within an extern inline function.",
          "code": "extern inline void func(void) {\n  static int I = 12;\n  /* Perform calculations which may modify I */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Inline, Modifiable Static)",
          "pre_code_commentary": "This compliant solution removes the static keyword from the local variable definition. If the modifications to I must be retained between invocations of func() , it must be declared at file scope so that it will be defined with external linkage.",
          "code": "extern inline void func(void) {\n  int I = 12;\n  /* Perform calculations which may modify I */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Inline, Modifiable static )",
          "pre_code_commentary": "This noncompliant code example includes two translation units: file1.c and file2.c . The first file, file1.c , defines a pseudorandom number generation function:",
          "code": "/* file1.c */\n\n/* Externally linked definition of the function get_random() */\nextern unsigned int get_random(void) {\n  /* Initialize the seeds */\n  static unsigned int m_z = 0xdeadbeef;\n  static unsigned int m_w = 0xbaddecaf;\n\n  /* Compute the next pseudorandom value and update the seeds */\n  m_z = 36969 * (m_z & 65535) + (m_z >> 16);\n  m_w = 18000 * (m_w & 65535) + (m_w >> 16);\n  return (m_z << 16) + m_w;\n}\n",
          "explanation_after": "The left-shift operation in the last line may wrap, but this is permitted by exception INT30-C-EX3 to rule INT30-C. Ensure that unsigned integer operations do not wrap .\n\nThe second file, file2.c , defines an inline version of this function that references mutable static objects—namely, objects that maintain the state of the pseudorandom number generator. Separate invocations of the get_random() function can call different definitions, each operating on separate static objects, resulting in a faulty pseudorandom number generator."
        },
        "compliant": {
          "heading": "Compliant Solution (Inline, Modifiable static )",
          "pre_code_commentary": "This compliant solution adds the static modifier to the inline function definition in file2.c , giving it internal linkage. All references to get_random() in file.2.c will now reference the internally linked definition. The first file, which was not changed, is not shown here.",
          "code": "/* file2.c */\n\n/* Static inline definition of get_random function */\nstatic inline unsigned int get_random(void) {\n  /* \n   * Initialize the seeds. \n   * No more constraint violation; the inline function is now \n   * internally linked. \n   */\n  static unsigned int m_z = 0xdeadbeef;\n  static unsigned int m_w = 0xbaddecaf;\n\n  /* Compute the next pseudorandom value and update the seeds  */\n  m_z = 36969 * (m_z & 65535) + (m_z >> 16);\n  m_w = 18000 * (m_w & 65535) + (m_w >> 16);\n  return (m_z << 16) + m_w;\n}\n\nint main(void) {\n  /* Generate pseudorandom numbers using get_random()... */\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Constraint violations are a broad category of error that can result in unexpected control flow and corrupted data.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC41-C",
    "title": "Never hard code sensitive information",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/MSC41-C.+Never+hard+code+sensitive+information",
    "description": "Hard coding sensitive information, such as passwords or encryption keys can expose the information to attackers. Anyone who has access to the executable or dynamic library files can examine them for strings or other critical data, revealing the sensitive information. Leaking data protected by International Traffic in Arms Regulations (ITAR) or the Health Insurance Portability and Accountability Act ( HIPAA) can also have legal consequences. Consequently, programs must not hard code sensitive information.\n\nHard coding sensitive information also increases the need to manage and accommodate changes to the code. For example, changing a hard-coded password in a deployed program may require distribution of a patch [ Chess 2007 ].",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Hard-Coded Database Password)",
          "pre_code_commentary": "This noncompliant code example must authenticate to a remote service with a code, using the authenticate() function declared below. It passes the authentication code to this function as a string literal.",
          "code": "/* Returns nonzero if authenticated */\nint authenticate(const char* code);\n\nint main() {\n  if (!authenticate(\"correct code\")) {\n    printf(\"Authentication error\\n\");\n    return -1;\n  }\n\n  printf(\"Authentication successful\\n\");\n  // ...Work with system...\n  return 0;\n}\n",
          "explanation_after": "The authentication code exists in the program's binary executable and can be easily discovered.\n\nMany Unix platforms provide a strings utility that prints out all of the ASCII strings in a binary file. Here is the output of running strings on this program, on an Ubuntu 16.04 platform:"
        },
        "compliant": {
          "heading": "Compliant Solution (C23, memset_explicit() )",
          "pre_code_commentary": "This compliant solution requires the user to supply the authentication code, and securely erases it when done, using memset_explicit() .",
          "code": "/* Returns nonzero if authenticated */\nint authenticate(const char* code);\n\nint main() {\n#define CODE_LEN 50\n  char code[CODE_LEN];\n  printf(\"Please enter your authentication code:\\n\");\n  fgets(code, sizeof(code), stdin);\n  int flag = authenticate(code);\n  memset_explicit(code, 0, sizeof(code));\n  if (!flag) {\n    printf(\"Access denied\\n\");\n    return -1;\n  }\n  printf(\"Access granted\\n\");\n  // ...Work with system...\n  return 0;\n}\n",
          "explanation_after": "Alternatively, the program could read the authentication code from a file, letting file system security protect the file and the code from untrusted users."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Hard coding sensitive information exposes that information to attackers. The severity of this rule can vary depending on the kind of information that is disclosed. Frequently, the information disclosed is password or key information, which can lead to remote exploitation. Consequently, a high severity rating is given but may be adjusted downwards according to the nature of the sensitive data.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "POS01-C",
    "title": "Check for the existence of links when dealing with files",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS01-C.+Check+for+the+existence+of+links+when+dealing+with+files",
    "description": "Many common operating systems such as Windows and UNIX support file links, including hard links, symbolic (soft) links, and virtual drives. Hard links can be created in UNIX with the ln command or in Windows operating systems by calling the CreateHardLink() function. Symbolic links can be created in UNIX using the ln -s command or in Windows by using directory junctions in NTFS or the Linkd.exe (Win 2K resource kit) or \"junction\" freeware. Virtual drives can also be created in Windows using the subst command.\n\nln\n\nCreateHardLink()\n\nln -s\n\nsubst\n\nFile links can create security issues for programs that fail to consider the possibility that the file being opened may actually be a link to a different file. This is especially dangerous when the vulnerable program is running with elevated privileges.\n\nFrequently, there is no need to check for the existence of symbolic links because this problem can be solved using other techniques. When opening an existing file, for example, the simplest solution is often to drop privileges to the privileges of the user. This solution permits the use of links while preventing access to files for which the user of the application is not privileged.\n\nWhen creating new files, it may be possible to use functions that create a new file only where a file does not already exist. This prevents the application from overwriting an existing file during file creation. (See FIO03-C. Do not make assumptions about fopen() and file creation .)\n\nIn rare cases, it is necessary to check for the existence of symbolic or hard links to ensure that a program is reading from an intended file and not a different file in another directory. In these cases, avoid creating a race condition when checking for the existence of symbolic links. (See POS35-C. Avoid race conditions while checking for the existence of a symbolic link .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example opens the file specified by the string file_name for read/write access and then writes user-supplied data to the file:",
          "code": "char *file_name = /* something */;\nchar *userbuf = /* something */;\nunsigned int userlen = /* length of userbuf string */;\n\nint fd = open(file_name, O_RDWR);\nif (fd == -1) {\n   /* handle error */\n}\nwrite(fd, userbuf, userlen);\n",
          "explanation_after": "If the process is running with elevated privileges, an attacker can exploit this code, for example, by replacing the file with a symbolic link to the /etc/passwd authentication file. The attacker can then overwrite data stored in the password file to create a new root account with no password. As a result, this attack can be used to gain root privileges on a vulnerable system."
        },
        "compliant": {
          "heading": "Compliant Solution (Linux 2.1.126+, FreeBSD, Solaris 10, POSIX.1-2008 O_NOFOLLOW )",
          "pre_code_commentary": "Some systems provide the O_NOFOLLOW flag to help mitigate this problem. The flag is required by the POSIX.1-2008 standard and so will become more portable over time [ Open Group 2008 ]. If the flag is set and the supplied file_name is a symbolic link, then the open will fail.",
          "code": "char *file_name = /* something */;\nchar *userbuf = /* something */;\nunsigned int userlen = /* length of userbuf string */;\n\nint fd = open(file_name, O_RDWR | O_NOFOLLOW);\nif (fd == -1) {\n  /* handle error */\n}\nwrite(fd, userbuf, userlen);\n",
          "explanation_after": "Note that this compliant solution does not check for hard links."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example opens the file specified by the string file_name for read/write access and then writes user-supplied data to the file:",
          "code": "char *file_name = /* something */;\nchar *userbuf = /* something */;\nunsigned int userlen = /* length of userbuf string */;\n\nint fd = open(file_name, O_RDWR);\nif (fd == -1) {\n   /* handle error */\n}\nwrite(fd, userbuf, userlen);\n",
          "explanation_after": "If the process is running with elevated privileges, an attacker can exploit this code, for example, by replacing the file with a symbolic link to the /etc/passwd authentication file. The attacker can then overwrite data stored in the password file to create a new root account with no password. As a result, this attack can be used to gain root privileges on a vulnerable system."
        },
        "compliant": {
          "heading": "Compliant Solution ( lstat - fopen - fstat )",
          "pre_code_commentary": "This compliant solution uses the lstat - fopen - fstat idiom illustrated in FIO05-C. Identify files using multiple file attributes :",
          "code": "char *file_name = /* some value */;\n\nstruct stat orig_st;\nif (lstat( file_name, &orig_st) != 0) {\n  /* handle error */\n}\n\nif (!S_ISREG( orig_st.st_mode)) {\n  /* file is irregular or symlink */\n}\n\nint fd = open(file_name, O_RDWR);\nif (fd == -1) {\n  /* handle error */\n}\n\nstruct stat new_st;\nif (fstat(fd, &new_st) != 0) {\n  /* handle error */\n}\n\nif (orig_st.st_dev != new_st.st_dev ||\n    orig_st.st_ino != new_st.st_ino) {\n  /* file was tampered with during race window */\n}\n\n/* ... file is good, operate on fd ... */\n",
          "explanation_after": "This code is still subject to a time-of-check, time-of-use (TOCTOU) race condition, but before doing any operation on the file, it verifies that the file opened is the same file as was previously checked (by checking the file's device and i-node.) As a result, the code will recognize if an attacker has tampered with the file during the race window and can operate accordingly.\n\nNote that this code does not check for hard links.\n\nHard links are problematic because if a file has multiple hard links, it is impossible to distinguish the original link from one that might have been created by a malicious attacker.\n\nOne way to deal with hard links is simply to disallow opening of any file with two or more hard links. The following code snippet, when inserted into the previous example, will identify if a file has multiple hard links:\n\nBecause a hard link may not be created if the link and the linked-to file are on different devices, many platforms place system-critical files on a different device from the one where user-editable files are kept. For instance, the / directory, which contains critical system files like /etc/passwd , would live on one hard drive, while the /home directory, which contains user-editable files, would reside on a separate hard drive. This prevents users, for example, from creating hard links to /etc/passwd ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to check for the existence of links can result in a critical system file being overwritten, leading to data integrity violations.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "POS02-C",
    "title": "Follow the principle of least privilege",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS02-C.+Follow+the+principle+of+least+privilege",
    "description": "The principle of least privilege states that every program and every user of the system should operate using the least set of privileges necessary to complete the job [ Saltzer 1974 , Saltzer 1975 ]. The Build Security In website [ DHS 2006 ] provides additional definitions of this principle. Executing with minimal privileges mitigates against exploitation in case a vulnerability is discovered in the code.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Privileged operations are often required in a program, though the program might not need to retain the special privileges. For instance, a network program may require superuser privileges to capture raw network packets but may not require the same set of privileges for carrying out other tasks such as packet analysis. Dropping or elevating privileges alternately according to program requirements is a good design strategy. Moreover, assigning only the required privileges limits the window of exposure for any privilege escalation exploit to succeed.\n\nConsider a custom service that must bind to a well-known port (below 1024). To prevent malicious entities from hijacking client connections, the kernel imposes a condition so that only the superuser can use the bind() system call to bind to these ports.\n\nThis noncompliant code example is configured as setuid-superuser. It calls bind() and later forks out a child to perform the bookkeeping tasks. The program continues to run with superuser privileges even after the bind() operation is completed.",
          "code": "int establish(void) {\n  struct sockaddr_in sa; /* listening socket's address */\n  int s; /* listening socket */\n\n  /*  Fill up the structure with address and port number  */\n\n  sa.sin_port = htons(portnum);\n\n  /*  Other system calls like socket()  */\n\n  if (bind(s, (struct sockaddr *)&sa,\n        sizeof(struct sockaddr_in)) < 0) {\n    /* Perform cleanup */\n  }\n\n  /* Return */\n}\n\nint main(void) {\n  int s = establish();\n\n  /*  Block with accept() until a client connects  */\n\n  switch (fork()) {\n    case -1 :  /* Error, clean up and quit */\n    case  0 :  /* This is the child, handle the client */\n    default :  /* This is the parent, continue blocking */\n  }\n  return 0;\n}\n",
          "explanation_after": "If a vulnerability is exploited in the main body of the program that allows an attacker to execute arbitrary code, this malicious code will run with elevated privileges."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The program must follow the principle of least privilege while carefully separating the binding and bookkeeping tasks. To minimize the chance of a flaw in the program from compromising the superuser-level account, it should drop superuser privileges as soon as the privileged operations are completed. In the following code, privileges are permanently dropped as soon as the bind() operation is carried out. The code also ensures privileges may not be regained after being permanently dropped, as in POS37-C. Ensure that privilege relinquishment is successful .",
          "code": "/*  Code with elevated privileges  */\n\nint establish(void) {\n  struct sockaddr_in sa; /* listening socket's address */\n  int s; /* listening socket */\n\n  /* Fill up the structure with address and port number */\n\n  sa.sin_port = htons(portnum);\n\n  /* Other system calls like socket() */\n\n  if (bind(s, (struct sockaddr *)&sa,\n        sizeof(struct sockaddr_in)) < 0) {\n    /* Perform cleanup */\n  }\n\n  /* Return */\n}\n\nint main(void) {\n  int s = establish();\n\n  /* Drop privileges permanently */\n  if (setuid(getuid()) == -1) {\n     /*  Handle the error  */\n  }\n\n  if (setuid(0) != -1) {\n    /* Privileges can be restored, handle error */\n  }\n\n  /* Block with accept() until a client connects */\n\n  switch (fork()) {\n    case -1: /* Error, clean up and quit */\n    case  0: /* Close all open file descriptors\n              * This is the child, handle the client\n              */\n    default: /* This is the parent, continue blocking */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to follow the principle of least privilege may allow exploits to execute with elevated privileges.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "POS04-C",
    "title": "Avoid using PTHREAD_MUTEX_NORMAL type mutex locks",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS04-C.+Avoid+using+PTHREAD_MUTEX_NORMAL+type+mutex+locks",
    "description": "Pthread mutual exclusion (mutex) locks are used to avoid simultaneous usage of common resources. Several types of mutex locks are defined by pthreads: NORMAL , ERRORCHECK , RECURSIVE , and DEFAULT .\n\nNORMAL\n\nERRORCHECK\n\nRECURSIVE\n\nDEFAULT\n\nPOSIX describes PTHREAD_MUTEX_NORMAL locks as having the following undefined behavior [ Open Group 2004 ]:\n\nPTHREAD_MUTEX_NORMAL\n\nThis type of mutex does not provide deadlock detection. A thread attempting to relock this mutex without first unlocking it shall deadlock. An error is not returned to the caller. Attempting to unlock a mutex locked by a different thread results in undefined behavior. Attempting to unlock an unlocked mutex results in undefined behavior.\n\nThe DEFAULT mutex pthread is also generally mapped to PTHREAD_MUTEX_NORMAL but is known to vary from platform to platform [ SOL 2010 ]. Consequently, NORMAL locks should not be used, and ERRORCHECK or RECURSIVE locks should be defined explicitly when mutex locks are used.\n\nDEFAULT\n\nPTHREAD_MUTEX_NORMAL\n\nNORMAL\n\nERRORCHECK\n\nRECURSIVE",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example shows a simple mutex being created using PTHREAD_MUTEX_NORMAL . Note that the caller does not expect a return code when NORMAL mutex locks are used.",
          "code": "pthread_mutexattr_t attr;\npthread_mutex_t mutex;\nsize_t const shared_var = 0;\n\nint main(void) {\n  int result;\n\n  if ((result = pthread_mutexattr_init(&attr)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutex_init(&mutex, &attr)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  /* Critical Region*/\n\n  if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution shows an ERRORCHECK mutex lock being created so that return codes will be available during locking and unlocking:",
          "code": "pthread_mutexattr_t attr;\npthread_mutex_t mutex;\nsize_t const shared_var = 0;\n\nint main(void) {\n  int result;\n\n  if ((result = pthread_mutexattr_init(&attr)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutex_init(&mutex, &attr)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  /* Critical Region*/\n\n  if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using NORMAL mutex locks can lead to deadlocks or abnormal program termination.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS05-C",
    "title": "Limit access to files by creating a jail",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS05-C.+Limit+access+to+files+by+creating+a+jail",
    "description": "Creating a jail isolates a program from the rest of the file system. The idea is to create a sandbox, so entities the program does not need to access under normal operation are made inaccessible. This makes it much harder to abuse any vulnerability that can otherwise lead to unconstrained system compromise and consequently functions as a defense-in-depth strategy. A jail may consist of world-viewable programs that require fewer resources to execute than those that exist on that system. Jails are useful only when there is no way to elevate privileges in the event of program failure.\n\nAdditionally, care must be taken to ensure that all the required resources (libraries, files, and so on) are replicated within the jail directory and that no reference is made to other parts of the file system from within this directory. It is also advisable to administer restrictive read/write permissions on the jail directories and resources on the basis of the program's privilege requirements. Although creating jails is an effective security measure when used correctly, it is not a surrogate for compliance with the other rules and recommendations in this standard.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "A security flaw exists in this noncompliant code example resulting from the absence of proper canonicalization measures on the file path. This allows an attacker to traverse the file system and possibly write to a file of the attacker's choice with the privileges of the vulnerable program. For example, it may be possible to overwrite the password file (such as the /etc/passwd , common to many POSIX-based systems) or a device file, such as the mouse, which in turn can aid further exploitation or cause a denial of service to occur.",
          "code": "enum { array_max = 100 };\n\n/*\n * Program running with elevated privileges where argv[1]\n * and argv[2] are supplied by the user\n */\n\nchar x[array_max];\nFILE *fp = fopen(argv[1], \"w\");\n\nstrncpy(x, argv[2], array_max);\nx[array_max - 1] = '\\0';\n\n/*\n * Write operation to an unintended file such as /etc/passwd\n * gets executed\n */\nif (fwrite(x, sizeof(x[0]), sizeof(x)/sizeof(x[0]), fp) <\n    sizeof(x)/sizeof(x[0])) {\n  /* Handle error */\n}\n",
          "explanation_after": "An attacker can control the value of argv[1] and consequently access any resource on the file system.\n\nThis noncompliant code example also violates FIO02-C. Canonicalize path names originating from tainted sources and FIO03-C. Do not make assumptions about fopen() and file creation ."
        },
        "compliant": {
          "heading": "Compliant Solution (UNIX)",
          "pre_code_commentary": "Some UNIX-based systems (such as OpenBSD) can restrict file system access by creating a chroot() jail. The chroot() jail requires care to implement securely [ Wheeler 2003 ]. It is achieved by passing a predefined directory name as an argument to chroot() . The call to chroot() requires superuser privileges. However, this call does not leave the process inside the jail directory as might be expected. A subsequent chdir() is required to restrict access to the jail boundaries.\n\nAnother essential step is to drop superuser privileges permanently after these calls (see POS02-C. Follow the principle of least privilege ). The chroot() system call is not secure against the superuser changing the current root directory (if privileges are not dropped). Successful jail creation prevents unintentional file system access even if an attacker gives malicious input, such as through command-line arguments.",
          "code": "/*\n * Make sure that the chroot/jail directory exists within\n * the current working directory. Also assign appropriate\n * permissions to the directory to restrict access. Close\n * all file system descriptors to outside resources lest\n * they escape the jail.\n */\n\nif (setuid(0) == -1) {\n  /* Handle error */\n}\n\nif (chroot(\"chroot/jail\") == -1) {\n  /* Handle error */\n}\n\nif (chdir(\"/\") == -1) {\n  /* Handle error */\n}\n\n/* Drop privileges permanently */\nif (setgid(getgid()) == -1) {\n  /* Handle error */\n}\n\nif (setuid(getuid()) == -1) {\n  /* Handle error */\n}\n\n/* Perform unprivileged operations */\nenum {array_max = 100};\n\nFILE *fp = fopen(argv[1], \"w\");\nchar x[array_max];\nstrncpy(x, argv[2], array_max);\nx[array_max - 1] = '\\0';\n\n/* Write operation is safe within jail */\nif (fwrite(x, sizeof(x[0]), sizeof(x)/sizeof(x[0]), fp) <\n    sizeof(x)/sizeof(x[0])) {\n  /* Handle error */\n}\n",
          "explanation_after": "An alternative sequence is to first call chdir(\"chroot/jail\") and then call chroot(\".\") . However, calling chdir(\"/some/path\") , then chroot(\"/some/path\") , should be avoided because this sequence may be susceptible to a race condition: an attacker with sufficient privileges can arrange for /some/path to refer to different directories in the two system calls. Consequently, the program will not have its current working directory set to the new root directory. Using either chdir(\"/\") after chroot() or chroot(\".\") after chdir() guarantees that the current working directory will be the same directory as the new root."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to follow this recommendation may lead to full-system compromise if a file system vulnerability is discovered and exploited.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS30-C",
    "title": "Use the readlink() function properly",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS30-C.+Use+the+readlink%28%29+function+properly",
    "description": "The readlink() function reads where a link points to. It makes no effort to null-terminate its second argument, buffer . Instead, it just returns the number of characters it has written.\n\nreadlink()\n\nbuffer",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "If len is equal to sizeof(buf) , the null terminator is written 1 byte past the end of buf :",
          "code": "char buf[1024];\nssize_t len = readlink(\"/usr/bin/perl\", buf, sizeof(buf));\nbuf[len] = '\\0';\n",
          "explanation_after": "An incorrect solution to this problem is to try to make buf large enough that it can always hold the result:\n\nThis modification incorrectly assumes that the symbolic link cannot be longer than the value of SYMLINK_MAX returned by pathconf() . However, the value returned by pathconf() is out of date by the time readlink() is called, so the off-by-one buffer-overflow risk is still present because, between the two calls, the location of /usr/bin/perl can change to a file system with a larger SYMLINK_MAX value. Also, if SYMLINK_MAX is indeterminate (that is, if pathconf() returned -1 without setting errno ), the code uses an arbitrary large buffer size (10,000) that it hopes will be sufficient, but there is a small chance that readlink() can return exactly this size.\n\nAn additional issue is that readlink() can return -1 if it fails, causing an off-by-one underflow."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution ensures there is no overflow by reading in only sizeof(buf)-1 characters. It also properly checks to see if an error has occurred:",
          "code": "enum { BUFFERSIZE = 1024 };\nchar buf[BUFFERSIZE];\nssize_t len = readlink(\"/usr/bin/perl\", buf, sizeof(buf)-1);\n\nif (len != -1) {\n  buf[len] = '\\0';\n}\nelse {\n  /* handle error condition */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to properly null-terminate the result of readlink() can result in abnormal program termination and buffer-overflow vulnerabilities.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "POS34-C",
    "title": "Do not call putenv() with a pointer to an automatic variable as the argument",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS34-C.+Do+not+call+putenv%28%29+with+a+pointer+to+an+automatic+variable+as+the+argument",
    "description": "The POSIX function putenv() is used to set environment variable values. The putenv() function does not create a copy of the string supplied to it as an argument; rather, it inserts a pointer to the string into the environment array. If a pointer to a buffer of automatic storage duration is supplied as an argument to putenv() , the memory allocated for that buffer may be overwritten when the containing function returns and stack memory is recycled. This behavior is noted in the Open Group Base Specifications, Issue 6 [ Open Group 2004 ]:\n\nputenv()\n\nputenv()\n\nputenv()\n\nA potential error is to call putenv() with an automatic variable as the argument, then return from the calling function while string is still part of the environment.\n\nputenv()\n\nstring\n\nThe actual problem occurs when passing a pointer to an automatic variable to putenv() . An automatic pointer to a static buffer would work as intended.\n\nputenv()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a pointer to a buffer of automatic storage duration is used as an argument to putenv() [ Dowd 2006 ]. The TEST environment variable may take on an unintended value if it is accessed after func() has returned and the stack frame containing env has been recycled.\n\nNote that this example also violates DCL30-C. Declare objects with appropriate storage durations .",
          "code": "int func(const char *var) {\n  char env[1024];\n  int retval = snprintf(env, sizeof(env),\"TEST=%s\", var);\n  if (retval < 0 || (size_t)retval >= sizeof(env)) {\n    /* Handle error */\n  }\n\n  return putenv(env);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( static )",
          "pre_code_commentary": "This compliant solution uses a static array for the argument to putenv() .",
          "code": "int func(const char *var) {\n  static char env[1024];\n\n  int retval = snprintf(env, sizeof(env),\"TEST=%s\", var);\n  if (retval < 0 || (size_t)retval >= sizeof(env)) {\n    /* Handle error */\n  }\n\n  return putenv(env);\n}\n",
          "explanation_after": "According to the [ Open Group 2004 ] entry for putenv() :\n\n...the string pointed to by string shall become part of the environment, so altering the string shall change the environment.\n\nThis means that the call to putenv() is only necessary the first time func() is called, since subsequent changes to the string update the environment. If func() were called more than once, an additional variable could be added to avoid calling it unnecessarily."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a pointer to a buffer of automatic storage duration is used as an argument to putenv() [ Dowd 2006 ]. The TEST environment variable may take on an unintended value if it is accessed after func() has returned and the stack frame containing env has been recycled.\n\nNote that this example also violates DCL30-C. Declare objects with appropriate storage durations .",
          "code": "int func(const char *var) {\n  char env[1024];\n  int retval = snprintf(env, sizeof(env),\"TEST=%s\", var);\n  if (retval < 0 || (size_t)retval >= sizeof(env)) {\n    /* Handle error */\n  }\n\n  return putenv(env);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Heap Memory)",
          "pre_code_commentary": "This compliant solution dynamically allocates memory for the argument to putenv() :",
          "code": "int func(const char *var) {\n  const char *env_format = \"TEST=%s\";\n  const size_t len = strlen(var) + strlen(env_format);\n  char *env = (char *) malloc(len);\n  if (env == NULL) {\n    return -1;\n  }\n  int retval = snprintf(env, len, env_format, var);\n  if (retval < 0 || (size_t)retval >= len) {\n    /* Handle error */\n  }\n  if (putenv(env) != 0) {\n    free(env);\n    return -1;\n  }\n  return 0;\n}\n",
          "explanation_after": "The POSIX setenv() function is preferred over this function [ Open Group 2004 ]. In particular, using putenv() will necessarily leak memory if called multiple times for the same environment variable, due to restrictions on when you can safely free the old value. According to the [ Open Group 2004 ] entry for putenv() :\n\nAlthough the space used by string is no longer used once a new string which defines name is passed to putenv (), if any thread in the application has used getenv () to retrieve a pointer to this variable, it should not be freed by calling free () . If the changed environment variable is one known by the system (such as the locale environment variables) the application should never free the buffer used by earlier calls to putenv () for the same variable."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a pointer to a buffer of automatic storage duration is used as an argument to putenv() [ Dowd 2006 ]. The TEST environment variable may take on an unintended value if it is accessed after func() has returned and the stack frame containing env has been recycled.\n\nNote that this example also violates DCL30-C. Declare objects with appropriate storage durations .",
          "code": "int func(const char *var) {\n  char env[1024];\n  int retval = snprintf(env, sizeof(env),\"TEST=%s\", var);\n  if (retval < 0 || (size_t)retval >= sizeof(env)) {\n    /* Handle error */\n  }\n\n  return putenv(env);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( setenv() )",
          "pre_code_commentary": "The setenv() function allocates heap memory for environment variables, which eliminates the possibility of accessing volatile stack memory:",
          "code": "int func(const char *var) {\n  return setenv(\"TEST\", var, 1);\n}\n",
          "explanation_after": "Using setenv() is easier and consequently less error prone than using putenv() ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Providing a pointer to a buffer of automatic storage duration as an argument to putenv() may cause that buffer to take on an unintended value. Depending on how and when the buffer is used, it can cause unexpected program behavior or possibly allow an attacker to run arbitrary code.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "POS35-C",
    "title": "Avoid race conditions while checking for the existence of a symbolic link",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS35-C.+Avoid+race+conditions+while+checking+for+the+existence+of+a+symbolic+link",
    "description": "Many common operating systems, such as Windows and UNIX, support symbolic (soft) links. Symbolic links can be created in UNIX using the ln -s command or in Windows by using directory junctions in NTFS or the Linkd.exe (Win 2K resource kit) or \"junction\" freeware.\n\nln -s\n\nIf not properly performed, checking for the existence of symbolic links can lead to race conditions.\n\nThis rule is a specific instance of rule FIO45-C. Avoid TOCTOU race conditions while accessing files .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The POSIX lstat() function collects information about a symbolic link rather than its target. This noncompliant code example uses the lstat() function to collect information about the file, checks the st_mode field to determine if the file is a symbolic link, and then opens the file if it is not a symbolic link:",
          "code": "char *filename = /* file name */;\nchar *userbuf = /* user data */;\nunsigned int userlen = /* length of userbuf string */;\n\nstruct stat lstat_info;\nint fd;\n/* ... */\nif (lstat(filename, &lstat_info) == -1) {\n  /* Handle error */\n}\n\nif (!S_ISLNK(lstat_info.st_mode)) {\n   fd = open(filename, O_RDWR);\n   if (fd == -1) {\n       /* Handle error */\n   }\n}\nif (write(fd, userbuf, userlen) < userlen) {\n  /* Handle error */\n}\n",
          "explanation_after": "This code contains a time-of-check, time-of-use (TOCTOU) race condition between the call to lstat() and the subsequent call to open() because both functions operate on a file name that can be manipulated asynchronously to the execution of the program. (See FIO01-C. Be careful using functions that use file names for identification .)"
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX.1-2008 or newer)",
          "pre_code_commentary": "This compliant solution eliminates the race condition by using O_NOFOLLOW to cause open() to fail if passed a symbolic link, avoiding the TOCTOU by not having a separate \"check\" and \"use\":",
          "code": "char *filename = /* file name */;\nchar *userbuf = /* user data */;\nunsigned int userlen = /* length of userbuf string */;\n\nint fd = open(filename, O_RDWR|O_NOFOLLOW);\nif (fd == -1) {\n  /* Handle error */\n}\nif (write(fd, userbuf, userlen) < userlen) {\n  /* Handle error */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The POSIX lstat() function collects information about a symbolic link rather than its target. This noncompliant code example uses the lstat() function to collect information about the file, checks the st_mode field to determine if the file is a symbolic link, and then opens the file if it is not a symbolic link:",
          "code": "char *filename = /* file name */;\nchar *userbuf = /* user data */;\nunsigned int userlen = /* length of userbuf string */;\n\nstruct stat lstat_info;\nint fd;\n/* ... */\nif (lstat(filename, &lstat_info) == -1) {\n  /* Handle error */\n}\n\nif (!S_ISLNK(lstat_info.st_mode)) {\n   fd = open(filename, O_RDWR);\n   if (fd == -1) {\n       /* Handle error */\n   }\n}\nif (write(fd, userbuf, userlen) < userlen) {\n  /* Handle error */\n}\n",
          "explanation_after": "This code contains a time-of-check, time-of-use (TOCTOU) race condition between the call to lstat() and the subsequent call to open() because both functions operate on a file name that can be manipulated asynchronously to the execution of the program. (See FIO01-C. Be careful using functions that use file names for identification .)"
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX.1-2001 or older)",
          "pre_code_commentary": "This compliant solution eliminates the race condition by\n\nCalling lstat() on the file name. Calling open() to open the file. Calling fstat() on the file descriptor returned by open() . Comparing the file information returned by the calls to lstat() and fstat() to ensure that the files are the same.",
          "code": "char *filename = /* file name */;\nchar *userbuf = /* user data */;\nunsigned int userlen = /* length of userbuf string */;\n\nstruct stat lstat_info;\nstruct stat fstat_info;\nint fd;\n/* ... */\nif (lstat(filename, &lstat_info) == -1) {\n  /* handle error */\n}\n\nfd = open(filename, O_RDWR);\nif (fd == -1) {\n  /* handle error */\n}\n\nif (fstat(fd, &fstat_info) == -1) {\n  /* handle error */\n}\n\nif (lstat_info.st_mode == fstat_info.st_mode &&\n    lstat_info.st_ino == fstat_info.st_ino  &&\n    lstat_info.st_dev == fstat_info.st_dev) {\n  if (write(fd, userbuf, userlen) < userlen) {\n    /* Handle Error */\n  }\n}\n",
          "explanation_after": "This code eliminates the TOCTOU condition because fstat() is applied to file descriptors, not file names, so the file passed to fstat() must be identical to the file that was opened. The lstat() function does not follow symbolic links, but open() does. Comparing modes using the st_mode field is sufficient to check for a symbolic link.\n\nComparing i-nodes, using the st_ino fields, and devices, using the st_dev fields, ensures that the file passed to lstat() is the same as the file passed to fstat() . (See FIO05-C. Identify files using multiple file attributes .)"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "TOCTOU race condition vulnerabilities can be exploited to gain elevated privileges.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P 9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "POS36-C",
    "title": "Observe correct revocation order while relinquishing privileges",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS36-C.+Observe+correct+revocation+order+while+relinquishing+privileges",
    "description": "In case of set-user-ID and set-group-ID programs, when the effective user ID and group ID are different from those of the real user, it is important to drop not only the user-level privileges but also the group privileges. While doing so, the order of revocation must be correct.\n\nPOSIX defines setgid() to have the following behavior [ Open Group 2004 ]:\n\nsetgid()\n\nIf the process has appropriate privileges, setgid() shall set the real group ID, effective group ID, and the saved set-group-ID of the calling process to gid . If the process does not have appropriate privileges, but gid is equal to the real group ID or the saved set-group-ID, setgid() shall set the effective group ID to gid ; the real group ID and saved set-group-ID shall remain unchanged.\n\nsetgid()\n\ngid\n\ngid\n\nsetgid()\n\ngid",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example drops privileges to those of the real user and similarly drops the group privileges. However, the order is incorrect because the setgid() function must be run with superuser privileges, but the call to setuid() leaves the effective user ID as nonzero. As a result, if a vulnerability is discovered in the program that allows for the execution of arbitrary code, an attacker can regain the original group privileges.",
          "code": "/* Drop superuser privileges in incorrect order */\n\nif (setuid(getuid()) == -1) {\n  /* handle error condition */\n}\nif (setgid(getgid()) == -1) {\n  /* handle error condition */\n}\n\n/* It is still possible to regain group privileges due to\n * incorrect relinquishment order */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution relinquishes group privileges before taking away the user-level privileges so that both operations execute as intended.",
          "code": "/*  Drop superuser privileges in correct order */\n\nif (setgid(getgid()) == -1) {\n  /* handle error condition */\n}\nif (setuid(getuid()) == -1) {\n  /* handle error condition */\n}\n\n/*\n * Not possible to regain group privileges due to correct relinquishment order\n */\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to observe the correct revocation order while relinquishing privileges allows an attacker to regain elevated privileges.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "POS37-C",
    "title": "Ensure that privilege relinquishment is successful",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS37-C.+Ensure+that+privilege+relinquishment+is+successful",
    "description": "The POSIX setuid() function has complex semantics and platform-specific behavior [ Open Group 2004 ].\n\nsetuid()\n\nIf the process has appropriate privileges, setuid() shall set the real user ID, effective user ID, and the saved set-user-ID of the calling process to uid . If the process does not have appropriate privileges, but uid is equal to the real user ID or the saved set-user-ID, setuid() shall set the effective user ID to uid ; the real user ID and saved set-user-ID shall remain unchanged.\n\nsetuid()\n\nuid\n\nuid\n\nsetuid()\n\nuid\n\nThe meaning of \"appropriate privileges\" varies from platform to platform. For example, on Solaris, appropriate privileges for setuid() means that the PRIV_PROC_SETID privilege is in the effective privilege set of the process. On BSD, it means that the effective user ID (EUID) is zero (that is, the process is running as root) or that uid=geteuid() . On Linux, it means that the process has CAP_SETUID capability and that setuid(geteuid()) will fail if the EUID is not equal to 0, the real user ID (RUID), or the saved set-user ID (SSUID).\n\nsetuid()\n\nPRIV_PROC_SETID\n\nuid=geteuid()\n\nCAP_SETUID\n\nsetuid(geteuid())\n\nBecause of this complex behavior, desired privilege drops sometimes may fail. For example, the range of Linux Kernel versions (2.2.0–2.2.15) is vulnerable to an insufficient privilege attack wherein setuid(getuid() did not drop privileges as expected when the capability bits were set to zero. As a precautionary measure, subtle behavior and error conditions for the targeted implementation must be carefully noted.\n\nsetuid(getuid()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example compiles cleanly on most POSIX systems, but no explicit checks are made to ensure that privilege relinquishment has succeeded. This may be dangerous depending on the sequence of the preceding privilege changes.",
          "code": "/* Code intended to run with elevated privileges */\n\n/* Temporarily drop privileges */\nif (seteuid(getuid()) != 0) {\n  /* Handle error */\n}\n\n/* Code intended to run with lower privileges */\n\nif (need_more_privileges) {\n  /* Restore privileges */\n  if (seteuid(0) != 0) {\n    /* Handle error */\n  }\n\n  /* Code intended to run with elevated privileges */\n}\n\n/* ... */\n\n/* Permanently drop privileges */\nif (setuid(getuid()) != 0) {\n  /* Handle error */\n}\n\n/*\n * Code intended to run with lower privileges,\n * but if privilege relinquishment failed,\n * attacker can regain elevated privileges!\n */\n",
          "explanation_after": "If the program is run as a setuid root program, over time, the state of the UIDs might look like the following:\n\nDescription\n\nCode\n\nEUID\n\nRUID\n\nSSUID\n\nProgram startup\n\n0\n\nUser\n\nTemporary drop\n\nseteuid(getuid())\n\nRestore\n\nseteuid(0)\n\nPermanent drop\n\nsetuid(getuid())\n\nRestore (attacker)\n\nsetuid(0) (fails)\n\nIf the program fails to restore privileges, it will be unable to permanently drop them later:\n\nsetuid(0)"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution was implemented in sendmail, a popular mail transfer agent, to determine if superuser privileges were successfully dropped [ Wheeler 2003 ]. If the setuid() call succeeds after (supposedly) dropping privileges permanently, then the privileges were not dropped as intended.",
          "code": "/* Code intended to run with elevated privileges   */\n\n/* Temporarily drop privileges */\nif (seteuid(getuid()) != 0) {\n  /* Handle error */\n}\n\n/* Code intended to run with lower privileges */\n\nif (need_more_privileges) {\n  /* Restore Privileges */\n  if (seteuid(0) != 0) {\n    /* Handle error */\n  }\n\n  /* Code intended to run with elevated privileges */\n}\n\n/* ... */\n\n/* Permanently drop privileges */\nif (setuid(getuid()) != 0) {\n  /* Handle error */\n}\n\nif (setuid(0) != -1) {\n  /* Privileges can be restored, handle error */\n}\n\n/*\n * Code intended to run with lower privileges;\n * attacker cannot regain elevated privileges\n */\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example compiles cleanly on most POSIX systems, but no explicit checks are made to ensure that privilege relinquishment has succeeded. This may be dangerous depending on the sequence of the preceding privilege changes.",
          "code": "/* Code intended to run with elevated privileges */\n\n/* Temporarily drop privileges */\nif (seteuid(getuid()) != 0) {\n  /* Handle error */\n}\n\n/* Code intended to run with lower privileges */\n\nif (need_more_privileges) {\n  /* Restore privileges */\n  if (seteuid(0) != 0) {\n    /* Handle error */\n  }\n\n  /* Code intended to run with elevated privileges */\n}\n\n/* ... */\n\n/* Permanently drop privileges */\nif (setuid(getuid()) != 0) {\n  /* Handle error */\n}\n\n/*\n * Code intended to run with lower privileges,\n * but if privilege relinquishment failed,\n * attacker can regain elevated privileges!\n */\n",
          "explanation_after": "If the program is run as a setuid root program, over time, the state of the UIDs might look like the following:\n\nDescription\n\nCode\n\nEUID\n\nRUID\n\nSSUID\n\nProgram startup\n\n0\n\nUser\n\nTemporary drop\n\nseteuid(getuid())\n\nRestore\n\nseteuid(0)\n\nPermanent drop\n\nsetuid(getuid())\n\nRestore (attacker)\n\nsetuid(0) (fails)\n\nIf the program fails to restore privileges, it will be unable to permanently drop them later:\n\nsetuid(0)"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "A better solution is to ensure that proper privileges exist before attempting to perform a permanent drop:",
          "code": "/* Store the privileged ID for later verification */\nuid_t privid = geteuid();\n\n/* Code intended to run with elevated privileges   */\n\n/* Temporarily drop privileges */\nif (seteuid(getuid()) != 0) {\n  /* Handle error */\n}\n\n/* Code intended to run with lower privileges  */\n\nif (need_more_privileges) {\n  /* Restore Privileges */\n  if (seteuid(privid) != 0) {\n    /* Handle error */\n  }\n\n  /* Code intended to run with elevated privileges   */\n}\n\n/* ... */\n\n/* Restore privileges if needed */\nif (geteuid() != privid) {\n  if (seteuid(privid) != 0) {\n    /* Handle error */\n  }\n}\n\n/* Permanently drop privileges */\nif (setuid(getuid()) != 0) {\n  /* Handle error */\n}\n\nif (setuid(0) != -1) {\n  /* Privileges can be restored, handle error */\n}\n\n/*\n * Code intended to run with lower privileges;\n * attacker cannot regain elevated privileges\n */\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "If privilege relinquishment conditions are left unchecked, any flaw in the program may lead to unintended system compromise corresponding to the more privileged user or group account.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "POS38-C",
    "title": "Beware of race conditions when using fork and file descriptors",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS38-C.+Beware+of+race+conditions+when+using+fork+and+file+descriptors",
    "description": "When forking a child process, file descriptors are copied to the child process, which can result in concurrent operations on the file. Concurrent operations on the same file can cause data to be read or written in a nondeterministic order, creating race conditions and unpredictable behavior.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this example, the programmer wishes to open a file, read a character, fork, and then have both parent and child process read the second character of the file independently. However, because both processes share a file descriptor, one process might get the second character, and one might get the third. Furthermore, there is no guarantee the reads are atomic—the processes might get unpredictable results. Regardless of what the programmer is trying to accomplish with this code, this code is incorrect because it contains a race condition.",
          "code": "char c;\npid_t pid;\n\nint fd = open(filename, O_RDWR);\nif (fd == -1) {\n  /* Handle error */\n}\nread(fd, &c, 1);\nprintf(\"root process:%c\\n\",c);\n\npid = fork();\nif (pid == -1) {\n  /* Handle error */\n}\n\nif (pid == 0) { /*child*/\n  read(fd, &c, 1);\n  printf(\"child:%c\\n\",c);\n}\nelse { /*parent*/\n  read(fd, &c, 1);\n  printf(\"parent:%c\\n\",c);\n}\n",
          "explanation_after": "If the file accessed has contents \"abc\" , the output of this program could be either\n\nor\n\nThis code's output cannot reliably be determined and should not be used."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the programmer closes the file descriptor in the child after forking and then reopens it, ensuring that the file has not been modified in the meantime. See POS01-C. Check for the existence of links when dealing with files for details.",
          "code": "char c;\n\npid_t pid;\n\n/* Open file and remember file status  */\nstruct stat orig_st;\nif (lstat( filename, &orig_st) != 0) {\n  /* handle error */\n}\nint fd = open(filename, O_RDWR);\nif (fd == -1) {\n  /* Handle error */\n}\nstruct stat new_st;\nif (fstat(fd, &new_st) != 0) {\n  /* handle error */\n}\nif (orig_st.st_dev != new_st.st_dev ||\n    orig_st.st_ino != new_st.st_ino) {\n  /* file was tampered with while opening */\n}\n\n/* file is good, operate on fd */\n\nread(fd,&c,1);\nprintf(\"root process:%c\\n\",c);\n\npid = fork();\nif (pid == -1) {\n  /* Handle error */\n}\n\nif (pid == 0){ /*child*/\n  close(fd);\n\n  /* Reopen file, creating new file descriptor */\n  fd = open(filename, O_RDONLY);\n  if (fd == -1) {\n    /* Handle error */\n  }\n  if (fstat(fd, &new_st) != 0) {\n    /* handle error */\n  }\n  if (orig_st.st_dev != new_st.st_dev ||\n      orig_st.st_ino != new_st.st_ino) {\n    /* file was tampered with between opens */\n  }\n\n  read(fd, &c, 1);\n  read(fd, &c, 1);\n  printf(\"child:%c\\n\", c);\n  close(fd);\n}\n\nelse { /*parent*/\n  read(fd, &c, 1);\n  printf(\"parent:%c\\n\", c);\n  close(fd);\n}\n",
          "explanation_after": "The output of this code is"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Because race conditions in code are extremely hard to find, this problem might not appear during standard debugging stages of development. However, depending on what file is being read and how important the order of read operations is, this problem can be particular dangerous.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS39-C",
    "title": "Use the correct byte ordering when transferring data between systems",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS39-C.+Use+the+correct+byte+ordering+when+transferring+data+between+systems",
    "description": "Different system architectures use different byte ordering, either little endian (least significant byte first) or big endian (most significant byte first). IA-32 is an example of an architecture that implements little endian byte ordering. In contrast, PowerPC and most Network Protocols (including TCP and IP) use big endian.\n\nWhen transferring data between systems of different endianness, the programmer must take care to reverse the byte ordering before interpreting the data.\n\nThe functions htonl() , htons() , ntohl() , and ntohs() can be used to transfer between network byte ordering (big endian) and the host's byte ordering. On big endian systems, these functions do nothing. They may also be implemented as macros rather than functions.\n\nhtonl()\n\nhtons()\n\nntohl()\n\nntohs()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the programmer tries to read an unsigned 32-bit integer off a previously connected network socket.\n\nIt is important to know the sizes of your data types lest they be different on architectures that are accessible over the network. Hence, we transfer a uint32_t rather than an int . For more information, see FIO09-C. Be careful with binary data when transferring data across systems .",
          "code": "/* sock is a connected TCP socket */\n\nuint32_t num;\n\nif (recv(sock, (void *)&num, sizeof(uint32_t), 0) < (int)sizeof(uint32_t)) {\n  /* Handle error */\n}\n\nprintf(\"We received %u from the network!\\n\", (unsigned int)num);\n",
          "explanation_after": "This program prints out the number received from the socket using an incorrect byte ordering. For example, if the value 4 is sent from a big endian machine, and the receiving system is little endian, the value 536,870,912 is read. This problem can be corrected by sending and receiving using network byte ordering."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the programmer uses the ntohl() function to convert the integer from network byte order to host byte ordering:",
          "code": "/* sock is a connected TCP socket */\n\nuint32_t num;\n\nif (recv(sock, (void *)&num, sizeof(uint32_t), 0) < (int)sizeof(uint32_t)) {\n  /* Handle error */\n}\n\nnum = ntohl(num);\nprintf(\"We recieved %u from the network!\\n\", (unsigned int)num);\n",
          "explanation_after": "The ntohl() function (network to host long) translates a uint32_t value into the host byte ordering from the network byte ordering. This function is always appropriate to use because its implementation depends on the specific system's byte ordering. Consequently, on a big endian architecture, ntohl() does nothing.\n\nThe reciprocal function htonl() (host to network long) should be used before sending any data to another system over network protocols.\n\nntohs() , ntohl() , htons() , and htonl() are not part of the C Standard and are consequently not guaranteed to be portable to non-POSIX systems. The POSIX implementations of ntohs() , ntohl() , htons() , and htonl() take arguments of types uint16_t and uint32_t and can be found in the header file <arpa/inet.h> . The Windows implementations use unsigned short and unsigned long and can be found in the header file <winsock2.h> . Other variants of ntoht() and htont() , such as ntohi() / htoni() or ntohll() / htonll() , may exist on some systems."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "If the programmer is careless, this bug is likely. However, it will immediately break the program by printing the incorrect result and therefore should be caught by the programmer during the early stages of debugging and testing. Recognizing a value as in reversed byte ordering, however, can be difficult depending on the type and magnitude of the data.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "POS44-C",
    "title": "Do not use signals to terminate threads",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS44-C.+Do+not+use+signals+to+terminate+threads",
    "description": "Do not send an uncaught signal to kill a thread because the signal kills the entire process, not just the individual thread. This rule is a specific instance of SIG02-C. Avoid using signals to implement normal functionality . In POSIX systems, using the signal() function in a multithreaded program falls under exception CON37C-C-EX0 of rule CON37-C. Do not call signal() in a multithreaded program . Noncompliant Code Example This code uses the pthread_kill() function to send a SIGTERM signal to the created thread. The thread receives the signal, and the entire process is terminated. void func(void *foo) {\n  /* Execution of thread */\n}\n\nint main(void) {\n  int result;\n  pthread_t thread;\n\n  if ((result = pthread_create(&thread, NULL, func, 0)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_kill(thread, SIGTERM)) != 0) {\n    /* Handle Error */\n  }\n\n  /* This point is not reached because the process terminates in pthread_kill() */\n\n  return 0;\n} Compliant Solution This compliant code uses instead the pthread_cancel() function to terminate the thread. The thread continues to run until it reaches a cancellation point. See The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition [ Open Group 2004 ] for lists of functions that are required and allowed to be cancellation points. If the cancellation type is set to asynchronous, the thread is terminated immediately. However, POSIX requires only the pthread_cancel() , pthread_setcancelstate() , and pthread_setcanceltype() functions to be async-cancel safe. An application that calls other POSIX functions with asynchronous cancellation enabled is nonconforming. Consequently, we recommend disallowing asynchronous cancellation, as explained by POS47-C. Do not use threads that can be canceled asynchronously . void func(void *foo) {\n  /* Execution of thread */\n}\n\nint main(void) {\n  int result;\n  pthread_t thread;\n\n  if ((result = pthread_create(&thread, NULL, func, 0)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_cancel(thread)) != 0) {\n    /* Handle Error */\n  }\n\n  /* Continue executing */\n\n  return 0;\n} Risk Assessment Sending the signal to a process causes it to be abnormally terminated . Rule Severity Likelihood Detectable Repairable Priority Level POS44-C Low Probable No No P2 L3 Automated Detection Tool Version Checker Description CodeSonar 9.1p0 CONCURRENCY.BADFUNC.PTHREAD_KILL Use of pthread_kill Helix QAC 2025.2 C5034 Klocwork 2025.2 MISRA.INCL.SIGNAL.2012 Parasoft C/C++test 2024.2 CERT_C-POS44-a The 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads PC-lint Plus 1.4 586 Fully supported Polyspace Bug Finder R2024b CERT C: Rule POS44-C Checks for use of signal to kill thread (rule fully covered) Related Vulnerabilities Search for vulnerabilities resulting from the violation of this rule on the CERT website . Bibliography [ OpenBSD ] signal() Man Page [ MKS ] pthread_cancel() Man Page [ Open Group 2004 ] Threads Overview\n\nvoid func(void *foo) {\n  /* Execution of thread */\n}\n\nint main(void) {\n  int result;\n  pthread_t thread;\n\n  if ((result = pthread_create(&thread, NULL, func, 0)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_kill(thread, SIGTERM)) != 0) {\n    /* Handle Error */\n  }\n\n  /* This point is not reached because the process terminates in pthread_kill() */\n\n  return 0;\n}\n\nvoid func(void *foo) {\n  /* Execution of thread */\n}\n\nint main(void) {\n  int result;\n  pthread_t thread;\n\n  if ((result = pthread_create(&thread, NULL, func, 0)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_cancel(thread)) != 0) {\n    /* Handle Error */\n  }\n\n  /* Continue executing */\n\n  return 0;\n}\n\nsignal()\n\npthread_kill()\n\nSIGTERM\n\npthread_cancel()\n\npthread_cancel()\n\npthread_setcancelstate()\n\npthread_setcanceltype()\n\nsignal()\n\npthread_cancel()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code uses the pthread_kill() function to send a SIGTERM signal to the created thread. The thread receives the signal, and the entire process is terminated.",
          "code": "void func(void *foo) {\n  /* Execution of thread */\n}\n\nint main(void) {\n  int result;\n  pthread_t thread;\n\n  if ((result = pthread_create(&thread, NULL, func, 0)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_kill(thread, SIGTERM)) != 0) {\n    /* Handle Error */\n  }\n\n  /* This point is not reached because the process terminates in pthread_kill() */\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant code uses instead the pthread_cancel() function to terminate the thread. The thread continues to run until it reaches a cancellation point. See The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition [ Open Group 2004 ] for lists of functions that are required and allowed to be cancellation points. If the cancellation type is set to asynchronous, the thread is terminated immediately. However, POSIX requires only the pthread_cancel() , pthread_setcancelstate() , and pthread_setcanceltype() functions to be async-cancel safe. An application that calls other POSIX functions with asynchronous cancellation enabled is nonconforming. Consequently, we recommend disallowing asynchronous cancellation, as explained by POS47-C. Do not use threads that can be canceled asynchronously .",
          "code": "void func(void *foo) {\n  /* Execution of thread */\n}\n\nint main(void) {\n  int result;\n  pthread_t thread;\n\n  if ((result = pthread_create(&thread, NULL, func, 0)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_cancel(thread)) != 0) {\n    /* Handle Error */\n  }\n\n  /* Continue executing */\n\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Sending the signal to a process causes it to be abnormally terminated .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS47-C",
    "title": "Do not use threads that can be canceled asynchronously",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS47-C.+Do+not+use+threads+that+can+be+canceled+asynchronously",
    "description": "In threading, pthreads can optionally be set to cancel immediately or defer until a specific cancellation point. Canceling asynchronously (immediately) is dangerous, however, because most threads are in fact not safe to cancel immediately.\n\nThe IEEE standards page states that\n\nonly functions that are cancel-safe may be called from a thread that is asynchronously cancelable.\n\nCanceling asynchronously would follow the same route as passing a signal into the thread to kill it, posing problems similar to those in CON37-C. Do not call signal() in a multithreaded program , which is strongly related to SIG02-C. Avoid using signals to implement normal functionality . POS44-C and SIG02-C expand on the dangers of canceling a thread suddenly, which can create a data race condition .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the worker thread is doing something as simple as swapping a and b repeatedly.\n\nThis code uses one lock. The global_lock mutex ensures that the worker thread and main thread do not collide in accessing the a and b variables.\n\nThe worker thread repeatedly exchanges the values of a and b until it is canceled by the main thread. The main thread then prints out the current values of a and b . Ideally, one should be 5, and the other should be 10.",
          "code": "volatile int a = 5;\nvolatile int b = 10;\n\n/* Lock to enable threads to access a and b safely */\npthread_mutex_t global_lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid* worker_thread(void* dummy) {\n  int i;\n  int c;\n  int result;\n\n  if ((result = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,&i)) != 0) {\n    /* handle error */\n  }\n\n  while (1) {\n    if ((result = pthread_mutex_lock(&global_lock)) != 0) {\n      /* handle error */\n    }\n    c = b;\n    b = a;\n    a = c;\n    if ((result = pthread_mutex_unlock(&global_lock)) != 0) {\n      /* handle error */\n    }\n  }\n  return NULL;\n}\n\n\nint main(void) {\n  int result;\n  pthread_t worker;\n\n  if ((result = pthread_create( &worker, NULL, worker_thread, NULL)) != 0) {\n    /* handle error */\n  }\n\n  /* .. Do stuff...meanwhile worker thread runs for some time */\n\n  /* since we don't know when the character is read in, the program could continue at any time */\n  if ((result = pthread_cancel(worker)) != 0) {\n    /* handle error */\n  }\n  /* pthread_join waits for the thread to finish up before continuing */\n  if ((result = pthread_join(worker, 0)) != 0) {\n    /* handle error */\n  }\n\n  if ((result = pthread_mutex_lock(&global_lock)) != 0) {\n    /* handle error */\n  }\n  printf(\"a: %i | b: %i\", a, b);\n  if ((result = pthread_mutex_unlock(&global_lock)) != 0) {\n    /* handle error */\n  }\n\n  return 0;\n}\n",
          "explanation_after": "However, this program is subject to a race condition because an asynchronous cancel can happen at any time. If the worker thread is canceled while the global_lock mutex is held, it is never actually released. In this case, the main thread will wait forever trying to acquire the global_lock , and the program will deadlock.\n\nIt is also possible that the main thread cancels the worker thread before it has invoked pthread_setcanceltype() . If this happens, the cancellation will be delayed until the worker thread calls pthread_setcanceltype() .\n\nIn this example, the worker thread arranges to release the global_lock mutex if it gets interrupted:\n\nThe global variables are still subject to a race condition because an asynchronous cancel can happen at any time. For instance, the worker thread could be canceled just before the last line ( a = c ) and thereby lose the old value of b . Consequently, the main thread might print that a and b have the same value.\n\nThe program is still subject to the race condition where the main thread cancels the worker thread before it has invoked pthread_setcanceltype() . If this happens, the cancelation will be delayed until the worker thread calls pthread_setcanceltype() .\n\nFurthermore, though less likely, the program can still deadlock if the worker thread gets canceled after the global_lock is acquired but before pthread_cleanup_push() is invoked. In this case, the worker thread is canceled while holding global_lock , and the program will deadlock.\n\nFrom IEEE standards page :\n\nThe cancelability state and type of any newly created threads, including the thread in which main() was first invoked, shall be PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DEFERRED respectively.\n\nBecause the default condition for POSIX, according to the IEEE standards, is PTHREAD_CANCEL_DEFERRED , it is not necessary to invoke pthread_setcanceltype() in the compliant solution:\n\nBecause this code limits cancellation of the worker thread to the end of the while loop, the worker thread can preserve the data invariant that a != b . Consequently, the program might print that a is 5 and b is 10 or that a is 10 and b is 5, but they will always be revealed to have different values when the worker thread is canceled.\n\nThe other race conditions that plague the noncompliant code examples are not possible here. Because the worker thread does not modify its cancel type, it cannot be canceled before being improperly initialized. And because it cannot be canceled while the global_lock mutex is held, there is no possibility of deadlock, and the worker thread does not need to register any cleanup handlers.\n\nIncorrectly using threads that asynchronously cancel may result in silent corruption, resource leaks, and, in the worst case, unpredictable interactions.\n\nRule\n\nSeverity\n\nLikelihood\n\nDetectable\n\nRepairable\n\nPriority\n\nLevel\n\nPOS47-C\n\nMedium\n\nProbable\n\nNo\n\nP4\n\nL3\n\nTool\n\nVersion\n\nChecker\n\nDescription\n\nbad-macro-use\n\nbad-macro-expansion\n\n7.2.0\n\n2025.2\n\n2024.2\n\nCERT_C-POS47-a\n\nThe function 'pthread_setcanceltype()' should not be called with 'PTHREAD_CANCEL_ASYNCHRONOUS' argument\n\n1.4\n\n586\n\nFully supported\n\nR2024b\n\n24.04\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website .\n\nSEI CERT Oracle Coding Standard for Java : THI05-J. Do not use Thread.stop() to terminate threads In Java, similar reasoning resulted in the deprecation of Thread.stop() ."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this example, the worker thread arranges to release the global_lock mutex if it gets interrupted:",
          "code": "void release_global_lock(void* dummy) {\n  int result;\n  if ((result = pthread_mutex_unlock(&global_lock)) != 0) {\n    /* handle error */\n  }\n}\n\nvoid* worker_thread(void* dummy) {\n  int i;\n  int c;\n  int result;\n\n  if ((result = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,&i)) != 0) {\n    /* handle error */\n  }\n\n  while (1) {\n    if ((result = pthread_mutex_lock(&global_lock)) != 0) {\n      /* handle error */\n    }\n    pthread_cleanup_push( release_global_lock, NULL);\n    c = b;\n    b = a;\n    a = c;\n    pthread_cleanup_pop(1);\n  }\n  return NULL;\n}\n",
          "explanation_after": "The global variables are still subject to a race condition because an asynchronous cancel can happen at any time. For instance, the worker thread could be canceled just before the last line ( a = c ) and thereby lose the old value of b . Consequently, the main thread might print that a and b have the same value.\n\nThe program is still subject to the race condition where the main thread cancels the worker thread before it has invoked pthread_setcanceltype() . If this happens, the cancelation will be delayed until the worker thread calls pthread_setcanceltype() .\n\nFurthermore, though less likely, the program can still deadlock if the worker thread gets canceled after the global_lock is acquired but before pthread_cleanup_push() is invoked. In this case, the worker thread is canceled while holding global_lock , and the program will deadlock."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "From IEEE standards page :\n\nThe cancelability state and type of any newly created threads, including the thread in which main() was first invoked, shall be PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DEFERRED respectively.\n\nBecause the default condition for POSIX, according to the IEEE standards, is PTHREAD_CANCEL_DEFERRED , it is not necessary to invoke pthread_setcanceltype() in the compliant solution:",
          "code": "void* worker_thread(void* dummy) {\n  int c;\n  int result;\n\n  while (1) {\n    if ((result = pthread_mutex_lock(&global_lock)) != 0) {\n      /* handle error */\n    }\n    c = b;\n    b = a;\n    a = c;\n    if ((result = pthread_mutex_unlock(&global_lock)) != 0) {\n      /* handle error */\n    }\n\n    /* now we're safe to cancel, creating cancel point */\n    pthread_testcancel();\n  }\n  return NULL;\n}\n",
          "explanation_after": "Because this code limits cancellation of the worker thread to the end of the while loop, the worker thread can preserve the data invariant that a != b . Consequently, the program might print that a is 5 and b is 10 or that a is 10 and b is 5, but they will always be revealed to have different values when the worker thread is canceled.\n\nThe other race conditions that plague the noncompliant code examples are not possible here. Because the worker thread does not modify its cancel type, it cannot be canceled before being improperly initialized. And because it cannot be canceled while the global_lock mutex is held, there is no possibility of deadlock, and the worker thread does not need to register any cleanup handlers."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrectly using threads that asynchronously cancel may result in silent corruption, resource leaks, and, in the worst case, unpredictable interactions.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS48-C",
    "title": "Do not unlock or destroy another POSIX thread's mutex",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS48-C.+Do+not+unlock+or+destroy+another+POSIX+thread%27s+mutex",
    "description": "Mutexes are used to protect shared data structures being accessed concurrently. The thread that locks the mutex owns it, and the owning thread should be the only thread to unlock the mutex. If the mutex is destroyed while still in use, critical sections and shared data are no longer protected. This rule is a specific instance of CON31-C. Do not unlock or destroy another thread's mutex using POSIX threads.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a race condition exists between a cleanup and a worker thread. The cleanup thread destroys the lock, which it believes is no longer in use. If there is a heavy load on the system, the worker thread that held the lock can take longer than expected. If the lock is destroyed before the worker thread has completed modifying the shared data, the program may exhibit unexpected behavior.",
          "code": "pthread_mutex_t theLock;\nint data;\n\nint cleanupAndFinish(void) {\n  int result;\n  if ((result = pthread_mutex_destroy(&theLock)) != 0) {\n    /* Handle error */\n  }\n  data++;\n  return data;\n}\n\nvoid worker(int value) {\n  if ((result = pthread_mutex_lock(&theLock)) != 0) {\n    /* Handle error */\n  }\n  data += value;\n  if ((result = pthread_mutex_unlock(&theLock)) != 0) {\n    /* Handle error */\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution requires that there is no chance a mutex will be needed after it has been destroyed. As always, it is important to check for error conditions when locking the mutex.",
          "code": "mutex_t theLock;\nint data;\n\nint cleanupAndFinish(void) {\n  int result;\n\n  /* A user-written function that is application-dependent */\n  wait_for_all_threads_to_finish();\n  if ((result = pthread_mutex_destroy(&theLock)) != 0) {\n    /* Handle error */\n  }\n  data++;\n  return data;\n}\n\nvoid worker(int value) {\n  int result;\n  if ((result = pthread_mutex_lock(&theLock)) != 0) {\n    /* Handle error */\n  }\n  data += value;\n  if ((result = pthread_mutex_unlock(&theLock)) != 0) {\n    /* Handle error */\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The risks of ignoring mutex ownership are similar to the risk of not using mutexes at all, which can result in a violation of data integrity.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS49-C",
    "title": "When data must be accessed by multiple threads, provide a mutex and guarantee no adjacent data is also accessed",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS49-C.+When+data+must+be+accessed+by+multiple+threads%2C+provide+a+mutex+and+guarantee+no+adjacent+data+is+also+accessed",
    "description": "When multiple threads must access or make modifications to a common variable, they may also inadvertently access other variables adjacent in memory. This is an artifact of variables being stored compactly, with one byte possibly holding multiple variables, and is a common optimization on word-addressed machines. Bit-fields are especially prone to this behavior because compliers are allowed to store multiple bit-fields in one addressable byte or word. This implies that race conditions may exist not just on a variable accessed by multiple threads but also on other variables sharing the same byte or word address. This recommendation is a specific instance of CON32-C. Prevent data races when accessing bit-fields from multiple threads using POSIX threads.\n\nA common tool for preventing race conditions in concurrent programming is the mutex. When properly observed by all threads, a mutex can provide safe and secure access to a common variable; however, it guarantees nothing with regard to other variables that might be accessed when a common variable is accessed.\n\nUnfortunately, there is no portable way to determine which adjacent variables may be stored along with a certain variable.\n\nA better approach is to embed a concurrently accessed variable inside a union, along with a long variable, or at least some padding to ensure that the concurrent variable is the only element to be accessed at that address. This technique would effectively guarantee that no other variables are accessed or modified when the concurrent variable is accessed or modified.\n\nlong",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Bit-field)",
          "pre_code_commentary": "In this noncompliant code example, two executing threads simultaneously access two separate members of a global struct :",
          "code": "struct multi_threaded_flags {\n  unsigned int flag1 : 2;\n  unsigned int flag2 : 2;\n};\n\nstruct multi_threaded_flags flags;\n\nvoid thread1(void) {\n  flags.flag1 = 1;\n}\n\nvoid thread2(void) {\n  flags.flag2 = 2;\n}\n",
          "explanation_after": "Although this code appears to be harmless, it is likely that flag1 and flag2 are stored in the same byte. If both assignments occur on a thread-scheduling interleaving that ends with both stores occurring after one another, it is possible that only one of the flags will be set as intended, and the other flag will equal its previous value, because both bit-fields are represented by the same byte, which is the smallest unit the processor can work on.\n\nFor example, the following sequence of events can occur:\n\nEven though each thread is modifying a separate bit-field, they are both modifying the same location in memory. This is the same problem discussed in CON43-C. Do not allow data races in multithreaded code but is harder to diagnose because it is not immediately obvious that the same memory location is being modified."
        },
        "compliant": {
          "heading": "Compliant Solution (Bit-field)",
          "pre_code_commentary": "This compliant solution protects all accesses of the flags with a mutex, thereby preventing any thread-scheduling interleaving from occurring. In addition, the flags are declared volatile to ensure that the compiler will not attempt to move operations on them outside the mutex. Finally, the flags are embedded in a union alongside a long , and a static assertion guarantees that the flags do not occupy more space than the long . This technique prevents any data not checked by the mutex from being accessed or modified with the bit-fields.",
          "code": "struct multi_threaded_flags {\n  volatile unsigned int flag1 : 2;\n  volatile unsigned int flag2 : 2;\n};\n\nunion mtf_protect {\n  struct multi_threaded_flags s;\n  long padding;\n};\n\nstatic_assert(sizeof(long) >= sizeof(struct multi_threaded_flags));\n\nstruct mtf_mutex {\n  union mtf_protect u;\n  pthread_mutex_t mutex;\n};\n\nstruct mtf_mutex flags;\n\nvoid thread1(void) {\n  int result;\n  if ((result = pthread_mutex_lock(&flags.mutex)) != 0) {\n    /* Handle error */\n  }\n  flags.u.s.flag1 = 1;\n  if ((result = pthread_mutex_unlock(&flags.mutex)) != 0) {\n    /* Handle error */\n  }\n}\n\nvoid thread2(void) {\n  int result;\n  if ((result = pthread_mutex_lock(&flags.mutex)) != 0) {\n    /* Handle error */\n  }\n  flags.u.s.flag2 = 2;\n  if ((result = pthread_mutex_unlock(&flags.mutex)) != 0) {\n    /* Handle error */\n  }\n}\n",
          "explanation_after": "Static assertions are discussed in detail in DCL03-C. Use a static assertion to test the value of a constant expression ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Although the race window is narrow, having an assignment or an expression evaluate improperly because of misinterpreted data can result in a corrupted running state or unintended information disclosure.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS50-C",
    "title": "Declare objects shared between POSIX threads with appropriate storage durations",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS50-C.+Declare+objects+shared+between+POSIX+threads+with+appropriate+storage+durations",
    "description": "Accessing the stack or thread-local variables of a thread from another thread can cause invalid memory accesses because the execution of threads can be interwoven within the constraints of the synchronization model. As a result, the referenced stack frame or thread-local variable may not be valid when the other thread tries to access it. Regular shared variables should be protected by thread synchronization mechanisms. However, local variables should not be shared in the same fashion because the referenced stack frame's thread would have to stop executing, or some other way must be found to ensure that the referenced stack frame is still valid. See CON32-C. Prevent data races when accessing bit-fields from multiple threads for information on how to securely share nonautomatic and non-thread-local variables. See DCL30-C. Declare objects with appropriate storage durations for information on how to declare objects with appropriate storage durations when data is not being shared between threads. Note that this is a specific instance of CON34-C. Declare objects shared between threads with appropriate storage durations for POSIX threads.\n\nIt is important to note that local data can be used securely with threads when using other non-POSIX thread interfaces, so the programmer should not always copy data into nonlocal memory when sharing data with threads. For example, the shared keyword in OpenMP can be used in combination with OpenMP's threading interface to share local memory without having to worry about whether local automatic variables remain valid. Furthermore, copying the shared data into dynamic memory may completely negate the performance benefits of multithreading.\n\nshared",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Automatic Storage)",
          "pre_code_commentary": "The createThread() function allocates an integer on the stack and passes a void pointer, spawning off a new thread, childThread() . The order of thread execution is interleaved, so val can reference an object outside of its lifetime, causing the child thread to access an invalid memory location.",
          "code": "void *childThread(void *val) {\n  /*\n   * Depending on the order of thread execution, the object\n   * referred to by val may be out of its lifetime, resulting\n   * in a potentially incorrect result being printed out.\n   */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n\nvoid createThread(pthread_t *tid) {\n  /* Store 1 in val on the stack. */\n  int val = 1;\n  int result;\n  if ((result = pthread_create(tid, NULL, childThread, &val)) != 0) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  pthread_t tid;\n  int result;\n  createThread(&tid);\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Thread-Local Storage)",
          "pre_code_commentary": "This noncompliant code example is incorrect because createThread() can finish running before childThread() , so childThread() may not access a valid object:",
          "code": "__thread int val;\n\nvoid *childThread(void *val) {\n  int *res = (int *)val;\n\n  printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n\nvoid *createThread(void *childTid) {\n  pthread_t *tid = (pthread_t *)childTid;\n  int result;\n  val = 1;\n  if ((result = pthread_create(tid, NULL, childThread, &val)) != 0) {\n    /* Handle error */\n  }\n  return NULL;\n}\n\nvoid *empty(void *arg) {\n  /* Function that does nothing */\n  val = 0;\n  return NULL;\n}\n\nint main(void) {\n  pthread_t parentTid, childTid, emptyTid;\n  int result;\n\n  /*\n   * createThread() may complete before childThread(), and\n   * the thread-local variable, val, belonging to createThread(),\n   * may no longer be valid when childThread() runs.\n   */\n  if ((result = pthread_create(&parentTid, NULL, createThread, &childTid)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_join(parentTid, NULL)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_create(&emptyTid, NULL, empty, NULL)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_join(emptyTid, NULL)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_join(childTid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution (Allocated Storage)",
          "pre_code_commentary": "Instead of passing the pointer to the stack of the parent thread, one solution is to allocate space on the heap, copying the data to dynamic memory. Because the lifetime of an object stored in dynamic memory lasts until it is freed, the child thread ensures that memory accesses are valid.",
          "code": "void *childThread(void *val) {\n  /* Correctly prints 1 */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  free(res);\n  return NULL;\n}\n\nvoid createThread(pthread *tid) {\n  int result;\n  /* Copy data into dynamic memory */\n  int *val = malloc(sizeof(int));\n\n  if (!val) {\n    /* Handle error */\n  }\n  *val = 1;\n  if ((result = pthread_create(&id, NULL, childThread, val)) != 0) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  pthread_t tid;\n  int result;\n  createThread(&tid);\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution (Static Storage)",
          "pre_code_commentary": "Another solution is to store the data as a global static variable. Unlike local automatic variables, which are stored on the stack, static variables are stored in the data section of memory. Static variables last for the execution of the entire program, so a thread can safely access global static variables.",
          "code": "/* Declare val as a global static variable */\nint val;\n\nvoid *childThread(void *val) {\n  /* Correctly prints 1 */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n\nvoid createThread(pthread_t *tid) {\n  val = 1;\n  int result;\n  if ((result = pthread_create(tid, NULL, childThread, &val)) != 0) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  pthread_t tid;\n  createThread(&tid);\n  int result;\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution (Automatic Storage)",
          "pre_code_commentary": "Another solution is to ensure that local variables shared between threads are declared in the same or previous stack frame as a call to a thread synchronization mechanism, such as pthread_join() . For example, in this compliant solution, val is declared in main() , where pthread_join() is called. Because the parent thread will wait until the child thread completes before continuing its execution, the child thread is guaranteed to access an object that is still within its lifetime.",
          "code": "void *childThread(void *val) {\n  /* Correctly prints 1 */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n\nvoid createThread(pthread_t *tid, int *val) {\n  int result = pthread_create(tid, NULL, childThread, val);\n  if (result != 0) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  /* Declare val in the same function as pthread_join */\n  int val = 1;\n  int result;\n  pthread_t tid;\n  createThread(&tid, &val);\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution (Thread-Local Storage)",
          "pre_code_commentary": "Another solution is to declare val a thread-local variable combined with a call to a thread synchronization mechanism, such as pthread_join() . Because the parent thread will wait until the child thread completes before continuing its execution, the child thread is guaranteed to access an object that is still within its lifetime.",
          "code": "/* Declare val as a thread-local value */\n__thread int val;\n\nvoid *childThread(void *val) {\n  /* Correctly prints 1 */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n\nvoid createThread(pthread_t *tid) {\n  val = 1;\n  int result = pthread_create(tid, NULL, childThread, &val);\n  if (result != 0) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  pthread_t tid;\n  int result;\n  createThread(&tid);\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Threads that reference the stack of other threads can potentially overwrite important information on the stack, such as function pointers and return addresses. However, it would be difficult for an attacker to exploit this code from this error alone. The compiler will not generate warnings if the programmer decides to give another thread access to one thread's local variables, so a programmer may not catch a potential error at compile time. The remediation cost for this error is high because analysis tools have difficulty diagnosing problems with concurrency and race conditions.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS51-C",
    "title": "Avoid deadlock with POSIX threads by locking in predefined order",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS51-C.+Avoid+deadlock+with+POSIX+threads+by+locking+in+predefined+order",
    "description": "Mutexes are often used to prevent multiple threads from accessing critical resources at the same time. Sometimes, when locking mutexes, multiple threads hold each other's lock, and the program consequently deadlocks. There are four requirements for deadlock:\n\nMutual exclusion Hold and wait No preemption Circular wait\n\nDeadlock requires all four conditions, so to prevent deadlock, prevent any one of the four conditions. This guideline recommends locking the mutexes in a predefined order to prevent circular wait. This rule is a specific instance of CON35-C. Avoid deadlock by locking in predefined order using POSIX threads.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example has behavior that depends on the runtime environment and the platform's scheduler. However, with proper timing, the main() function will deadlock when running thr1 and thr2 , where thr1 tries to lock ba2 's mutex, while thr2 tries to lock on ba1 's mutex in the deposit() function, and the program will not progress.",
          "code": "typedef struct {\n  int balance;\n  pthread_mutex_t balance_mutex;\n} bank_account;\n\ntypedef struct {\n  bank_account *from;\n  bank_account *to;\n  int amount;\n} deposit_thr_args;\n\nvoid create_bank_account(bank_account **ba, int initial_amount) {\n  int result;\n  bank_account *nba = malloc(sizeof(bank_account));\n  if (nba == NULL) {\n    /* Handle error */\n  }\n\n  nba->balance = initial_amount;\n  result = pthread_mutex_init(&nba->balance_mutex, NULL);\n  if (result) {\n    /* Handle error */\n  }\n\n  *ba = nba;\n}\n\n\nvoid *deposit(void *ptr) {\n  int result;\n  deposit_thr_args *args = (deposit_thr_args *)ptr;\n\n  if ((result = pthread_mutex_lock(&(args->from->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n\n  /* Not enough balance to transfer */\n  if (args->from->balance < args->amount) {\n    if ((result = pthread_mutex_unlock(&(args->from->balance_mutex))) != 0) {\n      /* Handle error  */\n    }\n    return NULL;\n  }\n\n  if ((result = pthread_mutex_lock(&(args->to->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n\n  args->from->balance -= args->amount;\n  args->to->balance += args->amount;\n\n  if ((result = pthread_mutex_unlock(&(args->from->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_mutex_unlock(&(args->to->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n\n  free(ptr);\n  return NULL;\n}\n\nint main(void) {\n\n  pthread_t thr1, thr2;\n  int result;\n\n  bank_account *ba1;\n  bank_account *ba2;\n  create_bank_account(&ba1, 1000);\n  create_bank_account(&ba2, 1000);\n\n  deposit_thr_args *arg1 = malloc(sizeof(deposit_thr_args));\n  if (arg1 == NULL) {\n    /* Handle error */\n  }\n  deposit_thr_args *arg2 = malloc(sizeof(deposit_thr_args));\n  if (arg2 == NULL) {\n    /* Handle error */\n  }\n\n  arg1->from = ba1;\n  arg1->to = ba2;\n  arg1->amount = 100;\n\n  arg2->from = ba2;\n  arg2->to = ba1;\n  arg2->amount = 100;\n\n  /* Perform the deposits */\n  if ((result = pthread_create(&thr1, NULL, deposit, (void *)arg1)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_create(&thr2, NULL, deposit, (void *)arg2)) != 0) {\n    /* Handle error */\n  }\n\n  pthread_exit(NULL);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The solution to the deadlock problem is to use a predefined order for the locks in the deposit() function. In this compliant solution, each thread will lock on the basis of the bank_account ID, defined in the struct initialization. This solution prevents the circular wait problem:",
          "code": "typedef struct {\n  int balance;\n  pthread_mutex_t balance_mutex;\n  unsigned int id; /* Should never be changed after initialized */\n} bank_account;\n\nunsigned int global_id = 1;\n\nvoid create_bank_account(bank_account **ba, int initial_amount) {\n  int result;\n  bank_account *nba = malloc(sizeof(bank_account));\n  if (nba == NULL) {\n    /* Handle error */\n  }\n\n  nba->balance = initial_amount;\n  result = pthread_mutex_init(&nba->balance_mutex, NULL);\n  if (result != 0) {\n    /* Handle error */\n  }\n\n  nba->id = global_id++;\n  *ba = nba;\n}\n\nvoid *deposit(void *ptr) {\n  deposit_thr_args *args = (deposit_thr_args *)ptr;\n  int result;\n\n  if (args->from->id == args->to->id)\n\t\treturn;\n\n  /* Ensure proper ordering for locking */\n  if (args->from->id < args->to->id) {\n    if ((result = pthread_mutex_lock(&(args->from->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n    if ((result = pthread_mutex_lock(&(args->to->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n  } else {\n    if ((result = pthread_mutex_lock(&(args->to->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n    if ((result = pthread_mutex_lock(&(args->from->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n  }\n\n  /* Not enough balance to transfer */\n  if (args->from->balance < args->amount) {\n    if ((result = pthread_mutex_unlock(&(args->from->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n    if ((result = pthread_mutex_unlock(&(args->to->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n    return;\n  }\n\n  args->from->balance -= args->amount;\n  args->to->balance += args->amount;\n\n  if ((result = pthread_mutex_unlock(&(args->from->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_mutex_unlock(&(args->to->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n\n  free(ptr);\n  return;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Deadlock prevents multiple threads from progressing, thus halting the executing program. A denial-of-service attack is possible because the attacker can force deadlock situations. Deadlock is likely to occur in multithreaded programs that manage multiple shared resources.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS52-C",
    "title": "Do not perform operations that can block while holding a POSIX lock",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS52-C.+Do+not+perform+operations+that+can+block+while+holding+a+POSIX+lock",
    "description": "If a lock is being held and an operation that can block is performed, any other thread that needs to acquire that lock may also block. This condition can degrade the performance of a system or cause a deadlock to occur.\n\nBlocking calls include, but are not limited to: network, file, and console I/O. This rule is a specific instance of CON05-C. Do not perform operations that can block while holding a lock using POSIX threads.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example demonstrates an occurrence of a blocking call that waits to receive data on a socket while a mutex is locked. The recv() call blocks until data arrives on the socket. While it is blocked, other threads that are waiting for the lock are also blocked.\n\nAlthough this example is specific to network I/O, the recv() call could be replaced with any blocking call, and the same behavior would occur.",
          "code": "pthread_mutexattr_t attr;\npthread_mutex_t mutex;\n\nvoid thread_foo(void *ptr) {\n  uint32_t num;\n  int result;\n  int sock;\n\n  /* sock is a connected TCP socket */\n\n  if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  if ((result = recv(sock, (void *)&num, sizeof(uint32_t), 0)) < 0) {\n    /* Handle Error */\n  }\n\n  /* ... */\n\n  if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n}\n\nint main() {\n  pthread_t thread;\n  int result;\n\n  if ((result = pthread_mutexattr_settype(\n      &mutex, PTHREAD_MUTEX_ERRORCHECK)) != 0) {\n    /* Handle Error */\n  }\n\n  if ((result = pthread_mutex_init(&mutex, &attr)) != 0) {\n    /* Handle Error */\n  }\n\n  if (pthread_create(&thread, NULL,(void *)& thread_foo, NULL) != 0) {\n    /* Handle Error */\n  }\n\n  /* ... */\n\n  pthread_join(thread, NULL);\n\n  if ((result = pthread_mutex_destroy(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Block while Not Locked)",
          "pre_code_commentary": "This compliant solution performs the recv() call when the lock has not been acquired. The blocking behavior consequently affects only the thread that called the blocking function.",
          "code": "void thread_foo(void *ptr) {\n  uint32_t num;\n  int result;\n  int sock;\n\n  /* sock is a connected TCP socket */\n\n  if ((result = recv(sock, (void *)&num, sizeof(uint32_t), 0)) < 0) {\n    /* Handle Error */\n  }\n\n  if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  /* ... */\n\n  if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example demonstrates an occurrence of a blocking call that waits to receive data on a socket while a mutex is locked. The recv() call blocks until data arrives on the socket. While it is blocked, other threads that are waiting for the lock are also blocked.\n\nAlthough this example is specific to network I/O, the recv() call could be replaced with any blocking call, and the same behavior would occur.",
          "code": "pthread_mutexattr_t attr;\npthread_mutex_t mutex;\n\nvoid thread_foo(void *ptr) {\n  uint32_t num;\n  int result;\n  int sock;\n\n  /* sock is a connected TCP socket */\n\n  if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  if ((result = recv(sock, (void *)&num, sizeof(uint32_t), 0)) < 0) {\n    /* Handle Error */\n  }\n\n  /* ... */\n\n  if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n}\n\nint main() {\n  pthread_t thread;\n  int result;\n\n  if ((result = pthread_mutexattr_settype(\n      &mutex, PTHREAD_MUTEX_ERRORCHECK)) != 0) {\n    /* Handle Error */\n  }\n\n  if ((result = pthread_mutex_init(&mutex, &attr)) != 0) {\n    /* Handle Error */\n  }\n\n  if (pthread_create(&thread, NULL,(void *)& thread_foo, NULL) != 0) {\n    /* Handle Error */\n  }\n\n  /* ... */\n\n  pthread_join(thread, NULL);\n\n  if ((result = pthread_mutex_destroy(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Use a Nonblocking Call)",
          "pre_code_commentary": "This compliant solution performs the recv() call with the parameter MSG_DONTWAIT , which causes the call to fail if no messages are available on the socket:",
          "code": "void thread_foo(void *ptr) {\n  uint32_t num;\n  int result;\n\n  /* sock is a connected TCP socket */\n\n  if ((result = recv(sock, (void *)&num, sizeof(uint32_t), MSG_DONTWAIT)) < 0) {\n    /* Handle Error */\n  }\n\n  if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  /* ... */\n\n  if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Blocking or lengthy operations performed within synchronized regions could result in a deadlocked or an unresponsive system.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "POS53-C",
    "title": "Do not use more than one mutex for concurrent waiting operations on a condition variable",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS53-C.+Do+not+use+more+than+one+mutex+for+concurrent+waiting+operations+on+a+condition+variable",
    "description": "pthread_cond_wait() and pthread_cond_timedwait() take a condition variable and locked mutex as arguments. These functions unlock the mutex until the condition variable is signaled and then relock the mutex before returning. While a thread is waiting on a particular condition variable and mutex, other threads may only wait on the same condition variable if they also pass the same mutex as an argument. This requirement is noted in the Open Group Base Specifications, Issue 6 :\n\npthread_cond_wait()\n\npthread_cond_timedwait()\n\nAs long as at least one thread is blocked on the condition variable. During this time, the effect of an attempt by any thread to wait on that condition variable using a different mutex is undefined.\n\nIt also specifies that pthread_cond_wait() may € fail if:\n\npthread_cond_wait()\n\n[EINVAL] The value specified by cond or mutex is invalid. [EPERM] The mutex was not owned by the current thread at the time of the call.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, mutex1 protects count1 and mutex2 protects count2 . A race condition exists between the waiter1 and waiter2 threads because they use the same condition variable with different mutexes. If both threads attempt to call pthread_cond_wait() at the same time, one thread will succeed and the other thread will invoke undefined behavior .",
          "code": "#include <stdio.h>\n#include <string.h>\n#include <pthread.h>\n#include <assert.h>\n#include <unistd.h>\n#include <errno.h>\n\npthread_mutex_t mutex1;\npthread_mutex_t mutex2;\npthread_mutexattr_t attr;\npthread_cond_t cv;\n\nvoid *waiter1();\nvoid *waiter2();\nvoid *signaler();\n\nint count1 = 0, count2 = 0;\n#define COUNT_LIMIT 5\n\nint main() {\n  int ret;\n  pthread_t thread1, thread2, thread3;\n\n  if ((ret = pthread_mutexattr_init( &attr)) != 0) {\n    /* Handle error */\n  }\n\n  if ((ret = pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_ERRORCHECK)) != 0) {\n    /* Handle error */\n  }\n\n  if ((ret = pthread_mutex_init( &mutex1, &attr)) != 0) {\n    /* Handle error */\n  }\n\n  if ((ret = pthread_mutex_init( &mutex2, &attr)) != 0) {\n    /* Handle error */\n  }\n\n  if ((ret = pthread_cond_init( &cv, NULL)) != 0) {\n    /* handle error */\n  }\n\n  if ((ret = pthread_create( &thread1, NULL, &waiter1, NULL))) {\n    /* Handle error */\n  }\n\n  if ((ret = pthread_create( &thread2, NULL, &waiter2, NULL))) {\n    /* handle error */\n  }\n\n  if ((ret = pthread_create( &thread3, NULL, &signaler, NULL))) {\n    /* Handle error */\n  }\n\n  if ((ret = pthread_join( thread1, NULL)) != 0) {\n    /* Handle error */\n  }\n\n  if ((ret = pthread_join( thread2, NULL)) != 0) {\n    /* Handle error */\n  }\n\n  if ((ret = pthread_join( thread3, NULL)) != 0) {\n    /* Handle error */\n  }\n\n  return 0;\n}\n\n\nvoid *waiter1() {\n  int ret;\n  while (count1 < COUNT_LIMIT) {\n    if ((ret = pthread_mutex_lock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n\n    if ((ret = pthread_cond_wait(&cv, &mutex1)) != 0) {\n      /* Handle error */\n    }\n\n    printf(\"count1 = %d\\n\", ++count1);\n\n    if ((ret = pthread_mutex_unlock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n  }\n\n  return NULL;\n}\n\nvoid *waiter2() {\n  int ret;\n  while (count2 < COUNT_LIMIT) {\n    if ((ret = pthread_mutex_lock(&mutex2)) != 0) {\n      /* Handle error */\n    }\n\n    if ((ret = pthread_cond_wait(&cv, &mutex2)) != 0) {\n      /* Handle error */\n    }\n\n    printf(\"count2 = %d\\n\", ++count2);\n\n    if ((ret = pthread_mutex_unlock(&mutex2)) != 0) {\n      /* Handle error */\n    }\n  }\n\n  return NULL;\n}\n\nvoid *signaler() {\n  int ret;\n  while ((count1 < COUNT_LIMIT) || (count2 < COUNT_LIMIT)) {\n    sleep(1);\n    printf(\"signaling\\n\");\n    if ((ret = pthread_cond_signal(&cv)) != 0) {\n      /* Handle error */\n    }\n  }\n\n  return NULL;\n}\n",
          "explanation_after": "When the system is built on the following platform,\n\nRed Hat Enterprise Linux Client release 5.5 (Tikanga) kernel 2.6.18 gcc 4.3.5 with the --D_GNU_SOURCE flag\n\nthe preceding code works as expected. waiter1 and waiter2 increment the variable once they are signaled, and the correct mutex is acquired after pthread_cond_wait returns in each thread.\n\nThe man page for pthread_cond_wait on this configuration says that it may € fail with a return value of EINVAL if \"different mutexes were supplied for concurrent pthread_cond_timedwait() or pthread_cond_wait() operations on the same condition variable.\" However, this does not happen.\n\nOS X 10.6.4 (Snow Leopard) gcc 4.2.1\n\npthread_cond_wait() returns EINVAL if it is called when another thread is waiting on the condition variable with a different mutex. This approach is arguably better because it forces the coder to fix the problem instead of allowing reliance on undefined behavior.\n\nThe man page for pthread_cond_wait()}] simply says that {{EINVAL will be returned if \"the value specified by cond or the value specified by mutex is invalid,\" but it doesn't say what invalid means."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This problem can be solved either by always using the same mutex whenever a particular condition variable is used or by using separate condition variables, depending on how the code is expected to work. This compliant solution uses the €œsame-mutex€ solution:",
          "code": "#include <stdio.h>\n#include <pthread.h>\n \npthread_mutex_t mutex1; /* Initialized as PTHREAD_MUTEX_ERRORCHECK */\npthread_cond_t cv;\nint count1 = 0, count2 = 0;\n#define COUNT_LIMIT 5\n\nvoid *waiter1() {\n  int ret;\n  while (count1 < COUNT_LIMIT) {\n    if ((ret = pthread_mutex_lock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n\n    if ((ret = pthread_cond_wait(&cv, &mutex1)) != 0) {\n      /* Handle error */\n    }\n\n    printf(\"count1 = %d\\n\", ++count1);\n\n    if ((ret = pthread_mutex_unlock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n  }\n\n  return NULL;\n}\n\nvoid *waiter2() {\n  int ret;\n  while (count2 < COUNT_LIMIT) {\n    if ((ret = pthread_mutex_lock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n\n    if ((ret = pthread_cond_wait(&cv, &mutex1)) != 0) {\n      /* Handle error */\n    }\n\n    printf(\"count2 = %d\\n\", ++count2);\n\n    if ((ret = pthread_mutex_unlock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n  }\n\n  return NULL;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Waiting on the same condition variable with two different mutexes could cause a thread to be signaled and resume execution with the wrong mutex locked. It could lead to unexpected program behavior if the same shared data were simultaneously accessed by two threads.\n\nThe severity is medium because improperly accessing shared data could lead to data integrity violation. Likelihood is probable because in such an implementation, an error code would not be returned, and remediation cost is high because detection and correction of this problem are both manual.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "POS54-C",
    "title": "Detect and handle POSIX library errors",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/POS54-C.+Detect+and+handle+POSIX+library+errors",
    "description": "All standard library functions, including I/O functions and memory allocation functions, return either a valid value or a value of the correct return type that indicates an error (for example, −1 or a null pointer). Assuming that all calls to such functions will succeed and failing to check the return value for an indication of an error is a dangerous practice that may lead to unexpected or undefined behavior when an error occurs. It is essential that programs detect and appropriately handle all errors in accordance with an error-handling policy, as discussed in ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy .  In addition to the C standard library functions mentioned in ERR33-C. Detect and handle standard library errors , the following functions defined in POSIX require error checking (list is not all-inclusive).\n\nThe successful completion or failure of each of the standard library functions listed in the following table shall be determined either by comparing the function’s return value with the value listed in the column labeled “Error Return” or by calling one of the library functions mentioned in the footnotes to the same column.\n\nFunction Successful Return Error Return errno fmemopen() Pointer to a FILE object NULL ENOMEM open_memstream() Pointer to a FILE object NULL ENOMEM posix_memalign() 0 Nonzero Unchanged\n\nerrno\n\nfmemopen()\n\nFILE\n\nNULL\n\nENOMEM\n\nopen_memstream()\n\nFILE\n\nNULL\n\nENOMEM\n\nposix_memalign()\n\n0\n\nSetting errno is a POSIX [ ISO/IEC 9945:2008 ] extension to the C Standard. On error, posix_memalign() returns a value that corresponds to one of the constants defined in the <errno.h> header. The function does not set errno . The posix_memalign() function is optional and is not required to be provided by POSIX-conforming implementations.\n\nerrno\n\nposix_memalign()\n\n<errno.h>\n\nerrno\n\nposix_memalign()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( POSIX )",
          "pre_code_commentary": "In this noncompliant code example, fmemopen() and open_memstream() are assumed to succeed. However, if the calls fail, the two file pointers in and out will be null and the program will have undefined behavior .",
          "code": "#include <stdio.h>\n#include <string.h>\n \nint main(int argc, char *argv[]) {\n  FILE *out;\n  FILE *in;\n  size_t size;\n  char *ptr;\n \n  if (argc != 2) {\n    /* Handle error */\n  }\n \n  in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n  /* Use in */\n \n  out = open_memstream(&ptr, &size);\n  /* Use out */\n \n  return 0; \n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "A compliant solution avoids assuming that fmemopen() and open_memstream() succeed regardless of its arguments and tests the return value of the function before using the file pointers in and out :",
          "code": "#include <stdio.h>\n#include <string.h>\n \nint main(int argc, char *argv[]) {\n  FILE *out;\n  FILE *in;\n  size_t size;\n  char *ptr;\n \n  if (argc != 2) {\n    /* Handle error */\n  }\n \n  in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n\n  if (in == NULL){\n    /* Handle error */\n  }\n  /* Use in */\n \n  out = open_memstream(&ptr, &size);\n\n  if (out == NULL){\n    /* Handle error */\n  }\n  /* Use out */\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to detect error conditions can lead to unpredictable results, including abnormal program termination and denial-of-service attacks or, in some situations, could even allow an attacker to run arbitrary code.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P27",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "PRE00-C",
    "title": "Prefer inline or static functions to function-like macros",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE00-C.+Prefer+inline+or+static+functions+to+function-like+macros",
    "description": "Macros are dangerous because their use resembles that of real functions, but they have different semantics. The inline function-specifier was introduced to the C programming language in the C99 standard. Inline functions should be preferred over macros when they can be used interchangeably. Making a function an inline function suggests that calls to the function be as fast as possible by using, for example, an alternative to the usual function call mechanism, such as inline substitution . (See also PRE31-C. Avoid side effects in arguments to unsafe macros , PRE01-C. Use parentheses within macros around parameter names , and PRE02-C. Macro replacement lists should be parenthesized .)\n\nInline substitution is not textual substitution, nor does it create a new function. For example, the expansion of a macro used within the body of the function uses the definition it had at the point the function body appeared, not where the function is called; and identifiers refer to the declarations in scope where the body occurs.\n\nArguably, a decision to inline a function is a low-level optimization detail that the compiler should make without programmer input. The use of inline functions should be evaluated on the basis of (a) how well they are supported by targeted compilers, (b) what (if any) impact they have on the performance characteristics of your system, and (c) portability concerns. Static functions are often as good as inline functions and are supported in C.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the macro CUBE() has undefined behavior when passed an expression that contains side effects:",
          "code": "#define CUBE(X) ((X) * (X) * (X))\n \nvoid func(void) {\n  int i = 2;\n  int a = 81 / CUBE(++i);\n  /* ... */\n}",
          "explanation_after": "For this example, the initialization for a expands to\n\nwhich is undefined (see EXP30-C. Do not depend on the order of evaluation for side effects )."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "When the macro definition is replaced by an inline function, the side effect is executed only once before the function is called:",
          "code": "inline int cube(int i) {\n  return i * i * i;\n}\n \nvoid func(void) {\n  int i = 2;\n  int a = 81 / cube(++i);\n  /* ... */ \n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the programmer has written a macro called EXEC_BUMP() to call a specified function and increment a global counter [ Dewhurst 2002 ]. When the expansion of a macro is used within the body of a function, as in this example, identifiers refer to the declarations in scope where the body occurs. As a result, when the macro is called in the aFunc() function, it inadvertently increments a local counter with the same name as the global variable. Note that this example also violates DCL01-C. Do not reuse variable names in subscopes .",
          "code": "size_t count = 0;\n\n#define EXEC_BUMP(func) (func(), ++count)\n\nvoid g(void) {\n  printf(\"Called g, count = %zu.\\n\", count);\n}\n\nvoid aFunc(void) {\n  size_t count = 0;\n  while (count++ < 10) {\n    EXEC_BUMP(g);\n  }\n}\n",
          "explanation_after": "The result is that invoking aFunc() (incorrectly) prints out the following line five times:"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the EXEC_BUMP() macro is replaced by the inline function exec_bump() . Invoking aFunc() now (correctly) prints the value of count ranging from 0 to 9:",
          "code": "size_t count = 0;\n\nvoid g(void) {\n  printf(\"Called g, count = %zu.\\n\", count);\n}\n\ntypedef void (*exec_func)(void);\ninline void exec_bump(exec_func f) {\n  f();\n  ++count;\n}\n\nvoid aFunc(void) {\n  size_t count = 0;\n  while (count++ < 10) {\n    exec_bump(g);\n  }\n}\n",
          "explanation_after": "The use of the inline function binds the identifier count to the global variable when the function body is compiled. The name cannot be re-bound to a different variable (with the same name) when the function is called."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Unlike functions, the execution of macros can interleave. Consequently, two macros that are harmless in isolation can cause undefined behavior when combined in the same expression. In this example, F() and G() both increment the global variable operations , which causes problems when the two macros are used together:",
          "code": "int operations = 0, calls_to_F = 0, calls_to_G = 0;\n \n#define F(x) (++operations, ++calls_to_F, 2 * x)\n#define G(x) (++operations, ++calls_to_G, x + 1)\n\nvoid func(int x) {\n  int y = F(x) + G(x);\n\n}",
          "explanation_after": "The variable operations is both read and modified twice in the same expression, so it can receive the wrong value if, for example, the following ordering occurs:\n\nThis noncompliant code example also violates EXP30-C. Do not depend on the order of evaluation for side effects ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The execution of functions, including inline functions, cannot be interleaved, so problematic orderings are not possible:",
          "code": "int operations = 0, calls_to_F = 0, calls_to_G = 0;\n \ninline int f(int x) {\n  ++operations;\n  ++calls_to_F;\n  return 2 * x;\n}\n\ninline int g(int x) {\n  ++operations;\n  ++calls_to_G;\n  return x + 1;\n}\n\n \nvoid func(int x) {\n  int y = f(x) + g(x);\n\n}",
          "explanation_after": "GNU C (and some other compilers) supported inline functions before they were added to the C Standard and, as a result, have significantly different semantics. Richard Kettlewell provides a good explanation of differences between the C99 and GNU C rules [ Kettlewell 2003 ]."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Improper use of macros may result in undefined behavior .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE01-C",
    "title": "Use parentheses within macros around parameter names",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE01-C.+Use+parentheses+within+macros+around+parameter+names",
    "description": "Parenthesize all parameter names in macro definitions. See also PRE00-C. Prefer inline or static functions to function-like macros and PRE02-C. Macro replacement lists should be parenthesized .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This CUBE() macro definition is noncompliant because it fails to parenthesize the parameter names:",
          "code": "#define CUBE(I) (I * I * I)\n",
          "explanation_after": "As a result, the invocation\n\nexpands to\n\nwhich is clearly not the desired result."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Parenthesizing all parameter names in the CUBE() macro allows it to expand correctly (when invoked in this manner):",
          "code": "#define CUBE(I) ( (I) * (I) * (I) )\nint a = 81 / CUBE(2 + 1);\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to parenthesize the parameter names in a macro can result in unintended program behavior.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "PRE02-C",
    "title": "Macro replacement lists should be parenthesized",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE02-C.+Macro+replacement+lists+should+be+parenthesized",
    "description": "Macro replacement lists should be parenthesized to protect any lower-precedence operators from the surrounding expression. See also PRE00-C. Prefer inline or static functions to function-like macros and PRE01-C. Use parentheses within macros around parameter names .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This CUBE() macro definition is noncompliant because it fails to parenthesize the replacement list:",
          "code": "#define CUBE(X) (X) * (X) * (X)\nint i = 3;\nint a = 81 / CUBE(i);\n",
          "explanation_after": "As a result, the invocation\n\nexpands to\n\nwhich evaluates as\n\nwhich is not the desired behavior."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "With its replacement list parenthesized, the CUBE() macro expands correctly for this type of invocation.",
          "code": "#define CUBE(X) ((X) * (X) * (X))\nint i = 3;\nint a = 81 / CUBE(i);\n",
          "explanation_after": "This compliant solution violates PRE00-C. Prefer inline or static functions to function-like macros . Consequently, this solution would be better implemented as an inline function."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, END_OF_FILE is defined as -1 . The macro replacement list consists of a unary negation operator followed by an integer literal 1:",
          "code": "#define END_OF_FILE -1\n/* ... */\nif (getchar() END_OF_FILE) {\n   /* ... */\n}\n",
          "explanation_after": "In this example, the programmer has mistakenly omitted the comparison operator from the conditional statement, which should be getchar() != END_OF_FILE . (See void MSC02-C. Avoid errors of omission .) After macro expansion, the conditional expression is incorrectly evaluated as a binary operation: getchar()-1 . This statement is syntactically correct, even though it is certainly not what the programmer intended. Note that this example also violates DCL00-C. Const-qualify immutable objects .\n\nParenthesizing the -1 in the declaration of END_OF_FILE ensures that the macro expansion is evaluated correctly:\n\nOnce this modification is made, the noncompliant code example no longer compiles because the macro expansion results in the conditional expression getchar() (-1) , which is no longer syntactically valid. Note that there must be a space after END_OF_FILE because, otherwise, it becomes a function-like macro (and one that is incorrectly formed because −1 cannot be a formal parameter)."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the macro definition is replaced with an enumeration constant in compliance with DCL00-C. Const-qualify immutable objects . In addition, because EOF is a reserved macro defined in the <stdio.h> header, the compliant solution must also use a different indentifier in order to comply with DCL37-C. Do not declare or define a reserved identifier .",
          "code": "enum { END_OF_FILE = -1 };\n/* ... */\nif (getchar() != END_OF_FILE) {\n   /* ... */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to parenthesize macro replacement lists can cause unexpected results.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "PRE04-C",
    "title": "Do not reuse a standard header file name",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE04-C.+Do+not+reuse+a+standard+header+file+name",
    "description": "If a file with the same name as a standard header is placed in the search path for included source files, the behavior is undefined .\n\nThe following table from the C Standard, subclause 7.1.2 [ ISO/IEC 9899:2011 ], lists these standard headers:\n\n<assert.h> <float.h> <math.h> <stdatomic.h> <stdlib.h> <time.h> <complex.h> <inttypes.h> <setjmp.h> <stdbool.h> <stdnoreturn.h> <uchar.h> <ctype.h> <iso646.h> <signal.h> <stddef.h> <string.h> <wchar.h> <errno.h> <limits.h> <stdalign.h> <stdint.h> <tgmath.h> <wctype.h> <fenv.h> <locale.h> <stdarg.h> <stdio.h> <threads.h>\n\n<assert.h>\n\n<float.h>\n\n<math.h>\n\n<stdatomic.h>\n\n<stdlib.h>\n\n<time.h>\n\n<complex.h>\n\n<inttypes.h>\n\n<setjmp.h>\n\n<stdbool.h>\n\n<stdnoreturn.h>\n\n<uchar.h>\n\n<ctype.h>\n\n<iso646.h>\n\n<signal.h>\n\n<stddef.h>\n\n<string.h>\n\n<wchar.h>\n\n<errno.h>\n\n<limits.h>\n\n<stdalign.h>\n\n<stdint.h>\n\n<tgmath.h>\n\n<wctype.h>\n\n<fenv.h>\n\n<locale.h>\n\n<stdarg.h>\n\n<stdio.h>\n\n<threads.h>\n\nDo not reuse standard header file names, system-specific header file names, or other header file names.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the programmer chooses to use a local version of the standard library but does not make the change clear:",
          "code": "#include \"stdio.h\"  /* Confusing, distinct from <stdio.h> */\n\n/* ... */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The solution addresses the problem by giving the local library a unique name (per PRE08-C. Guarantee that header file names are unique ), which makes it apparent that the library used is not the original:",
          "code": "/* Using a local version of stdio.h */ \n#include \"mystdio.h\"\n\n/* ... */\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using header file names that conflict with other header file names can result in an incorrect file being included.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE05-C",
    "title": "Understand macro replacement when concatenating tokens or performing stringification",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE05-C.+Understand+macro+replacement+when+concatenating+tokens+or+performing+stringification",
    "description": "It is necessary to understand how macro replacement works in C, particularly in the context of concatenating tokens using the ## operator and converting macro parameters to strings using the # operator.\n\n##\n\n#\n\nConcatenating Tokens\n\nThe ## preprocessing operator is used to merge two tokens into one while expanding macros, which is called token pasting or token concatenation . When a macro is expanded, the two tokens on either side of each ## operator are combined into a single token that replaces the ## and the two original tokens in the macro expansion [ FSF 2005 ].\n\n##\n\n##\n\n##\n\nToken pasting is most useful when one or both of the tokens come from a macro argument. If either of the tokens next to a ## is a parameter name, it is replaced by its actual argument before ## executes. The actual argument is not macro expanded first.\n\n##\n\n##\n\nStringification\n\nParameters are not replaced inside string constants, but the # preprocessing operator can be used instead. When a macro parameter is used with a leading # , the preprocessor replaces it with the literal text of the actual argument converted to a string constant [ FSF 2005 ].\n\n#\n\n#",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The following definition for static_assert() from DCL03-C. Use a static assertion to test the value of a constant expression uses the JOIN() macro to concatenate the token assertion_failed_at_line_ with the value of __LINE__ :",
          "code": "#define static_assert(e) \\\n  typedef char JOIN(assertion_failed_at_line_, __LINE__) \\\n    [(e) ? 1 : -1]\n",
          "explanation_after": "__LINE__ is a predefined macro name that expands to an integer constant representing the presumed line number of the current source line within the current source file. If the intention is to expand the __LINE__ macro, which is likely the case here, the following definition for JOIN() is noncompliant because the __LINE__ is not expanded, and the character array is subsequently named assertion_failed_at_line___LINE__ :"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "To get the macro to expand, a second level of indirection is required, as shown by this compliant solution:",
          "code": "#define JOIN(x, y) JOIN_AGAIN(x, y)\n#define JOIN_AGAIN(x, y) x ## y\n",
          "explanation_after": "JOIN(x, y) calls JOIN_AGAIN(x, y) so that if x or y is a macro, it is expanded before the ## operator pastes them together.\n\nNote also that macro parameters cannot be individually parenthesized when concatenating tokens using the ## operator, converting macro parameters to strings using the # operator, or concatenating adjacent string literals. This is an exception, PRE01-C-EX2 , to PRE01-C. Use parentheses within macros around parameter names ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This example is noncompliant if the programmer's intent is to expand the macro before stringification:",
          "code": "#define str(s) #s\n#define foo 4\n\nstr(foo)\n",
          "explanation_after": "The macro invocation str(foo) expands to foo ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "To stringify the result of expansion of a macro argument, two levels of macros must be used:",
          "code": "#define xstr(s) str(s)\n#define str(s) #s\n#define foo 4\n",
          "explanation_after": "The macro invocation xstr(foo) expands to 4 because s is stringified when it is used in str() , so it is not macro expanded first. However, s is an ordinary argument to xstr() , so it is completely macro expanded before xstr() is expanded. Consequently, by the time str() gets to its argument, it has already been macro expanded."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE06-C",
    "title": "Enclose header files in an include guard",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE06-C.+Enclose+header+files+in+an+include+guard",
    "description": "Until the early 1980s, large software development projects had a continual problem with the inclusion of headers. One group might have produced a graphics.h , for example, which started by including io.h . Another group might have produced keyboard.h , which also included io.h . If io.h could not safely be included several times, arguments would break out about which header should include it. Sometimes an agreement was reached that each header should include no other headers, and as a result, some application programs started with dozens of #include lines, and sometimes they got the ordering wrong or forgot a required header.\n\ngraphics.h\n\nio.h\n\nkeyboard.h\n\nio.h\n\nio.h\n\n#include",
    "examples": [
      {
        "noncompliant": null,
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "All these complications disappeared with the discovery of a simple technique: each header should #define a symbol that means \"I have already been included.\" The entire header is then enclosed in an include guard:",
          "code": "#ifndef HEADER_H\n#define HEADER_H\n\n/* ... Contents of <header.h> ... */\n\n#endif /* HEADER_H */\n",
          "explanation_after": "Consequently, the first time header.h is #include 'd, all of its contents are included. If the header file is subsequently #include 'd again, its contents are bypassed.\n\nBecause solutions such as this one make it possible to create a header file that can be included more than once, the C Standard guarantees that the standard headers are safe for multiple inclusion.\n\nNote that it is a common mistake to choose a reserved name (such as _HEADER_H_ or __HEADER_H__ ) for the name of the macro used in the include guard. See DCL37-C. Do not declare or define a reserved identifier for more information.\n\nUntil the early 1980s, large software development projects had a continual problem with the inclusion of headers. One group might have produced a graphics.h , for example, which started by including io.h . Another group might have produced keyboard.h , which also included io.h . If io.h could not safely be included several times, arguments would break out about which header should include it. Sometimes an agreement was reached that each header should include no other headers, and as a result, some application programs started with dozens of #include lines, and sometimes they got the ordering wrong or forgot a required header."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to include header files in an include guard can result in unexpected behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE07-C",
    "title": "Avoid using repeated question marks",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE07-C.+Avoid+using+repeated+question+marks",
    "description": "Two consecutive question marks signify the start of a trigraph sequence. According to the C Standard, subclause 5.2.1.1 [ ISO/IEC 9899:2011 ],\n\nAll occurrences in a source file of the following sequences of three characters (that is, trigraph sequences ) are replaced with the corresponding single character. ??= # ??) ] ??! | ??( [ ??' ^ ??> } ??/ \\ ??< { ??- ~\n\n??=\n\n#\n\n??)\n\n]\n\n??!\n\n|\n\n??(\n\n[\n\n??'\n\n^\n\n??>\n\n}\n\n??/\n\n\\\n\n??<\n\n{\n\n??-\n\n~",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a++ is not executed because the trigraph sequence ??/ is replaced by \\ , logically putting a++ on the same line as the comment:",
          "code": "// What is the value of a now??/\na++;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution eliminates the accidental introduction of the trigraph by separating the question marks:",
          "code": "// What is the value of a now? ?/\na++;\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example includes the trigraph sequence ??! , which is replaced by the character | :",
          "code": "size_t i = /* Some initial value */;\nif (i > 9000) {\n   if (puts(\"Over 9000!??!\") == EOF) {\n     /* Handle error */\n   }\n}\n",
          "explanation_after": "This example prints Over 9000!| if a C-compliant compiler is used."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses string concatenation to concatenate the two question marks; otherwise, they are interpreted as beginning a trigraph sequence:",
          "code": "size_t i = /* Some initial value */;\n/* Assignment of i */\nif (i > 9000) {\n   if (puts(\"Over 9000!?\"\"?!\") == EOF) {\n     /* Handle error */\n   }\n}\n",
          "explanation_after": "This code prints Over 9000!??! , as intended."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Inadvertent trigraphs can result in unexpected behavior. Some compilers provide options to warn when trigraphs are encountered or to disable trigraph expansion. Use the warning options, and ensure your code compiles cleanly. (See MSC00-C. Compile cleanly at high warning levels .)",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE08-C",
    "title": "Guarantee that header file names are unique",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE08-C.+Guarantee+that+header+file+names+are+unique",
    "description": "Make sure that included header file names are unique. According to the C Standard, subclause 6.10.2, paragraph 5 [ ISO/IEC 9899:2011 ],\n\nThe implementation shall provide unique mappings for sequences consisting of one or more nondigits or digits (6.4.2.1) followed by a period (.) and a single nondigit. The first character shall not be a digit. The implementation may ignore distinctions of alphabetical case and restrict the mapping to eight significant characters before the period.\n\nThis means that\n\nOnly the first eight characters in the file name are guaranteed to be significant. The file has only one nondigit character after the period in the file name. The case of the characters in the file name is not guaranteed to be significant.\n\nTo guarantee that header file names are unique, all included files should differ (in a case-insensitive manner) in their first eight characters or in their (one-character) file extension.\n\nNote that compliance with this recommendation does not require that short file names are used, only that the file names are unique.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example contains references to headers that may exist independently in various environments but can be ambiguously interpreted by a C-compliant compiler:",
          "code": "#include \"Library.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"library.h\"\n\n#include \"utilities_math.h\"\n#include \"utilities_physics.h\"\n\n#include \"my_library.h\"\n\n/* ... */\n",
          "explanation_after": "Library.h and library.h may refer to the same file. Also, because only the first eight characters are guaranteed to be significant, it is unclear whether utilities_math.h and utilities_physics.h are parsed. Finally, if a file such as my_libraryOLD.h exists, it may inadvertently be included instead of my_library.h ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution avoids the ambiguity by renaming the associated files to be unique under the preceding constraints:",
          "code": "#include \"Lib_main.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"lib_2.h\"\n\n#include \"util_math.h\"\n#include \"util_physics.h\"\n\n#include \"my_library.h\"\n\n/* ... */\n",
          "explanation_after": "The only solution for mitigating ambiguity of a file, such as my_libraryOLD.h , is to rename old files with either a prefix (that would fall within the first eight characters) or add an extension (such as my_library.h.old )."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to guarantee uniqueness of header files may result in the inclusion of an older version of a header file, which may include incorrect macro definitions or obsolete function prototypes or result in other errors that may or may not be detected by the compiler. Portability issues may also stem from the use of header names that are not guaranteed to be unique.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE09-C",
    "title": "Do not replace secure functions with deprecated or obsolescent functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE09-C.+Do+not+replace+secure+functions+with+deprecated+or+obsolescent+functions",
    "description": "Macros are frequently used in the remediation of existing code to globally replace one identifier with another, for example, when an existing API changes. Although some risk is always involved, this practice becomes particularly dangerous if a function name is replaced with the function name of a deprecated or obsolescent function. Deprecated functions are defined by the C Standard and Technical Corrigenda. Obsolescent functions are defined by MSC24-C. Do not use deprecated or obsolescent functions .\n\nAlthough compliance with rule MSC24-C. Do not use deprecated or obsolescent functions guarantees compliance with this recommendation, the emphasis of this recommendation is the extremely risky and deceptive practice of replacing functions with less secure alternatives.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The Internet Systems Consortium's (ISC) Dynamic Host Configuration Protocol (DHCP) contained a vulnerability that introduced several potential buffer overflow conditions [ VU#654390 ]. ISC DHCP makes use of the vsnprintf() function for writing various log file strings; vsnprintf() is defined in the Portable Operating System Interface (POSIX ® ), Base Specifications, Issue 7 [ IEEE Std 1003.1:2013 ] as well as in the C Standard. For systems that do not support vsnprintf() , a C include file was created that defines the vsnprintf() function to vsprintf() , as shown in this noncompliant code example:",
          "code": "#define vsnprintf(buf, size, fmt, list) \\\nvsprintf(buf, fmt, list)\n",
          "explanation_after": "The vsprintf() function does not check bounds. Consequently, size is discarded, creating the potential for a buffer overflow when untrusted data is used."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The solution is to include an implementation of the missing function vsnprintf() to eliminate the dependency on external library functions when they are not available. This compliant solution assumes that __USE_ISOC11 is not defined on systems that fail to provide a vsnprintf() implementation:",
          "code": "#include <stdio.h>\n#ifndef __USE_ISOC11\n  /* Reimplements vsnprintf() */\n  #include \"my_stdio.h\"\n#endif\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Replacing secure functions with less secure functions is a very risky practice because developers can be easily fooled into trusting the function to perform a security check that is absent. This may be a concern, for example, as developers attempt to adopt more secure functions that might not be available on all platforms. (See VOID STR07-C. Use the bounds-checking interfaces for string manipulation .)",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "PRE10-C",
    "title": "Wrap multistatement macros in a do-while loop",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE10-C.+Wrap+multistatement+macros+in+a+do-while+loop",
    "description": "Macros are often used to execute a sequence of multiple statements as a group.\n\nInline functions are, in general, more suitable for this task (see PRE00-C. Prefer inline or static functions to function-like macros ). Occasionally, however, they are not feasible (when macros are expected to operate on variables of different types, for example).\n\nWhen multiple statements are used in a macro, they should be bound together in a do-while loop syntactically, so the macro can appear safely inside if clauses or other places that expect a single statement or a statement block. Note that this is only effective if none of the multiple statements are break or continue , as they would be captured by the do-while loop. (Alternatively, when an if , for , or while statement uses braces even for a single body statement, then multiple statements in a macro will expand correctly even without a do-while loop (see EXP19-C. Use braces for the body of an if, for, or while statement ).\n\ndo-while\n\nif\n\nbreak\n\ncontinue\n\ndo-while\n\nif\n\nfor\n\nwhile\n\ndo-while",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example contains multiple, unbound statements:",
          "code": "/*\n * Swaps two values and requires\n * tmp variable to be defined.\n */\n#define SWAP(x, y) \\\n  tmp = x; \\\n  x = y; \\\n  y = tmp\n",
          "explanation_after": "This macro expands correctly in a normal sequence of statements but not as the then clause in an if statement:\n\nIt expands to the following, which is certainly not what the programmer intended:\n\nFurthermore, this macro violates PRE02-C. Macro replacement lists should be parenthesized ."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example parenthesizes its macro arguments, but inadequately bounds multiple statements:",
          "code": "/*\n * Swaps two values and requires\n * tmp variable to be defined.\n */\n#define SWAP(x, y) { tmp = (x); (x) = (y); (y) = tmp; }\n",
          "explanation_after": "This macro fails to expand correctly in some case, such as the following example, which is meant to be an if statement with two branches:\n\nFollowing macro expansion, however, this code is interpreted as an if statement with only one branch:\n\nThe problem is the semicolon ( ; ) following the block."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Wrapping the macro inside a do-while loop mitigates the problem:",
          "code": "/*\n * Swaps two values and requires\n * tmp variable to be defined.\n */\n#define SWAP(x, y) \\\n  do { \\\n    tmp = (x); \\\n    (x) = (y); \\\n    (y) = tmp; } \\\n  while (0)\n",
          "explanation_after": "The do-while loop will always be executed exactly once.\n\nThis macro still violates the recommendation PRE12-C. Do not define unsafe macros , because both macro arguments are evaluated twice. It is expected that the arguments are simple lvalues."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Improperly wrapped statement macros can result in unexpected and difficult to diagnose behavior.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "PRE11-C",
    "title": "Do not conclude macro definitions with a semicolon",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE11-C.+Do+not+conclude+macro+definitions+with+a+semicolon",
    "description": "Macros are frequently used to make source code more readable. Macro definitions, regardless of whether they expand to a single or multiple statements, should not conclude with a semicolon. (See PRE10-C. Wrap multistatement macros in a do-while loop .) If required, the semicolon should be included following the macro expansion. Inadvertently inserting a semicolon at the end of the macro definition can unexpectedly change the control flow of the program.\n\nAnother way to avoid this problem is to prefer inline or static functions over function-like macros. (See also PRE00-C. Prefer inline or static functions to function-like macros .)\n\nIn general, the programmer should ensure that there is no semicolon at the end of a macro definition. The responsibility for having a semicolon where needed during the use of such a macro should be delegated to the person invoking the macro.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example creates a macro definition for a for loop in the program. A for loop should require braces, even if it contains only a single body statement. (See EXP19-C. Use braces for the body of an if, for, or while statement .) This macro takes an integer argument, which is the number of times the loop should run. The programmer has inserted a semicolon at the end of the macro definition by mistake.",
          "code": "#define FOR_LOOP(n)  for(i=0; i<(n); i++);\n\nint i;\nFOR_LOOP(3)\n{\n  puts(\"Inside for loop\\n\");\n}\n",
          "explanation_after": "The programmer expects to get the following output from the code:\n\nBut because of the semicolon at the end of the macro definition, the for loop in the program has a null statement, so the statement \"Inside for loop\" gets printed just once. Essentially, the semicolon at the end of the macro definition changes the program control flow.\n\nAlthough this example might not actually be used in code, it shows the effect a semicolon in a macro definition can have."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution is to write the macro definition without the semicolon at the end, leaving the decision whether or not to have a semicolon up to the person who is using the macro:",
          "code": "#define FOR_LOOP(n)  for(i=0; i<(n); i++)\n\nint i;\nFOR_LOOP(3)\n{\n  puts(\"Inside for loop\\n\");\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the programmer defines a macro that increments the value of the first argument, x , by 1 and modulates it with the value of the second argument, max :",
          "code": "#define INCREMOD(x, max) ((x) = ((x) + 1) % (max));\n\nint index = 0;\nint value;\nvalue = INCREMOD(index, 10) + 2;\n/* ... */\n",
          "explanation_after": "In this case, the programmer intends to increment index and then use that as a value by adding 2 to it. Unfortunately, the value is equal to the incremented value of index because of the semicolon present at the end of the macro. The + 2; is treated as a separate statement by the compiler. The user will not get any compilation errors. If the user has not enabled warnings while compiling, the effect of the semicolon in the macro cannot be detected at an early stage."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution is to write the macro definition without the semicolon at the end, leaving the decision whether or not to have a semicolon up to the person who is using the macro:",
          "code": "#define INCREMOD(x, max) ((x) = ((x) + 1) % (max))\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the programmer defines a macro that increments the value of the first argument, x , by 1 and modulates it with the value of the second argument, max :",
          "code": "#define INCREMOD(x, max) ((x) = ((x) + 1) % (max));\n\nint index = 0;\nint value;\nvalue = INCREMOD(index, 10) + 2;\n/* ... */\n",
          "explanation_after": "In this case, the programmer intends to increment index and then use that as a value by adding 2 to it. Unfortunately, the value is equal to the incremented value of index because of the semicolon present at the end of the macro. The + 2; is treated as a separate statement by the compiler. The user will not get any compilation errors. If the user has not enabled warnings while compiling, the effect of the semicolon in the macro cannot be detected at an early stage."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses an inline function as recommended by PRE00-C. Prefer inline or static functions to function-like macros .",
          "code": "inline int incremod(int *x, int max) {*x = (*x + 1) % max;}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Using a semicolon at the end of a macro definition can result in the change of program control flow and thus unintended program behavior.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "PRE12-C",
    "title": "Do not define unsafe macros",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE12-C.+Do+not+define+unsafe+macros",
    "description": "An unsafe function-like macro is one that, when expanded, evaluates its argument more than once or does not evaluate it at all. Contrasted with function calls, which always evaluate each of their arguments exactly once, unsafe function-like macros often have unexpected and surprising effects and lead to subtle, hard-to-find defects (see PRE31-C. Avoid side effects in arguments to unsafe macros ). Consequently, every function-like macro should evaluate each of its arguments exactly once. Alternatively and preferably, defining function-like macros should be avoided in favor of inline functions (see PRE00-C. Prefer inline or static functions to function-like macros ).",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Multiple Argument Evaluation)",
          "pre_code_commentary": "The most severe problem with unsafe function-like macros is side effects of macro arguments, as shown in this noncompliant code example:",
          "code": "#define ABS(x) (((x) < 0) ? -(x) : (x))\n\nvoid f(int n) {\n  int m;\n  m = ABS(++n);\n  /* ... */\n}\n",
          "explanation_after": "The invocation of the ABS() macro in this noncompliant code example expands to the following code. The resulting code has well-defined behavior but causes n to be incremented twice rather than once, which may be surprising to those unfamiliar with the implementation of the macro or unaware that they are using a macro in the first place."
        },
        "compliant": {
          "heading": "Compliant Solution (Inline Function)",
          "pre_code_commentary": "A possible and preferable compliant solution is to define an inline function with equivalent but unsurprising semantics:",
          "code": "inline int Abs(int x) {\n  return x < 0 ? -x : x;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Multiple Argument Evaluation)",
          "pre_code_commentary": "The most severe problem with unsafe function-like macros is side effects of macro arguments, as shown in this noncompliant code example:",
          "code": "#define ABS(x) (((x) < 0) ? -(x) : (x))\n\nvoid f(int n) {\n  int m;\n  m = ABS(++n);\n  /* ... */\n}\n",
          "explanation_after": "The invocation of the ABS() macro in this noncompliant code example expands to the following code. The resulting code has well-defined behavior but causes n to be incremented twice rather than once, which may be surprising to those unfamiliar with the implementation of the macro or unaware that they are using a macro in the first place."
        },
        "compliant": {
          "heading": "Compliant Solution (Language Extension)",
          "pre_code_commentary": "Some implementations provide language extensions that make it possible to define safe function-like macros, such as the macro ABS() , that would otherwise require evaluating their arguments more than once. For example, the GCC extension Statements and Declarations in Expressions makes it possible to implement the macro ABS() in a safe way. Note, however, that because relying on implementation-defined extensions introduces undesirable platform dependencies that may make the resulting code nonportable, such solutions should be avoided in favor of portable ones wherever possible (see MSC14-C. Do not introduce unnecessary platform dependencies ).\n\nAnother GCC extension known as statement expression makes it possible for the block statement to appear where an expression is expected. The statement expression extension establishes a scope (note the curly braces) and any declarations in it are distinct from those in enclosing scopes.",
          "code": "#define ABS(x) __extension__ ({ __typeof (x) __tmp = x; __tmp < 0 ? - __tmp : __tmp; })",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Defining an unsafe macro leads to invocations of the macro with an argument that has side effects , causing those side effects to occur more than once. Unexpected or undefined program behavior can result.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE30-C",
    "title": "Do not create a universal character name through concatenation",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE30-C.+Do+not+create+a+universal+character+name+through+concatenation",
    "description": "The C Standard supports universal character names that may be used in identifiers, character constants, and string literals to designate characters that are not in the basic character set. The universal character name \\U nnnnnnnn designates the character whose 8-digit short identifier (as specified by ISO/IEC 10646) is nnnnnnnn . Similarly, the universal character name \\u nnnn designates the character whose 4-digit short identifier is nnnn (and whose 8-digit short identifier is 0000 nnnn ).\n\n\\U\n\n\\u\n\n0000\n\nThe C Standard, 5.1.1.2, paragraph 4 [ ISO/IEC 9899:2024 ], says\n\nIf a character sequence that matches the syntax of a universal character name is produced by token concatenation (6.10.5.3), the behavior is undefined.\n\nSee also undefined behavior 3 .\n\nIn general, avoid universal character names in identifiers unless absolutely necessary.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code example is noncompliant because it produces a universal character name by token concatenation:",
          "code": "#define assign(uc1, uc2, val) uc1##uc2 = val\n\nvoid func(void) {\n  int \\u0401;\n  /* ... */\n  assign(\\u04, 01, 4);\n  /* ... */\n}",
          "explanation_after": "This code compiles and runs with Microsoft Visual Studio 2013, assigning 4 to the variable as expected.\n\nGCC 4.8.1 on Linux refuses to compile this code; it emits a diagnostic reading, \"stray '\\' in program,\" referring to the universal character fragment in the invocation of the assign macro."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses a universal character name but does not create it by using token concatenation:",
          "code": "#define assign(ucn, val) ucn = val\n \nvoid func(void) {\n  int \\u0401;\n  /* ... */\n  assign(\\u0401, 4);\n  /* ... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Creating a universal character name through token concatenation results in undefined behavior. See undefined behavior 3 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE31-C",
    "title": "Avoid side effects in arguments to unsafe macros",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE31-C.+Avoid+side+effects+in+arguments+to+unsafe+macros",
    "description": "An unsafe function-like macro is one whose expansion results in evaluating one of its parameters more than once or not at all. Never invoke an unsafe macro with arguments containing an assignment, increment, decrement, volatile access, input/output, or other expressions with side effects (including function calls, which may cause side effects).\n\nThe documentation for unsafe macros should warn against invoking them with arguments with side effects, but the responsibility is on the programmer using the macro. Because of the risks associated with their use, it is recommended that the creation of unsafe function-like macros be avoided. (See PRE00-C. Prefer inline or static functions to function-like macros .)\n\nThis rule is similar to EXP44-C. Do not rely on side effects in operands to sizeof, _Alignof, or _Generic .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "One problem with unsafe macros is side effects on macro arguments, as shown by this noncompliant code example:",
          "code": "#define ABS(x) (((x) < 0) ? -(x) : (x))\n \nvoid func(int n) {\n  /* Validate that n is within the desired range */\n  int m = ABS(++n);\n\n  /* ... */\n}",
          "explanation_after": "The invocation of the ABS() macro in this example expands to\n\nThe resulting code is well defined but causes n to be incremented twice rather than once."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the increment operation ++n is performed before the call to the unsafe macro.",
          "code": "#define ABS(x) (((x) < 0) ? -(x) : (x)) /* UNSAFE */\n \nvoid func(int n) {\n  /* Validate that n is within the desired range */\n  ++n;\n  int m = ABS(n);\n\n  /* ... */\n}",
          "explanation_after": "Note the comment warning programmers that the macro is unsafe. The macro can also be renamed ABS_UNSAFE() to make it clear that the macro is unsafe. This compliant solution, like all the compliant solutions for this rule, has undefined behavior (see undefined behavior 36 ) if the argument to ABS() is equal to the minimum (most negative) value for the signed integer type. (See INT32-C. Ensure that operations on signed integers do not result in overflow for more information.)"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "One problem with unsafe macros is side effects on macro arguments, as shown by this noncompliant code example:",
          "code": "#define ABS(x) (((x) < 0) ? -(x) : (x))\n \nvoid func(int n) {\n  /* Validate that n is within the desired range */\n  int m = ABS(++n);\n\n  /* ... */\n}",
          "explanation_after": "The invocation of the ABS() macro in this example expands to\n\nThe resulting code is well defined but causes n to be incremented twice rather than once."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution follows the guidance of PRE00-C. Prefer inline or static functions to function-like macros by defining an inline function iabs() to replace the ABS() macro. Unlike the ABS() macro, which operates on operands of any type, the iabs() function will truncate arguments of types wider than int whose value is not in range of the latter type.",
          "code": "#include <complex.h>\n#include <math.h>\n \nstatic inline int iabs(int x) {\n  return (((x) < 0) ? -(x) : (x));\n}\n \nvoid func(int n) {\n  /* Validate that n is within the desired range */\n\nint m = iabs(++n);\n\n  /* ... */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "One problem with unsafe macros is side effects on macro arguments, as shown by this noncompliant code example:",
          "code": "#define ABS(x) (((x) < 0) ? -(x) : (x))\n \nvoid func(int n) {\n  /* Validate that n is within the desired range */\n  int m = ABS(++n);\n\n  /* ... */\n}",
          "explanation_after": "The invocation of the ABS() macro in this example expands to\n\nThe resulting code is well defined but causes n to be incremented twice rather than once."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "A more flexible compliant solution is to declare the ABS() macro using a _Generic selection. To support all arithmetic data types, this solution also makes use of inline functions to compute integer absolute values. (See PRE00-C. Prefer inline or static functions to function-like macros and PRE12-C. Do not define unsafe macros .)\n\nAccording to the C Standard, 6.5.2.1, paragraph 3 [ ISO/IEC 9899:2024 ]:\n\nThe controlling expression of a generic selection is not evaluated. If a generic selection has a generic association with a type name that is compatible with the type of the controlling expression, then the result expression of the generic selection is the expression in that generic association. Otherwise, the result expression of the generic selection is the expression in the default generic association. None of the expressions from any other generic association of the generic selection is evaluated.\n\nBecause the expression is not evaluated as part of the generic selection, the use of a macro in this solution is guaranteed to evaluate the macro parameter v only once.",
          "code": "#include <complex.h>\n#include <math.h>\n \nstatic inline long long llabs(long long v) {\n  return v < 0 ? -v : v;\n}\nstatic inline long labs(long v) {\n  return v < 0 ? -v : v;\n}\nstatic inline int iabs(int v) {\n  return v < 0 ? -v : v;\n}\nstatic inline int sabs(short v) {\n  return v < 0 ? -v : v;\n}\nstatic inline int scabs(signed char v) {\n  return v < 0 ? -v : v;\n}\n \n#define ABS(v)  _Generic(v, signed char : scabs, \\\n                            short : sabs, \\\n                            int : iabs, \\\n                            long : labs, \\\n                            long long : llabs, \\\n                            float : fabsf, \\\n                            double : fabs, \\\n                            long double : fabsl, \\\n                            double complex : cabs, \\\n                            float complex : cabsf, \\\n                            long double complex : cabsl)(v)\n \nvoid func(int n) {\n  /* Validate that n is within the desired range */\n  int m = ABS(++n);\n  /* ... */\n}",
          "explanation_after": "Generic selections were introduced in C11 and are not available in C99 and earlier editions of the C Standard."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "One problem with unsafe macros is side effects on macro arguments, as shown by this noncompliant code example:",
          "code": "#define ABS(x) (((x) < 0) ? -(x) : (x))\n \nvoid func(int n) {\n  /* Validate that n is within the desired range */\n  int m = ABS(++n);\n\n  /* ... */\n}",
          "explanation_after": "The invocation of the ABS() macro in this example expands to\n\nThe resulting code is well defined but causes n to be incremented twice rather than once."
        },
        "compliant": {
          "heading": "Compliant Solution (GCC)",
          "pre_code_commentary": "GCC's __typeof extension makes it possible to declare and assign the value of the macro operand to a temporary of the same type and perform the computation on the temporary, consequently guaranteeing that the operand will be evaluated exactly once. Another GCC extension, known as statement expression , makes it possible for the block statement to appear where an expression is expected:",
          "code": "#define ABS(x) __extension__ ({ __typeof (x) tmp = x; \\\n                    tmp < 0 ? -tmp : tmp; })",
          "explanation_after": "Note that relying on such extensions makes code nonportable and violates MSC14-C. Do not introduce unnecessary platform dependencies ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( assert() )",
          "pre_code_commentary": "The assert() macro is a convenient mechanism for incorporating diagnostic tests in code. (See MSC11-C. Incorporate diagnostic tests using assertions .) Expressions used as arguments to the standard assert() macro should not have side effects. The behavior of the assert() macro depends on the definition of the object-like macro NDEBUG . If the macro NDEBUG is undefined, the assert() macro is defined to evaluate its expression argument and, if the result of the expression compares equal to 0, call the abort() function. If NDEBUG is defined, assert is defined to expand to ((void)0) . Consequently, the expression in the assertion is not evaluated, and no side effects it may have had otherwise take place in non-debugging executions of the code.\n\nThis noncompliant code example includes an assert() macro containing an expression ( index++ ) that has a side effect:",
          "code": "#include <assert.h>\n#include <stddef.h>\n  \nvoid process(size_t index) {\n  assert(index++ > 0); /* Side effect */\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( assert() )",
          "pre_code_commentary": "This compliant solution avoids the possibility of side effects in assertions by moving the expression containing the side effect outside of the assert() macro.",
          "code": "#include <assert.h>\n#include <stddef.h>\n  \nvoid process(size_t index) {\n  assert(index > 0); /* No side effect */\n  ++index;\n  /* ... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Invoking an unsafe macro with an argument that has side effects may cause those side effects to occur more than once. This practice can lead to unexpected program behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE32-C",
    "title": "Do not use preprocessor directives in invocations of function-like macros",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/PRE32-C.+Do+not+use+preprocessor+directives+in+invocations+of+function-like+macros",
    "description": "The arguments to a macro must not include preprocessor directives, such as #define , #ifdef , and #include . Doing so results in undefined behavior , according to the C Standard, 6.10.5, paragraph 11 [ ISO/IEC 9899:2024 ]:\n\n#define\n\n#ifdef\n\n#include\n\nThe sequence of preprocessing tokens bounded by the outside-most matching parentheses forms the list of arguments for the function-like macro. The individual arguments within the list are separated by comma preprocessing tokens, but comma preprocessing tokens between matching inner parentheses do not separate arguments. If there are sequences of preprocessing tokens within the list of arguments that would otherwise act as preprocessing directives, the behavior is undefined.\n\nSee also undefined behavior 92 .\n\nThis rule also applies to the use of preprocessor directives in arguments to any function where it is unknown whether or not the function is implemented using a macro. This includes all standard library functions, such as memcpy() , printf() , and assert() , because any standard library function may be implemented as a macro. (C24, 7.1.4, paragraph 1).\n\nmemcpy()\n\nprintf()\n\nassert()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example [ GCC Bugs ], the programmer uses preprocessor directives to specify platform-specific arguments to memcpy() . However, if memcpy() is implemented using a macro, the code results in undefined behavior 92 .",
          "code": "#include <string.h>\n \nvoid func(const char *src) {\n  /* Validate the source string; calculate size */\n  char *dest;\n  /* malloc() destination string */ \n  memcpy(dest, src,\n    #ifdef PLATFORM1\n      12\n    #else\n      24\n    #endif\n  );\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution [ GCC Bugs ], the appropriate call to memcpy() is determined outside the function call:",
          "code": "#include <string.h>\n\nvoid func(const char *src) {\n  /* Validate the source string; calculate size */\n  char *dest;\n  /* malloc() destination string */ \n  #ifdef PLATFORM1\n    memcpy(dest, src, 12);\n  #else\n    memcpy(dest, src, 24);\n  #endif\n  /* ... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Including preprocessor directives in macro arguments is undefined behavior 92 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "SIG00-C",
    "title": "Mask signals handled by noninterruptible signal handlers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/SIG00-C.+Mask+signals+handled+by+noninterruptible+signal+handlers",
    "description": "A signal is a mechanism for transferring control that is typically used to notify a process that an event has occurred. That process can then respond to the event accordingly. The C Standard provides functions for sending and handling signals within a C program.\n\nProcesses handle signals by registering a signal handler using the signal() function, which is specified as\n\nsignal()\n\nvoid (*signal(int sig, void (*func)(int)))(int);\n\nvoid (*signal(int sig, void (*func)(int)))(int);\n\nThis signal handler is conceptually equivalent to\n\ntypedef void (*sighandler_t)(int signum);\nextern sighandler_t signal(\n  int signum, \n  sighandler_t handler\n);\n\ntypedef void (*sighandler_t)(int signum);\nextern sighandler_t signal(\n  int signum, \n  sighandler_t handler\n);\n\nSignal handlers can be interrupted by signals, including their own. If a signal is not reset before its handler is called, the handler can interrupt its own execution. A handler that always successfully executes its code despite interrupting itself or being interrupted is async-signal-safe .\n\nSome platforms provide the ability to mask signals while a signal handler is being processed. If a signal is masked while its own handler is processed, the handler is noninterruptible and need not be async-signal-safe. However, even when a signal is masked while its own handler is processed, the handler must still avoid invoking async-signal-safe unsafe functions because their execution may be (or have been) interrupted by another signal.\n\nVulnerabilities can arise if a signal handler that is not async-signal-safe is interrupted with any unmasked signal, including its own.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example registers a single signal handler to process both SIGUSR1 and SIGUSR2 . The variable sig2 should be set to 1 if one or more SIGUSR1 signals are followed by SIGUSR2 , essentially implementing a finite state machine within the signal handler.",
          "code": "#include <signal.h>\n\nvolatile sig_atomic_t sig1 = 0;\nvolatile sig_atomic_t sig2 = 0;\n\nvoid handler(int signum) {\n  if (signum == SIGUSR1) {\n    sig1 = 1;\n  }\n  else if (sig1) {\n    sig2 = 1;\n  }\n}\n\nint main(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  if (signal(SIGUSR2, handler) == SIG_ERR) {\n    /* Handler error */\n  }\n\n  while (sig2 == 0) {\n    /* Do nothing or give up CPU for a while */\n  }\n\n  /* ... */\n\n  return 0;\n}\n",
          "explanation_after": "Unfortunately, a race condition occurs in the implementation of handler() . If handler() is called to handle SIGUSR1 and is interrupted to handle SIGUSR2 , it is possible that sig2 will not be set."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "The POSIX sigaction() function assigns handlers to signals in a similar manner to the C signal() function, but it also allows signal masks to be set explicitly. Consequently, sigaction() can be used to prevent a signal handler from interrupting itself.",
          "code": "#include <signal.h>\n#include <stdio.h>\n\nvolatile sig_atomic_t sig1 = 0;\nvolatile sig_atomic_t sig2 = 0;\n\nvoid handler(int signum) {\n  if (signum == SIGUSR1) {\n    sig1 = 1;\n  }\n  else if (sig1) {\n    sig2 = 1;\n  }\n}\n\nint main(void) {\n  struct sigaction act;\n  act.sa_handler = &handler;\n  act.sa_flags = 0;\n  if (sigemptyset(&act.sa_mask) != 0) {\n    /* Handle error */\n  }\n  if (sigaddset(&act.sa_mask, SIGUSR1)) {\n    /* Handle error */\n  }\n  if (sigaddset(&act.sa_mask, SIGUSR2)) {\n    /* Handle error */\n  }\n\n  if (sigaction(SIGUSR1, &act, NULL) != 0) {\n    /* Handle error */\n  }\n  if (sigaction(SIGUSR2, &act, NULL) != 0) {\n    /* Handle error */\n  }\n\n  while (sig2 == 0) {\n    /* Do nothing or give up CPU for a while */\n  }\n\n  /* ... */\n\n  return 0;\n}\n",
          "explanation_after": "POSIX recommends sigaction() and deprecates the use of signal() to register signal handlers. Unfortunately, sigaction() is not defined in the C Standard and is consequently not as portable a solution."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Interrupting a noninterruptible signal handler can result in a variety of vulnerabilities [ Zalewski 2001 ].",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "SIG01-C",
    "title": "Understand implementation-specific details regarding signal handler persistence",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/SIG01-C.+Understand+implementation-specific+details+regarding+signal+handler+persistence",
    "description": "The signal() function has implementation-defined behavior and behaves differently on Windows, for example, than it does on many UNIX systems.\n\nsignal()\n\nThe following code example shows this behavior:\n\n#include <stdio.h>\n#include <signal.h>\n\nvolatile sig_atomic_t e_flag = 0;\n\nvoid handler(int signum) {\n  e_flag = 1;\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  while (!e_flag) {}\n  puts(\"Escaped from first while ()\");\n  e_flag = 0;\n  while (!e_flag) {}\n  puts(\"Escaped from second while ()\");\n  return 0;\n}\n\n#include <stdio.h>\n#include <signal.h>\n\nvolatile sig_atomic_t e_flag = 0;\n\nvoid handler(int signum) {\n  e_flag = 1;\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  while (!e_flag) {}\n  puts(\"Escaped from first while ()\");\n  e_flag = 0;\n  while (!e_flag) {}\n  puts(\"Escaped from second while ()\");\n  return 0;\n}\n\nMany UNIX (and UNIX-like) systems automatically reinstall signal handlers upon handler execution, meaning that the signal handler defined by the user is left in place until it is explicitly removed. For example, when this code is compiled with GCC 3.4.4 and executed under Red Hat Linux, SIGINT is captured both times by handler :\n\nSIGINT\n\nhandler\n\n% ./test\n^C\nEscaped from first while ()\n^C\nEscaped from second while ()\n%\n\n% ./test\n^C\nEscaped from first while ()\n^C\nEscaped from second while ()\n%\n\nWhen a signal handler is installed with the signal() function in Windows and some UNIX systems, the default action is restored for that signal after the signal is triggered. This means that signal handlers are not automatically reinstalled. For example, when this code is compiled with Microsoft Visual Studio 2005, version 8.0, only the first SIGINT is captured by handler :\n\nsignal()\n\nSIGINT\n\nhandler\n\n> test.exe\n^C\nEscaped from first while ()\n^C\n>\n\n> test.exe\n^C\nEscaped from first while ()\n^C\n>\n\nThe second SIGINT executes the default action, which is to terminate program execution.\n\nSIGINT\n\nDifferent actions must be taken depending on whether or not the application requires signal handlers to be persistent.\n\nPersistent Handlers\n\nAsynchronous signals may originate from malicious actors external to the process. Consequently, vulnerabilities may exist if the signal-handler-persistence behavior is inconsistent with the developer's expectations, such as when the developer expects the signal handler to persist but it does not.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example fails to persist the signal handler on Windows platforms and on those UNIX systems where handlers are not persistent by default:",
          "code": "void handler(int signum) {\n  /* Handle signal */\n}\n",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "A common approach to create persistent signal handlers is to call signal() from within the handler itself, consequently unresetting the reset signal:",
          "code": "void handler(int signum) {\n  if (signal(signum, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  /* Handle signal */\n}\n",
          "explanation_after": "Unfortunately, this solution still contains a race window, starting when the host environment resets the signal and ending when the handler calls signal() . During that time, a second signal sent to the program will trigger the default signal behavior, defeating the persistent behavior. (See SIG34-C. Do not call signal() from within interruptible signal handlers .)\n\nA secure solution must prevent the environment from resetting the signal in the first place, guaranteeing persistence. Unfortunately, Windows does not provide a secure solution to this problem."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "The POSIX sigaction() function assigns handlers to signals in a manner similar to the C signal() function but also allows signal-handler persistence to be controlled via the SA_RESETHAND flag. (Leaving the flag clear makes the handler persistent.)",
          "code": "/* \n * Equivalent to signal(SIGUSR1, handler) but makes\n * signal persistent. \n */\nstruct sigaction act;\nact.sa_handler = handler;\nact.sa_flags = 0;\nif (sigemptyset(&act.sa_mask) != 0) {\n  /* Handle error */\n}\nif (sigaction(SIGUSR1, &act, NULL) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": "POSIX recommends sigaction() and deprecates signal() . Unfortunately, sigaction() is not defined in the C Standard and is consequently not as portable a solution.\n\nErrors may also occur when the developer expects the default action to be restored for a signal but the signal handler persists instead."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (UNIX)",
          "pre_code_commentary": "This noncompliant code example fails to reset the signal handler to its default behavior on systems where handlers are persistent by default:",
          "code": "void handler(int signum) {\n  /* Handle signal */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (UNIX and Windows)",
          "pre_code_commentary": "A C-compliant solution to reset the handler on a UNIX system is to rebind the signal to the default handler in the first line of the handler itself. Windows, however, automatically resets handlers to their default behavior.",
          "code": "void handler(int signum) {\n#ifndef WINDOWS\n  if (signal(signum, SIG_DFL) == SIG_ERR) {\n    /* Handler error */\n  }\n#endif\n  /* Handle signal */\n}\n",
          "explanation_after": "With the compliant solution for UNIX, no race condition occurs that can be exploited by an attacker sending a second signal. This is because a second signal sent to the handler, before the latter calls signal(signum, SIG_DFL) , will only cause the handler to restart and call signal() anyway.\n\nThis solution is an exception to SIG34-C. Do not call signal() from within interruptible signal handlers ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (UNIX)",
          "pre_code_commentary": "This noncompliant code example fails to reset the signal handler to its default behavior on systems where handlers are persistent by default:",
          "code": "void handler(int signum) {\n  /* Handle signal */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "The POSIX sigaction() function assigns handlers to signals in a manner similar to the C signal() function but also allows signal-handler persistence to be controlled via the SA_RESETHAND flag. (Setting the flag makes the handler nonpersistent.)",
          "code": "/* \n * Equivalent to signal(SIGUSR1, handler) but makes\n * signal nonpersistent.\n */\nstruct sigaction act;\nact.sa_handler = handler;\nact.sa_flags = SA_RESETHAND;\nif (sigemptyset(&act.sa_mask) != 0) {\n  /* Handle error */\n}\nif (sigaction(SIGUSR1, &act, NULL) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to understand implementation-specific details regarding signal-handler persistence can lead to unexpected behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "SIG02-C",
    "title": "Avoid using signals to implement normal functionality",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/SIG02-C.+Avoid+using+signals+to+implement+normal+functionality",
    "description": "Avoid using signals to implement normal functionality. Signal handlers are severely limited in the actions they can perform in a portably secure manner. Their use should be reserved for abnormal events that can be serviced by little more than logging.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example uses signals as a means to pass state changes around in a multithreaded environment:",
          "code": "/* THREAD 1 */\nint do_work(void) {\n  /* ... */\n  kill(THR2_PID, SIGUSR1);\n}\n\n/* THREAD 2 */\nvolatile sig_atomic_t flag;\n\nvoid sigusr1_handler(int signum) {\n  flag = 1;\n}\n\nint wait_and_work(void) {\n  flag = 0;\n  while (!flag) {}\n  /* ... */\n}\n",
          "explanation_after": "However, using signals for such functionality often leads to nonportable or otherwise complicated solutions.\n\nThis code illustrates one thread using a signal to wake up a second thread. Using an architecture's native thread library usually allows for a more sophisticated means of sending messages between threads."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "A better solution, in this case, is to use condition variables. This code example uses a condition variable from the POSIX pthread library [ IEEE Std 1003.1:2013 ]:",
          "code": "#include <pthread.h>\n\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\npthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;\n\n/* THREAD 1 */\nint do_work(void) {\n  int result;\n  /* ... */\n  if ((result = pthread_mutex_lock(&mut)) != 0) {\n    /* Handle error condition */\n  }\n  if ((result = pthread_cond_signal(&cond,&mut)) != 0) {\n    /* Handle error condition */\n  }\n  if ((result = pthread_mutex_unlock(&mut)) != 0) {\n    /* Handle error condition */\n  }\n}\n\n/* THREAD 2 */\nint wait_and_work(void) {\n  if ((result = pthread_mutex_lock(&mut)) != 0) {\n    /* Handle error condition */\n  }\n  while (/* Condition does not hold */) {\n    if ((result = pthread_cond_wait(&cond, &mut)) != 0) {\n      /* Handle error condition */\n    }\n    /* ... */\n  }\n  if ((result = pthread_mutex_unlock(&mut)) != 0) {\n    /* Handle error condition */\n  }\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example uses signals as a means to pass state changes around in a multithreaded environment:",
          "code": "/* THREAD 1 */\nint do_work(void) {\n  /* ... */\n  kill(THR2_PID, SIGUSR1);\n}\n\n/* THREAD 2 */\nvolatile sig_atomic_t flag;\n\nvoid sigusr1_handler(int signum) {\n  flag = 1;\n}\n\nint wait_and_work(void) {\n  flag = 0;\n  while (!flag) {}\n  /* ... */\n}\n",
          "explanation_after": "However, using signals for such functionality often leads to nonportable or otherwise complicated solutions.\n\nThis code illustrates one thread using a signal to wake up a second thread. Using an architecture's native thread library usually allows for a more sophisticated means of sending messages between threads."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "This compliant solution uses a condition variable from the Win32 API [ MSDN ]:",
          "code": "#include <windows.h>\n\n/* \n * Note that the CRITICAL_SECTION must be initialized with\n * InitializeCriticalSection, and the CONDITION_VARIABLE must\n * be initialized with InitializeConditionVariable prior to \n * using them.\n */\nCRITICAL_SECTION CritSection;\nCONDITION_VARIABLE ConditionVar;\n\n/* THREAD 1 */\nint do_work(void) {\n  /* ... */\n  WakeConditionVariable(&ConditionVar);\n}\n\n/* THREAD 2 */\nint wait_and_work(void) {\n\n  EnterCriticalSection(&CritSection);\n  SleepConditionVariableCS(&ConditionVar, &CritSection, INFINITE);\n  LeaveCriticalSection(&CritSection);\n  /* ... */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example is from a signal race vulnerability in WU-FTPD v2.4 [ Greenman 1997 ]:",
          "code": "void dologout(status) {\n  if (logged_in) {\n    (void) seteuid((uid_t)0);\n    logwtmp(ttyline, \"\", \"\");\n    /* ... */\n  }\n  _exit(status);\n}\n\nstatic void lostconn(int signo) {\n  if (debug)\n    syslog(LOG_DEBUG, \"lost connection\");\n  dologout(-1);\n}\n\nstatic void myoob(signo) {\n  if (!transflag)\n    return;\n  /* ... */\n  if (strcmp(cp, \"ABOR\\r\\n\") == 0) {\n    tmpline[0] = '\\0';\n    reply(426, \"Transfer aborted. Data connection closed.\");\n    reply(226, \"Abort successful\");\n    longjmp(urgcatch, 1);\n  }\n  /* ... */\n}\n\n/* ... */\n\nsignal(SIGPIPE, lostconn);\nsignal(SIGURG, myoob);\n",
          "explanation_after": "A serious exploit can occur if SIGURG is caught immediately following the elevation of privileges in dologout() . If the longjmp() in the SIGURG handler myoob() is invoked, execution returns to the main processing loop with an effective UID of 0.\n\nPlease note that this code sample violates SIG30-C. Call only asynchronous-safe functions within signal handlers and SIG31-C. Do not access shared objects in signal handlers .\n\nAn immediate fix is to ensure that dologout() cannot be interrupted by a SIGURG :\n\nA better solution is for myoob() to set a failure flag of type volatile sig_atomic_t that is periodically checked within the main loop:\n\nThis solution, however, still violates SIG30-C. Call only asynchronous-safe functions within signal handlers and SIG31-C. Do not access shared objects in signal handlers ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "A compliant solution (not shown) is to not use signals to signify lost connections and to design the system to have a robust error-handling mechanism (see ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy ).",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "SIG30-C",
    "title": "Call only asynchronous-safe functions within signal handlers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/SIG30-C.+Call+only+asynchronous-safe+functions+within+signal+handlers",
    "description": "Call only asynchronous-safe functions within signal handlers. For strictly conforming programs, only the C standard library functions abort() , _Exit() , quick_exit() , and signal() can be safely called from within a signal handler.\n\nabort()\n\n_Exit()\n\nquick_exit()\n\nsignal()\n\nThe C Standard, 7.14.1.1, paragraph 5 [ ISO/IEC 9899:2024 ], states that if the signal occurs other than as the result of calling the abort() or raise() function, the behavior is undefined if\n\nabort()\n\nraise()\n\nIf the signal occurs other than as the result of calling the abort or raise function, the behavior is undefined if the signal handler refers to any object with static or thread storage duration that is not a lock-free atomic object and that is not declared with the constexpr storage-class specifier other than by assigning a value to an object declared as volatile sig _ atomic _ t , or the signal handler calls any function in the standard library other than —  the abort function, —  the _ Exit function, —  the quick _ exit function, —  the functions in <stdatomic.h> (except where explicitly stated otherwise) when the atomic arguments are lock-free, —  the atomic _ is _ lock _ free function with any atomic argument, or —  the signal function with the first argument equal to the signal number corresponding to the signal that caused the invocation of the handler. Furthermore, if such a call to the signal function results in a SIG _ ERR return, the object designated by errno has an indeterminate representation. 294)\n\nImplementations may define a list of additional asynchronous-safe functions. These functions can also be called within a signal handler. This restriction applies to library functions as well as application-defined functions.\n\nAccording to the C Rationale, 7.14.1.1 [ C99 Rationale 2003 ],\n\nWhen a signal occurs, the normal flow of control of a program is interrupted. If a signal occurs that is being trapped by a signal handler, that handler is invoked. When it is finished, execution continues at the point at which the signal occurred. This arrangement can cause problems if the signal handler invokes a library function that was being executed at the time of the signal.\n\nIn general, it is not safe to invoke I/O functions from within signal handlers. Programmers should ensure a function is included in the list of an implementation's asynchronous-safe functions for all implementations the code will run on before using them in signal handlers.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, the C standard library functions fputs() and free() are called from the signal handler via the function log_message() . Neither function is asynchronous-safe .",
          "code": "#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nenum { MAXLINE = 1024 };\nchar *info = NULL;\n\nvoid log_message(void) {\n  fputs(info, stderr);\n}\n\nvoid handler(int signum) {\n  log_message();\n  free(info);\n  info = NULL;\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  info = (char *)malloc(MAXLINE);\n  if (info == NULL) {\n    /* Handle Error */\n  }\n\n  while (1) {\n    /* Main loop program code */\n\n    log_message();\n\n    /* More program code */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Signal handlers should be as concise as possible—ideally by unconditionally setting a flag and returning. This compliant solution sets a flag of type volatile sig_atomic_t and returns; the log_message() and free() functions are called directly from main() :",
          "code": "#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nenum { MAXLINE = 1024 };\nvolatile sig_atomic_t eflag = 0;\nchar *info = NULL;\n\nvoid log_message(void) {\n  fputs(info, stderr);\n}\n\nvoid handler(int signum) {\n  eflag = 1;\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  info = (char *)malloc(MAXLINE);\n  if (info == NULL) {\n    /* Handle error */\n  }\n\n  while (!eflag) {\n    /* Main loop program code */\n\n    log_message();\n\n    /* More program code */\n  }\n\n  log_message();\n  free(info);\n  info = NULL;\n\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( longjmp() )",
          "pre_code_commentary": "Invoking the longjmp() function from within a signal handler can lead to undefined behavior 132 if it results in the invocation of any non- asynchronous-safe functions. Consequently, neither longjmp() nor the POSIX siglongjmp() functions should ever be called from within a signal handler.\n\nThis noncompliant code example is similar to a vulnerability in an old version of Sendmail [ VU #834865 ]. The intent is to execute code in a main() loop, which also logs some data. Upon receiving a SIGINT , the program transfers out of the loop, logs the error, and terminates.\n\nHowever, an attacker can exploit this noncompliant code example by generating a SIGINT just before the second if statement in log_message() . The result is that longjmp() transfers control back to main() , where log_message() is called again. However, the first if statement would not be executed this time (because buf is not set to NULL as a result of the interrupt), and the program would write to the invalid memory location referenced by buf0 .",
          "code": "#include <setjmp.h>\n#include <signal.h>\n#include <stdlib.h>\n\nenum { MAXLINE = 1024 };\nstatic jmp_buf env;\n\nvoid handler(int signum) {\n  longjmp(env, 1);\n}\n\nvoid log_message(char *info1, char *info2) {\n  static char *buf = NULL;\n  static size_t bufsize;\n  char buf0[MAXLINE];\n\n  if (buf == NULL) {\n    buf = buf0;\n    bufsize = sizeof(buf0);\n  }\n\n  /*\n   * Try to fit a message into buf, else reallocate\n   * it on the heap and then log the message.\n   */\n\n  /* Program is vulnerable if SIGINT is raised here */\n\n  if (buf == buf0) {\n    buf = NULL;\n  }\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  char *info1;\n  char *info2;\n\n  /* info1 and info2 are set by user input here */\n\n  if (setjmp(env) == 0) {\n    while (1) {\n      /* Main loop program code */\n      log_message(info1, info2);\n      /* More program code */\n    }\n  } else {\n    log_message(info1, info2);\n  }\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the call to longjmp() is removed; the signal handler sets an error flag instead:",
          "code": "#include <signal.h>\n#include <stdlib.h>\n\nenum { MAXLINE = 1024 };\nvolatile sig_atomic_t eflag = 0;\n\nvoid handler(int signum) {\n  eflag = 1;\n}\n\nvoid log_message(char *info1, char *info2) {\n  static char *buf = NULL;\n  static size_t bufsize;\n  char buf0[MAXLINE];\n\n  if (buf == NULL) {\n    buf = buf0;\n    bufsize = sizeof(buf0);\n  }\n\n  /*\n   * Try to fit a message into buf, else reallocate\n   * it on the heap and then log the message.\n   */\n  if (buf == buf0) {\n    buf = NULL;\n  }\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  char *info1;\n  char *info2;\n\n  /* info1 and info2 are set by user input here */\n\n  while (!eflag) {\n    /* Main loop program code */\n    log_message(info1, info2);\n    /* More program code */\n  }\n\n  log_message(info1, info2);\n\n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( raise() )",
          "pre_code_commentary": "In this noncompliant code example, the int_handler() function is used to carry out tasks specific to SIGINT and then raises SIGTERM . However, there is a nested call to the raise() function, which is undefined behavior 131 .",
          "code": "#include <signal.h>\n#include <stdlib.h>\n \nvoid term_handler(int signum) {\n  /* SIGTERM handler */\n}\n \nvoid int_handler(int signum) {\n  /* SIGINT handler */\n  if (raise(SIGTERM) != 0) {\n    /* Handle error */\n  }\n}\n \nint main(void) {\n  if (signal(SIGTERM, term_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  if (signal(SIGINT, int_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n \n  /* Program code */\n  if (raise(SIGINT) != 0) {\n    /* Handle error */\n  }\n  /* More code */\n \n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, int_handler() invokes term_handler() instead of raising SIGTERM :",
          "code": "#include <signal.h>\n#include <stdlib.h>\n \nvoid term_handler(int signum) {\n  /* SIGTERM handler */\n}\n \nvoid int_handler(int signum) {\n  /* SIGINT handler */\n  /* Pass control to the SIGTERM handler */\n  term_handler(SIGTERM);\n}\n \nint main(void) {\n  if (signal(SIGTERM, term_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  if (signal(SIGINT, int_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n \n  /* Program code */\n  if (raise(SIGINT) != 0) {\n    /* Handle error */\n  }\n  /* More code */\n \n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Invoking functions that are not asynchronous-safe from within a signal handler is undefined behavior 132 .",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "SIG31-C",
    "title": "Do not access shared objects in signal handlers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers",
    "description": "Accessing or modifying shared objects in signal handlers can result in race conditions that can leave data in an inconsistent state. The two exceptions (C Standard, 5.1.2.3, paragraph 5) to this rule are the ability to read from and write to lock-free atomic objects and variables of type volatile sig_atomic_t . Accessing any other type of object from a signal handler is undefined behavior . (See undefined behavior 131 .)\n\nvolatile sig_atomic_t\n\nThe need for the volatile keyword is described in DCL22-C. Use volatile for data that cannot be cached .\n\nvolatile\n\nThe type sig_atomic_t is the integer type of an object that can be accessed as an atomic entity even in the presence of asynchronous interrupts. The type of sig_atomic_t is implementation-defined , though it provides some guarantees. Integer values ranging from SIG_ATOMIC_MIN through SIG_ATOMIC_MAX , inclusive, may be safely stored to a variable of the type. In addition, when sig_atomic_t is a signed integer type, SIG_ATOMIC_MIN must be no greater than −127 and SIG_ATOMIC_MAX no less than 127 . Otherwise, SIG_ATOMIC_MIN must be 0 and SIG_ATOMIC_MAX must be no less than 255 . The macros SIG_ATOMIC_MIN and SIG_ATOMIC_MAX are defined in the header <stdint.h> .\n\nsig_atomic_t\n\nsig_atomic_t\n\nSIG_ATOMIC_MIN\n\nSIG_ATOMIC_MAX\n\nsig_atomic_t\n\nSIG_ATOMIC_MIN\n\n−127\n\nSIG_ATOMIC_MAX\n\n127\n\nSIG_ATOMIC_MIN\n\n0\n\nSIG_ATOMIC_MAX\n\n255\n\nSIG_ATOMIC_MIN\n\nSIG_ATOMIC_MAX\n\n<stdint.h>\n\nAccording to the C99 Rationale [ C99 Rationale 2003 ], other than calling a limited, prescribed set of library functions,\n\nthe C89 Committee concluded that about the only thing a strictly conforming program can do in a signal handler is to assign a value to a volatile static variable which can be written uninterruptedly and promptly return.\n\nvolatile static\n\nHowever, this issue was discussed at the April 2008 meeting of ISO/IEC WG14, and it was agreed that there are no known implementations in which it would be an error to read a value from a volatile sig_atomic_t variable, and the original intent of the committee was that both reading and writing variables of volatile sig_atomic_t would be strictly conforming.\n\nvolatile sig_atomic_t\n\nvolatile sig_atomic_t\n\nThe signal handler may also call a handful of functions, including abort(). (See SIG30-C. Call only asynchronous-safe functions within signal handlers for more information.)\n\nabort().",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, err_msg is updated to indicate that the SIGINT signal was delivered.  The err_msg variable is a character pointer and not a variable of type volatile sig_atomic_t .",
          "code": "#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n\nenum { MAX_MSG_SIZE = 24 };\nchar *err_msg;\n\nvoid handler(int signum) {\n  strcpy(err_msg, \"SIGINT encountered.\");\n}\n\nint main(void) {\n  signal(SIGINT, handler);\n\n  err_msg = (char *)malloc(MAX_MSG_SIZE);\n  if (err_msg == NULL) {\n    /* Handle error */\n  }\n  strcpy(err_msg, \"No errors yet.\");\n  /* Main code loop */\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Writing volatile sig_atomic_t )",
          "pre_code_commentary": "For maximum portability, signal handlers should only unconditionally set a variable of type volatile sig_atomic_t and return, as in this compliant solution:",
          "code": "#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n\nenum { MAX_MSG_SIZE = 24 };\nvolatile sig_atomic_t e_flag = 0;\n\nvoid handler(int signum) {\n  e_flag = 1;\n}\n\nint main(void) {\n  char *err_msg = (char *)malloc(MAX_MSG_SIZE);\n  if (err_msg == NULL) {\n    /* Handle error */\n  }\n\n  signal(SIGINT, handler);\n  strcpy(err_msg, \"No errors yet.\");\n  /* Main code loop */\n  if (e_flag) {\n    strcpy(err_msg, \"SIGINT received.\");\n  } \n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, err_msg is updated to indicate that the SIGINT signal was delivered.  The err_msg variable is a character pointer and not a variable of type volatile sig_atomic_t .",
          "code": "#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n\nenum { MAX_MSG_SIZE = 24 };\nchar *err_msg;\n\nvoid handler(int signum) {\n  strcpy(err_msg, \"SIGINT encountered.\");\n}\n\nint main(void) {\n  signal(SIGINT, handler);\n\n  err_msg = (char *)malloc(MAX_MSG_SIZE);\n  if (err_msg == NULL) {\n    /* Handle error */\n  }\n  strcpy(err_msg, \"No errors yet.\");\n  /* Main code loop */\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Lock-Free Atomic Access)",
          "pre_code_commentary": "Signal handlers can refer to objects with static or thread storage durations that are lock-free atomic objects, as in this compliant solution:",
          "code": "#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdatomic.h>\n \n#ifdef __STDC_NO_ATOMICS__\n#error \"Atomics are not supported\"\n#elif ATOMIC_INT_LOCK_FREE == 0\n#error \"int is never lock-free\"\n#endif\n\natomic_int e_flag = ATOMIC_VAR_INIT(0);\n \nvoid handler(int signum) {\n  e_flag = 1;\n}\n\nint main(void) {\n  enum { MAX_MSG_SIZE = 24 };\n  char err_msg[MAX_MSG_SIZE];\n#if ATOMIC_INT_LOCK_FREE == 1\n  if (!atomic_is_lock_free(&e_flag)) {\n    return EXIT_FAILURE;\n  }\n#endif\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    return EXIT_FAILURE;\n  }\n  strcpy(err_msg, \"No errors yet.\");\n  /* Main code loop */\n  if (e_flag) {\n    strcpy(err_msg, \"SIGINT received.\");\n  }\n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Accessing or modifying shared objects in signal handlers can result in accessing data in an inconsistent state. Michal Zalewski's paper \"Delivering Signals for Fun and Profit\" [ Zalewski 2001 ] provides some examples of vulnerabilities that can result from violating this and other signal-handling rules.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "SIG34-C",
    "title": "Do not call signal() from within interruptible signal handlers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/SIG34-C.+Do+not+call+signal%28%29+from+within+interruptible+signal+handlers",
    "description": "A signal handler should not reassert its desire to handle its own signal. This is often done on nonpersistent platforms—that is, platforms that, upon receiving a signal, reset the handler for the signal to SIG_DFL before calling the bound signal handler. Calling signal() under these conditions presents a race condition. (See SIG01-C. Understand implementation-specific details regarding signal handler persistence .)\n\n signal()\n\nA signal handler may call signal() only if it does not need to be asynchronous-safe (that is, if all relevant signals are masked so that the handler cannot be interrupted).\n\nsignal()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "On nonpersistent platforms, this noncompliant code example contains a race window, starting when the host environment resets the signal and ending when the handler calls signal() . During that time, a second signal sent to the program will trigger the default signal behavior, consequently defeating the persistent behavior implied by the call to signal() from within the handler to reassert the binding.\n\nIf the environment is persistent (that is, it does not reset the handler when the signal is received), the signal() call from within the handler() function is redundant.",
          "code": "#include <signal.h>\n \nvoid handler(int signum) {\n  if (signal(signum, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  /* Handle signal */\n}\n \nvoid func(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "Calling the signal() function from within the signal handler to reassert the binding is unnecessary for persistent platforms, as in this compliant solution:",
          "code": "#include <signal.h>\n \nvoid handler(int signum) {\n  /* Handle signal */\n}\n \nvoid func(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "On nonpersistent platforms, this noncompliant code example contains a race window, starting when the host environment resets the signal and ending when the handler calls signal() . During that time, a second signal sent to the program will trigger the default signal behavior, consequently defeating the persistent behavior implied by the call to signal() from within the handler to reassert the binding.\n\nIf the environment is persistent (that is, it does not reset the handler when the signal is received), the signal() call from within the handler() function is redundant.",
          "code": "#include <signal.h>\n \nvoid handler(int signum) {\n  if (signal(signum, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  /* Handle signal */\n}\n \nvoid func(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "POSIX defines the sigaction() function, which assigns handlers to signals in a similar manner to signal() but allows the caller to explicitly set persistence. Consequently, the sigaction() function can be used to eliminate the race window on nonpersistent platforms, as in this compliant solution:",
          "code": "#include <signal.h>\n#include <stddef.h>\n \nvoid handler(int signum) {\n  /* Handle signal */\n}\n\nvoid func(void) {\n  struct sigaction act;\n  act.sa_handler = handler;\n  act.sa_flags = 0;\n  if (sigemptyset(&act.sa_mask) != 0) {\n    /* Handle error */\n  }\n  if (sigaction(SIGUSR1, &act, NULL) != 0) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "Although the handler in this example does not call signal() , it could do so safely because the signal is masked and the handler cannot be interrupted. If the same handler is installed for more than one signal, the signals must be masked explicitly in act.sa_mask to ensure that the handler cannot be interrupted because the system masks only the signal being delivered.\n\nPOSIX recommends that new applications should use sigaction() rather than signal() . The sigaction() function is not defined by the C Standard and is not supported on some platforms, including Windows."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "On nonpersistent platforms, this noncompliant code example contains a race window, starting when the host environment resets the signal and ending when the handler calls signal() . During that time, a second signal sent to the program will trigger the default signal behavior, consequently defeating the persistent behavior implied by the call to signal() from within the handler to reassert the binding.\n\nIf the environment is persistent (that is, it does not reset the handler when the signal is received), the signal() call from within the handler() function is redundant.",
          "code": "#include <signal.h>\n \nvoid handler(int signum) {\n  if (signal(signum, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  /* Handle signal */\n}\n \nvoid func(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "There is no safe way to implement persistent signal-handler behavior on Windows platforms, and it should not be attempted. If a design depends on this behavior, and the design cannot be altered, it may be necessary to claim a deviation from this rule after completing an appropriate risk analysis.\n\nThe reason for this is that Windows is a nonpersistent platform as discussed above.  Just before calling the current handler function, Windows resets the handler for the next occurrence of the same signal to SIG_DFL . If the handler calls signal() to reinstall itself, there is still a race window. A signal might occur between the start of the handler and the call to signal() , which would invoke the default behavior instead of the desired handler.",
          "code": null,
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Two signals in quick succession can trigger a race condition on nonpersistent platforms, causing the signal's default behavior despite a handler's attempt to override it.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "SIG35-C",
    "title": "Do not return from a computational exception signal handler",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/SIG35-C.+Do+not+return+from+a+computational+exception+signal+handler",
    "description": "According to the C Standard, 7.14.1.1 paragraph 3 [ ISO/IEC 9899:2024 ], if a signal handler returns when it has been entered as a result of a computational exception (that is, with the value of its argument of SIGFPE , SIGILL , SIGSEGV , or any other implementation-defined value corresponding to such an exception) returns, then the behavior is undefined . (See undefined behavior 130 .)\n\nSIGFPE\n\nSIGILL\n\nSIGSEGV\n\nSIGSEGV\n\nWhen a signal occurs and func points to a function, it is implementation-defined whether the equivalent of signal (sig, SIG_DFL); is executed or the implementation prevents some implementation- defined set of signals (at least including sig) from occurring until the current signal handling has completed; in the case of SIGILL, the implementation may alternatively define that no action is taken. Then the equivalent of (*func)(sig); is executed. If and when the function returns, if the value of sig is SIGFPE, SIGILL, SIGSEGV, or any other implementation-defined value corresponding to a computational exception, the behavior is undefined; otherwise the program will resume execution at the point it was interrupted.\n\nThe Portable Operating System Interface (POSIX ® ), Base Specifications, Issue 7 [ IEEE Std 1003.1:2013 ], adds SIGBUS to the list of computational exception signal handlers:\n\nSIGBUS\n\nThe behavior of a process is undefined after it returns normally from a signal-catching function for a SIGBUS , SIGFPE , SIGILL , or SIGSEGV signal that was not generated by kill() , sigqueue() , or raise() .\n\nSIGBUS\n\nSIGFPE\n\nSIGILL\n\nSIGSEGV\n\nkill()\n\nsigqueue()\n\nraise()\n\nDo not return from SIGFPE , SIGILL , SIGSEGV , or any other implementation-defined value corresponding to a computational exception, such as SIGBUS on POSIX systems, regardless of how the signal was generated.\n\nSIGFPE\n\nSIGILL\n\nSIGSEGV\n\nSIGSEGV\n\nSIGBUS",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the division operation has undefined behavior 41 if denom equals 0. (See INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors )  and may result in a SIGFPE signal to the program.)",
          "code": "#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n\nvolatile sig_atomic_t denom;\n\nvoid sighandle(int s) {\n  /* Fix the offending volatile */\n  if (denom == 0) {\n    denom = 1;\n  }\n}\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    return 0;\n  }\n \n  char *end = NULL;\n  long temp = strtol(argv[1], &end, 10);\n \n  if (end == argv[1] || 0 != *end ||\n      ((LONG_MIN == temp || LONG_MAX == temp) && errno == ERANGE)) {\n    /* Handle error */\n  }\n \n  denom = (sig_atomic_t)temp;\n  signal(SIGFPE, sighandle);\n\n  long result = 100 / (long)denom;\n  return 0;\n}\n",
          "explanation_after": "When compiled with some implementations, this noncompliant code example will loop infinitely if given the input 0 . It illustrates that even when a SIGFPE handler attempts to fix the error condition while obeying all other rules of signal handling, the program still does not behave as expected."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The only portably safe way to leave a SIGFPE , SIGILL , or SIGSEGV handler is to invoke abort() , quick_exit() , or _Exit() . In the case of SIGFPE , the default action is abnormal termination , so no user-defined handler is required:",
          "code": "#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    return 0;\n  }\n \n  char *end = NULL;\n  long denom = strtol(argv[1], &end, 10);\n \n  if (end == argv[1] || 0 != *end ||\n      ((LONG_MIN == denom || LONG_MAX == denom) && errno == ERANGE)) {\n    /* Handle error */\n  }\n \n  long result = 100 / denom;\n  return 0;\n}",
          "explanation_after": "Some implementations define useful behavior for programs that return from one or more of these signal handlers. For example, Solaris provides the sigfpe() function specifically to set a SIGFPE handler that a program may safely return from. Oracle also provides platform-specific computational exceptions for the SIGTRAP , SIGBUS , and SIGEMT signals. Finally, GNU libsigsegv takes advantage of the ability to return from a SIGSEGV handler to implement page-level memory management in user mode."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Returning from a computational exception signal handler is undefined behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "STR00-C",
    "title": "Represent characters using an appropriate type",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR00-C.+Represent+characters+using+an+appropriate+type",
    "description": "Strings are a fundamental concept in software engineering, but they are not a built-in type in C. Null-terminated byte strings (NTBS) consist of a contiguous sequence of characters terminated by and including the first null character and are supported in C as the format used for string literals. The C programming language supports single-byte character strings, multibyte character strings, and wide-character strings. Single-byte and multibyte character strings are both described as null-terminated byte strings, which are also called narrow character strings.\n\nA pointer to a null-terminated byte string points to its initial character. The length of the string is the number of bytes preceding the null character, and the value of the string is the sequence of the values of the contained characters, in order.\n\nA wide string is a contiguous sequence of wide characters (of type wchar_t ) terminated by and including the first null wide character. A pointer to a wide string points to its initial (lowest addressed) wide character. The length of a wide string is the number of wide characters preceding the null wide character, and the value of a wide string is the sequence of code values of the contained wide characters, in order.\n\nwchar_t\n\nNull-terminated byte strings are implemented as arrays of characters and are susceptible to the same problems as arrays. As a result, rules and recommendations for arrays should also be applied to null-terminated byte strings.\n\nThe C Standard uses the following philosophy for choosing character types, though it is not explicitly stated in one place:\n\nsigned char and unsigned char\n\nsigned char\n\nunsigned char\n\nSuitable for small integer values\n\n\"Plain\" char\n\nchar\n\nThe type of each element of a string literal Used for character data from a limited character set (where signedness has little meaning) as opposed to integer data\n\nint\n\nint\n\nUsed for data that can be either EOF (a negative value) or character data interpreted as unsigned char and then converted to int . As a result, it is returned by fgetc() , getc() , getchar() , and ungetc() . Also, accepted by the character-handling functions from <ctype.h> because they might be passed the result of fgetc() , and so on The type of a character constant; its value is that of a plain char converted to int\n\nEOF\n\nunsigned char\n\nint\n\nfgetc()\n\ngetc()\n\ngetchar()\n\nungetc()\n\n<ctype.h>\n\nfgetc()\n\nchar\n\nint\n\nNote that the two different ways a character is used as an int (as an unsigned char + EOF or as a plain char converted to int ) can lead to confusion. For example, isspace('\\200') results in undefined behavior when char is signed.\n\nint\n\nunsigned char\n\nEOF\n\nchar\n\nint\n\nisspace('\\200')\n\nchar\n\nunsigned char\n\nunsigned char\n\nUsed internally for string comparison functions even though these functions operate on character data; consequently, the result of a string comparison does not depend on whether plain char is signed Used when the object being manipulated might be of any type, and it is necessary to access all bits of that object, as with fwrite()\n\nchar\n\nfwrite()\n\nUnlike other integer types, unsigned char has the unique property that\n\nunsigned char\n\nvalues stored in . . . objects of type unsigned char shall be represented using a pure binary notation (C Standard, subclause 6.2.6.1 [ ISO/IEC 9899:2011 ])\n\nunsigned char\n\nwhere a pure binary notation is defined as the following:\n\nA positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral powers of 2, except perhaps the bit with the highest position. A byte contains CHAR_BIT bits, and the values of type unsigned char range from 0 to 2 CHAR_BIT − 1. (subclause 6.2.6, footnote 49)\n\nCHAR_BIT\n\nunsigned char\n\nCHAR_BIT\n\nThat is, objects of type unsigned char may have no padding bits and consequently no trap representation . As a result, non-bit-field objects of any type may be copied into an array of unsigned char (for example, via memcpy() ) and have their representation examined one byte at a time.\n\nunsigned char\n\nunsigned char\n\nmemcpy()\n\nwchar_t\n\nwchar_t\n\nWide characters are used for natural-language character data",
    "examples": null,
    "risk_assessment": {
      "explanation": "Understanding how to represent characters and character strings can eliminate many common programming errors that lead to software vulnerabilities .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "STR01-C",
    "title": "Adopt and implement a consistent plan for managing strings",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR01-C.+Adopt+and+implement+a+consistent+plan+for+managing+strings",
    "description": "There are two basic approaches for managing strings in C programs: the first is to maintain strings in statically allocated arrays; the second is to dynamically allocate memory as required. Each approach has advantages and disadvantages. However, it generally makes sense to select a single approach to managing strings and apply it consistently across a project. Otherwise, the decision is left to individual programmers who are likely to make different, inconsistent choices.\n\nStatically allocated strings assume a fixed-size character array, meaning that it is impossible to add data after the buffer is filled. Because the static approach discards excess data, actual program data can be lost. Consequently, the resulting string must be fully validated.\n\nDynamically allocated buffers dynamically resize as additional memory is required. Dynamic approaches scale better and do not discard excess data. The major disadvantage is that, if inputs are not limited, they can exhaust memory on a machine and consequently be used in denial-of-service attacks.\n\nDynamic allocation is often disallowed in safety-critical systems. For example, the MISRA standard requires that \"dynamic heap memory allocation shall not be used\" [ MISRA 2004 ]. Some safety-critical systems can take advantage of dynamic memory allocation during initialization but not during operations. For example, avionics software may dynamically allocate memory while initializing the aircraft but not during flight.\n\nA number of existing libraries are available for managing string data; the library selected depends on the approach adopted for managing null-terminated byte strings. The functions defined by the C Standard, subclause 7.24, are primarily intended for managing statically allocated strings. However, these functions are problematic because many of them are insufficiently bounded.\n\nISO/IEC TR 24731 Part II offers one approach to resolve this, supplying functions that allocate enough memory for their results [ ISO/IEC TR 24731-2 ]. It provides an API that dynamically allocates the results of string functions as needed. Almost all of the APIs in this technical report are also in a current international standard. For example, TR 24731 Part II includes POSIX functions, such as strdup() [ ISO/IEC 9945:2003 ], as well as functions from the Linux Standard Base Core Specification such as asprintf() [ ISO/IEC 23360-1:2006 ].\n\nstrdup()\n\nasprintf()",
    "examples": null,
    "risk_assessment": {
      "explanation": "Failing to adopt a consistent plan for managing strings within an application can lead to inconsistent decisions, which may make it difficult to ensure system properties, such as adhering to safety requirements.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P1",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "STR02-C",
    "title": "Sanitize data passed to complex subsystems",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems",
    "description": "String data passed to complex subsystems may contain special characters that can trigger commands or actions, resulting in a software vulnerability . As a result, it is necessary to sanitize all string data passed to complex subsystems so that the resulting string is innocuous in the context in which it will be interpreted.\n\nThese are some examples of complex subsystems:\n\nCommand processor via a call to system() or similar function (also addressed in ENV03-C. Sanitize the environment when invoking external programs ) External programs Relational databases Third-party commercial off-the-shelf components (for example, an enterprise resource planning subsystem)\n\nsystem()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Data sanitization requires an understanding of the data being passed and the capabilities of the subsystem. John Viega and Matt Messier provide an example of an application that inputs an email address to a buffer and then uses this string as an argument in a call to system() [ Viega 2003 ]:",
          "code": "sprintf(buffer, \"/bin/mail %s < /tmp/email\", addr);\nsystem(buffer);\n",
          "explanation_after": "The risk, of course, is that the user enters the following string as an email address:\n\nFor more information on the system() call, see ENV03-C. Sanitize the environment when invoking external programs and ENV33-C. Do not call system() ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "It is necessary to ensure that all valid data is accepted, while potentially dangerous data is rejected or sanitized . Doing so can be difficult when valid characters or sequences of characters also have special meaning to the subsystem and may involve validating the data against a grammar. In cases where there is no overlap, whitelisting can be used to eliminate dangerous characters from the data.\n\nThe whitelisting approach to data sanitization is to define a list of acceptable characters and remove any character that is not acceptable. The list of valid input values is typically a predictable, well-defined set of manageable size. This compliant solution, based on the tcp_wrappers package written by Wietse Venema, shows the whitelisting approach:",
          "code": "static char ok_chars[] = \"abcdefghijklmnopqrstuvwxyz\"\n                         \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                         \"1234567890_-.@\";\nchar user_data[] = \"Bad char 1:} Bad char 2:{\";\nchar *cp = user_data; /* Cursor into string */\nconst char *end = user_data + strlen( user_data);\nfor (cp += strspn(cp, ok_chars); cp != end; cp += strspn(cp, ok_chars)) {\n  *cp = '_';\n}\n",
          "explanation_after": "The benefit of whitelisting is that a programmer can be certain that a string contains only characters that are considered safe by the programmer. Whitelisting is recommended over blacklisting, which traps all unacceptable characters, because the programmer needs only to ensure that acceptable characters are identified. As a result, the programmer can be less concerned about which characters an attacker may try in an attempt to bypass security checks."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example is taken from [ VU#881872 ], a vulnerability in the Sun Solaris TELNET daemon ( in.telnetd ) that allows a remote attacker to log on to the system with elevated privileges.\n\nThe vulnerability in in.telnetd invokes the login program by calling execl() . This call passes unsanitized data from an untrusted source (the USER environment variable) as an argument to the login program:",
          "code": "(void) execl(LOGIN_PROGRAM, \"login\",\n  \"-p\",\n  \"-d\", slavename,\n  \"-h\", host,\n  \"-s\", pam_svc_name,\n  (AuthenticatingUser != NULL ? AuthenticatingUser :\n  getenv(\"USER\")),\n  0);\n",
          "explanation_after": "An attacker, in this case, can gain unauthenticated access to a system by setting the USER environment variable to a string, which is interpreted as an additional command-line option by the login program. This kind of attack is called argument injection ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution inserts the \"--\" (double dash) argument before the call to getenv(\"USER\") in the call to execl() :",
          "code": "(void) execl(LOGIN_PROGRAM, \"login\",\n  \"-p\",\n  \"-d\", slavename,\n  \"-h\", host,\n  \"-s\", pam_svc_name,\n  \"--\",\n  (AuthenticatingUser != NULL ? AuthenticatingUser :\n  getenv(\"USER\")), 0);\n",
          "explanation_after": "Because the login program uses the POSIX getopt() function to parse command-line arguments, and because the \"--\" option causes getopt() to stop interpreting options in the argument list, the USER variable cannot be used by an attacker to inject an additional command-line option. This is a valid means of sanitizing the untrusted user data in this context because the behavior of the interpretation of the resulting string is rendered innocuous.\n\nThe call to execl() is not susceptible to command injection because the shell command interpreter is not invoked. (See ENV33-C. Do not call system() .)"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to sanitize data passed to a complex subsystem can lead to an injection attack, data integrity issues, and a loss of sensitive data.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "STR03-C",
    "title": "Do not inadvertently truncate a string",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR03-C.+Do+not+inadvertently+truncate+a+string",
    "description": "Alternative functions that limit the number of bytes copied are often recommended to mitigate buffer overflow vulnerabilities . Examples include\n\nstrncpy() instead of strcpy() strncat() instead of strcat() fgets() instead of gets() snprintf() instead of sprintf()\n\nstrncpy()\n\nstrcpy()\n\nstrncat()\n\nstrcat()\n\nfgets()\n\ngets()\n\nsnprintf()\n\nsprintf()\n\nThese functions truncate strings that exceed the specified limits. Additionally, some functions, such as strncpy() , do not guarantee that the resulting character sequence is null-terminated. (See STR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string .)\n\nstrncpy()\n\nUnintentional truncation results in a loss of data and in some cases leads to software vulnerabilities.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The standard functions strncpy() and strncat() copy a specified number of characters n from a source string to a destination array. In the case of strncpy() , if there is no null character in the first n characters of the source array, the result will not be null-terminated and any remaining characters are truncated.",
          "code": "char *string_data;\nchar a[16];\n/* ... */\nstrncpy(a, string_data, sizeof(a));\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Adequate Space)",
          "pre_code_commentary": "Either the strcpy() or strncpy() function can be used to copy a string and a null character to a destination buffer, provided there is enough space. The programmer must be careful to ensure that the destination buffer is large enough to hold the string to be copied and the null byte to prevent errors, such as data truncation and buffer overflow.",
          "code": "char *string_data = NULL;\nchar a[16];\n\n/* ... */\n\nif (string_data == NULL) {\n  /* Handle null pointer error */\n}\nelse if (strlen(string_data) >= sizeof(a)) {\n  /* Handle overlong string error */\n}\nelse {\n  strcpy(a, string_data);\n}\n",
          "explanation_after": "This solution requires that string_data is null-terminated; that is, a null byte can be found within the bounds of the referenced character array. Otherwise, strlen() will stray into other objects before finding a null byte."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Truncating strings can lead to a loss of data.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "STR04-C",
    "title": "Use plain char for characters in the basic character set",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR04-C.+Use+plain+char+for+characters+in+the+basic+character+set",
    "description": "There are three character types : char , signed char , and unsigned char . Compilers have the latitude to define char to have the same range, representation, and behavior as either signed char or unsigned char . Irrespective of the choice made, char is a separate type from the other two and is not compatible with either.\n\nchar\n\nsigned char\n\nunsigned char\n\nchar\n\nsigned char\n\nunsigned char\n\nchar\n\nFor characters in the basic character set, it does not matter which data type is used, except for type compatibility. Consequently, it is best to use plain char for character data for compatibility with standard string-handling functions.\n\nchar\n\nIn most cases, the only portable operators on plain char types are assignment and equality operators ( = , == , != ). An exception is the translation to and from digits. For example, if the char c is a digit, c - '0' is a value between 0 and 9.\n\nchar\n\n=\n\n==\n\n!=\n\nchar\n\nc\n\nc - '0'",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example simply shows the standard string-handling function strlen() being called with a plain character string, a signed character string, and an unsigned character string. The strlen() function takes a single argument of type const char *:",
          "code": "size_t len;\nchar cstr[] = \"char string\";\nsigned char scstr[] = \"signed char string\";\nunsigned char ucstr[] = \"unsigned char string\";\n\nlen = strlen(cstr);\nlen = strlen(scstr);  /* Warns when char is unsigned */\nlen = strlen(ucstr);  /* Warns when char is signed */\n",
          "explanation_after": "Compiling at high warning levels in compliance with MSC00-C. Compile cleanly at high warning levels causes warnings to be issued when\n\nConverting from unsigned char[] to const char * when char is signed Converting from signed char[] to const char * when char is defined to be unsigned\n\nCasts are required to eliminate these warnings, but excessive casts can make code difficult to read and hide legitimate warning messages.\n\nIf this C code were compiled using a C++ compiler, conversions from unsigned char[] to const char * and from signed char[] to const char * would be flagged as errors requiring casts."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution uses plain char for character data:",
          "code": "size_t len;\nchar cstr[] = \"char string\";\n\nlen = strlen(cstr);\n",
          "explanation_after": "Conversions are not required, and the code compiles cleanly at high warning levels without casts."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to use plain char for characters in the basic character set can lead to excessive casts and less effective compiler diagnostics.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "STR05-C",
    "title": "Use pointers to const when referring to string literals",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR05-C.+Use+pointers+to+const+when+referring+to+string+literals",
    "description": "The type of a narrow string literal is an array of char , and the type of a wide string literal is an array of wchar_t . However, string literals (of both types) are notionally constant and should consequently be protected by const qualification. This recommendation is a specialization of DCL00-C. Const-qualify immutable objects and also supports STR30-C. Do not attempt to modify string literals .\n\nchar\n\nwchar_t\n\nconst\n\nAdding const qualification may propagate through a program; as const qualifiers are added, still more become necessary. This phenomenon is sometimes called const-poisoning . Const-poisoning can frequently lead to violations of EXP05-C. Do not cast away a const qualification . Although const qualification is a good idea, the costs may outweigh the value in the remediation of existing code.\n\nconst\n\nconst\n\nconst",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Narrow String Literal)",
          "pre_code_commentary": "In this noncompliant code example, the const keyword has been omitted:",
          "code": "char *c = \"Hello\";\n",
          "explanation_after": "If a statement such as c[0] = 'C' were placed following the declaration in the noncompliant code example, the code is likely to compile cleanly, but the result of the assignment would be undefined because string literals are considered constant."
        },
        "compliant": {
          "heading": "Compliant Solution (Immutable Strings)",
          "pre_code_commentary": "In this compliant solution, the characters referred to by the pointer c are const -qualified, meaning that any attempt to assign them to different values is an error:",
          "code": "const char *c = \"Hello\";\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Narrow String Literal)",
          "pre_code_commentary": "In this noncompliant code example, the const keyword has been omitted:",
          "code": "char *c = \"Hello\";\n",
          "explanation_after": "If a statement such as c[0] = 'C' were placed following the declaration in the noncompliant code example, the code is likely to compile cleanly, but the result of the assignment would be undefined because string literals are considered constant."
        },
        "compliant": {
          "heading": "Compliant Solution (Mutable Strings)",
          "pre_code_commentary": "In cases where the string is meant to be modified, use initialization instead of assignment. In this compliant solution, c is a modifiable char array that has been initialized using the contents of the corresponding string literal:",
          "code": "char c[] = \"Hello\";\n",
          "explanation_after": "Consequently, a statement such as c[0] = 'C' is valid and behaves as expected."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Wide String Literal)",
          "pre_code_commentary": "In this noncompliant code example, the const keyword has been omitted:",
          "code": "wchar_t *c = L\"Hello\";\n",
          "explanation_after": "If a statement such as c[0] = L'C' were placed following this declaration, the code is likely to compile cleanly, but the result of the assignment would be undefined because string literals are considered constant."
        },
        "compliant": {
          "heading": "Compliant Solution (Immutable Strings)",
          "pre_code_commentary": "In this compliant solution, the characters referred to by the pointer c are const -qualified, meaning that any attempt to assign them to different values is an error:",
          "code": "wchar_t const *c = L\"Hello\";\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Wide String Literal)",
          "pre_code_commentary": "In this noncompliant code example, the const keyword has been omitted:",
          "code": "wchar_t *c = L\"Hello\";\n",
          "explanation_after": "If a statement such as c[0] = L'C' were placed following this declaration, the code is likely to compile cleanly, but the result of the assignment would be undefined because string literals are considered constant."
        },
        "compliant": {
          "heading": "Compliant Solution (Mutable Strings)",
          "pre_code_commentary": "In cases where the string is meant to be modified, use initialization instead of assignment. In this compliant solution, c is a modifiable wchar_t array that has been initialized using the contents of the corresponding string literal:",
          "code": "wchar_t c[] = L\"Hello\";\n",
          "explanation_after": "Consequently, a statement such as c[0] = L'C' is valid and behaves as expected."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Modifying string literals causes undefined behavior , resulting in abnormal program termination and denial-of-service vulnerabilities .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "STR06-C",
    "title": "Do not assume that strtok() leaves the parse string unchanged",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR06-C.+Do+not+assume+that+strtok%28%29+leaves+the+parse+string+unchanged",
    "description": "The C function strtok() is a string tokenization function that takes two arguments: an initial string to be parsed and a const -qualified character delimiter. It returns a pointer to the first character of a token or to a null pointer if there is no token.\n\nstrtok()\n\nconst\n\nThe first time strtok() is called, the string is parsed into tokens and a character delimiter. The strtok() function parses the string up to the first instance of the delimiter character, replaces the character in place with a null byte ( '\\0' ), and returns the address of the first character in the token. Subsequent calls to strtok() begin parsing immediately after the most recently placed null character.\n\nstrtok()\n\nstrtok()\n\n'\\0'\n\nstrtok()\n\nBecause strtok() modifies the initial string to be parsed, the string is subsequently unsafe and cannot be used in its original form. If you need to preserve the original string, copy it into a buffer and pass the address of the buffer to strtok() instead of the original string.\n\nstrtok()\n\nstrtok()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this example, the strtok() function is used to parse the first argument into colon-delimited tokens; it outputs each word from the string on a new line. Assume that PATH is \"/usr/bin:/usr/sbin:/sbin\" .",
          "code": "char *token;\nchar *path = getenv(\"PATH\");\n\ntoken = strtok(path, \":\");\nputs(token);\n\nwhile (token = strtok(0, \":\")) {\n  puts(token);\n}\n\nprintf(\"PATH: %s\\n\", path);\n/* PATH is now just \"/usr/bin\" */\n",
          "explanation_after": "After the loop ends, path is modified as follows: \"/usr/bin\\0/bin\\0/usr/sbin\\0/sbin\\0\" . This is an issue because the local path variable becomes /usr/bin and because the environment variable PATH has been unintentionally changed, which can have unintended consequences. (See ENV30-C. Do not modify the object referenced by the return value of certain functions .)"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the string being tokenized is copied into a temporary buffer that is not referenced after the call to strtok() :",
          "code": "char *token;\nconst char *path = getenv(\"PATH\");\n/* PATH is something like \"/usr/bin:/bin:/usr/sbin:/sbin\" */\n\nchar *copy = (char *)malloc(strlen(path) + 1);\nif (copy == NULL) {\n  /* Handle error */\n}\nstrcpy(copy, path);\ntoken = strtok(copy, \":\");\nputs(token);\n\nwhile (token = strtok(0, \":\")) {\n  puts(token);\n}\n\nfree(copy);\ncopy = NULL;\n\nprintf(\"PATH: %s\\n\", path);\n/* PATH is still \"/usr/bin:/bin:/usr/sbin:/sbin\" */\n",
          "explanation_after": "Another possibility is to provide your own implementation of strtok() that does not modify the initial arguments."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The Linux Programmer's Manual (man) page on strtok(3) [ Linux 2008 ] states:\n\nNever use this function. This function modifies its first argument. The identity of the delimiting character is lost. This function cannot be used on constant strings.\n\nThe improper use of strtok() is likely to result in truncated data, producing unexpected results later in program execution.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "STR09-C",
    "title": "Don't assume numeric values for expressions with type plain character",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR09-C.+Don%27t+assume+numeric+values+for+expressions+with+type+plain+character",
    "description": "For portable applications, use only the assignment = operator, the equality operators == and != , and the unary & operator on plain-character-typed or plain-wide-character-typed expressions.\n\n=\n\n==\n\n!=\n\n&\n\nThis practice is recommended because the C Standard requires only the digit characters (0–9) to have consecutive numerical values. Consequently, operations that rely on expected values for plain-character- or plain-wide-character-typed expressions can lead to unexpected behavior.\n\nHowever, because of the requirement for digit characters, other operators can be used for them according to the following restrictions:\n\nThe binary + operator may be used to add integer values 0 through 9 to '0' . The binary - operator may be used to subtract character 0. Relational operators < , <= , > , and >= can be used to check whether a character or wide character is a digit.\n\n+\n\n'0'\n\n-\n\n<\n\n<=\n\n>\n\n>=\n\nCharacter types should be chosen and used in accordance with STR04-C. Use plain char for characters in the basic character set .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to determine if the value of a character variable is between 'a' and 'c' inclusive. However, because the C Standard does not require the letter characters to be in consecutive or alphabetic order, the check might not work as expected.",
          "code": "char ch = 'b';\nif ((ch >= 'a') && (ch <= 'c')) {\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this example, the specific check is enforced using compliant operations on character expressions:",
          "code": "char ch = 't';\nif ((ch == 'a') || (ch == 'b') || (ch == 'c')) {\n  /* ... */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "STR10-C",
    "title": "Do not concatenate different type of string literals",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR10-C.+Do+not+concatenate+different+type+of+string+literals",
    "description": "According to MISRA 2008 , concatenation of wide and narrow string literals leads to undefined behavior . This was once considered implicitly undefined behavior until C90 [ ISO/IEC 9899:1990 ]. However, C99 defined this behavior [ ISO/IEC 9899:1999 ], and C11 further explains in subclause 6.4.5, paragraph 5 [ ISO/IEC 9899:2011 ]:\n\nIn translation phase 6, the multibyte character sequences specified by any sequence of adjacent character and identically-prefixed string literal tokens are concatenated into a single multibyte character sequence. If any of the tokens has an encoding prefix, the resulting multibyte character sequence is treated as having the same prefix; otherwise, it is treated as a character string literal. Whether differently-prefixed wide string literal tokens can be concatenated and, if so, the treatment of the resulting multibyte character sequence are implementation-defined.\n\nNonetheless, it is recommended that string literals that are concatenated should all be the same type so as not to rely on implementation-defined behavior or undefined behavior if compiled on a platform that supports only C90.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (C90)",
          "pre_code_commentary": "This noncompliant code example concatenates wide and narrow string literals. Although the behavior is undefined in C90, the programmer probably intended to create a wide string literal.",
          "code": "wchar_t *msg = L\"This message is very long, so I want to divide it \"\n                \"into two parts.\";\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (C90, Wide String Literals)",
          "pre_code_commentary": "If the concatenated string needs to be a wide string literal, each element in the concatenation must be a wide string literal, as in this compliant solution:",
          "code": "wchar_t *msg = L\"This message is very long, so I want to divide it \"\n               L\"into two parts.\";\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (C90)",
          "pre_code_commentary": "This noncompliant code example concatenates wide and narrow string literals. Although the behavior is undefined in C90, the programmer probably intended to create a wide string literal.",
          "code": "wchar_t *msg = L\"This message is very long, so I want to divide it \"\n                \"into two parts.\";\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (C90, Narrow String Literals)",
          "pre_code_commentary": "If wide string literals are unnecessary, it is better to use narrow string literals, as in this compliant solution:",
          "code": "char *msg = \"This message is very long, so I want to divide it \"\n            \"into two parts.\";\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The concatenation of wide and narrow string literals could lead to undefined behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "STR11-C",
    "title": "Do not specify the bound of a character array initialized with a string literal",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR11-C.+Do+not+specify+the+bound+of+a+character+array+initialized+with+a+string+literal",
    "description": "The C Standard allows an array variable to be declared both with a bound index and with an initialization literal. The initialization literal also implies an array size in the number of elements specified. For strings, the size specified by a string literal is the number of characters in the literal plus one for the terminating null character.\n\nIt is common for an array variable to be initialized by a string literal and declared with an explicit bound that matches the number of characters in the string literal. Subclause 6.7.9, paragraph 14, of the C Standard [ ISO/IEC 9899:2011 ], says:\n\nAn array of character type may be initialized by a character string literal or UTF −8 string literal, optionally enclosed in braces. Successive bytes of the string literal (including the terminating null character if there is room or if the array is of unknown size) initialize the elements of the array.\n\nHowever, if the string is intended to be used as a null-terminated byte string, then the array will have one too few characters to hold the string because it does not account for the terminating null character. Such a sequence of characters has limited utility and has the potential to cause vulnerabilities if a null-terminated byte string is assumed.\n\nA better approach is to not specify the bound of a string initialized with a string literal because the compiler will automatically allocate sufficient space for the entire string literal, including the terminating null character. This rule is a specific exception to ARR02-C. Explicitly specify array bounds, even if implicitly defined by an initializer .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example initializes an array of characters using a string literal that defines one character more (counting the terminating '\\0' ) than the array can hold:",
          "code": "const char s[3] = \"abc\";\n",
          "explanation_after": "The size of the array s is 3, although the size of the string literal is 4. Any subsequent use of the array as a null-terminated byte string can result in a vulnerability, because s is not properly null-terminated. (See STR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string .)\n\nThis code compiles with no warning with Visual Studio 2013 and GCC 4.8.1. It produces a three-character array with no terminating null character, as specified by the standard."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not specify the bound of a character array in the array declaration. If the array bound is omitted, the compiler allocates sufficient storage to store the entire string literal, including the terminating null character.",
          "code": "const char s[] = \"abc\";\n",
          "explanation_after": "This approach is preferred because the size of the array can always be derived even if the size of the string literal changes."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "STR30-C",
    "title": "Do not attempt to modify string literals",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR30-C.+Do+not+attempt+to+modify+string+literals",
    "description": "According to the C Standard, 6.4.5, paragraph 3 [ ISO/IEC 9899:2024 ]:\n\nA character string literal is a sequence of zero or more multibyte characters enclosed in double-quotes, as in \"xyz\" . A UTF-8 string literal is the same, except prefixed by u8 . A wchar _ t string literal is the same, except prefixed by L . A UTF-16 string literal is the same, except prefixed by u . A UTF-32 string literal is the same, except prefixed by U . Collectively, wchar _ t , UTF-16, and UTF-32 string literals are called wide string literals .\n\nAt compile time, string literals are used to create an array of static storage duration of sufficient length to contain the character sequence and a terminating null character. String literals are usually referred to by a pointer to (or array of) characters. Ideally, they should be assigned only to pointers to (or arrays of) const char or const wchar_t . It is unspecified whether these arrays of string literals are distinct from each other. The behavior is undefined if a program attempts to modify any portion of a string literal. Modifying a string literal frequently results in an access violation because string literals are typically stored in read-only memory. (See undefined behavior 32 .)\n\nconst char\n\nconst wchar_t\n\nAvoid assigning a string literal to a pointer to non- const or casting a string literal to a pointer to non- const . For the purposes of this rule, a pointer to (or array of) const characters must be treated as a string literal. Similarly, the returned value of the following library functions must be treated as a string literal if the first argument is a string literal:\n\nconst\n\nconst\n\nconst\n\nstrpbrk(), strchr(), strrchr(), strstr() wcspbrk(), wcschr(), wcsrchr () , wcsstr() memchr(), wmemchr()\n\nstrpbrk(), strchr(), strrchr(), strstr()\n\nwcspbrk(), wcschr(), wcsrchr\n()\n, wcsstr()\n\nmemchr(), wmemchr()\n\nThis rule is a specific instance of EXP40-C. Do not modify constant objects .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the char pointer str is initialized to the address of a string literal. Attempting to modify the string literal is undefined behavior 32 :",
          "code": "char *str  = \"string literal\";\nstr[0] = 'S';\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "As an array initializer, a string literal specifies the initial values of characters in an array as well as the size of the array. (See STR11-C. Do not specify the bound of a character array initialized with a string literal .) This code creates a copy of the string literal in the space allocated to the character array str . The string stored in str can be modified safely.",
          "code": "char str[] = \"string literal\";\nstr[0] = 'S';\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "In this noncompliant code example, a string literal is passed to the (pointer to non- const ) parameter of the POSIX function mkstemp() , which then modifies the characters of the string literal:",
          "code": "#include <stdlib.h>\n \nvoid func(void) {\n  mkstemp(\"/tmp/edXXXXXX\");\n}",
          "explanation_after": "The behavior of mkstemp() is described in more detail in FIO21-C. Do not create temporary files in shared directories ."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution uses a named array instead of passing a string literal:",
          "code": "#include <stdlib.h>\n \nvoid func(void) {\n  static char fname[] = \"/tmp/edXXXXXX\";\n  mkstemp(fname);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Result of strrchr() )",
          "pre_code_commentary": "In this noncompliant example, the char * result of the strrchr() function is used to modify the object pointed to by pathname . Because the argument to strrchr() points to a string literal, the effects of the modification are undefined.",
          "code": "#include <stdio.h>\n#include <string.h>\n \nconst char *get_dirname(const char *pathname) {\n  char *slash;\n  slash = strrchr(pathname, '/');\n  if (slash) {\n    *slash = '\\0'; /* Undefined behavior */\n  }\n  return pathname;\n}\n\nint main(void) {\n  puts(get_dirname(__FILE__));\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Result of strrchr() )",
          "pre_code_commentary": "This compliant solution avoids modifying a const object, even if it is possible to obtain a non- const pointer to such an object by calling a standard C library function, such as strrchr() . To reduce the risk to callers of get_dirname() , a buffer and length for the directory name are passed into the function. It is insufficient to change pathname to require a char * instead of a const char * because conforming compilers are not required to diagnose passing a string literal to a function accepting a char * .",
          "code": "#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n \nchar *get_dirname(const char *pathname, char *dirname, size_t size) {\n  const char *slash;\n  slash = strrchr(pathname, '/');\n  if (slash) {\n    ptrdiff_t slash_idx = slash - pathname;\n    if ((size_t)slash_idx < size) {\n      memcpy(dirname, pathname, slash_idx);\n      dirname[slash_idx] = '\\0';      \n      return dirname;\n    }\n  }\n  return 0;\n}\n \nint main(void) {\n  char dirname[260];\n  if (get_dirname(__FILE__, dirname, sizeof(dirname))) {\n    puts(dirname);\n  }\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Modifying string literals can lead to abnormal program termination and possibly denial-of-service attacks .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "STR31-C",
    "title": "Guarantee that storage for strings has sufficient space for character data and the null terminator",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator",
    "description": "Copying data to a buffer that is not large enough to hold that data results in a buffer overflow. Buffer overflows occur frequently when manipulating strings [ Seacord 2013b ]. To prevent such errors, either limit copies through truncation or, preferably, ensure that the destination is of sufficient size to hold the character data to be copied and the null-termination character. (See STR03-C. Do not inadvertently truncate a string .)\n\nWhen strings live on the heap, this rule is a specific instance of MEM35-C. Allocate sufficient memory for an object . Because strings are represented as arrays of characters, this rule is related to both ARR30-C. Do not form or use out-of-bounds pointers or array subscripts and ARR38-C. Guarantee that library functions do not form invalid pointers .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Off-by-One Error)",
          "pre_code_commentary": "This noncompliant code example demonstrates an off-by-one error [ Dowd 2006 ]. The loop copies data from src to dest . However, because the loop does not account for the null-termination character, it may be incorrectly written 1 byte past the end of dest .",
          "code": "#include <stddef.h>\n \nvoid copy(size_t n, char src[n], char dest[n]) {\n   size_t i;\n \n   for (i = 0; src[i] && (i < n); ++i) {\n     dest[i] = src[i];\n   }\n   dest[i] = '\\0';\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Off-by-One Error)",
          "pre_code_commentary": "In this compliant solution, the loop termination condition is modified to account for the null-termination character that is appended to dest :",
          "code": "#include <stddef.h>\n \nvoid copy(size_t n, char src[n], char dest[n]) {\n   size_t i;\n \n   for (i = 0; src[i] && (i < n - 1); ++i) {\n     dest[i] = src[i];\n   }\n   dest[i] = '\\0';\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( gets() )",
          "pre_code_commentary": "The gets() function, which was deprecated in the C99 Technical Corrigendum 3 and removed from C11 , is inherently unsafe and should never be used because it provides no way to control how much data is read into a buffer from stdin . This noncompliant code example assumes that gets() will not read more than BUFFER_SIZE - 1 characters from stdin . This is an invalid assumption, and the resulting operation can result in a buffer overflow.\n\nThe gets() function reads characters from the stdin into a destination array until end-of-file is encountered or a newline character is read. Any newline character is discarded, and a null character is written immediately after the last character read into the array.",
          "code": "#include <stdio.h>\n \n#define BUFFER_SIZE 1024\n\nvoid func(void) {\n  char buf[BUFFER_SIZE];\n  if (gets(buf) == NULL) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "See also MSC24-C. Do not use deprecated or obsolescent functions ."
        },
        "compliant": {
          "heading": "Compliant Solution ( fgets() )",
          "pre_code_commentary": "The fgets() function reads, at most, one less than the specified number of characters from a stream into an array. This solution is compliant because the number of characters copied from stdin to buf cannot exceed the allocated memory:",
          "code": "#include <stdio.h>\n#include <string.h>\n \nenum { BUFFERSIZE = 32 };\n \nvoid func(void) {\n  char buf[BUFFERSIZE];\n  int ch;\n\n  if (fgets(buf, sizeof(buf), stdin)) {\n    /* fgets() succeeded; scan for newline character */\n    char *p = strchr(buf, '\\n');\n    if (p) {\n      *p = '\\0';\n    } else {\n      /* Newline not found; flush stdin to end of line */\n      while ((ch = getchar()) != '\\n' && ch != EOF)\n        ;\n      if (ch == EOF && !feof(stdin) && !ferror(stdin)) {\n          /* Character resembles EOF; handle error */ \n      }\n    }\n  } else {\n    /* fgets() failed; handle error */\n  }\n}",
          "explanation_after": "The fgets() function is not a strict replacement for the gets() function because fgets() retains the newline character (if read) and may also return a partial line. It is possible to use fgets() to safely process input lines too long to store in the destination array, but this is not recommended for performance reasons. Consider using one of the following compliant solutions when replacing gets() ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( gets() )",
          "pre_code_commentary": "The gets() function, which was deprecated in the C99 Technical Corrigendum 3 and removed from C11 , is inherently unsafe and should never be used because it provides no way to control how much data is read into a buffer from stdin . This noncompliant code example assumes that gets() will not read more than BUFFER_SIZE - 1 characters from stdin . This is an invalid assumption, and the resulting operation can result in a buffer overflow.\n\nThe gets() function reads characters from the stdin into a destination array until end-of-file is encountered or a newline character is read. Any newline character is discarded, and a null character is written immediately after the last character read into the array.",
          "code": "#include <stdio.h>\n \n#define BUFFER_SIZE 1024\n\nvoid func(void) {\n  char buf[BUFFER_SIZE];\n  if (gets(buf) == NULL) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "See also MSC24-C. Do not use deprecated or obsolescent functions ."
        },
        "compliant": {
          "heading": "Compliant Solution ( getline() , POSIX)",
          "pre_code_commentary": "The getline() function is similar to the fgets() function but can dynamically allocate memory for the input buffer. If passed a null pointer, getline() dynamically allocates a buffer of sufficient size to hold the input. If passed a pointer to dynamically allocated storage that is too small to hold the contents of the string, the getline() function resizes the buffer, using realloc() , rather than truncating the input. If successful, the getline() function returns the number of characters read, which can be used to determine if the input has any null characters before the newline. The getline() function works only with dynamically allocated buffers. Allocated memory must be explicitly deallocated by the caller to avoid memory leaks. (See MEM31-C. Free dynamically allocated memory when no longer needed .)",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid func(void) {\n  int ch;\n  size_t buffer_size = 32;\n  char *buffer = malloc(buffer_size);\n \n  if (!buffer) {\n    /* Handle error */\n    return;\n  }\n\n  if ((ssize_t size = getline(&buffer, &buffer_size, stdin))\n        == -1) {\n    /* Handle error */\n  } else {\n    char *p = strchr(buffer, '\\n');\n    if (p) {\n      *p = '\\0';\n    } else {\n      /* Newline not found; flush stdin to end of line */\n      while ((ch = getchar()) != '\\n' && ch != EOF)\n\t    ;\n\t  if (ch == EOF && !feof(stdin) && !ferror(stdin)) {\n         /* Character resembles EOF; handle error */\n      }\n    }\n  }\n  free (buffer);\n}",
          "explanation_after": "Note that the getline() function uses an in-band error indicator , in violation of ERR02-C. Avoid in-band error indicators ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( getchar() )",
          "pre_code_commentary": "Reading one character at a time provides more flexibility in controlling behavior, though with additional performance overhead. This noncompliant code example uses the getchar() function to read one character at a time from stdin instead of reading the entire line at once. The stdin stream is read until end-of-file is encountered or a newline character is read. Any newline character is discarded, and a null character is written immediately after the last character read into the array. Similar to the noncompliant code example that invokes gets() , there are no guarantees that this code will not result in a buffer overflow.",
          "code": "#include <stdio.h>\n \nenum { BUFFERSIZE = 32 };\n \nvoid func(void) {\n  char buf[BUFFERSIZE];\n  char *p;\n  int ch;\n  p = buf;\n  while ((ch = getchar()) != '\\n' && ch != EOF) {\n    *p++ = (char)ch;\n  }\n  *p++ = 0;\n  if (ch == EOF) {\n      /* Handle EOF or error */\n  }\n}",
          "explanation_after": "After the loop ends, if ch == EOF , the loop has read through to the end of the stream without encountering a newline character, or a read error occurred before the loop encountered a newline character. To conform to FIO34-C. Distinguish between characters read from a file and EOF or WEOF , the error-handling code must verify that an end-of-file or error has occurred by calling feof() or ferror() ."
        },
        "compliant": {
          "heading": "Compliant Solution ( getchar() )",
          "pre_code_commentary": "In this compliant solution, characters are no longer copied to buf once index == BUFFERSIZE - 1 , leaving room to null-terminate the string. The loop continues to read characters until the end of the line, the end of the file, or an error is encountered. When truncated == true , the input string has been truncated.",
          "code": "#include <stdio.h>\n \nenum { BUFFERSIZE = 32 };\n\nvoid func(void) {\n  char buf[BUFFERSIZE];\n  int ch;\n  size_t index = 0;\n  bool truncated = false;\n\n  while ((ch = getchar()) != '\\n' && ch != EOF) {\n    if (index < sizeof(buf) - 1) {\n      buf[index++] = (char)ch;\n    } else {\n      truncated = true;\n    }\n  }\n  buf[index] = '\\0';  /* Terminate string */\n  if (ch == EOF) {\n    /* Handle EOF or error */\n  }\n  if (truncated) {\n    /* Handle truncation */\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fscanf() )",
          "pre_code_commentary": "In this noncompliant example, the call to fscanf() can result in a write outside the character array buf :",
          "code": "#include <stdio.h>\n \nenum { BUF_LENGTH = 1024 };\n \nvoid get_data(void) {\n  char buf[BUF_LENGTH];\n  if (1 != fscanf(stdin, \"%s\", buf)) {\n    /* Handle error */\n  }\n\n  /* Rest of function */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( fscanf() )",
          "pre_code_commentary": "In this compliant solution, the call to fscanf() is constrained not to overflow buf :",
          "code": "#include <stdio.h>\n \nenum { BUF_LENGTH = 1024 };\n \nvoid get_data(void) {\n  char buf[BUF_LENGTH];\n  if (1 != fscanf(stdin, \"%1023s\", buf)) {\n    /* Handle error */\n  }\n\n  /* Rest of function */\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( argv )",
          "pre_code_commentary": "In a hosted environment , arguments read from the command line are stored in process memory. The function main() , called at program startup, is typically declared as follows when the program accepts command-line arguments:",
          "code": "int main(int argc, char *argv[]) { /* ... */ }\n",
          "explanation_after": "Command-line arguments are passed to main() as pointers to strings in the array members argv[0] through argv[argc - 1] . If the value of argc is greater than 0, the string pointed to by argv[0] is, by convention, the program name. If the value of argc is greater than 1, the strings referenced by argv[1] through argv[argc - 1] are the program arguments.\n\nVulnerabilities can occur when inadequate space is allocated to copy a command-line argument or other program input. In this noncompliant code example, an attacker can manipulate the contents of argv[0] to cause a buffer overflow:"
        },
        "compliant": {
          "heading": "Compliant Solution ( argv )",
          "pre_code_commentary": "The strlen() function can be used to determine the length of the strings referenced by argv[0] through argv[argc - 1] so that adequate memory can be dynamically allocated.",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nint main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char *const name = (argc && argv[0]) ? argv[0] : \"\";\n  char *prog_name = (char *)malloc(strlen(name) + 1);\n  if (prog_name != NULL) {\n    strcpy(prog_name, name);\n  } else {\n    /* Handle error */\n  }\n  free(prog_name);\n  return 0;\n}\n",
          "explanation_after": "Remember to add a byte to the destination string size to accommodate the null-termination character."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( argv )",
          "pre_code_commentary": "In a hosted environment , arguments read from the command line are stored in process memory. The function main() , called at program startup, is typically declared as follows when the program accepts command-line arguments:",
          "code": "int main(int argc, char *argv[]) { /* ... */ }\n",
          "explanation_after": "Command-line arguments are passed to main() as pointers to strings in the array members argv[0] through argv[argc - 1] . If the value of argc is greater than 0, the string pointed to by argv[0] is, by convention, the program name. If the value of argc is greater than 1, the strings referenced by argv[1] through argv[argc - 1] are the program arguments.\n\nVulnerabilities can occur when inadequate space is allocated to copy a command-line argument or other program input. In this noncompliant code example, an attacker can manipulate the contents of argv[0] to cause a buffer overflow:"
        },
        "compliant": {
          "heading": "Compliant Solution ( argv )",
          "pre_code_commentary": "The strcpy_s() function provides additional safeguards, including accepting the size of the destination buffer as an additional argument. (See VOID STR07-C. Use the bounds-checking interfaces for string manipulation .)",
          "code": "#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdlib.h>\n#include <string.h>\n \nint main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char *const name = (argc && argv[0]) ? argv[0] : \"\";\n  char *prog_name;\n  size_t prog_size;\n\n  prog_size = strlen(name) + 1;\n  prog_name = (char *)malloc(prog_size);\n\n  if (prog_name != NULL) {\n    if (strcpy_s(prog_name, prog_size, name)) {\n      /* Handle  error */\n    }\n  } else {\n    /* Handle error */\n  }\n  /* ... */\n  free(prog_name);\n  return 0;\n}\n",
          "explanation_after": "The strcpy_s() function can be used to copy data to or from dynamically allocated memory or a statically allocated array. If insufficient space is available, strcpy_s() returns an error."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( argv )",
          "pre_code_commentary": "In a hosted environment , arguments read from the command line are stored in process memory. The function main() , called at program startup, is typically declared as follows when the program accepts command-line arguments:",
          "code": "int main(int argc, char *argv[]) { /* ... */ }\n",
          "explanation_after": "Command-line arguments are passed to main() as pointers to strings in the array members argv[0] through argv[argc - 1] . If the value of argc is greater than 0, the string pointed to by argv[0] is, by convention, the program name. If the value of argc is greater than 1, the strings referenced by argv[1] through argv[argc - 1] are the program arguments.\n\nVulnerabilities can occur when inadequate space is allocated to copy a command-line argument or other program input. In this noncompliant code example, an attacker can manipulate the contents of argv[0] to cause a buffer overflow:"
        },
        "compliant": {
          "heading": "Compliant Solution ( argv )",
          "pre_code_commentary": "If an argument will not be modified or concatenated, there is no reason to make a copy of the string. Not copying a string is the best way to prevent a buffer overflow and is also the most efficient solution. Care must be taken to avoid assuming that argv[0] is non-null.",
          "code": "int main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char * const prog_name = (argc && argv[0]) ? argv[0] : \"\";\n  /* ... */\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( getenv() )",
          "pre_code_commentary": "According to the C Standard, 7.22.4.6 [ ISO/IEC 9899:2011 ]\n\nThe getenv function searches an environment list, provided by the host environment, for a string that matches the string pointed to by name . The set of environment names and the method for altering the environment list are implementation defined.\n\nEnvironment variables can be arbitrarily large, and copying them into fixed-length arrays without first determining the size and allocating adequate storage can result in a buffer overflow.",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nvoid func(void) {\n  char buff[256];\n  char *editor = getenv(\"EDITOR\");\n  if (editor == NULL) {\n    /* EDITOR environment variable not set */\n  } else {\n    strcpy(buff, editor);\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( getenv() )",
          "pre_code_commentary": "Environmental variables are loaded into process memory when the program is loaded. As a result, the length of these strings can be determined by calling the strlen() function, and the resulting length can be used to allocate adequate dynamic memory:",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nvoid func(void) {\n  char *buff;\n  char *editor = getenv(\"EDITOR\");\n  if (editor == NULL) {\n    /* EDITOR environment variable not set */\n  } else {\n    size_t len = strlen(editor) + 1;\n    buff = (char *)malloc(len);\n    if (buff == NULL) {\n      /* Handle error */\n    }  \n    memcpy(buff, editor, len);\n    free(buff);\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( sprintf() )",
          "pre_code_commentary": "In this noncompliant code example, name refers to an external string; it could have originated from user input, the file system, or the network. The program constructs a file name from the string in preparation for opening the file.",
          "code": "#include <stdio.h>\n \nvoid func(const char *name) {\n  char filename[128];\n  sprintf(filename, \"%s.txt\", name);\n}",
          "explanation_after": "Because the sprintf() function makes no guarantees regarding the length of the generated string, a sufficiently long string in name could generate a buffer overflow."
        },
        "compliant": {
          "heading": "Compliant Solution ( sprintf() )",
          "pre_code_commentary": "The buffer overflow in the preceding noncompliant example can be prevented by adding a precision to the %s conversion specification. If the precision is specified, no more than that many bytes are written. The precision 123 in this compliant solution ensures that filename can contain the first 123 characters of name , the .txt extension, and the null terminator.",
          "code": "#include <stdio.h>\n \nvoid func(const char *name) {\n  char filename[128];\n  sprintf(filename, \"%.123s.txt\", name);\n}\n",
          "explanation_after": "You can also use * to indicate that the precision should be provided as a variadic argument:"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( sprintf() )",
          "pre_code_commentary": "In this noncompliant code example, name refers to an external string; it could have originated from user input, the file system, or the network. The program constructs a file name from the string in preparation for opening the file.",
          "code": "#include <stdio.h>\n \nvoid func(const char *name) {\n  char filename[128];\n  sprintf(filename, \"%s.txt\", name);\n}",
          "explanation_after": "Because the sprintf() function makes no guarantees regarding the length of the generated string, a sufficiently long string in name could generate a buffer overflow."
        },
        "compliant": {
          "heading": "Compliant Solution ( snprintf() )",
          "pre_code_commentary": "A more general solution is to use the snprintf() function, which also truncates name if it will not fit in the filename .",
          "code": "#include <stdio.h>\n \nvoid func(const char *name) {\n  char filename[128];\n  int result = snprintf(filename, sizeof(filename), \"%s.txt\", name);\n  if (result != strlen(filename) {\n    /* truncation occurred */\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Copying string data to a buffer that is too small to hold that data results in a buffer overflow. Attackers can exploit this condition to execute arbitrary code with the permissions of the vulnerable process.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "STR32-C",
    "title": "Do not pass a non-null-terminated character sequence to a library function that expects a string",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR32-C.+Do+not+pass+a+non-null-terminated+character+sequence+to+a+library+function+that+expects+a+string",
    "description": "Many library functions accept a string or wide string argument with the constraint that the string they receive is properly null-terminated. Passing a character sequence or wide character sequence that is not null-terminated to such a function can result in accessing memory that is outside the bounds of the object. Do not pass a character sequence or wide character sequence that is not null-terminated to a library function that expects a string or wide string argument.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code example is noncompliant because the character sequence c_str will not be null-terminated when passed as an argument to printf(). (See STR11-C. Do not specify the bound of a character array initialized with a string literal on how to properly initialize character arrays.)",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  char c_str[3] = \"abc\";\n  printf(\"%s\\n\", c_str);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not specify the bound of the character array in the array declaration. If the array bound is omitted, the compiler allocates sufficient storage to store the entire string literal, including the terminating null character.",
          "code": "#include <stdio.h>\n \nvoid func(void) {\n  char c_str[] = \"abc\";\n  printf(\"%s\\n\", c_str);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code example is noncompliant because the wide character sequence cur_msg will not be null-terminated when passed to wcslen() . This will occur if lessen_memory_usage() is invoked while cur_msg_size still has its initial value of 1024.",
          "code": "#include <stdlib.h>\n#include <wchar.h>\n \nwchar_t *cur_msg = NULL;\nsize_t cur_msg_size = 1024;\nsize_t cur_msg_len = 0;\n\nvoid lessen_memory_usage(void) {\n  wchar_t *temp;\n  size_t temp_size;\n\n  /* ... */\n\n  if (cur_msg != NULL) {\n    temp_size = cur_msg_size / 2 + 1;\n    temp = realloc(cur_msg, temp_size * sizeof(wchar_t));\n    /* temp &and cur_msg may no longer be null-terminated */\n    if (temp == NULL) {\n      /* Handle error */\n    }\n\n    cur_msg = temp;\n    cur_msg_size = temp_size;\n    cur_msg_len = wcslen(cur_msg); \n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, cur_msg will always be null-terminated when passed to wcslen() :",
          "code": "#include <stdlib.h>\n#include <wchar.h>\n \nwchar_t *cur_msg = NULL;\nsize_t cur_msg_size = 1024;\nsize_t cur_msg_len = 0;\n\nvoid lessen_memory_usage(void) {\n  wchar_t *temp;\n  size_t temp_size;\n\n  /* ... */\n\n  if (cur_msg != NULL) {\n    temp_size = cur_msg_size / 2 + 1;\n    temp = realloc(cur_msg, temp_size * sizeof(wchar_t));\n    /* temp and cur_msg may no longer be null-terminated */\n    if (temp == NULL) {\n      /* Handle error */\n    }\n\n    cur_msg = temp;\n    /* Properly null-terminate cur_msg */\n    cur_msg[temp_size - 1] = L'\\0'; \n    cur_msg_size = temp_size;\n    cur_msg_len = wcslen(cur_msg); \n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( strncpy() )",
          "pre_code_commentary": "Although the strncpy() function takes a string as input, it does not guarantee that the resulting value is still null-terminated. In the following noncompliant code example, if no null character is contained in the first n characters of the source array, the result will not be null-terminated. Passing a non-null-terminated character sequence to strlen() is undefined behavior 196 .",
          "code": "#include <string.h>\n \nenum { STR_SIZE = 32 };\n \nsize_t func(const char *source) {\n  char c_str[STR_SIZE];\n  size_t ret = 0;\n\n  if (source) {\n    c_str[sizeof(c_str) - 1] = '\\0';\n    strncpy(c_str, source, sizeof(c_str));\n    ret = strlen(c_str);\n  } else {\n    /* Handle null pointer */\n  }\n  return ret;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Truncation)",
          "pre_code_commentary": "This compliant solution is correct if the programmer's intent is to truncate the string:",
          "code": "#include <string.h>\n \nenum { STR_SIZE = 32 };\n \nsize_t func(const char *source) {\n  char c_str[STR_SIZE];\n  size_t ret = 0;\n\n  if (source) {\n    strncpy(c_str, source, sizeof(c_str) - 1);\n    c_str[sizeof(c_str) - 1] = '\\0';\n    ret = strlen(c_str);\n  } else {\n    /* Handle null pointer */\n  }\n  return ret;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( strncpy() )",
          "pre_code_commentary": "Although the strncpy() function takes a string as input, it does not guarantee that the resulting value is still null-terminated. In the following noncompliant code example, if no null character is contained in the first n characters of the source array, the result will not be null-terminated. Passing a non-null-terminated character sequence to strlen() is undefined behavior 196 .",
          "code": "#include <string.h>\n \nenum { STR_SIZE = 32 };\n \nsize_t func(const char *source) {\n  char c_str[STR_SIZE];\n  size_t ret = 0;\n\n  if (source) {\n    c_str[sizeof(c_str) - 1] = '\\0';\n    strncpy(c_str, source, sizeof(c_str));\n    ret = strlen(c_str);\n  } else {\n    /* Handle null pointer */\n  }\n  return ret;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Copy without Truncation)",
          "pre_code_commentary": "If the programmer's intent is to copy without truncation, this compliant solution copies the data and guarantees that the resulting array is null-terminated. If the string cannot be copied, it is handled as an error condition.",
          "code": "#include <string.h>\n \nenum { STR_SIZE = 32 };\n \nsize_t func(const char *source) {\n  char c_str[STR_SIZE];\n  size_t ret = 0;\n\n  if (source) {\n    if (strnlen(source, sizeof(c_str)) < sizeof(c_str)) {\n      strcpy(c_str, source);\n      ret = strlen(c_str);\n    } else {\n      /* Handle string-too-large */\n    }\n  } else {\n    /* Handle null pointer */\n  }\n  return ret;\n}",
          "explanation_after": "Note that this code is not bulletproof. It gracefully handles the case where source is NULL, when it is a valid string, and when source is not null-terminated, but at least the first 32 bytes are valid. However, in cases where source is not NULL, but points to invalid memory, or any of the first 32 bytes are invalid memory, the first call to strnlen() will access this invalid memory, and the resulting behavior is undefined. Unfortunately, standard C provides no way to prevent or even detect this condition without some external knowledge about the memory source points to."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to properly null-terminate a character sequence that is passed to a library function that expects a string can result in buffer overflows and the execution of arbitrary code with the permissions of the vulnerable process. Null-termination errors can also result in unintended information disclosure.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "STR34-C",
    "title": "Cast characters to unsigned char before converting to larger integer sizes",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR34-C.+Cast+characters+to+unsigned+char+before+converting+to+larger+integer+sizes",
    "description": "Signed character data must be converted to unsigned char before being assigned or converted to a larger signed type. This rule applies to both signed char and (plain) char characters on implementations where char is defined to have the same range, representation, and behaviors as signed char .\n\nunsigned char\n\nsigned char\n\nchar\n\nchar\n\nsigned char\n\nHowever, this rule is applicable only in cases where the character data may contain values that can be misinterpreted as negative numbers. For example, if the char type is represented by a two's complement 8-bit value, any character value greater than +127 is interpreted as a negative value.\n\nchar\n\nThis rule is a generalization of STR37-C. Arguments to character-handling functions must be representable as an unsigned char .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example is taken from a vulnerability in bash versions 1.14.6 and earlier that led to the release of CERT Advisory CA-1996-22 . This vulnerability resulted from the sign extension of character data referenced by the c_str pointer in the yy_string_get() function in the parse.y module of the bash source code:",
          "code": "static int yy_string_get(void) {\n  register char *c_str;\n  register int c;\n\n  c_str = bash_input.location.string;\n  c = EOF;\n\n  /* If the string doesn't exist or is empty, EOF found */\n  if (c_str && *c_str) {\n    c = *c_str++;\n    bash_input.location.string = c_str;\n  }\n  return (c);\n}\n",
          "explanation_after": "The c_str variable is used to traverse the character string containing the command line to be parsed. As characters are retrieved from this pointer, they are stored in a variable of type int . For implementations in which the char type is defined to have the same range, representation, and behavior as signed char , this value is sign-extended when assigned to the int variable. For character code 255 decimal (−1 in two's complement form), this sign extension results in the value −1 being assigned to the integer, which is indistinguishable from EOF ."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This problem can be repaired by explicitly declaring the c_str variable as unsigned char :",
          "code": "static int yy_string_get(void) {\n  register unsigned char *c_str;\n  register int c;\n\n  c_str = bash_input.location.string;\n  c = EOF;\n\n  /* If the string doesn't exist or is empty, EOF found */\n  if (c_str && *c_str) {\n    c = *c_str++;\n    bash_input.location.string = c_str;\n  }\n  return (c);\n}\n",
          "explanation_after": "This example, however, violates STR04-C. Use plain char for characters in the basic character set ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the result of the expression *c_str++ is cast to unsigned char before assignment to the int variable c :",
          "code": "static int yy_string_get(void) {\n  register char *c_str;\n  register int c;\n\n  c_str = bash_input.location.string;\n  c = EOF;\n\n  /* If the string doesn't exist or is empty, EOF found */\n  if (c_str && *c_str) {\n    /* Cast to unsigned type */\n    c = (unsigned char)*c_str++;\n\n    bash_input.location.string = c_str;\n  }\n  return (c);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the cast of *s to unsigned int can result in a value in excess of UCHAR_MAX because of integer promotions, a violation of ARR30-C. Do not form or use out-of-bounds pointers or array subscripts :",
          "code": "#include <limits.h>\n#include <stddef.h>\n \nstatic const char table[UCHAR_MAX + 1] = { 'a' /* ... */ };\n\nptrdiff_t first_not_in_table(const char *c_str) {\n  for (const char *s = c_str; *s; ++s) {\n    if (table[(unsigned int)*s] != *s) {\n      return s - c_str;\n    }\n  }\n  return -1;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution casts the value of type char to unsigned char before the implicit promotion to a larger type:",
          "code": "#include <limits.h>\n#include <stddef.h>\n \nstatic const char table[UCHAR_MAX + 1] = { 'a' /* ... */ };\n\nptrdiff_t first_not_in_table(const char *c_str) {\n  for (const char *s = c_str; *s; ++s) {\n    if (table[(unsigned char)*s] != *s) {\n      return s - c_str;\n    }\n  }\n  return -1;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Conversion of character data resulting in a value in excess of UCHAR_MAX is an often-missed error that can result in a disturbingly broad range of potentially severe vulnerabilities .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "STR37-C",
    "title": "Arguments to character-handling functions must be representable as an unsigned char",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR37-C.+Arguments+to+character-handling+functions+must+be+representable+as+an+unsigned+char",
    "description": "According to the C Standard, 7.4.1 paragraph 1 [ ISO/IEC 9899:2024 ],\n\nThe header <ctype.h> declares several functions useful for classifying and mapping characters. In all cases the argument is an int , the value of which shall be representable as an unsigned char or shall equal the value of the macro EOF . If the argument has any other value, the behavior is undefined .\n\n<ctype.h>\n\nint\n\nunsigned char\n\nEOF\n\nSee also undefined behavior 112 .\n\nThis rule is applicable only to code that runs on platforms where the char data type is defined to have the same range, representation, and behavior as signed char .\n\nchar\n\nsigned char\n\nFollowing are the character classification functions that this rule addresses:\n\nisalnum() isalpha() isascii() XSI isblank() iscntrl() isdigit() isgraph() islower() isprint() ispunct() isspace() isupper() isxdigit() toascii() XSI toupper() tolower()\n\nisalnum()\n\nisalpha()\n\nisascii()\n\nisblank()\n\niscntrl()\n\nisdigit()\n\nisgraph()\n\nislower()\n\nisprint()\n\nispunct()\n\nisspace()\n\nisupper()\n\nisxdigit()\n\ntoascii()\n\ntoupper()\n\ntolower()\n\nXSI denotes an X/Open System Interfaces Extension to ISO/IEC 9945—POSIX. These functions are not defined by the C Standard.\n\nThis rule is a specific instance of STR34-C. Cast characters to unsigned char before converting to larger integer sizes .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "On implementations where plain char is signed, this code example is noncompliant because the parameter to isspace() , *t , is defined as a const char * , and this value might not be representable as an unsigned char :",
          "code": "#include <ctype.h>\n#include <string.h>\n \nsize_t count_preceding_whitespace(const char *s) {\n  const char *t = s;\n  size_t length = strlen(s) + 1;\n  while (isspace(*t) && (t - s < length)) { \n    ++t;\n  }\n  return t - s;\n} ",
          "explanation_after": "The argument to isspace() must be EOF or representable as an unsigned char ; otherwise, the result is undefined."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution casts the character to unsigned char before passing it as an argument to the isspace() function:",
          "code": "#include <ctype.h>\n#include <string.h>\n \nsize_t count_preceding_whitespace(const char *s) {\n  const char *t = s;\n  size_t length = strlen(s) + 1;\n  while (isspace((unsigned char)*t) && (t - s < length)) { \n    ++t;\n  }\n  return t - s;\n} ",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Passing values to character handling functions that cannot be represented as an unsigned char to character handling functions is undefined behavior 112 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "STR38-C",
    "title": "Do not confuse narrow and wide character strings and functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/STR38-C.+Do+not+confuse+narrow+and+wide+character+strings+and+functions",
    "description": "Passing narrow string arguments to wide string functions or wide string arguments to narrow string functions can lead to unexpected and undefined behavior 151 . Scaling problems are likely because of the difference in size between wide and narrow characters. (See ARR39-C. Do not add or subtract a scaled integer to a pointer.) Because wide strings are terminated by a null wide character and can contain null bytes, determining the length is also problematic.\n\nBecause wchar_t and char are distinct types, many compilers will produce a warning diagnostic if an inappropriate function is used. (See MSC00-C. Compile cleanly at high warning levels .)\n\nwchar_t\n\nchar",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Wide Strings with Narrow String Functions)",
          "pre_code_commentary": "This noncompliant code example incorrectly uses the strncpy() function in an attempt to copy up to 10 wide characters. However, because wide characters can contain null bytes, the copy operation may end earlier than anticipated, resulting in the truncation of the wide string.",
          "code": "#include <stddef.h>\n#include <string.h>\n \nvoid func(void) {\n  wchar_t wide_str1[]  = L\"0123456789\";\n  wchar_t wide_str2[] =  L\"0000000000\";\n\n  strncpy(wide_str2, wide_str1, 10);\n}",
          "explanation_after": null
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Narrow Strings with Wide String Functions)",
          "pre_code_commentary": "This noncompliant code example incorrectly invokes the wcsncpy() function to copy up to 10 wide characters from narrow_str1 to narrow_str2 . Because narrow_str2 is a narrow string, it has insufficient memory to store the result of the copy and the copy will result in a buffer overflow.",
          "code": "#include <wchar.h>\n \nvoid func(void) {\n  char narrow_str1[] = \"01234567890123456789\";\n  char narrow_str2[] = \"0000000000\";\n\n  wcsncpy(narrow_str2, narrow_str1, 10);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses the proper-width functions. Using wcsncpy() for wide character strings and strncpy() for narrow character strings ensures that data is not truncated and buffer overflow does not occur.",
          "code": "#include <string.h>\n#include <wchar.h>\n \nvoid func(void) {\n  wchar_t wide_str1[] = L\"0123456789\";\n  wchar_t wide_str2[] = L\"0000000000\";\n  /* Use of proper-width function */ \n  wcsncpy(wide_str2, wide_str1, 10);\n\n  char narrow_str1[] = \"0123456789\";\n  char narrow_str2[] = \"0000000000\";\n  /* Use of proper-width function */ \n  strncpy(narrow_str2, narrow_str1, 10);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( strlen() )",
          "pre_code_commentary": "In this noncompliant code example, the strlen() function is used to determine the size of a wide character string:",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nvoid func(void) {\n  wchar_t wide_str1[] = L\"0123456789\";\n  wchar_t *wide_str2 = (wchar_t*)malloc(strlen(wide_str1) + 1);\n  if (wide_str2 == NULL) {\n    /* Handle error */\n  }\n  /* ... */\n  free(wide_str2);\n  wide_str2 = NULL;\n}",
          "explanation_after": "The strlen() function determines the number of characters that precede the terminating null character. However, wide characters can contain null bytes, particularly when expressing characters from the ASCII character set, as in this example. As a result, the strlen() function will return the number of bytes preceding the first null byte in the wide string."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution correctly calculates the number of bytes required to contain a copy of the wide string, including the terminating null wide character:",
          "code": "#include <stdlib.h>\n#include <wchar.h>\n \nvoid func(void) {\n  wchar_t wide_str1[] = L\"0123456789\";\n  wchar_t *wide_str2 = (wchar_t *)malloc(\n    (wcslen(wide_str1) + 1) * sizeof(wchar_t));\n  if (wide_str2 == NULL) {\n    /* Handle error */\n  }\n  /* ... */\n\n  free(wide_str2);\n  wide_str2 = NULL;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Confusing narrow and wide character strings can result in buffer overflows, data truncation, and other defects.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "WIN00-C",
    "title": "Be specific when dynamically loading libraries",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/WIN00-C.+Be+specific+when+dynamically+loading+libraries",
    "description": "The LoadLibrary() or LoadLibraryEx() function calls [ MSDN ] allow you to dynamically load a library at runtime and use a specific algorithm to locate the library within the file system [ MSDN ]. It is possible for an attacker to place a file on the DLL search path such that your application inadvertently loads and executes arbitrary source code.\n\nLoadLibrary()\n\nLoadLibraryEx()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": null,
          "code": "#include <Windows.h>\n \nvoid func(void) {\n  HMODULE hMod = LoadLibrary(TEXT(\"MyLibrary.dll\"));\n  if (hMod != NULL) {\n    typedef void (__cdecl func_type)(void);\n    func_type *fn = (func_type *)GetProcAddress(hMod, \"MyFunction\");\n    if (fn != NULL)\n      fn();\n  }\n}",
          "explanation_after": "If an attacker were to place a malicious DLL named MyLibrary.dll higher on the search path than where the library resides, she could trigger arbitrary code to execute either via the DllMain() entrypoint (which is called automatically by the system loader) or by providing an implementation for MyFunction() , either of which would run within the security context of your application. If your application runs with elevated privileges (such as a service application), an escalation of privileges could result."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "By refusing to load a library unless it is located precisely where expected, you reduce the chance of executing arbitrary code when dynamically loading libraries. This compliant solution uses LoadLibraryEx() to ensure that only the application and System32 directories are searched (eliminating other search paths such as the current directory or PATH environment variable):",
          "code": "#include <Windows.h>\n \nvoid func(void) {\n  HMODULE hMod = LoadLibraryEx(TEXT(\"MyLibrary.dll\"), NULL,\n                               LOAD_LIBRARY_SEARCH_APPLICATION_DIR |\n                               LOAD_LIBRARY_SEARCH_SYSTEM32);\n  if (hMod != NULL) {\n    typedef void (__cdecl func_type)(void);\n    func_type *fn = (func_type *)GetProcAddress(hMod, \"MyFunction\");\n    if (fn != NULL)\n      fn();\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Depending on the version of Windows the application is run on, failure to properly specify the library can lead to arbitrary code execution.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "WIN01-C",
    "title": "Do not forcibly terminate execution",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/WIN01-C.+Do+not+forcibly+terminate+execution",
    "description": "When a thread terminates under normal conditions, thread-specific resources such as the initial stack space and thread-specific HANDLE objects are released automatically by the system and notifications are sent to other parts of the application, such as DLL_THREAD_DETACH messages being sent to DLLs.  However, if a thread is forcibly terminated by calling TerminateThread() , the cleanup and notifications do not have the chance to run.  MSDN states\n\nHANDLE\n\nDLL_THREAD_DETACH\n\nTerminateThread()\n\nTerminateThread is a dangerous function that should only be used in the most extreme cases. You should call TerminateThread only if you know exactly what the target thread is doing, and you control all of the code that the target thread could possibly be running at the time of the termination. For example, TerminateThread can result in the following problems: If the target thread owns a critical section, the critical section will not be released. If the target thread is allocating memory from the heap, the heap lock will not be released. If the target thread is executing certain kernel32 calls when it is terminated, the kernel32 state for the thread's process could be inconsistent. If the target thread is manipulating the global state of a shared DLL, the state of the DLL could be destroyed, affecting other users of the DLL.\n\nOn some platforms (such as Microsoft Windows XP and Microsoft Windows Server 2003), the thread's initial stack is not freed, causing a resource leak.\n\nProcesses behave similar to threads, and so share the same concerns.  Do not use the TerminateThread() or TerminateProcess() APIs.  Instead, you should prefer to exit threads and processes by returning from the entrypoint, by calling ExitThread() , or by calling ExitProcess() .\n\nTerminateThread()\n\nTerminateProcess()\n\nExitThread()\n\nExitProcess()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In the following example, TerminateThread() is used to forcibly terminate another thread, which can leak resources and leave the application in an indeterminate state.",
          "code": "#include <Windows.h>\n \nDWORD ThreadID;  /* Filled in by call to CreateThread */\n \n/* Thread 1 */\nDWORD WINAPI ThreadProc(LPVOID param) {\n  /* Performing work */\n}\n \n/* Thread 2 */\nHANDLE hThread = OpenThread(THREAD_TERMINATE, FALSE, ThreadID);\nif (hThread) {\n  TerminateThread(hThread, 0xFF);\n  CloseHandle(hThread);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution avoids calling TerminateThread() by requesting the thread terminate itself by exiting its entrypoint.  It does so in a lock-free, thread-safe manner by using the InterlockedCompareExchange() and InterlockedExchange() Win32 APIs.",
          "code": "#include <Windows.h>\n \nDWORD ThreadID;  /* Filled in by call to CreateThread */\nLONG ShouldThreadExit = 0;\n\n/* Thread 1 */\nDWORD WINAPI ThreadProc(LPVOID param) {\n  while (1) {\n    /* Performing work */\n    if (1 == InterlockedCompareExchange(&ShouldThreadExit, 0, 1))\n      return 0xFF;\n  }\n}\n \n/* Thread 2 */\nInterlockedExchange(&ShouldThreadExit, 1);",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrectly using threads that asynchronously cancel may result in silent corruption, resource leaks, and, in the worst case, unpredictable interactions.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "WIN02-C",
    "title": "Restrict privileges when spawning child processes",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/WIN02-C.+Restrict+privileges+when+spawning+child+processes",
    "description": "The principle of least privilege states that every program and every user of the system should operate using the least set of privileges necessary to complete the job [ Saltzer 1974 , Saltzer 1975 ]. The Build Security In website [ DHS 2006 ] provides additional definitions of this principle. Executing with minimal privileges mitigates against exploitation in case a vulnerability is discovered in the code.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "An application may spawn another process as part of its normal course of action. On Windows, the newly-spawned process automatically receives the same privileges as the parent process [ MSDN ]. By allowing the child process to run in the same security context as the parent process, the attack surface for the application is extended to the child process. Furthermore, this example allows the child process to inherit handles from the parent process by passing TRUE to the bInheritsHandles parameter.",
          "code": "#include <Windows.h>\n \nvoid launch_notepad(void) {\n  PROCESS_INFORMATION pi;\n  STARTUPINFO si;\n \n  ZeroMemory(&si, sizeof(si));\n  si.cb = sizeof( si );\n  if (CreateProcess(TEXT(\"C:\\\\Windows\\\\Notepad.exe\"), NULL, NULL, NULL, TRUE,\n                    0, NULL, NULL, &si, &pi )) {\n    /* Process has been created; work with the process and wait for it to\n       terminate. */\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n  }\n}\n",
          "explanation_after": "It is possible that the act of calling launch_notepad() will give the user an elevated Notepad application (from which the user could execute Explorer.exe), allowing the user access to all user's files, change system settings, and so on."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "By using the Windows Integrity Mechanism [ MSDN ] when creating the process, you can assign an integrity level to the launched child process. Doing so allows you to execute the child process with a specific set of privileges instead of defaulting to the parent process's security level.",
          "code": "#include <Windows.h>\n#include <sddl.h>\n \nstatic void launch_notepad_as_user(HANDLE token) {\n  PROCESS_INFORMATION pi;\n  STARTUPINFO si;\n \n  ZeroMemory(&si, sizeof(si));\n  si.cb = sizeof( si );\n  if (CreateProcessAsUser(token, TEXT(\"C:\\\\Windows\\\\Notepad.exe\"), NULL, NULL,\n                          NULL, FALSE, 0, NULL, NULL, &si, &pi )) {\n    /* Process has been created; work with the process and wait for it to\n       terminate. */\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n  }\n}\n \nstatic BOOL adjust_token_integrity_level(HANDLE token, const char *sid) {\n  /* Convert the string SID to a SID *, then adjust the token's\n     privileges. */\n  BOOL ret;\n  PSID psd = NULL;\n  if (ConvertStringSidToSidA(sid, &psd)) {\n    TOKEN_MANDATORY_LABEL tml;\n    \n    ZeroMemory(&tml, sizeof(tml));\n    tml.Label.Attributes = SE_GROUP_INTEGRITY;\n    tml.Label.Sid = psd;\n \n    ret = SetTokenInformation(token, TokenIntegrityLevel, &tml,\n                              sizeof(tml) + GetLengthSid(psd));\n    \n    LocalFree(psd);\n  }\n  return ret;\n}\n \nvoid launch_notepad(void) {\n  /* Low level; see table for integrity level string names */\n  const char *requested_sid = \"S-1-16-4096\";\n  HANDLE token_cur, token_dup;\n  /* Get the current process' security token as a starting point, then modify\n     a duplicate so that it runs with a fixed integrity level. */\n  if (OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE |\n                                            TOKEN_ADJUST_DEFAULT |\n                                            TOKEN_QUERY |\n                                            TOKEN_ASSIGN_PRIMARY,\n                                            &token_cur)) {\n    if (DuplicateTokenEx(token_cur, 0, NULL, SecurityImpersonation,\n                         TokenPrimary, &token_dup)) {\n      if (adjust_token_integrity_level(token_dup, requested_sid))\n        launch_notepad_as_user(token_dup);\n      CloseHandle(token_dup);\n    }\n    CloseHandle(token_cur);\n  }\n}\n",
          "explanation_after": "The compliant solution demonstrates how to launch notepad.exe using a low integrity level, regardless of what privilege level the parent process is running from. It also disallows handle inheritance by passing FALSE to the bInheritsHandles parameter, because notepad.exe does not require access to any of the process's handles.\n\nPossible values for the integrity level SID strings are listed in the following table:\n\nS-1-16-4096\n\nMandatory Label\\Low Mandatory Level\n\nS-1-16-8192\n\nMandatory Label\\Medium Mandatory Level\n\nS-1-16-12288\n\nMandatory Label\\High Mandatory Level\n\nS-1-16-16384\n\nMandatory Label\\System Mandatory Level"
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failure to follow the principle of least privilege may allow exploits to execute with elevated privileges.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "WIN03-C",
    "title": "Understand HANDLE inheritance",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/WIN03-C.+Understand+HANDLE+inheritance",
    "description": "Securable resources such as access tokens, events, files, threads, and others are represented via HANDLE objects on Windows [ MSDN ]. Handle inheritance is a two-step process.  When obtaining a HANDLE , an option is given to specify whether the object is inheritable or not. This option is usually in the form of a BOOL parameter (as in the case of OpenMutex() ), or a SECURITY_DESCRIPTOR parameter (as in the case of CreateFile() ). When creating a process via the CreateProcess() family of APIs, a parameter is given specifying whether the spawned process will inherit handles previously flagged as being inheritable. Any handles that were opened as being inheritable will be opened in the child process using the same handle value and access privileges as in the parent process. The parent process can then alert the child process of the handle values via an inter-process communication mechanism, and the child process can use those values as though it had opened the handle [ MSDN ].\n\nHANDLE\n\nHANDLE\n\nBOOL\n\nOpenMutex()\n\nSECURITY_DESCRIPTOR\n\nCreateFile()\n\nCreateProcess()\n\nWhen opening handles to securable resources or spawning child processes, prohibit handle inheritance by default to prevent accidental information leakage. If obtaining an inherited handle from a parent process, prevent leakage to subsequent child processes by duplicating the handle without inheritance.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Mutex)",
          "pre_code_commentary": "This noncompliant code example attempts to open an existing mutex handle that can be inherited by a child process:",
          "code": "#include <Windows.h>\n \nvoid func(void) {\n  HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, TRUE, TEXT(\"Global\\\\CommonMutex\"));\n  if (!hMutex) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "Even if the process does not currently spawn child processes, this code example is noncompliant because future changes involving child processes could leak this handle accidentally."
        },
        "compliant": {
          "heading": "Compliant Solution (Mutex)",
          "pre_code_commentary": "This compliant solution opens the same mutex without specifying the handle can be inherited by a child process:",
          "code": "#include <Windows.h>\n \nvoid func(void) {\n  HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, TEXT(\"Global\\\\CommonMutex\"));\n  if (!hMutex) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Further Inheritance)",
          "pre_code_commentary": "In this noncompliant example, the child process is spawned and inherits a single file handle from its parent process. The first argument to the main function is the handle's integer value as a hexadecimal string. However, the child process is not validating that the handle is a valid file handle, and it is not restricting further inheritance of the handle. Additionally, a portability concern arises if the parent process and the child process are the same architecture (for example, if one is 32-bit and the other is 64-bit).",
          "code": "#include <Windows.h>\n \nint CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR cmdLine, int show) {\n  HANDLE hFile = (HANDLE)_strtoui64(cmdLine, NULL, 16);\n \n  /* Continue working with the file */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Further Inheritance)",
          "pre_code_commentary": "This compliant solution receives the inherited handle via the command line but prevents further inheritance by duplicating the handle. It also ensures that the value passed is a valid HANDLE value. Then it validates the handle as a proper file handle by calling GetFileInformationByHandle() . This solution also properly handles cross-architecture situations between the processes.",
          "code": "#include <Windows.h>\n \nint CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR cmdLine, int show) {\n  HANDLE hUntrusted = (HANDLE)_strtoui64(cmdLine, NULL, 16);\n  HANDLE hFile = NULL;\n  BY_HANDLE_FILE_INFORMATION info;\n \n  if (!DuplicateHandle(GetCurrentProcess(), hUntrusted, GetCurrentProcess(), &hFile,\n                       0, FALSE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE)) {\n    /* Handle error; possibly not even a valid handle */\n  }\n  \n  if (!GetFileInformationByHandle(hFile, &info)) {\n    /* Handle error; likely not a valid file handle */\n \n    // Close the file handle since we no longer trust it.\n    CloseHandle(hFile);\n    hFile = NULL;\n  }\n  \n  /* Continue working with the file */\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "By default, all files on Windows that are opened using fopen() will allow handle inheritance, and processes spawned via the system() API automatically inherit handles. In this noncompliant code example, SomeProcess.exe inherits the file handle for SomeFile.txt :",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint main(void) {\n  FILE *fp = fopen(\"SomeFile.txt\", \"rw\");\n  if (!fp) {\n    return -1;\n  }\n  \n  system(\"SomeProcess.exe\");\n \n  fclose(fp);\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( fopen() )",
          "pre_code_commentary": "In this compliant solution, the Windows-specific 'N' mode parameter is passed  to the call to fopen() , which ensures the file is opened without allowing handle inheritance:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nint main(void) {\n  FILE *fp = fopen(\"SomeFile.txt\", \"rwN\");\n  if (!fp) {\n    return -1;\n  }\n  \n  system(\"SomeProcess.exe\");\n \n  fclose(fp);\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Leaking handles across process boundaries can leak information or cause denial-of-service attacks.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "WIN04-C",
    "title": "Consider encrypting function pointers",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/WIN04-C.+Consider+encrypting+function+pointers",
    "description": "If an attacker can overwrite memory containing function pointers, they may be able to execute arbitrary code. To mitigate the effects of such attacks, pointers to functions can be encrypted at runtime on the basis of some characteristics of the execution process so that only a running process will be able to decode them.  This is only required for stored function pointers stored to writable memory, including the stack.  The Microsoft SDL [Microsoft 2012] recommends encoding long-lived pointers in your code.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example assigns the address of the printf() function to the log_fn function pointer, which can be allocated in the stack or data segment:",
          "code": "int (*log_fn)(const char *, ...) = printf;\n/* ... */\nlog_fn(\"foo\");\n",
          "explanation_after": "If a vulnerability exists in this program that allows an attacker to overwrite the log_fn function pointer, such as a buffer overflow or arbitrary memory write, the attacker may be able to overwrite the value of printf with the location of an arbitrary function."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "Microsoft Windows provides the EncodePointer() and DecodePointer() functions that encrypt and decrypt pointers using a secret that is unique to the given process:",
          "code": "#include <Windows.h>\n \nvoid *log_fn = EncodePointer(printf);\n/* ... */\nint (*fn)(const char *, ...) = (int (*)(const char *, ...))DecodePointer(log_fn);\n\nfn(\"foo\");",
          "explanation_after": "Note that DecodePointer() does not return success or failure.  If an attacker has overwritten the pointer contained in log_fn , the pointer returned will be invalid and cause your application to crash.  However, this is preferable to giving an attacker the ability to execute arbitrary code."
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "WIN30-C",
    "title": "Properly pair allocation and deallocation functions",
    "url": "https://wiki.sei.cmu.edu/confluence/display/c/WIN30-C.+Properly+pair+allocation+and+deallocation+functions",
    "description": "Windows provides several APIs for allocating memory.  While some of these functions have converged over time, it is still important to always properly pair allocations and deallocations.  The following table shows the proper pairings.\n\nAllocator Deallocator malloc() free() realloc() free() LocalAlloc() LocalFree() LocalReAlloc() LocalFree() GlobalAlloc() GlobalFree() GlobalReAlloc() GlobalFree() VirtualAlloc() VirtualFree() VirtualAllocEx() VirtualFreeEx() VirtualAllocExNuma() VirtualFreeEx() AllocateUserPhysicalPages() FreeUserPhysicalPages() AllocateUserPhysicalPagesNuma() FreeUserPhysicalPages() HeapAlloc() HeapFree() HeapReAlloc() HeapFree()\n\nmalloc()\n\nfree()\n\nrealloc()\n\nfree()\n\nLocalAlloc()\n\nLocalFree()\n\nLocalReAlloc()\n\nLocalFree()\n\nGlobalAlloc()\n\nGlobalFree()\n\nGlobalReAlloc()\n\nGlobalFree()\n\nVirtualAlloc()\n\nVirtualFree()\n\nVirtualAllocEx()\n\nVirtualFreeEx()\n\nVirtualAllocExNuma()\n\nVirtualFreeEx()\n\nAllocateUserPhysicalPages()\n\nFreeUserPhysicalPages()\n\nAllocateUserPhysicalPagesNuma()\n\nFreeUserPhysicalPages()\n\nHeapAlloc()\n\nHeapFree()\n\nHeapReAlloc()\n\nHeapFree()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this example, the FormatMessage() function allocates a buffer and stores it in the buf parameter.  From the documentation of FORMAT_MESSAGE_ALLOCATE_BUFFER [ MSDN ]:\n\nThe function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated buffer at the address specified by lpBuffer.  The lpBuffer parameter is a pointer to anL PTSTR; you must cast the pointer to an LPTSTR (for example, (LPTSTR)&lpBuffer). The nSize parameter specifies the minimum number of TCHARs to allocate for an output message buffer. The caller should use the LocalFree function to free the buffer when it is no longer needed.\n\nInstead of freeing the memory using LocalFree() , this code example uses GlobalFree() erroneously.",
          "code": "LPTSTR buf;\nDWORD n = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                        FORMAT_MESSAGE_FROM_SYSTEM |\n                        FORMAT_MESSAGE_IGNORE_INSERTS, 0, GetLastError(),\n                        LANG_USER_DEFAULT, (LPTSTR)&buf, 1024, 0);\nif (n != 0) {\n  /* Format and display the error to the user */\n\n  GlobalFree(buf);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution uses the proper deallocation function as described by the documentation.",
          "code": "LPTSTR buf;\nDWORD n = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                        FORMAT_MESSAGE_FROM_SYSTEM |\n                        FORMAT_MESSAGE_IGNORE_INSERTS, 0, GetLastError(),\n                        LANG_USER_DEFAULT, (LPTSTR)&buf, 1024, 0);\nif (n != 0) {\n  /* Format and display the error to the user */\n\n  LocalFree(buf);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Mixing allocation and deallocation functions can lead to memory corruption issues, or result in accessing out-of-bounds memory.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "WIN30-C",
    "title": "Properly pair allocation and deallocation functions",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87151918",
    "description": "Windows provides several APIs for allocating memory.  While some of these functions have converged over time, it is still important to always properly pair allocations and deallocations.  The following table shows the proper pairings.\n\nAllocator Deallocator malloc() free() realloc() free() LocalAlloc() LocalFree() LocalReAlloc() LocalFree() GlobalAlloc() GlobalFree() GlobalReAlloc() GlobalFree() VirtualAlloc() VirtualFree() VirtualAllocEx() VirtualFreeEx() VirtualAllocExNuma() VirtualFreeEx() AllocateUserPhysicalPages() FreeUserPhysicalPages() AllocateUserPhysicalPagesNuma() FreeUserPhysicalPages() HeapAlloc() HeapFree() HeapReAlloc() HeapFree()\n\nmalloc()\n\nfree()\n\nrealloc()\n\nfree()\n\nLocalAlloc()\n\nLocalFree()\n\nLocalReAlloc()\n\nLocalFree()\n\nGlobalAlloc()\n\nGlobalFree()\n\nGlobalReAlloc()\n\nGlobalFree()\n\nVirtualAlloc()\n\nVirtualFree()\n\nVirtualAllocEx()\n\nVirtualFreeEx()\n\nVirtualAllocExNuma()\n\nVirtualFreeEx()\n\nAllocateUserPhysicalPages()\n\nFreeUserPhysicalPages()\n\nAllocateUserPhysicalPagesNuma()\n\nFreeUserPhysicalPages()\n\nHeapAlloc()\n\nHeapFree()\n\nHeapReAlloc()\n\nHeapFree()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this example, the FormatMessage() function allocates a buffer and stores it in the buf parameter.  From the documentation of FORMAT_MESSAGE_ALLOCATE_BUFFER [ MSDN ]:\n\nThe function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated buffer at the address specified by lpBuffer.  The lpBuffer parameter is a pointer to anL PTSTR; you must cast the pointer to an LPTSTR (for example, (LPTSTR)&lpBuffer). The nSize parameter specifies the minimum number of TCHARs to allocate for an output message buffer. The caller should use the LocalFree function to free the buffer when it is no longer needed.\n\nInstead of freeing the memory using LocalFree() , this code example uses GlobalFree() erroneously.",
          "code": "LPTSTR buf;\nDWORD n = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                        FORMAT_MESSAGE_FROM_SYSTEM |\n                        FORMAT_MESSAGE_IGNORE_INSERTS, 0, GetLastError(),\n                        LANG_USER_DEFAULT, (LPTSTR)&buf, 1024, 0);\nif (n != 0) {\n  /* Format and display the error to the user */\n\n  GlobalFree(buf);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution uses the proper deallocation function as described by the documentation.",
          "code": "LPTSTR buf;\nDWORD n = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                        FORMAT_MESSAGE_FROM_SYSTEM |\n                        FORMAT_MESSAGE_IGNORE_INSERTS, 0, GetLastError(),\n                        LANG_USER_DEFAULT, (LPTSTR)&buf, 1024, 0);\nif (n != 0) {\n  /* Format and display the error to the user */\n\n  LocalFree(buf);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Mixing allocation and deallocation functions can lead to memory corruption issues, or result in accessing out-of-bounds memory.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE13-C",
    "title": "Use the Standard predefined macros to test for versions and features.",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87151942",
    "description": "The C S tandard defines a set of predefined macros (see subclause 6.10.8) to help the user determine if the implementation being used is a conforming implementation, and if so, to which version of the C Standard it conforms. These macros can also help the user to determine which of the standard features are implemented.\n\nThe following tables list these macros and indicate in which version of the C Standard they were introduced. The following macros are required:\n\nMacro Name C90 C99 C11 __STDC__ ✓ ✓ ✓ __STDC_HOSTED__ ✓ ✓ __STDC_VERSION__ 1 ✓ ✓ __DATE__ ✓ ✓ ✓ __FILE__ ✓ ✓ ✓ __LINE__ ✓ ✓ ✓ __TIME__ ✓ ✓ ✓\n\n__STDC__\n\n__STDC_HOSTED__\n\n__STDC_VERSION__\n1\n\n__DATE__\n\n__FILE__\n\n__LINE__\n\n__TIME__\n\n1) __STDC_VERSION__ was introduced by an Amendment to C90, this version of the C Standard is commonly call C94\n\nThe following are optional environment macros:\n\nMacro Name C90 C99 C11 __STDC_ISO_10646__ ✓ ✓ __STDC_MB_MIGHT_NEQ_WC__ ✓ ✓ __STDC_UTF_16__ ✓ __STDC_UTF_32__ ✓\n\n__STDC_ISO_10646__\n\n__STDC_MB_MIGHT_NEQ_WC__\n\n__STDC_UTF_16__\n\n__STDC_UTF_32__\n\nThe following are optional feature macros:\n\nMacro Name C90 C99 C11 __STDC_ANALYZABLE__ ✓ __STDC_IEC_559__ ✓ ✓ __STDC_IEC_559_COMPLEX__ ✓ ✓ __STDC_LIB_EXT1__ ✓ __STDC_NO_ATOMICS__ ✓ __STDC_NO_COMPLEX__ ✓ __STDC_NO_THREADS__ ✓ __STDC_NO_VLA__ ✓\n\n__STDC_ANALYZABLE__\n\n__STDC_IEC_559__\n\n__STDC_IEC_559_COMPLEX__\n\n__STDC_LIB_EXT1__ \n\n__STDC_NO_ATOMICS__\n\n__STDC_NO_COMPLEX__\n\n__STDC_NO_THREADS__\n\n__STDC_NO_VLA__ \n\nThe following is optional and is defined by the user:\n\nMacro Name C90 C99 C11 __STDC_WANT_LIB_EXT1__ ✓\n\n__STDC_WANT_LIB_EXT1__",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Checking Value of Predefined Macro)",
          "pre_code_commentary": "C Standard predefined macros should never be tested for a value before the macro is tested for definition, as shown in this noncompliant code example:",
          "code": "#include <stdio.h>\n\nint main(void) {\n  #if (__STDC__ == 1)\n    printf(\"Implementation is ISO-conforming.\\n\");\n  #else\n    printf(\"Implementation is not ISO-conforming.\\n\");\n  #endif\n  /* ... */\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Testing for Definition of Macro)",
          "pre_code_commentary": "In this compliant solution, the definition of the predefined macro __STDC__ is tested before the value of the macro is tested:",
          "code": "#include <stdio.h>\n\nint main(void) {\n  #if defined(__STDC__)\n    #if (__STDC__ == 1)\n      printf(\"Implementation is ISO-conforming.\\n\");\n    #else\n      printf(\"Implementation is not ISO-conforming.\\n\");\n    #endif\n  #else   /* !defined(__STDC__) */\n    printf(\"__STDC__ is not defined.\\n\");\n  #endif\n  /* ... */\n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Checking Value of Predefined Macro)",
          "pre_code_commentary": "C Standard predefined macros should never be tested for a value before the macro is tested for definition, as shown in this noncompliant code example:",
          "code": "#include <stdio.h>\n\nint main(void) {\n  #if (__STDC__ == 1)\n    printf(\"Implementation is ISO-conforming.\\n\");\n  #else\n    printf(\"Implementation is not ISO-conforming.\\n\");\n  #endif\n  /* ... */\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Test for Optional Feature)",
          "pre_code_commentary": "This compliant solution tests to see if the C11 predefined macro __STDC_ANALYZABLE__ is defined and what value the implementation has given the macro:",
          "code": "#include <stdio.h>\n \nint main(void) {\n  #if defined (__STDC__)\n    #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)  /* C11 */\n      #if defined(__STDC_ANALYZABLE__)\n        #if (__STDC_ANALYZABLE__ == 1)\n\t      printf(\"Compiler conforms to Annex L (Analyzability).\\n\");\n        #else\n\t      printf(\"Compiler does not support Annex L (Analyzability).\\n\");\n        #endif\n      #else\n        printf(\"__STDC_ANALYZABLE__ is not defined.\\n\");\n      #endif\n    #else\n      printf(\"Compiler not C11.\\n\");\n    #endif\n  #else\n    printf(\"Compiler not Standard C.\\n\");\n  #endif\n \n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Checking Value of Predefined Macro)",
          "pre_code_commentary": "C Standard predefined macros should never be tested for a value before the macro is tested for definition, as shown in this noncompliant code example:",
          "code": "#include <stdio.h>\n\nint main(void) {\n  #if (__STDC__ == 1)\n    printf(\"Implementation is ISO-conforming.\\n\");\n  #else\n    printf(\"Implementation is not ISO-conforming.\\n\");\n  #endif\n  /* ... */\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Optional Language Features)",
          "pre_code_commentary": "This compliant solution checks for the C11 optional language features in Annex K. If Annex K is supported by the implementation, the functions defined in Annex K are used; if Annex K is not supported, then the standard library functions are used. (See DCL09-C. Declare functions that return errno with a return type of errno_t . )",
          "code": "#if defined(__STDC_LIB_EXT1__)\n  #if (__STDC_LIB_EXT1__ >= 201112L)\n    #define USE_EXT1 1\n    #define __STDC_WANT_LIB_EXT1__ 1 /* Want the ext1 functions */\n  #endif\n#endif\n \n#include <string.h>\n#include <stdlib.h>\n \nint main(void) {\n  char source_msg[] = \"This is a test.\";\n  char *msg = malloc(sizeof(source_msg) + 1);\n \n  if (msg != NULL) {\n    #if defined(USE_EXT1)\n      strcpy_s(msg, sizeof msg, source_msg);\n    #else\n      strcpy(msg, source_msg);\n    #endif\n  } \n  else {\n    return EXIT_FAILURE;\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Checking Value of Predefined Macro)",
          "pre_code_commentary": "C Standard predefined macros should never be tested for a value before the macro is tested for definition, as shown in this noncompliant code example:",
          "code": "#include <stdio.h>\n\nint main(void) {\n  #if (__STDC__ == 1)\n    printf(\"Implementation is ISO-conforming.\\n\");\n  #else\n    printf(\"Implementation is not ISO-conforming.\\n\");\n  #endif\n  /* ... */\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Optional Language Features)",
          "pre_code_commentary": "The previous compliant solution comes close to violating PRE09-C. Do not replace secure functions with deprecated or obsolescent functions , and would if a function-like macro were defined which called either strcpy_s() or strcpy() depending on if USE_EXT1 were defined.  This compliant solution solves the problem by including a custom library that implements the optional language feature, which in this case is the Safe C Library available from SourceForge .",
          "code": "#if defined(__STDC_LIB_EXT1__)\n  #if (__STDC_LIB_EXT1__ >= 201112L)\n    #define USE_EXT1 1\n    #define __STDC_WANT_LIB_EXT1__ 1 /* Want the ext1 functions */\n  #endif\n#endif\n \n#include <string.h>\n#include <stdlib.h>\n\n#if !defined(USE_EXT1)\n  #include \"safe_str_lib.h\"\n#endif\n  \nint main(void) {\n  char source_msg[] = \"This is a test.\";\n  char *msg = malloc(sizeof(source_msg) + 1);\n \n  if (msg != NULL) {\n    strcpy_s(msg, sizeof msg, source_msg);\n  } \n  else {\n    return EXIT_FAILURE;\n  }\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Not testing for language features or the version of the implementation being used can lead to unexpected or undefined program behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "WIN00-C",
    "title": "Be specific when dynamically loading libraries",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152030",
    "description": "The LoadLibrary() or LoadLibraryEx() function calls [ MSDN ] allow you to dynamically load a library at runtime and use a specific algorithm to locate the library within the file system [ MSDN ]. It is possible for an attacker to place a file on the DLL search path such that your application inadvertently loads and executes arbitrary source code.\n\nLoadLibrary()\n\nLoadLibraryEx()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": null,
          "code": "#include <Windows.h>\n \nvoid func(void) {\n  HMODULE hMod = LoadLibrary(TEXT(\"MyLibrary.dll\"));\n  if (hMod != NULL) {\n    typedef void (__cdecl func_type)(void);\n    func_type *fn = (func_type *)GetProcAddress(hMod, \"MyFunction\");\n    if (fn != NULL)\n      fn();\n  }\n}",
          "explanation_after": "If an attacker were to place a malicious DLL named MyLibrary.dll higher on the search path than where the library resides, she could trigger arbitrary code to execute either via the DllMain() entrypoint (which is called automatically by the system loader) or by providing an implementation for MyFunction() , either of which would run within the security context of your application. If your application runs with elevated privileges (such as a service application), an escalation of privileges could result."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "By refusing to load a library unless it is located precisely where expected, you reduce the chance of executing arbitrary code when dynamically loading libraries. This compliant solution uses LoadLibraryEx() to ensure that only the application and System32 directories are searched (eliminating other search paths such as the current directory or PATH environment variable):",
          "code": "#include <Windows.h>\n \nvoid func(void) {\n  HMODULE hMod = LoadLibraryEx(TEXT(\"MyLibrary.dll\"), NULL,\n                               LOAD_LIBRARY_SEARCH_APPLICATION_DIR |\n                               LOAD_LIBRARY_SEARCH_SYSTEM32);\n  if (hMod != NULL) {\n    typedef void (__cdecl func_type)(void);\n    func_type *fn = (func_type *)GetProcAddress(hMod, \"MyFunction\");\n    if (fn != NULL)\n      fn();\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Depending on the version of Windows the application is run on, failure to properly specify the library can lead to arbitrary code execution.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FIO44-C",
    "title": "Only use values for fsetpos() that are returned from fgetpos()",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152071",
    "description": "The C Standard, 7.23.9.3 paragraph 2 [ ISO/IEC 9899:2024 ], defines the following behavior for fsetpos() :\n\nfsetpos()\n\nThe fsetpos function sets the mbstate_t object (if any) and file position indicator for the stream pointed to by stream according to the value of the object pointed to by pos , which shall be a value obtained from an earlier successful call to the fgetpos function on a stream associated with the same file.\n\nfsetpos\n\nmbstate_t\n\nstream\n\npos\n\nfgetpos\n\nInvoking the fsetpos() function with any other values for pos is undefined behavior 181 .\n\nfsetpos()\n\npos",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example attempts to read three values from a file and then set the file position pointer back to the beginning of the file:",
          "code": "#include <stdio.h>\n#include <string.h>\n \nint opener(FILE *file) {\n  int rc;\n  fpos_t offset;\n\n  memset(&offset, 0, sizeof(offset));\n\n  if (file == NULL) { \n    return -1;\n  }\n\n  /* Read in data from file */\n\n  rc = fsetpos(file, &offset);\n  if (rc != 0 ) {\n    return rc;\n  }\n\n  return 0;\n}\n",
          "explanation_after": "Only the return value of an fgetpos() call is a valid argument to fsetpos() ; passing a value of type fpos_t that was created in any other way is undefined behavior 181 ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the initial file position indicator is stored by first calling fgetpos() , which is used to restore the state to the beginning of the file in the later call to fsetpos() :",
          "code": "#include <stdio.h>\n#include <string.h>\n \nint opener(FILE *file) {\n  int rc;\n  fpos_t offset;\n\n  if (file == NULL) {\n    return -1;\n  }\n\n  rc = fgetpos(file, &offset);\n  if (rc != 0 ) {\n    return rc;\n  }\n\n  /* Read in data from file */\n\n  rc = fsetpos(file, &offset);\n  if (rc != 0 ) {\n    return rc;\n  }\n\n  return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Misuse of the fsetpos() function can position a file position indicator to an unintended location in the file.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "API00-C",
    "title": "Functions should validate their parameters",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152074",
    "description": "Redundant testing by caller and by callee as a style of defensive programming is largely discredited in the C and C++ communities, the main problem being performance. The usual discipline in C and C++ is to require validation on only one side of each interface.\n\nRequiring the caller to validate arguments can result in faster code because the caller may understand certain invariants that prevent invalid values from being passed. Requiring the callee to validate arguments allows the validation code to be encapsulated in one location, reducing the size of the code and making it more likely that these checks are performed in a consistent and correct fashion.\n\nFor safety and security reasons, this standard recommends that the called function validate its parameters. Validity checks allow the function to survive at least some forms of improper usage, enabling an application using the function to likewise survive. Validity checks can also simplify the task of determining the condition that caused the invalid parameter.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, setfile() and usefile() do not validate their parameters. It is possible that an invalid file pointer can be used by the library, corrupting the library's internal state and exposing a vulnerability .",
          "code": "/* Sets some internal state in the library */\nextern int setfile(FILE *file);\n\n/* Performs some action using the file passed earlier */\nextern int usefile();\n\nstatic FILE *myFile;\n\nvoid setfile(FILE *file) {\n    myFile = file;\n}\n\nvoid usefile(void) {\n    /* Perform some action here */\n}\n",
          "explanation_after": "The vulnerability can be more severe if the internal state references sensitive or system-critical data."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Validating the function parameters and verifying the internal state leads to consistency of program execution and may eliminate potential vulnerabilities. In addition, implementing commit or rollback semantics (leaving program state unchanged on error) is a desirable practice for error safety.",
          "code": "/* Sets some internal state in the library */\nextern errno_t setfile(FILE *file);\n\n/* Performs some action using the file passed earlier */\nextern errno_t usefile(void);\n\nstatic FILE *myFile;\n\nerrno_t setfile(FILE *file) {\n if (file && !ferror(file) && !feof(file)) {\n    myFile = file;\n    return 0;\n  }\n\n  /* Error safety: leave myFile unchanged */\n  return -1;\n}\n\nerrno_t usefile(void) {\n  if (!myFile) return -1;\n\n    /*\n     * Perform other checks if needed; return \n     * error condition.\n     */\n\n    /* Perform some action here */\n    return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to validate the parameters in library functions may result in an access violation or a data integrity violation. Such a scenario indicates a flaw in how the library is used by the calling code. However, the library itself may still be the vector by which the calling code's vulnerability is exploited.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ENV01-C",
    "title": "Do not make assumptions about the size of an environment variable",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152092",
    "description": "Do not make any assumptions about the size of environment variables because an adversary might have full control over the environment. If the environment variable needs to be stored, the length of the associated string should be calculated and the storage dynamically allocated (see STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator ).",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example copies the string returned by getenv() into a fixed-size buffer:",
          "code": "void f() {\n  char path[PATH_MAX]; /* Requires PATH_MAX to be defined */\n  strcpy(path, getenv(\"PATH\"));\n  /* Use path */\n}\n",
          "explanation_after": "Even if your platform assumes that $PATH is defined, defines PATH_MAX , and enforces that paths not have more than PATH_MAX characters, the $PATH environment variable still is not required to have less than PATH_MAX chars. And if it has more than PATH_MAX chars, a buffer overflow will result. Also, if $PATH is not defined, then strcpy() will attempt to dereference a null pointer."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the strlen() function is used to calculate the size of the string, and the required space is dynamically allocated:",
          "code": "void f() {\n  char *path = NULL;\n  /* Avoid assuming $PATH is defined or has limited length */\n  const char *temp = getenv(\"PATH\");\n  if (temp != NULL) {\n    path = (char*) malloc(strlen(temp) + 1);\n    if (path == NULL) {\n      /* Handle error condition */\n    } else {\n      strcpy(path, temp);\n    }\n    /* Use path */\n    free(path);\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example copies the string returned by getenv() into a fixed-size buffer:",
          "code": "void f() {\n  char path[PATH_MAX]; /* Requires PATH_MAX to be defined */\n  strcpy(path, getenv(\"PATH\"));\n  /* Use path */\n}\n",
          "explanation_after": "Even if your platform assumes that $PATH is defined, defines PATH_MAX , and enforces that paths not have more than PATH_MAX characters, the $PATH environment variable still is not required to have less than PATH_MAX chars. And if it has more than PATH_MAX chars, a buffer overflow will result. Also, if $PATH is not defined, then strcpy() will attempt to dereference a null pointer."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX or C2x)",
          "pre_code_commentary": "In this compliant solution, the strdup() function is used to dynamically allocate a duplicate of the string:",
          "code": "void f() {\n  char *path = NULL;\n  /* Avoid assuming $PATH is defined or has limited length */\n  const char *temp = getenv(\"PATH\");\n  if (temp != NULL) {\n    path = strdup(temp);\n    if (path == NULL) {\n      /* Handle error condition */\n    }\n    /* Use path */\n    free(path);\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Making assumptions about the size of an environmental variable can result in a buffer overflow.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MSC00-C",
    "title": "Compile cleanly at high warning levels",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152104",
    "description": "Compile code using the highest warning level available for your compiler and eliminate warnings by modifying the code.\n\nAccording to the C Standard, subclause 5.1.1.3 [ ISO/IEC 9899:2011 ],\n\nA conforming implementation shall produce at least one diagnostic message (identified in an implementation-defined manner) if a preprocessing translation unit or translation unit contains a violation of any syntax rule or constraint, even if the behavior is also explicitly specified as undefined or implementation-defined. Diagnostic messages need not be produced in other circumstances.\n\nAssuming a conforming implementation , eliminating diagnostic messages will eliminate any syntactic or constraint violations.\n\nIf suitable source-code-checking tools are available, use them regularly.\n\nCompilers can produce diagnostic messages for correct code, as is permitted by C. It is usually preferable to rewrite code to eliminate compiler warnings, but if the code is correct, it is sufficient to provide a comment explaining why the warning message does not apply. Some compilers provide ways to suppress warnings, such as suitably formatted comments or pragmas, which can be used sparingly when the programmer understands the implications of the warning but has good reason to use the flagged construct anyway.\n\nDo not simply quiet warnings by adding type casts or other means. Instead, understand the reason for the warning and consider a better approach, such as using matching types and avoiding type casts whenever possible.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Windows)",
          "pre_code_commentary": "Using the default warning specifier with #pragma warning resets the behavior of a warning to its default value, which may not be the same as its previous behavior.  Programmers commonly, but incorrectly, use the default warning specifier to restore previous warning messages after a message is temporarily disabled.",
          "code": "#pragma warning(disable:4705) \n#pragma warning(disable:4706) \n#pragma warning(disable:4707) \n/* Unnecessarily flagged code */\n#pragma warning(default:4705) \n#pragma warning(default:4706) \n#pragma warning(default:4707) \n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "Instead of using the default warning specifier, the current state of the warnings should be saved and then restored after the unnecessarily flagged code.",
          "code": "#pragma warning(push) \n#pragma warning(disable:4705) \n#pragma warning(disable:4706) \n#pragma warning(disable:4707) \n/* Unnecessarily flagged code */\n#pragma warning(pop) ",
          "explanation_after": "The pragma warning(push) stores the current warning state for every warning. The pragma warning(pop) pops the last warning state pushed onto the stack. Any changes made to the warning state between the push and pop are undone."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Eliminating violations of syntax rules and other constraints can eliminate serious software vulnerabilities that can lead to the execution of arbitrary code with the permissions of the vulnerable process.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ENV30-C",
    "title": "Do not modify the object referenced by the return value of certain functions",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152111",
    "description": "Some functions return a pointer to an object that cannot be modified without causing undefined behavior . These functions include getenv() , setlocale() , localeconv() , asctime() , and strerror() . In such cases, the function call results must be treated as being const -qualified.\n\ngetenv()\n\nsetlocale()\n\nlocaleconv()\n\nasctime()\n\nstrerror()\n\nconst\n\nThe C Standard, 7.24.4.6, paragraph 4 [ ISO/IEC 9899:2024 ], defines getenv() as follows:\n\ngetenv()\n\nThe getenv function returns a pointer to a string associated with the matched list member. The string pointed to shall not be modified by the program, but may be overwritten by a subsequent call to the getenv function. If the specified name cannot be found, a null pointer is returned.\n\ngetenv\n\ngetenv\n\nIf the string returned by getenv() must be altered, a local copy should be created. Altering the string returned by getenv() is undefined behavior . (See undefined behavior 189 .)\n\ngetenv()\n\ngetenv()\n\nSimilarly, subclause 7.11.1.1, paragraph 8 [ ISO/IEC 9899:2024 ], defines setlocale() as follows:\n\nsetlocale()\n\nThe pointer to string returned by the setlocale function is such that a subsequent call with that string value and its associated category will restore that part of the program's locale. The string pointed to shall not be modified by the program, but may be overwritten by a subsequent call to the setlocale function.\n\nsetlocale\n\nsetlocale\n\nAnd subclause 7.11.2.1, paragraph 8 [ ISO/IEC 9899:2024 ], defines localeconv() as follows:\n\nlocaleconv()\n\nThe localeconv function returns a pointer to the filled-in object. The structure pointed to by the return value shall not be modified by the program, but may be overwritten by a subsequent call to the localeconv function. In addition, calls to the setlocale function with categories LC_ALL , LC_MONETARY , or LC_NUMERIC may overwrite the contents of the structure.\n\nlocaleconv\n\nlocaleconv\n\nsetlocale\n\nLC_ALL\n\nLC_MONETARY\n\nLC_NUMERIC\n\nAltering the string returned by setlocale() or the structure returned by localeconv() are undefined behaviors . (See undefined behaviors 119 and 121 .) Furthermore, the C Standard imposes no requirements on the contents of the string by setlocale() . Consequently, no assumptions can be made as to the string's internal contents or structure.\n\nsetlocale()\n\nlocaleconv()\n\nsetlocale()\n\nFinally, subclause 7.26.6.3, paragraph 4 [ ISO/IEC 9899:2024 ], states\n\nThe strerror function returns a pointer to the string, the contents of which are locale-specific. The array pointed to shall not be modified by the program. The behavior is undefined if the returned value is used after a subsequent call to the strerror function, or after the thread which called the function to obtain the returned value has exited.\n\nstrerror\n\nstrerror\n\nAltering the string returned by strerror() is undefined behavior . (See undefined behavior 189 .)\n\nstrerror()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( getenv() )",
          "pre_code_commentary": "This noncompliant code example modifies the string returned by getenv() by replacing all double quotation marks ( \" ) with underscores ( _ ):",
          "code": "#include <stdlib.h>\n \nvoid trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n\nvoid func(void) {\n  char *env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n  trstr(env,'\"', '_');\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( getenv() ) (Environment Not Modified)",
          "pre_code_commentary": "If the programmer does not intend to modify the environment, this compliant solution demonstrates how to modify a copy of the return value:",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nvoid trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n \nvoid func(void) {\n  const char *env;\n  char *copy_of_env;\n\n  env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n\n  copy_of_env = (char *)malloc(strlen(env) + 1);\n  if (copy_of_env == NULL) {\n    /* Handle error */\n  }\n\n  strcpy(copy_of_env, env);\n  trstr(copy_of_env,'\"', '_');\n  /* ... */\n  free(copy_of_env);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( getenv() )",
          "pre_code_commentary": "This noncompliant code example modifies the string returned by getenv() by replacing all double quotation marks ( \" ) with underscores ( _ ):",
          "code": "#include <stdlib.h>\n \nvoid trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n\nvoid func(void) {\n  char *env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n  trstr(env,'\"', '_');\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( getenv() ) (Modifying the Environment in POSIX)",
          "pre_code_commentary": "If the programmer's intent is to modify the environment, this compliant solution, which saves the altered string back into the environment by using the POSIX setenv() and strdup() functions, can be used:",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nvoid trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n \nvoid func(void) {\n  const char *env;\n  char *copy_of_env;\n\n  env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n\n  copy_of_env = strdup(env);\n  if (copy_of_env == NULL) {\n    /* Handle error */\n  }\n\n  trstr(copy_of_env,'\"', '_');\n\n  if (setenv(\"TEST_ENV\", copy_of_env, 1) != 0) {\n    /* Handle error */\n  }\n  /* ... */\n  free(copy_of_env);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( localeconv() )",
          "pre_code_commentary": "In this noncompliant example, the object returned by localeconv() is directly modified:",
          "code": "#include <locale.h>\n \nvoid f2(void) {\n  struct lconv *conv = localeconv();\n \n  if ('\\0' == conv->decimal_point[0]) {\n    conv->decimal_point = \".\";\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( localeconv() ) (Copy)",
          "pre_code_commentary": "This compliant solution modifies a copy of the object returned by localeconv() :",
          "code": "#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid f2(void) {\n  const struct lconv *conv = localeconv();\n  if (conv == NULL) {\n     /* Handle error */\n  }\n  \n  struct lconv *copy_of_conv = (struct lconv *)malloc(\n    sizeof(struct lconv));\n  if (copy_of_conv == NULL) {\n    /* Handle error */\n  }\n \n  memcpy(copy_of_conv, conv, sizeof(struct lconv));\n \n  if ('\\0' == copy_of_conv->decimal_point[0]) {\n    copy_of_conv->decimal_point = \".\";  \n  }\n  /* ... */\n  free(copy_of_conv);\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Modifying the object pointed to by the return value of getenv() , setlocale() , localeconv() , asctime() , or strerror() is undefined behavior . Even if the modification succeeds, the modified object can be overwritten by a subsequent call to the same function.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ARR00-C",
    "title": "Understand how arrays work",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152117",
    "description": "The incorrect use of arrays has traditionally been a source of exploitable vulnerabilities . Elements referenced within an array using the subscript operator [] are not checked unless the programmer provides adequate bounds checking. As a result, the expression array [pos] = value can be used by an attacker to transfer control to arbitrary code.\n\n[]\n\narray [pos] = value\n\nAn attacker who can control the values of both pos and value in the expression array [pos] = value can perform an arbitrary write (which is when the attacker overwrites other storage locations with different content). The consequences range from changing a variable used to determine what permissions the program grants to executing arbitrary code with the permissions of the vulnerable process. Arrays are also a common source of buffer overflows when iterators exceed the bounds of the array.\n\npos\n\nvalue\n\narray [pos] = value\n\nAn array is a series of objects, all of which are the same size and type. Each object in an array is called an array element . The entire array is stored contiguously in memory (that is, there are no gaps between elements). Arrays are commonly used to represent a sequence of elements where random access is important but there is little or no need to insert new elements into the sequence (which can be an expensive operation with arrays).\n\nArrays containing a constant number of elements can be declared as follows:\n\nenum { ARRAY_SIZE = 12 };\nint array[ARRAY_SIZE];\n\nenum { ARRAY_SIZE = 12 };\nint array[ARRAY_SIZE];\n\nThese statements allocate storage for an array of 12 integers referenced by array . Arrays are indexed from 0..n-1 (where n represents an array bound). Arrays can also be declared as follows:\n\narray\n\n0..n-1\n\nn\n\nint array[];\n\nint array[];\n\nThis array is called an incomplete type because the size is unknown. If an array of unknown size is initialized, its size is determined by the largest indexed element with an explicit initializer. At the end of its initializer list, the array no longer has incomplete type.\n\nint array[] = { 1, 2 };\n\nint array[] = { 1, 2 };\n\nAlthough these declarations work fine when the size of the array is known at compile time, it is not possible to declare an array in this fashion when the size can be determined only at runtime. The C Standard adds support for variable length arrays or arrays whose size is determined at runtime. Before the introduction of variable length arrays in C99, however, these \"arrays\" were typically implemented as pointers to their respective element types allocated using malloc() , as shown in this example:\n\nmalloc()\n\nint *dis = (int *)malloc(ARRAY_SIZE * sizeof(int));\n\nint *dis = (int *)malloc(ARRAY_SIZE * sizeof(int));\n\nAlways check that malloc() returns a non-null pointer, as per ERR33-C. Detect and handle standard library errors .\n\nmalloc()\n\nIt is important to retain any pointer value returned by malloc() so that the referenced memory may eventually be deallocated. One possible way to preserve such a value is to use a constant pointer:\n\nmalloc()\n\nint * const dat = (int * const)malloc(\n  ARRAY_SIZE * sizeof(int)\n);\n/* ... */\nfree(dat);\n\nint * const dat = (int * const)malloc(\n  ARRAY_SIZE * sizeof(int)\n);\n/* ... */\nfree(dat);\n\nBelow we consider some techniques for array initialization.  Both dis and dat arrays can be initialized as follows:\n\ndis\n\ndat\n\nfor (i = 0; i < ARRAY_SIZE; i++) {\n   dis[i] = 42; /* Assigns 42 to each element of dis */ \n   dat[i] = 42; /* Assigns 42 to each element of dat */\n}\n\nfor (i = 0; i < ARRAY_SIZE; i++) {\n   dis[i] = 42; /* Assigns 42 to each element of dis */ \n   dat[i] = 42; /* Assigns 42 to each element of dat */\n}\n\nThe dis array can also be initialized as follows:\n\ndis\n\nfor (i = 0; i < ARRAY_SIZE; i++) {\n   *dis = 42;\n   dis++;\n}\ndis -= ARRAY_SIZE;\n\nfor (i = 0; i < ARRAY_SIZE; i++) {\n   *dis = 42;\n   dis++;\n}\ndis -= ARRAY_SIZE;\n\nThis technique, however, will not work for dat .  The dat identifier cannot be incremented (produces a fatal compilation error), as it was declared with type int * const .  This problem can be circumvented by copying dat into a separate pointer:\n\ndat\n\ndat\n\nint * const\n\ndat\n\nint *p = dat;\nfor (i = 0; i < ARRAY_SIZE; i++)  {\n  *p = 42; /* Assigns 42 to each element */\n  p++;\n}\n\nint *p = dat;\nfor (i = 0; i < ARRAY_SIZE; i++)  {\n  *p = 42; /* Assigns 42 to each element */\n  p++;\n}\n\nThe variable p is declared as a pointer to an integer, initialized with the value stored in dat , and then incremented in the loop. This technique can be used to initialize both arrays, and is a better style of programming than incrementing the original pointer to the array (e.g., dis++ , in the above example), as it avoids having to reset the pointer back to the start of the array after the loop completes.\n\np\n\ndat\n\ndis++\n\nObviously, there is a relationship between array subscripts [] and pointers. The expression dis[i] is equivalent to *(dis+i) for all integral values of i . In other words, if dis is an array object (equivalently, a pointer to the initial element of an array object) and i is an integer, dis[i] designates the i th element of dis . In fact, because *(dis+i) can be expressed as *(i+dis) , the expression dis[i] can be represented as i[dis] , although doing so is not encouraged. Because array indices are zero-based, the first element is designated as dis[0] , or equivalently as *(dis+0) or simply *dis .\n\n[]\n\ndis[i]\n\n*(dis+i)\n\ni\n\ndis\n\ni\n\ndis[i]\n\ni\n\ndis\n\n*(dis+i)\n\n*(i+dis)\n\ndis[i]\n\ni[dis]\n\ndis[0]\n\n*(dis+0)\n\n*dis",
    "examples": null,
    "risk_assessment": {
      "explanation": "Arrays are a common source of vulnerabilities in C language programs because they are frequently used but not always fully understood.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "INT10-C",
    "title": "Do not assume a positive remainder when using the % operator",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152120",
    "description": "In C89 (and historical K&R implementations ), the meaning of the remainder operator for negative operands was implementation-defined . This behavior was changed in C99, and the change remains in C11.\n\nBecause not all C compilers are strictly C-conforming, programmers cannot rely on the behavior of the % operator if they need to run on a wide range of platforms with many different compilers.\n\n%\n\nThe C Standard, subclause 6.5.5 [ ISO/IEC 9899:2011 ], states:\n\nThe result of the / operator is the quotient from the division of the first operand by the second; the result of the % operator is the remainder. In both operations, if the value of the second operand is zero, the behavior is undefined .\n\n/\n\n%\n\nand\n\nWhen integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded. If the quotient a/b is representable, the expression (a/b)*b + a%b shall equal a .\n\n/\n\na/b\n\n(a/b)*b + a%b\n\na\n\nDiscarding the fractional part of the remainder is often called truncation toward zero .\n\nThe C definition of the % operator implies the following behavior:\n\n%\n\n11 %  5  ->  1\n 11 % -5  ->  1\n-11 %  5  -> -1\n-11 % -5  -> -1\n\n 11 %  5  ->  1\n 11 % -5  ->  1\n-11 %  5  -> -1\n-11 % -5  -> -1\n\nThe result has the same sign as the dividend (the first operand in the expression).",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the insert() function adds values to a buffer in a modulo fashion, that is, by inserting values at the beginning of the buffer once the end is reached. However, both size and index are declared as int and consequently are not guaranteed to be positive. Depending on the implementation and on the sign of size and index , the result of (index + 1) % size may be negative, resulting in a write outside the bounds of the list array.",
          "code": "int insert(int index, int *list, int size, int value) {\n  if (size != 0) {\n    index = (index + 1) % size;\n    list[index] = value;\n    return index;\n  }\n  else {\n    return -1;\n  }\n}\n",
          "explanation_after": "This code also violates ERR02-C. Avoid in-band error indicators ."
        },
        "compliant": null
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Taking the absolute value of the modulo operation returns a positive value:",
          "code": "int insert(int index, int *list, int size, int value) {\n  if (size != 0) {\n    index = abs((index + 1) % size);\n    list[index] = value;\n    return index;\n  }\n  else {\n    return -1;\n  }\n}\n",
          "explanation_after": "However, this noncompliant code example violates INT01-C. Use size_t or rsize_t for all integer values representing the size of an object . There is also a possibility that (index + 1) could result in a signed integer overflow in violation of INT32-C. Ensure that operations on signed integers do not result in overflow ."
        },
        "compliant": {
          "heading": "Compliant Solution (Unsigned Types)",
          "pre_code_commentary": "The most appropriate solution in this case is to use unsigned types to eliminate any possible implementation-defined behavior , as in this compliant solution. For compliance with ERR02-C. Avoid in-band error indicators , this solution fills a result argument with the mathematical result and returns nonzero only if the operation succeeds.",
          "code": "int insert(size_t* result, size_t index, int *list, size_t size, int value) {\n  if (size != 0 && size != SIZE_MAX) {\n    index = (index + 1) % size;\n    list[index] = value;\n    *result = index;\n    return 1;\n  }\n  else {\n    return 0;\n  }\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrectly assuming that the result of the remainder operator for signed operands will always be positive can lead to an out-of-bounds memory accessor other flawed logic.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM01-C",
    "title": "Store a new value in pointers immediately after free()",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152148",
    "description": "Dangling pointers can lead to exploitable double-free and access-freed-memory vulnerabilities . A simple yet effective way to eliminate dangling pointers and avoid many memory-related vulnerabilities is to set pointers to NULL after they are freed or to set them to another valid object.\n\nNULL",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the type of a message is used to determine how to process the message itself. It is assumed that message_type is an integer and message is a pointer to an array of characters that were allocated dynamically. If message_type equals value_1 , the message is processed accordingly. A similar operation occurs when message_type equals value_2 . However, if message_type == value_1 evaluates to true and message_type == value_2 also evaluates to true, then message is freed twice, resulting in a double-free vulnerability.",
          "code": "char *message;\nint message_type;\n\n/* Initialize message and message_type */\n\nif (message_type == value_1) {\n  /* Process message type 1 */\n  free(message);\n}\n/* ...*/\nif (message_type == value_2) {\n   /* Process message type 2 */\n  free(message);\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Calling free() on a null pointer results in no action being taken by free() . Setting message to NULL after it is freed eliminates the possibility that the message pointer can be used to free the same memory more than once.",
          "code": "char *message;\nint message_type;\n\n/* Initialize message and message_type */\n\nif (message_type == value_1) {\n  /* Process message type 1 */\n  free(message);\n  message = NULL;\n}\n/* ... */\nif (message_type == value_2) {\n  /* Process message type 2 */\n  free(message);\n  message = NULL;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Setting pointers to NULL or to another valid value after memory is freed is a simple and easily implemented solution for reducing dangling pointers. Dangling pointers can result in freeing memory multiple times or in writing to memory that has already been freed. Both of these problems can lead to an attacker executing arbitrary code with the permissions of the vulnerable process.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "MEM00-C",
    "title": "Allocate and free memory in the same module, at the same level of abstraction",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152150",
    "description": "Dynamic memory management is a common source of programming flaws that can lead to security vulnerabilities . Poor memory management can lead to security issues, such as heap-buffer overflows, dangling pointers, and double-free issues [ Seacord 2013 ]. From the programmer's perspective, memory management involves allocating memory, reading and writing to memory, and deallocating memory.\n\nAllocating and freeing memory in different modules and levels of abstraction may make it difficult to determine when and if a block of memory has been freed, leading to programming defects, such as memory leaks, double-free vulnerabilities , accessing freed memory, or writing to freed or unallocated memory.\n\nTo avoid these situations, memory should be allocated and freed at the same level of abstraction and, ideally, in the same code module. This includes the use of the following memory allocation and deallocation functions described in subclause 7.23.3 of the C Standard [ ISO/IEC 9899:2011 ]:\n\nvoid *malloc(size_t size);\n\nvoid *calloc(size_t nmemb, size_t size);\n\nvoid *realloc(void *ptr, size_t size);\n\nvoid *aligned_alloc(size_t alignment, size_t size);\n \nvoid free(void *ptr);\n\nvoid *malloc(size_t size);\n\nvoid *calloc(size_t nmemb, size_t size);\n\nvoid *realloc(void *ptr, size_t size);\n\nvoid *aligned_alloc(size_t alignment, size_t size);\n \nvoid free(void *ptr);\n\nFailing to follow this recommendation has led to real-world vulnerabilities. For example, freeing memory in different modules resulted in a vulnerability in MIT Kerberos 5 [ MIT 2004 ]. The MIT Kerberos 5 code in this case contained error-handling logic, which freed memory allocated by the ASN.1 decoders if pointers to the allocated memory were non-null. However, if a detectable error occurred, the ASN.1 decoders freed the memory that they had allocated. When some library functions received errors from the ASN.1 decoders, they also attempted to free the same memory, resulting in a double-free vulnerability.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example shows a double-free vulnerability resulting from memory being allocated and freed at differing levels of abstraction. In this example, memory for the list array is allocated in the process_list() function. The array is then passed to the verify_size() function that performs error checking on the size of the list. If the size of the list is below a minimum size, the memory allocated to the list is freed, and the function returns to the caller. The calling function then frees this same memory again, resulting in a double-free and potentially exploitable vulnerability.",
          "code": "enum { MIN_SIZE_ALLOWED = 32 };\n\nint verify_size(char *list, size_t size) {\n  if (size < MIN_SIZE_ALLOWED) {\n    /* Handle error condition */\n    free(list);\n    return -1;\n  }\n  return 0;\n}\n\nvoid process_list(size_t number) {\n  char *list = (char *)malloc(number);\n  if (list == NULL) {\n    /* Handle allocation error */\n  }\n\n  if (verify_size(list, number) == -1) {\n      free(list);\n      return;\n  }\n\n  /* Continue processing list */\n\n  free(list);\n}\n",
          "explanation_after": "The call to free memory in the verify_size() function takes place in a subroutine of the process_list() function, at a different level of abstraction from the allocation, resulting in a violation of this recommendation. The memory deallocation also occurs in error-handling code, which is frequently not as well tested as \"green paths\" through the code."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "To correct this problem, the error-handling code in verify_size() is modified so that it no longer frees list . This change ensures that list is freed only once, at the same level of abstraction, in the process_list() function.",
          "code": "enum { MIN_SIZE_ALLOWED = 32 };\n\nint verify_size(const char *list, size_t size) {\n  if (size < MIN_SIZE_ALLOWED) {\n    /* Handle error condition */\n    return -1;\n  }\n  return 0;\n}\n\nvoid process_list(size_t number) {\n  char *list = (char *)malloc(number);\n\n  if (list == NULL) {\n    /* Handle allocation error */\n  }\n\n  if (verify_size(list, number) == -1) {\n      free(list);\n      return;\n  }\n\n  /* Continue processing list */\n\n  free(list);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The mismanagement of memory can lead to freeing memory multiple times or writing to already freed memory. Both of these coding errors can result in an attacker executing arbitrary code with the permissions of the vulnerable process. Memory management errors can also lead to resource depletion and denial-of-service attacks .",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "STR00-C",
    "title": "Represent characters using an appropriate type",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152151",
    "description": "Strings are a fundamental concept in software engineering, but they are not a built-in type in C. Null-terminated byte strings (NTBS) consist of a contiguous sequence of characters terminated by and including the first null character and are supported in C as the format used for string literals. The C programming language supports single-byte character strings, multibyte character strings, and wide-character strings. Single-byte and multibyte character strings are both described as null-terminated byte strings, which are also called narrow character strings.\n\nA pointer to a null-terminated byte string points to its initial character. The length of the string is the number of bytes preceding the null character, and the value of the string is the sequence of the values of the contained characters, in order.\n\nA wide string is a contiguous sequence of wide characters (of type wchar_t ) terminated by and including the first null wide character. A pointer to a wide string points to its initial (lowest addressed) wide character. The length of a wide string is the number of wide characters preceding the null wide character, and the value of a wide string is the sequence of code values of the contained wide characters, in order.\n\nwchar_t\n\nNull-terminated byte strings are implemented as arrays of characters and are susceptible to the same problems as arrays. As a result, rules and recommendations for arrays should also be applied to null-terminated byte strings.\n\nThe C Standard uses the following philosophy for choosing character types, though it is not explicitly stated in one place:\n\nsigned char and unsigned char\n\nsigned char\n\nunsigned char\n\nSuitable for small integer values\n\n\"Plain\" char\n\nchar\n\nThe type of each element of a string literal Used for character data from a limited character set (where signedness has little meaning) as opposed to integer data\n\nint\n\nint\n\nUsed for data that can be either EOF (a negative value) or character data interpreted as unsigned char and then converted to int . As a result, it is returned by fgetc() , getc() , getchar() , and ungetc() . Also, accepted by the character-handling functions from <ctype.h> because they might be passed the result of fgetc() , and so on The type of a character constant; its value is that of a plain char converted to int\n\nEOF\n\nunsigned char\n\nint\n\nfgetc()\n\ngetc()\n\ngetchar()\n\nungetc()\n\n<ctype.h>\n\nfgetc()\n\nchar\n\nint\n\nNote that the two different ways a character is used as an int (as an unsigned char + EOF or as a plain char converted to int ) can lead to confusion. For example, isspace('\\200') results in undefined behavior when char is signed.\n\nint\n\nunsigned char\n\nEOF\n\nchar\n\nint\n\nisspace('\\200')\n\nchar\n\nunsigned char\n\nunsigned char\n\nUsed internally for string comparison functions even though these functions operate on character data; consequently, the result of a string comparison does not depend on whether plain char is signed Used when the object being manipulated might be of any type, and it is necessary to access all bits of that object, as with fwrite()\n\nchar\n\nfwrite()\n\nUnlike other integer types, unsigned char has the unique property that\n\nunsigned char\n\nvalues stored in . . . objects of type unsigned char shall be represented using a pure binary notation (C Standard, subclause 6.2.6.1 [ ISO/IEC 9899:2011 ])\n\nunsigned char\n\nwhere a pure binary notation is defined as the following:\n\nA positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral powers of 2, except perhaps the bit with the highest position. A byte contains CHAR_BIT bits, and the values of type unsigned char range from 0 to 2 CHAR_BIT − 1. (subclause 6.2.6, footnote 49)\n\nCHAR_BIT\n\nunsigned char\n\nCHAR_BIT\n\nThat is, objects of type unsigned char may have no padding bits and consequently no trap representation . As a result, non-bit-field objects of any type may be copied into an array of unsigned char (for example, via memcpy() ) and have their representation examined one byte at a time.\n\nunsigned char\n\nunsigned char\n\nmemcpy()\n\nwchar_t\n\nwchar_t\n\nWide characters are used for natural-language character data",
    "examples": null,
    "risk_assessment": {
      "explanation": "Understanding how to represent characters and character strings can eliminate many common programming errors that lead to software vulnerabilities .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM30-C",
    "title": "Do not access freed memory",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152153",
    "description": "Evaluating a pointer—including dereferencing the pointer, using it as an operand of an arithmetic operation, type casting it, and using it as the right-hand side of an assignment—into memory that has been deallocated by a memory management function is undefined behavior 183 . Pointers to memory that has been deallocated are called dangling pointers . Accessing a dangling pointer can result in exploitable vulnerabilities .\n\nAccording to the C Standard, using the value of a pointer that refers to space deallocated by a call to the free() or realloc() function is undefined behavior. (See undefined behavior 183 .)\n\nfree()\n\nrealloc()\n\nReading a pointer to deallocated memory is undefined behavior 183 because the pointer value is indeterminate and might be a trap representation . Fetching a trap representation might perform a hardware trap (but is not required to).\n\nIt is at the memory manager's discretion when to reallocate or recycle the freed memory. When memory is freed, all pointers into it become invalid, and its contents might either be returned to the operating system, making the freed space inaccessible, or remain intact and accessible. As a result, the data at the freed location can appear to be valid but change unexpectedly. Consequently, memory must not be written to or read from once it is freed.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This example from Brian Kernighan and Dennis Ritchie [ Kernighan 1988 ] shows both the incorrect and correct techniques for freeing the memory associated with a linked list. In their (intentionally) incorrect example, p is freed before p->next is executed, so that p->next reads memory that has already been freed.",
          "code": "#include <stdlib.h>\n \nstruct node {\n  int value;\n  struct node *next;\n};\n \nvoid free_list(struct node *head) {\n  for (struct node *p = head; p != NULL; p = p->next) {\n    free(p);\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Kernighan and Ritchie correct this error by storing a reference to p->next in q before freeing p :",
          "code": "#include <stdlib.h>\n \nstruct node {\n  int value;\n  struct node *next;\n};\n \nvoid free_list(struct node *head) {\n  struct node *q;\n  for (struct node *p = head; p != NULL; p = q) {\n    q = p->next;\n    free(p);\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, buf is written to after it has been freed. Write-after-free vulnerabilities can be exploited to run arbitrary code with the permissions of the vulnerable process. Typically, allocations and frees are far removed, making it difficult to recognize and diagnose these problems.",
          "code": "#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n  char *return_val = 0;\n  const size_t bufsize = strlen(argv[0]) + 1;\n  char *buf = (char *)malloc(bufsize);\n  if (!buf) {\n    return EXIT_FAILURE;\n  }\n  /* ... */\n  free(buf);\n  /* ... */\n  strcpy(buf, argv[0]);\n  /* ... */\n  return EXIT_SUCCESS;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the memory is freed after its final use:",
          "code": "#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n  char *return_val = 0;\n  const size_t bufsize = strlen(argv[0]) + 1;\n  char *buf = (char *)malloc(bufsize);\n  if (!buf) {\n    return EXIT_FAILURE;\n  }\n  /* ... */\n  strcpy(buf, argv[0]);\n  /* ... */\n  free(buf);\n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, realloc() may free c_str1 when it returns a null pointer, resulting in c_str1 being freed twice.  The C Standards Committee's proposed response to Defect Report #400 makes it implementation-defined whether or not the old object is deallocated when size is zero and memory for the new object is not allocated. The current implementation of realloc() in the GNU C Library and Microsoft Visual Studio's Runtime Library will free c_str1 and return a null pointer for zero byte allocations.  Freeing a pointer twice can result in a potentially exploitable vulnerability commonly referred to as a double-free vulnerability [ Seacord 2013b ].",
          "code": "#include <stdlib.h>\n \nvoid f(char *c_str1, size_t size) {\n  char *c_str2 = (char *)realloc(c_str1, size);\n  if (c_str2 == NULL) {\n    free(c_str1);\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution does not pass a size argument of zero to the realloc() function, eliminating the possibility of c_str1 being freed twice:",
          "code": "#include <stdlib.h>\n \nvoid f(char *c_str1, size_t size) {\n  if (size != 0) {\n    char *c_str2 = (char *)realloc(c_str1, size); \n    if (c_str2 == NULL) {\n      free(c_str1); \n    }\n  }\n  else {\n    free(c_str1);\n  }\n \n}",
          "explanation_after": "If the intent of calling f() is to reduce the size of the object, then doing nothing when the size is zero would be unexpected; instead, this compliant solution frees the object."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example ( CVE-2009-1364 ) from libwmf version 0.2.8.4, the return value of gdRealloc (a simple wrapper around realloc() that reallocates space pointed to by im->clip->list ) is set to more . However, the value of im->clip->list is used directly afterwards in the code, and the C Standard specifies that if realloc() moves the area pointed to, then the original block is freed. An attacker can then execute arbitrary code by forcing a reallocation (with a sufficient im->clip->count ) and accessing freed memory [ xorl 2009 ].",
          "code": "void gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) {\n  gdClipRectanglePtr more;\n  if (im->clip == 0) {\n   /* ... */\n  }\n  if (im->clip->count == im->clip->max) {\n    more = gdRealloc (im->clip->list,(im->clip->max + 8) *\n                      sizeof (gdClipRectangle));\n    /*\n     * If the realloc fails, then we have not lost the\n     * im->clip->list value.\n     */\n    if (more == 0) return; \n    im->clip->max += 8;\n  }\n  im->clip->list[im->clip->count] = *rect;\n  im->clip->count++;\n\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution simply reassigns im->clip->list to the value of more after the call to realloc() :",
          "code": "void gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) {\n  gdClipRectanglePtr more;\n  if (im->clip == 0) {\n    /* ... */\n  }\n  if (im->clip->count == im->clip->max) {\n    more = gdRealloc (im->clip->list,(im->clip->max + 8) *\n                      sizeof (gdClipRectangle));\n    if (more == 0) return;\n    im->clip->max += 8;\n    im->clip->list = more;\n  }\n  im->clip->list[im->clip->count] = *rect;\n  im->clip->count++;\n\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Reading memory that has already been freed can lead to abnormal program termination and denial-of-service attacks. Writing memory that has already been freed can additionally lead to the execution of arbitrary code with the permissions of the vulnerable process.\n\nFreeing memory multiple times has similar consequences to accessing memory after it is freed. Reading a pointer to deallocated memory is undefined behavior 183 because the pointer value is indeterminate and might be a trap representation . When reading from or writing to freed memory does not cause a trap, it may corrupt the underlying data structures that manage the heap in a manner that can be exploited to execute arbitrary code. Alternatively, writing to memory after it has been freed might modify memory that has been reallocated.\n\nProgrammers should be wary when freeing memory in a loop or conditional statement; if coded incorrectly, these constructs can lead to double-free vulnerabilities. It is also a common error to misuse the realloc() function in a manner that results in double-free vulnerabilities. (See MEM04-C. Beware of zero-length allocations .)",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FLP30-C",
    "title": "Do not use floating-point variables as loop counters",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152157",
    "description": "Because floating-point numbers represent real numbers, it is often mistakenly assumed that they can represent any simple fraction exactly. Floating-point numbers are subject to representational limitations just as integers are, and binary floating-point numbers cannot represent all real numbers exactly, even if they can be represented in a small number of decimal digits.\n\nIn addition, because floating-point numbers can represent large values, it is often mistakenly assumed that they can represent all significant digits of those values. To gain a large dynamic range, floating-point numbers maintain a fixed number of precision bits (also called the significand) and an exponent, which limit the number of significant digits they can represent.\n\nDifferent implementations have different precision limitations, and to keep code portable, floating-point variables must not be used as the loop induction variable. See Goldberg's work for an introduction to this topic [ Goldberg 1991 ].\n\nFor the purpose of this rule, a loop counter is an induction variable that is used as an operand of a comparison expression that is used as the controlling expression of a do , while , or for loop. An induction variable is a variable that gets increased or decreased by a fixed amount on every iteration of a loop [ Aho 1986 ]. Furthermore, the change to the variable must occur directly in the loop body (rather than inside a function executed within the loop).\n\ndo\n\nwhile\n\nfor",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a floating-point variable is used as a loop counter. The decimal number 0.1 is a repeating fraction in binary and cannot be exactly represented as a binary floating-point number. Depending on the implementation, the loop may iterate 9 or 10 times.",
          "code": "void func(void) {\n  for (float x = 0.1f; x <= 1.0f; x += 0.1f) {\n    /* Loop may iterate 9 or 10 times */\n  }\n}",
          "explanation_after": "For example, when compiled with GCC or Microsoft Visual Studio 2013 and executed on an x86 processor, the loop is evaluated only nine times."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the loop counter is an integer from which the floating-point value is derived:",
          "code": "#include <stddef.h>\n \nvoid func(void) {\n  for (size_t count = 1; count <= 10; ++count) {\n    float x = count / 10.0f;\n    /* Loop iterates exactly 10 times */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, a floating-point loop counter is incremented by an amount that is too small to change its value given its precision:",
          "code": "void func(void) {\n  for (float x = 100000001.0f; x <= 100000010.0f; x += 1.0f) {\n    /* Loop may not terminate */\n  }\n}",
          "explanation_after": "On many implementations, this produces an infinite loop."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the loop counter is an integer from which the floating-point value is derived. The variable x is assigned a computed value to reduce compounded rounding errors that are present in the noncompliant code example.",
          "code": "void func(void) {\n  for (size_t count = 1; count <= 10; ++count) {\n    float x = 100000000.0f + (count * 1.0f);\n    /* Loop iterates exactly 10 times */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The use of floating-point variables as loop counters can result in unexpected behavior .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FIO11-C",
    "title": "Take care when specifying the mode parameter of fopen()",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152174",
    "description": "The C Standard identifies specific strings to use for the mode on calls to fopen() and fopen_s() . C11 provides a new mode flag, x , that provides the mechanism needed to determine if the file that is to be opened exists. To be strictly conforming and portable, one of the strings from the following table (adapted from the C Standard, subclause 7.21.5.2 [ ISO/IEC 9899:2011 ]) must be used:\n\nmode\n\nfopen()\n\nfopen_s()\n\nx\n\nStrings to Use for the Mode on Calls to fopen() and fopen_s()\n\nfopen()\n\nfopen_s()\n\nmode String Result r Open text file for reading w Truncate to zero length or create text file for writing wx Create text file for writing a Append; open or create text file for writing at end-of-file rb Open binary file for reading wb Truncate to zero length or create binary file for writing wbx Create binary file for writing ab Append; open or create binary file for writing at end-of-file r+ Open text file for update (reading and writing) w+ Truncate to zero length or create text file for update w+x Create text file for update a+ Append; open or create text file for update, writing at end-of-file r+b or rb+ Open binary file for update (reading and writing) w+b or wb+ Truncate to zero length or create binary file for update w+bx or wb+x Create binary file for update a+b or ab+ Append; open or create binary file for update, writing at end-of-file\n\nmode\n\nr\n\nw\n\nwx\n\na\n\nrb\n\nwb\n\nwbx\n\nab\n\nr+\n\nw+\n\nw+x\n\na+\n\nr+b\n\nrb+\n\nw+b\n\nwb+\n\nw+bx\n\nwb+x\n\na+b\n\nab+\n\nIf the mode string begins with one of these sequences, the implementation might choose to ignore the remaining characters, or it might use them to select different kinds of files.\n\nmode\n\nWhen calling fopen_s() , any of the mode strings used for writing ( w or a ) may be prefixed with the u character to give the file system default access permissions.\n\nfopen_s()\n\nw\n\na\n\nu\n\nAn implementation may define additional mode strings, but only the modes shown in the table are fully portable and C compliant. Beware that Microsoft Visual Studio 2012 and earlier do not support the x or u mode characters [ MSDN ].\n\nmode\n\nx\n\nu",
    "examples": null,
    "risk_assessment": {
      "explanation": "Using a mode string that is not recognized by an implementation may cause the call to fopen() to fail.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ENV33-C",
    "title": "Do not call system()",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177",
    "description": "The C Standard system() function executes a specified command by invoking an implementation-defined command processor, such as a UNIX shell or CMD.EXE in Microsoft Windows. The POSIX popen() and Windows _popen() functions also invoke a command processor but create a pipe between the calling program and the executed command, returning a pointer to a stream that can be used to either read from or write to the pipe [ IEEE Std 1003.1:2013 ].\n\nsystem()\n\nCMD.EXE\n\npopen()\n\n_popen()\n\nUse of the system() function can result in exploitable vulnerabilities , in the worst case allowing execution of arbitrary system commands. Situations in which calls to system() have high risk include the following:\n\nWhen passing an unsanitized or improperly sanitized command string originating from a tainted source If a command is specified without a path name and the command processor path name resolution mechanism is accessible to an attacker If a relative path to an executable is specified and control over the current working directory is accessible to an attacker If the specified executable program can be spoofed by an attacker\n\nDo not invoke a command processor via system() or equivalent functions to execute a command.\n\nsystem()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the system() function is used to execute any_cmd in the host environment.",
          "code": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nenum { BUFFERSIZE = 512 };\n\nvoid func(const char *input) {\n  char cmdbuf[BUFFERSIZE];\n  int len_wanted = snprintf(cmdbuf, BUFFERSIZE,\n                            \"any_cmd '%s'\", input);\n  if (len_wanted >= BUFFERSIZE) {\n    /* Handle error */\n  } else if (len_wanted < 0) {\n    /* Handle error */\n  } else if (system(cmdbuf) == -1) {\n    /* Handle error */\n  }\n}\n",
          "explanation_after": "If this code is compiled and run with elevated privileges on a Linux system, for example, an attacker can create an account by entering the following string:\n\nThe shell would interpret this string as two separate commands:\n\nand create a new user account that the attacker can use to access the compromised system.\n\nThis noncompliant code example also violates STR02-C. Sanitize data passed to complex subsystems ."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "In this compliant solution, the call to system() is replaced with a call to execve() . The exec family of functions does not use a full shell interpreter, so it is not vulnerable to command-injection attacks, such as the one illustrated in the noncompliant code example.\n\nThe execlp() , execvp() , and (nonstandard) execvP() functions duplicate the actions of the shell in searching for an executable file if the specified file name does not contain a forward slash character ( / ). As a result, they should be used without a forward slash character ( / ) only if the PATH environment variable is set to a safe value, as described in ENV03-C. Sanitize the environment when invoking external programs .\n\nThe execl() , execle() , execv() , and execve() functions do not perform path name substitution.\n\nAdditionally, precautions should be taken to ensure the external executable cannot be modified by an untrusted user, for example, by ensuring the executable is not writable by the user.",
          "code": "#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n \nvoid func(char *input) {\n  pid_t pid;\n  int status;\n  pid_t ret;\n  char *const args[3] = {\"any_exe\", input, NULL};\n  char **env;\n  extern char **environ;\n\n  /* ... Sanitize arguments ... */\n\n  pid = fork();\n  if (pid == -1) {\n    /* Handle error */\n  } else if (pid != 0) {\n    while ((ret = waitpid(pid, &status, 0)) == -1) {\n      if (errno != EINTR) {\n        /* Handle error */\n        break;\n      }\n    }\n    if ((ret == 0) ||\n        !(WIFEXITED(status) && !WEXITSTATUS(status))) {\n      /* Report unexpected child status */\n    }\n  } else {\n    /* ... Initialize env as a sanitized copy of environ ... */\n    if (execve(\"/usr/bin/any_cmd\", args, env) == -1) {\n      /* Handle error */\n      _Exit(127);\n    }\n  }\n}\n",
          "explanation_after": "This compliant solution is significantly different from the preceding noncompliant code example. First, input is incorporated into the args array and passed as an argument to execve() , eliminating concerns about buffer overflow or string truncation while forming the command string. Second, this compliant solution forks a new process before executing \"/usr/bin/any_cmd\" in the child process. Although this method is more complicated than calling system() , the added security is worth the additional effort.\n\nThe exit status of 127 is the value set by the shell when a command is not found, and POSIX recommends that applications should do the same. XCU, Section 2.8.2, of Standard for Information Technology—Portable Operating System Interface (POSIX®), Base Specifications, Issue 7 [ IEEE Std 1003.1:2013 ], says\n\nIf a command is not found, the exit status shall be 127. If the command name is found, but it is not an executable utility, the exit status shall be 126. Applications that invoke utilities without using the shell should use these exit status values to report similar errors."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the system() function is used to execute any_cmd in the host environment.",
          "code": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nenum { BUFFERSIZE = 512 };\n\nvoid func(const char *input) {\n  char cmdbuf[BUFFERSIZE];\n  int len_wanted = snprintf(cmdbuf, BUFFERSIZE,\n                            \"any_cmd '%s'\", input);\n  if (len_wanted >= BUFFERSIZE) {\n    /* Handle error */\n  } else if (len_wanted < 0) {\n    /* Handle error */\n  } else if (system(cmdbuf) == -1) {\n    /* Handle error */\n  }\n}\n",
          "explanation_after": "If this code is compiled and run with elevated privileges on a Linux system, for example, an attacker can create an account by entering the following string:\n\nThe shell would interpret this string as two separate commands:\n\nand create a new user account that the attacker can use to access the compromised system.\n\nThis noncompliant code example also violates STR02-C. Sanitize data passed to complex subsystems ."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "This compliant solution uses the Microsoft Windows CreateProcess() API:",
          "code": "#include <Windows.h>\n\nvoid func(TCHAR *input) {\n  STARTUPINFO si = { 0 };\n  PROCESS_INFORMATION pi;\n  si.cb = sizeof(si);\n  if (!CreateProcess(TEXT(\"any_cmd.exe\"), input, NULL, NULL, FALSE,\n                     0, 0, 0, &si, &pi)) {\n    /* Handle error */\n  }\n  CloseHandle(pi.hThread);\n  CloseHandle(pi.hProcess);\n}",
          "explanation_after": "This compliant solution relies on the input parameter being non- const . If it were const , the solution would need to create a copy of the parameter because the CreateProcess() function can modify the command-line arguments to be passed into the newly created process.\n\nThis solution creates the process such that the child process does not inherit any handles from the parent process, in compliance with WIN03-C. Understand HANDLE inheritance ."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "This noncompliant code invokes the C system() function to remove the .config file in the user's home directory.",
          "code": "#include <stdlib.h>\n \nvoid func(void) {\n  system(\"rm ~/.config\");\n}\n",
          "explanation_after": "If the vulnerable program has elevated privileges, an attacker can manipulate the value of the HOME environment variable such that this program can remove any file named .config anywhere on the system."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "An alternative to invoking the system() call to execute an external program to perform a required operation is to implement the functionality directly in the program using existing library calls. This compliant solution calls the POSIX unlink() function to remove a file without invoking the system() function [ IEEE Std 1003.1:2013 ]",
          "code": "#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\nvoid func(void) {\n  const char *file_format = \"%s/.config\";\n  size_t len;\n  char *pathname;\n  struct passwd *pwd;\n\n  /* Get /etc/passwd entry for current user */\n  pwd = getpwuid(getuid());\n  if (pwd == NULL) {\n    /* Handle error */\n  }\n\n  /* Build full path name home dir from pw entry */\n\n  len = strlen(pwd->pw_dir) + strlen(file_format) + 1;\n  pathname = (char *)malloc(len);\n  if (NULL == pathname) {\n    /* Handle error */\n  }\n  int r = snprintf(pathname, len, file_format, pwd->pw_dir);\n  if (r < 0 || r >= len) {\n    /* Handle error */\n  }\n  if (unlink(pathname) != 0) {\n    /* Handle error */\n  }\n\n  free(pathname);\n}\n",
          "explanation_after": "The unlink() function is not susceptible to a symlink attack where the final component of pathname (the file name) is a symbolic link because unlink() will remove the symbolic link and not affect any file or directory named by the contents of the symbolic link. (See FIO01-C. Be careful using functions that use file names for identification .)  While this reduces the susceptibility of the unlink() function to symlink attacks, it does not eliminate it.  The unlink() function is still susceptible if one of the directory names included in the pathname is a symbolic link.  This could cause the unlink() function to delete a similarly named file in a different directory."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "This noncompliant code invokes the C system() function to remove the .config file in the user's home directory.",
          "code": "#include <stdlib.h>\n \nvoid func(void) {\n  system(\"rm ~/.config\");\n}\n",
          "explanation_after": "If the vulnerable program has elevated privileges, an attacker can manipulate the value of the HOME environment variable such that this program can remove any file named .config anywhere on the system."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "This compliant solution uses the Microsoft Windows SHGetKnownFolderPath() API to get the current user's My Documents folder, which is then combined with the file name to create the path to the file to be deleted. The file is then removed using the DeleteFile() API.",
          "code": "#include <Windows.h>\n#include <ShlObj.h>\n#include <Shlwapi.h>\n \n#if defined(_MSC_VER)\n  #pragma comment(lib, \"Shlwapi\")\n#endif\n\nvoid func(void) {\n  HRESULT hr;\n  LPWSTR path = 0;\n  WCHAR full_path[MAX_PATH];\n\n  hr = SHGetKnownFolderPath(&FOLDERID_Documents, 0, NULL, &path);\n  if (FAILED(hr)) {\n    /* Handle error */\n  }\n  if (!PathCombineW(full_path, path, L\".config\")) {\n    /* Handle error */\n  }\n  CoTaskMemFree(path);\n  if (!DeleteFileW(full_path)) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": null,
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "SIG30-C",
    "title": "Call only asynchronous-safe functions within signal handlers",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152178",
    "description": "Call only asynchronous-safe functions within signal handlers. For strictly conforming programs, only the C standard library functions abort() , _Exit() , quick_exit() , and signal() can be safely called from within a signal handler.\n\nabort()\n\n_Exit()\n\nquick_exit()\n\nsignal()\n\nThe C Standard, 7.14.1.1, paragraph 5 [ ISO/IEC 9899:2024 ], states that if the signal occurs other than as the result of calling the abort() or raise() function, the behavior is undefined if\n\nabort()\n\nraise()\n\nIf the signal occurs other than as the result of calling the abort or raise function, the behavior is undefined if the signal handler refers to any object with static or thread storage duration that is not a lock-free atomic object and that is not declared with the constexpr storage-class specifier other than by assigning a value to an object declared as volatile sig _ atomic _ t , or the signal handler calls any function in the standard library other than —  the abort function, —  the _ Exit function, —  the quick _ exit function, —  the functions in <stdatomic.h> (except where explicitly stated otherwise) when the atomic arguments are lock-free, —  the atomic _ is _ lock _ free function with any atomic argument, or —  the signal function with the first argument equal to the signal number corresponding to the signal that caused the invocation of the handler. Furthermore, if such a call to the signal function results in a SIG _ ERR return, the object designated by errno has an indeterminate representation. 294)\n\nImplementations may define a list of additional asynchronous-safe functions. These functions can also be called within a signal handler. This restriction applies to library functions as well as application-defined functions.\n\nAccording to the C Rationale, 7.14.1.1 [ C99 Rationale 2003 ],\n\nWhen a signal occurs, the normal flow of control of a program is interrupted. If a signal occurs that is being trapped by a signal handler, that handler is invoked. When it is finished, execution continues at the point at which the signal occurred. This arrangement can cause problems if the signal handler invokes a library function that was being executed at the time of the signal.\n\nIn general, it is not safe to invoke I/O functions from within signal handlers. Programmers should ensure a function is included in the list of an implementation's asynchronous-safe functions for all implementations the code will run on before using them in signal handlers.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant example, the C standard library functions fputs() and free() are called from the signal handler via the function log_message() . Neither function is asynchronous-safe .",
          "code": "#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nenum { MAXLINE = 1024 };\nchar *info = NULL;\n\nvoid log_message(void) {\n  fputs(info, stderr);\n}\n\nvoid handler(int signum) {\n  log_message();\n  free(info);\n  info = NULL;\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  info = (char *)malloc(MAXLINE);\n  if (info == NULL) {\n    /* Handle Error */\n  }\n\n  while (1) {\n    /* Main loop program code */\n\n    log_message();\n\n    /* More program code */\n  }\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Signal handlers should be as concise as possible—ideally by unconditionally setting a flag and returning. This compliant solution sets a flag of type volatile sig_atomic_t and returns; the log_message() and free() functions are called directly from main() :",
          "code": "#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nenum { MAXLINE = 1024 };\nvolatile sig_atomic_t eflag = 0;\nchar *info = NULL;\n\nvoid log_message(void) {\n  fputs(info, stderr);\n}\n\nvoid handler(int signum) {\n  eflag = 1;\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  info = (char *)malloc(MAXLINE);\n  if (info == NULL) {\n    /* Handle error */\n  }\n\n  while (!eflag) {\n    /* Main loop program code */\n\n    log_message();\n\n    /* More program code */\n  }\n\n  log_message();\n  free(info);\n  info = NULL;\n\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( longjmp() )",
          "pre_code_commentary": "Invoking the longjmp() function from within a signal handler can lead to undefined behavior 132 if it results in the invocation of any non- asynchronous-safe functions. Consequently, neither longjmp() nor the POSIX siglongjmp() functions should ever be called from within a signal handler.\n\nThis noncompliant code example is similar to a vulnerability in an old version of Sendmail [ VU #834865 ]. The intent is to execute code in a main() loop, which also logs some data. Upon receiving a SIGINT , the program transfers out of the loop, logs the error, and terminates.\n\nHowever, an attacker can exploit this noncompliant code example by generating a SIGINT just before the second if statement in log_message() . The result is that longjmp() transfers control back to main() , where log_message() is called again. However, the first if statement would not be executed this time (because buf is not set to NULL as a result of the interrupt), and the program would write to the invalid memory location referenced by buf0 .",
          "code": "#include <setjmp.h>\n#include <signal.h>\n#include <stdlib.h>\n\nenum { MAXLINE = 1024 };\nstatic jmp_buf env;\n\nvoid handler(int signum) {\n  longjmp(env, 1);\n}\n\nvoid log_message(char *info1, char *info2) {\n  static char *buf = NULL;\n  static size_t bufsize;\n  char buf0[MAXLINE];\n\n  if (buf == NULL) {\n    buf = buf0;\n    bufsize = sizeof(buf0);\n  }\n\n  /*\n   * Try to fit a message into buf, else reallocate\n   * it on the heap and then log the message.\n   */\n\n  /* Program is vulnerable if SIGINT is raised here */\n\n  if (buf == buf0) {\n    buf = NULL;\n  }\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  char *info1;\n  char *info2;\n\n  /* info1 and info2 are set by user input here */\n\n  if (setjmp(env) == 0) {\n    while (1) {\n      /* Main loop program code */\n      log_message(info1, info2);\n      /* More program code */\n    }\n  } else {\n    log_message(info1, info2);\n  }\n\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the call to longjmp() is removed; the signal handler sets an error flag instead:",
          "code": "#include <signal.h>\n#include <stdlib.h>\n\nenum { MAXLINE = 1024 };\nvolatile sig_atomic_t eflag = 0;\n\nvoid handler(int signum) {\n  eflag = 1;\n}\n\nvoid log_message(char *info1, char *info2) {\n  static char *buf = NULL;\n  static size_t bufsize;\n  char buf0[MAXLINE];\n\n  if (buf == NULL) {\n    buf = buf0;\n    bufsize = sizeof(buf0);\n  }\n\n  /*\n   * Try to fit a message into buf, else reallocate\n   * it on the heap and then log the message.\n   */\n  if (buf == buf0) {\n    buf = NULL;\n  }\n}\n\nint main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  char *info1;\n  char *info2;\n\n  /* info1 and info2 are set by user input here */\n\n  while (!eflag) {\n    /* Main loop program code */\n    log_message(info1, info2);\n    /* More program code */\n  }\n\n  log_message(info1, info2);\n\n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( raise() )",
          "pre_code_commentary": "In this noncompliant code example, the int_handler() function is used to carry out tasks specific to SIGINT and then raises SIGTERM . However, there is a nested call to the raise() function, which is undefined behavior 131 .",
          "code": "#include <signal.h>\n#include <stdlib.h>\n \nvoid term_handler(int signum) {\n  /* SIGTERM handler */\n}\n \nvoid int_handler(int signum) {\n  /* SIGINT handler */\n  if (raise(SIGTERM) != 0) {\n    /* Handle error */\n  }\n}\n \nint main(void) {\n  if (signal(SIGTERM, term_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  if (signal(SIGINT, int_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n \n  /* Program code */\n  if (raise(SIGINT) != 0) {\n    /* Handle error */\n  }\n  /* More code */\n \n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, int_handler() invokes term_handler() instead of raising SIGTERM :",
          "code": "#include <signal.h>\n#include <stdlib.h>\n \nvoid term_handler(int signum) {\n  /* SIGTERM handler */\n}\n \nvoid int_handler(int signum) {\n  /* SIGINT handler */\n  /* Pass control to the SIGTERM handler */\n  term_handler(SIGTERM);\n}\n \nint main(void) {\n  if (signal(SIGTERM, term_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  if (signal(SIGINT, int_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n \n  /* Program code */\n  if (raise(SIGINT) != 0) {\n    /* Handle error */\n  }\n  /* More code */\n \n  return EXIT_SUCCESS;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Invoking functions that are not asynchronous-safe from within a signal handler is undefined behavior 132 .",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "SIG00-C",
    "title": "Mask signals handled by noninterruptible signal handlers",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152179",
    "description": "A signal is a mechanism for transferring control that is typically used to notify a process that an event has occurred. That process can then respond to the event accordingly. The C Standard provides functions for sending and handling signals within a C program.\n\nProcesses handle signals by registering a signal handler using the signal() function, which is specified as\n\nsignal()\n\nvoid (*signal(int sig, void (*func)(int)))(int);\n\nvoid (*signal(int sig, void (*func)(int)))(int);\n\nThis signal handler is conceptually equivalent to\n\ntypedef void (*sighandler_t)(int signum);\nextern sighandler_t signal(\n  int signum, \n  sighandler_t handler\n);\n\ntypedef void (*sighandler_t)(int signum);\nextern sighandler_t signal(\n  int signum, \n  sighandler_t handler\n);\n\nSignal handlers can be interrupted by signals, including their own. If a signal is not reset before its handler is called, the handler can interrupt its own execution. A handler that always successfully executes its code despite interrupting itself or being interrupted is async-signal-safe .\n\nSome platforms provide the ability to mask signals while a signal handler is being processed. If a signal is masked while its own handler is processed, the handler is noninterruptible and need not be async-signal-safe. However, even when a signal is masked while its own handler is processed, the handler must still avoid invoking async-signal-safe unsafe functions because their execution may be (or have been) interrupted by another signal.\n\nVulnerabilities can arise if a signal handler that is not async-signal-safe is interrupted with any unmasked signal, including its own.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example registers a single signal handler to process both SIGUSR1 and SIGUSR2 . The variable sig2 should be set to 1 if one or more SIGUSR1 signals are followed by SIGUSR2 , essentially implementing a finite state machine within the signal handler.",
          "code": "#include <signal.h>\n\nvolatile sig_atomic_t sig1 = 0;\nvolatile sig_atomic_t sig2 = 0;\n\nvoid handler(int signum) {\n  if (signum == SIGUSR1) {\n    sig1 = 1;\n  }\n  else if (sig1) {\n    sig2 = 1;\n  }\n}\n\nint main(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  if (signal(SIGUSR2, handler) == SIG_ERR) {\n    /* Handler error */\n  }\n\n  while (sig2 == 0) {\n    /* Do nothing or give up CPU for a while */\n  }\n\n  /* ... */\n\n  return 0;\n}\n",
          "explanation_after": "Unfortunately, a race condition occurs in the implementation of handler() . If handler() is called to handle SIGUSR1 and is interrupted to handle SIGUSR2 , it is possible that sig2 will not be set."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "The POSIX sigaction() function assigns handlers to signals in a similar manner to the C signal() function, but it also allows signal masks to be set explicitly. Consequently, sigaction() can be used to prevent a signal handler from interrupting itself.",
          "code": "#include <signal.h>\n#include <stdio.h>\n\nvolatile sig_atomic_t sig1 = 0;\nvolatile sig_atomic_t sig2 = 0;\n\nvoid handler(int signum) {\n  if (signum == SIGUSR1) {\n    sig1 = 1;\n  }\n  else if (sig1) {\n    sig2 = 1;\n  }\n}\n\nint main(void) {\n  struct sigaction act;\n  act.sa_handler = &handler;\n  act.sa_flags = 0;\n  if (sigemptyset(&act.sa_mask) != 0) {\n    /* Handle error */\n  }\n  if (sigaddset(&act.sa_mask, SIGUSR1)) {\n    /* Handle error */\n  }\n  if (sigaddset(&act.sa_mask, SIGUSR2)) {\n    /* Handle error */\n  }\n\n  if (sigaction(SIGUSR1, &act, NULL) != 0) {\n    /* Handle error */\n  }\n  if (sigaction(SIGUSR2, &act, NULL) != 0) {\n    /* Handle error */\n  }\n\n  while (sig2 == 0) {\n    /* Do nothing or give up CPU for a while */\n  }\n\n  /* ... */\n\n  return 0;\n}\n",
          "explanation_after": "POSIX recommends sigaction() and deprecates the use of signal() to register signal handlers. Unfortunately, sigaction() is not defined in the C Standard and is consequently not as portable a solution."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Interrupting a noninterruptible signal handler can result in a variety of vulnerabilities [ Zalewski 2001 ].",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FIO30-C",
    "title": "Exclude user input from format strings",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152197",
    "description": "Never call a formatted I/O function with a format string containing a tainted value .  An attacker who can fully or partially control the contents of a format string can crash a vulnerable process, view the contents of the stack, view memory content, or write to an arbitrary memory location. Consequently, the attacker can execute arbitrary code with the permissions of the vulnerable process [ Seacord 2013b ]. Formatted output functions are particularly dangerous because many programmers are unaware of their capabilities. For example, formatted output functions can be used to write an integer value to a specified address using the %n conversion specifier.\n\n%n",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The incorrect_password() function in this noncompliant code example is called during identification and authentication to display an error message if the specified user is not found or the password is incorrect. The function accepts the name of the user as a string referenced by user . This is an exemplar of untrusted data that originates from an unauthenticated user. The function constructs an error message that is then output to stderr using the C Standard fprintf() function.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  fprintf(stderr, msg);\n  free(msg);\n}\n",
          "explanation_after": "The incorrect_password() function calculates the size of the message, allocates dynamic storage, and then constructs the message in the allocated memory using the snprintf() function. The addition operations are not checked for integer overflow because the string referenced by user is known to have a length of 256 or less. Because the %s characters are replaced by the string referenced by user in the call to snprintf() , the resulting string needs 1 byte less than is allocated. The snprintf() function is commonly used for messages that are displayed in multiple locations or messages that are difficult to build. However, the resulting code contains a format-string vulnerability because the msg includes untrusted user input and is passed as the format-string argument in the call to fprintf() ."
        },
        "compliant": {
          "heading": "Compliant Solution ( fputs() )",
          "pre_code_commentary": "This compliant solution fixes the problem by replacing the fprintf() call with a call to fputs() , which outputs msg directly to stderr without evaluating its contents:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  fputs(msg, stderr);\n  free(msg);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The incorrect_password() function in this noncompliant code example is called during identification and authentication to display an error message if the specified user is not found or the password is incorrect. The function accepts the name of the user as a string referenced by user . This is an exemplar of untrusted data that originates from an unauthenticated user. The function constructs an error message that is then output to stderr using the C Standard fprintf() function.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nvoid incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  fprintf(stderr, msg);\n  free(msg);\n}\n",
          "explanation_after": "The incorrect_password() function calculates the size of the message, allocates dynamic storage, and then constructs the message in the allocated memory using the snprintf() function. The addition operations are not checked for integer overflow because the string referenced by user is known to have a length of 256 or less. Because the %s characters are replaced by the string referenced by user in the call to snprintf() , the resulting string needs 1 byte less than is allocated. The snprintf() function is commonly used for messages that are displayed in multiple locations or messages that are difficult to build. However, the resulting code contains a format-string vulnerability because the msg includes untrusted user input and is passed as the format-string argument in the call to fprintf() ."
        },
        "compliant": {
          "heading": "Compliant Solution ( fprintf() )",
          "pre_code_commentary": "This compliant solution passes the untrusted user input as one of the variadic arguments to fprintf() and not as part of the format string, eliminating the possibility of a format-string vulnerability:",
          "code": "#include <stdio.h>\n \nvoid incorrect_password(const char *user) {\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  fprintf(stderr, msg_format, user);\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "This noncompliant code example is similar to the first noncompliant code example but uses the POSIX function syslog() [ IEEE Std 1003.1:2013 ] instead of the fprintf() function. The syslog() function is also susceptible to format-string vulnerabilities.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n \nvoid incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  syslog(LOG_INFO, msg);\n  free(msg);\n}\n",
          "explanation_after": "The syslog() function first appeared in BSD 4.2 and is supported by Linux and other modern UNIX implementations. It is not available on Windows systems."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution passes the untrusted user input as one of the variadic arguments to syslog() instead of including it in the format string:",
          "code": "#include <syslog.h>\n \nvoid incorrect_password(const char *user) {\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  syslog(LOG_INFO, msg_format, user);\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to exclude user input from format specifiers may allow an attacker to crash a vulnerable process, view the contents of the stack, view memory content, or write to an arbitrary memory location and consequently execute arbitrary code with the permissions of the vulnerable process.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "EXP30-C",
    "title": "Do not depend on the order of evaluation for side effects",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152202",
    "description": "Evaluation of an expression may produce side effects . At specific points during execution, known as sequence points , all side effects of previous evaluations are complete, and no side effects of subsequent evaluations have yet taken place. Do not depend on the order of evaluation for side effects unless there is an intervening sequence point.\n\nThe C Standard, 6.5, paragraph 2 [ ISO/IEC 9899:2024 ], states\n\nIf a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.\n\nThis requirement must be met for each allowable ordering of the subexpressions of a full expression; otherwise, the behavior is undefined . (See undefined behavior 34 .)\n\nThe following sequence points are defined in the C Standard, Annex C [ ISO/IEC 9899:2011 ]:\n\nBetween the evaluations of the function designator and actual arguments in a function call and the actual call Between the evaluations of the first and second operands of the following operators: Logical AND: && Logical OR: || Comma: , Between the evaluations of the first operand of the conditional ?: operator and whichever of the second and third operands is evaluated The end of a full declarator Between the evaluation of a full expression and the next full expression to be evaluated; the following are full expressions: An initializer that is not part of a compound literal The expression in an expression statement The controlling expression of a selection statement ( if or switch ) The controlling expression of a while or do statement Each of the (optional) expressions of a for statement The (optional) expression in a return statement Immediately before a library function returns After the actions associated with each formatted input/output function conversion specifier Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call\n\n&&\n\n||\n\n,\n\n?:\n\nif \n\nswitch\n\nwhile\n\ndo\n\nfor\n\nreturn\n\nFurthermore, Section 6.5.17.1, paragraph 3 [ ISO/IEC 9899:2024 ] says (regarding assignment operations):\n\nThe side effect of updating the stored value of the left operand is sequenced after the value computations of the left and right operands.\n\nThis rule means that statements such as\n\ni = i + 1;\na[i] = i;\n\ni = i + 1;\na[i] = i;\n\nhave defined behavior, and statements such as the following do not:\n\n/* i is modified twice between sequence points */\ni = ++i + 1;  \n\n/* i is read other than to determine the value to be stored */\na[i++] = i;\n\n/* i is modified twice between sequence points */\ni = ++i + 1;  \n\n/* i is read other than to determine the value to be stored */\na[i++] = i;   \n\nNot all instances of a comma in C code denote a usage of the comma operator. For example, the comma between arguments in a function call is not a sequence point. However, according to the C Standard, 6.5.3.3, paragraph 8 [ ISO/IEC 9899:2024 ]\n\nEvery evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function.\n\nThis rule means that the order of evaluation for function call arguments is unspecified and can happen in any order.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Programs cannot safely rely on the order of evaluation of operands between sequence points. In this noncompliant code example, i is evaluated twice without an intervening sequence point, so the behavior of the expression is undefined :",
          "code": "#include <stdio.h>\n\nvoid func(int i, int *b) {\n  int a = i + b[++i];\n  printf(\"%d, %d\", a, i);\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "These examples are independent of the order of evaluation of the operands and can be interpreted in only one way:",
          "code": "#include <stdio.h>\n\nvoid func(int i, int *b) {\n  int a;\n  ++i;\n  a = i + b[i];\n  printf(\"%d, %d\", a, i);\n}",
          "explanation_after": "Alternatively:"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The call to func() in this noncompliant code example has undefined behavior 34 because there is no sequence point between the argument expressions:",
          "code": "extern void func(int i, int j);\n \nvoid f(int i) {\n  func(i++, i);\n}",
          "explanation_after": "The first (left) argument expression reads the value of i (to determine the value to be stored) and then modifies i . The second (right) argument expression reads the value of i between the same pair of sequence points as the first argument, but not to determine the value to be stored in i . This additional attempt to read the value of i has undefined behavior 34 ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution is appropriate when the programmer intends for both arguments to func() to be equivalent:",
          "code": "extern void func(int i, int j);\n \nvoid f(int i) {\n  i++;\n  func(i, i);\n}",
          "explanation_after": "This compliant solution is appropriate when the programmer intends for the second argument to be 1 greater than the first:"
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The order of evaluation for function arguments is unspecified. This noncompliant code example exhibits unspecified behavior but not undefined behavior :",
          "code": "extern void c(int i, int j);\nint glob;\n \nint a(void) {\n  return glob + 10;\n}\n\nint b(void) {\n  glob = 42;\n  return glob;\n}\n \nvoid func(void) {\n  c(a(), b());\n}",
          "explanation_after": "It is unspecified what order a() and b() are called in; the only guarantee is that both a() and b() will be called before c() is called. If a() or b() rely on shared state when calculating their return value, as they do in this example, the resulting arguments passed to c() may differ between compilers or architectures."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the order of evaluation for a() and b() is fixed, and so no unspecified behavior occurs:",
          "code": "extern void c(int i, int j);\nint glob;\n \nint a(void) {\n  return glob + 10;\n}\nint b(void) {\n  glob = 42;\n  return glob;\n}\n \nvoid func(void) {\n  int a_val, b_val;\n \n  a_val = a();\n  b_val = b();\n\n  c(a_val, b_val);\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Attempting to modify an object multiple times between sequence points may cause that object to take on an unexpected value, which can lead to unexpected program behavior .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P8",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "EXP00-C",
    "title": "Use parentheses for precedence of operation",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152225",
    "description": "C programmers commonly make errors regarding the precedence rules of C operators because of the unintuitive low-precedence levels of & , | , ^ , << , and >> . Mistakes regarding precedence rules can be avoided by the suitable use of parentheses. Using parentheses defensively reduces errors and, if not taken to excess, makes the code more readable.\n\n&\n\n|\n\n^\n\n<<\n\n>>\n\nSubclause 6.5 of the C Standard defines the precedence of operation by the order of the subclauses.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The intent of the expression in this noncompliant code example is to test the least significant bit of x :",
          "code": "x & 1 == 0\n",
          "explanation_after": "Because of operator precedence rules, the expression is parsed as\n\nwhich evaluates to\n\nand then to 0 ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, parentheses are used to ensure the expression evaluates as expected:",
          "code": "(x & 1) == 0\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Mistakes regarding precedence rules may cause an expression to be evaluated in an unintended way, which can lead to unexpected and abnormal program behavior.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FIO17-C",
    "title": "Do not rely on an ending null character when using fread()",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152233",
    "description": "The fread() function, as defined in the C Standard, subclause 7.21.8.1 [ ISO/IEC 9899:2011 ], does not explicitly null-terminate the read character sequence.\n\nfread()\n\nSynopsis size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream) Description The fread function reads, into the array pointed to by ptr , up to nmemb elements whose size is specified by size , from the stream pointed to by stream .\n\nsize_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream)\n\nfread\n\nptr\n\nnmemb\n\nsize\n\nstream\n\nAlthough the content of a file has a properly null-terminated character sequence, if nmemb is less than the total length of the characters, the fread() function will not read after nmemb characters. fread() will not append a null character to the end of the string being read to.\n\nnmemb\n\nfread()\n\nnmemb\n\nfread()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Suppose we have a null-terminated character sequence in a file, and we need to extract a null-terminated byte string:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main (void) {\n\n    FILE *fp;\n    size_t size;\n    long length;\n    char *buffer;\n\n    fp = fopen(\"file.txt\", \"rb\");\n\n    if (fp == NULL) {\n      /* Handle file open error */\n    }\n\n    /* Obtain file size */\n    if (fseek(fp, 0, SEEK_END) != 0) {\n      /* Handle repositioning error */\n    }\n\n    length = ftell(fp);\n\n    if (fseek(fp, 0L, SEEK_SET) != 0) {\n      /* Handle repositioning error */\n    }\n\n    /* Allocate memory to contain whole file */\n    buffer = (char*) malloc(length);\n    if (buffer == NULL) {\n      /* Handle memory allocation error */\n    }\n    \n    /* size assigned here in some other code */\n\n    if (fread(buffer, 1, size, fp) < size) {\n      /* Handle file read error */\n    }\n    fclose(fp);\n\n    return 0;\n}\n",
          "explanation_after": "When size is less than the total length of the file ( file.txt ), buffer is not properly null-terminated."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "To correct this example, the size of buffer must be compared with the total length of the file to identify the erroneous case where size differs from length . At this point, it is up to the programmer to handle this case.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main (void) {\n\n    FILE *fp;\n    size_t size;\n    long length;\n    char *buffer;\n\n    fp = fopen(\"file.txt\", \"rb\");\n\n    if (fp == NULL) {\n      /* Handle file open error */\n    }\n\n    /* Obtain file size */\n    if (fseek(fp, 0, SEEK_END) != 0) {\n      /* Handle repositioning error */\n    }\n    length = ftell(fp);\n\n    if (fseek(fp, 0L, SEEK_SET) != 0) {\n      /* Handle repositioning error */\n    }\n\n    /* Allocate memory to contain whole file */\n    buffer = (char*) malloc(length);\n    if (buffer == NULL) {\n      /* Handle memory allocation error */\n    }\n\n    /* ... Assign size here ... */\n    if (length != size) {\n      /* Handle case when size isn't the length of file */\n    }\n    /* ... Other code ... */\n\n    if (fread(buffer, 1, size, fp) < size) {\n      /* Handle file read error */\n    }\n\n    fclose(fp);\n\n    return 0;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "When reading an input stream, the read character sequence is not explicitly null-terminated by the fread() function. Operations on the read-to buffer could result in overruns, causing abnormal program termination .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "INT30-C",
    "title": "Ensure that unsigned integer operations do not wrap",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152236",
    "description": "The C Standard, 6.2.5, paragraph 11 [ ISO/IEC 9899:2024 ], states\n\nA computation involving unsigned operands can never produce an overflow, because arithmetic for the unsigned type is performed modulo 2^ N .\n\nThis behavior is more informally called unsigned integer wrapping . Unsigned integer operations can wrap if the resulting value cannot be represented by the underlying representation of the integer. The following table indicates which operators can result in wrapping:\n\nOperator Wrap Operator Wrap Operator Wrap Operator Wrap + Yes -= Yes << Yes < No - Yes *= Yes >> No > No * Yes /= No & No >= No / No %= No | No <= No % No <<= Yes ^ No == No ++ Yes >>= No ~ No != No -- Yes &= No ! No && No = No |= No un + No || No += Yes ^= No un - Yes ?: No\n\n+\n\n-=\n\n<<\n\n<\n\n-\n\n*=\n\n>>\n\n>\n\n*\n\n/=\n\n&\n\n>=\n\n/\n\n%=\n\n|\n\n<=\n\n%\n\n<<=\n\n^\n\n==\n\n++\n\n>>=\n\n~\n\n!=\n\n--\n\n&=\n\n!\n\n&&\n\n=\n\n|=\n\nun +\n\n||\n\n+=\n\n^=\n\nun -\n\n?:\n\nThe following sections examine specific operations that are susceptible to unsigned integer wrap. When operating on integer types with less precision than int , integer promotions are applied. The usual arithmetic conversions may also be applied to (implicitly) convert operands to equivalent types before arithmetic operations are performed. Programmers should understand integer conversion rules before trying to implement secure arithmetic operations. (See INT02-C. Understand integer conversion rules .)\n\nint\n\nInteger values must not be allowed to wrap, especially if they are used in any of the following ways:\n\nInteger operands of any pointer arithmetic, including array indexing The assignment expression for the declaration of a variable length array The postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object Function arguments of type size_t or rsize_t (for example, an argument to a memory allocation function) In security-critical code\n\n[]\n\n[]\n\nsize_t\n\nrsize_t\n\nThe C Standard defines arithmetic on atomic integer types as read-modify-write operations with the same representation as regular integer types. As a result, wrapping of atomic unsigned integers is identical to regular unsigned integers and should also be prevented or detected.",
    "examples": null,
    "risk_assessment": {
      "explanation": "Integer wrap can lead to buffer overflows and the execution of arbitrary code by an attacker. Note that this rule is not automatically repairable in contrast to INT32-C. Ensure that operations on signed integers do not result in overflow . This is because integer wrapping is occasionally intended (see INT30-C-EX1 ), and repairing such wrapping would turn correct code into code that spuriously signals wraparound errors.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "DCL16-C",
    "title": "Use \"L,\" not \"l,\" to indicate a long value",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152241",
    "description": "Lowercase letter l (ell) can easily be confused with the digit 1 (one). This can be particularly confusing when indicating that an integer literal constant is a long value. This recommendation is similar to DCL02-C. Use visually distinct identifiers . Likewise, you should use uppercase LL rather than lowercase ll when indicating that an integer literal constant is a long long value.\n\nlong long\n\nTo be precise when using modifiers to indicate the type of an integer literal, the first character may not be l .  It may be L , u , or U . Subsequent characters have no strict case requirements.\n\nl\n\nL\n\nu\n\nU",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant example highlights the result of adding an integer and a long value even though it appears that two integers 1111 are being added:",
          "code": "\tprintf(\"Sum is %ld\\n\", 1111 + 111l);\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The compliant solution improvises by using an uppercase L instead of lowercase l to disambiguate the visual appearance:",
          "code": "\tprintf(\"Sum is %ld\\n\", 1111 + 111L);\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Confusing a lowercase letter l (ell) with a digit 1 (one) when indicating that an integer denotation is a long value could lead to an incorrect value being written into code.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MEM36-C",
    "title": "Do not modify the alignment of objects by calling realloc()",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152255",
    "description": "Do not invoke realloc() to modify the size of allocated objects that have stricter alignment requirements than those guaranteed by malloc() . Storage allocated by a call to the standard aligned_alloc() function, for example, can have stricter than normal alignment requirements. The C standard requires only that a pointer returned by realloc() be suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement.\n\nrealloc()\n\nmalloc()\n\naligned_alloc()\n\nrealloc()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example returns a pointer to allocated memory that has been aligned to a 4096-byte boundary.  If the resize argument to the realloc() function is larger than the object referenced by ptr , then realloc() will allocate new memory that is suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement but may not preserve the stricter alignment of the original object.",
          "code": "#include <stdlib.h>\n \nvoid func(void) {\n  size_t resize = 1024;\n  size_t alignment = 1 << 12;\n  int *ptr;\n  int *ptr1;\n  \n  if (NULL == (ptr = (int *)aligned_alloc(alignment, sizeof(int)))) {\n    /* Handle error */\n  }\n\n  if (NULL == (ptr1 = (int *)realloc(ptr, resize))) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "When compiled with GCC 4.1.2 and run on the x86_64 Red Hat Linux platform, the following code produces the following output:\n\nptr1 is no longer aligned to 4096 bytes."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution  allocates resize bytes of new memory with the same alignment as the old memory, copies the original memory content, and then frees the old memory. This solution has implementation-defined behavior because it depends on whether extended alignments in excess of _Alignof (max_align_t) are supported and the contexts in which they are supported. If not supported, the behavior of this compliant solution is undefined.",
          "code": "#include <stdlib.h>\n#include <string.h>\n \nvoid func(void) {\n  size_t resize = 1024;\n  size_t alignment = 1 << 12;\n  int *ptr;\n  int *ptr1;\n\n  if (NULL == (ptr = (int *)aligned_alloc(alignment,\n                                          sizeof(int)))) {\n    /* Handle error */\n  }\n\n  if (NULL == (ptr1 = (int *)aligned_alloc(alignment,\n                                           resize))) {\n    /* Handle error */\n  }\n  \n  if (NULL == memcpy(ptr1, ptr, sizeof(int))) {\n    /* Handle error */\n  }\n  \n  free(ptr);\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example returns a pointer to allocated memory that has been aligned to a 4096-byte boundary.  If the resize argument to the realloc() function is larger than the object referenced by ptr , then realloc() will allocate new memory that is suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental alignment requirement but may not preserve the stricter alignment of the original object.",
          "code": "#include <stdlib.h>\n \nvoid func(void) {\n  size_t resize = 1024;\n  size_t alignment = 1 << 12;\n  int *ptr;\n  int *ptr1;\n  \n  if (NULL == (ptr = (int *)aligned_alloc(alignment, sizeof(int)))) {\n    /* Handle error */\n  }\n\n  if (NULL == (ptr1 = (int *)realloc(ptr, resize))) {\n    /* Handle error */\n  }\n}",
          "explanation_after": "When compiled with GCC 4.1.2 and run on the x86_64 Red Hat Linux platform, the following code produces the following output:\n\nptr1 is no longer aligned to 4096 bytes."
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "Windows defines the _aligned_malloc() function to allocate memory on a specified alignment boundary.  The _aligned_realloc() [ MSDN ] can be used to change the size of this memory. This compliant solution demonstrates one such usage:",
          "code": "#include <malloc.h>\n\nvoid func(void) {\n  size_t alignment = 1 << 12;\n  int *ptr;\n  int *ptr1;\n\n  /* Original allocation */\n  if (NULL == (ptr = (int *)_aligned_malloc(sizeof(int),\n                                            alignment))) {\n    /* Handle error */\n}\n\n  /* Reallocation */\n  if (NULL == (ptr1 = (int *)_aligned_realloc(ptr, 1024,\n                                              alignment))) {\n    _aligned_free(ptr);\n    /* Handle error */\n  }\n\n  _aligned_free(ptr1);\n}",
          "explanation_after": "The size and alignment arguments for _aligned_malloc() are provided in reverse order of the C Standard aligned_alloc() function."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Improper alignment can lead to arbitrary memory locations being accessed and written to.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON30-C",
    "title": "Clean up thread-specific storage",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152258",
    "description": "The tss_create() function creates a thread-specific storage pointer identified by a key. Threads can allocate thread-specific storage and associate the storage with a key that uniquely identifies the storage by calling the tss_set() function. If not properly freed, this memory may be leaked. Ensure that thread-specific storage is freed.\n\ntss_create()\n\ntss_set()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, each thread dynamically allocates storage in the get_data() function, which is then associated with the global key by the call to tss_set() in the add_data() function. This memory is subsequently leaked when the threads terminate.",
          "code": "#include <threads.h>\n#include <stdlib.h>\n\n/* Global key to the thread-specific storage */\ntss_t key;\nenum { MAX_THREADS = 3 };\n\nint *get_data(void) {\n  int *arr = (int *)malloc(2 * sizeof(int));\n  if (arr == NULL) {\n    return arr;  /* Report error  */\n  }\n  arr[0] = 10;\n  arr[1] = 42;\n  return arr;\n}\n\nint add_data(void) {\n  int *data = get_data();\n  if (data == NULL) {\n    return -1;\t/* Report error */\n  }\n\n  if (thrd_success != tss_set(key, (void *)data)) {\n    /* Handle error */\n  }\n  return 0;\n}\n\nvoid print_data(void) {\n  /* Get this thread's global data from key */\n  int *data = tss_get(key);\n\n  if (data != NULL) {\n    /* Print data */\n  } \n}\n\nint function(void *dummy) {\n  if (add_data() != 0) {\n    return -1;\t/* Report error */\n  }\n  print_data();\n  return 0;\n}\n\nint main(void) {\n  thrd_t thread_id[MAX_THREADS];\n\n  /* Create the key before creating the threads */\n  if (thrd_success != tss_create(&key, NULL)) {\n    /* Handle error */\n  }\n\n  /* Create threads that would store specific storage */\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {\n      /* Handle error */\n    }\n  }\n\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_join(thread_id[i], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  tss_delete(key);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, each thread explicitly frees the thread-specific storage returned by the tss_get() function before terminating:",
          "code": "#include <threads.h>\n#include <stdlib.h>\n \n/* Global key to the thread-specific storage */\ntss_t key;\n \nint function(void *dummy) {\n  if (add_data() != 0) {\n    return -1;\t/* Report error */\n  }\n  print_data();\n  free(tss_get(key));\n  return 0;\n}\n\n/* ... Other functions are unchanged */\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, each thread dynamically allocates storage in the get_data() function, which is then associated with the global key by the call to tss_set() in the add_data() function. This memory is subsequently leaked when the threads terminate.",
          "code": "#include <threads.h>\n#include <stdlib.h>\n\n/* Global key to the thread-specific storage */\ntss_t key;\nenum { MAX_THREADS = 3 };\n\nint *get_data(void) {\n  int *arr = (int *)malloc(2 * sizeof(int));\n  if (arr == NULL) {\n    return arr;  /* Report error  */\n  }\n  arr[0] = 10;\n  arr[1] = 42;\n  return arr;\n}\n\nint add_data(void) {\n  int *data = get_data();\n  if (data == NULL) {\n    return -1;\t/* Report error */\n  }\n\n  if (thrd_success != tss_set(key, (void *)data)) {\n    /* Handle error */\n  }\n  return 0;\n}\n\nvoid print_data(void) {\n  /* Get this thread's global data from key */\n  int *data = tss_get(key);\n\n  if (data != NULL) {\n    /* Print data */\n  } \n}\n\nint function(void *dummy) {\n  if (add_data() != 0) {\n    return -1;\t/* Report error */\n  }\n  print_data();\n  return 0;\n}\n\nint main(void) {\n  thrd_t thread_id[MAX_THREADS];\n\n  /* Create the key before creating the threads */\n  if (thrd_success != tss_create(&key, NULL)) {\n    /* Handle error */\n  }\n\n  /* Create threads that would store specific storage */\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {\n      /* Handle error */\n    }\n  }\n\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_join(thread_id[i], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  tss_delete(key);\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution invokes a destructor function registered during the call to tss_create() to automatically free any thread-specific storage:",
          "code": "#include <threads.h>\n#include <stdlib.h>\n\n/* Global key to the thread-specific storage */\ntss_t key;\nenum { MAX_THREADS = 3 };\n\n/* ... Other functions are unchanged */\n\nvoid destructor(void *data) {\n  free(data);\n}\n \nint main(void) {\n  thrd_t thread_id[MAX_THREADS];\n\n  /* Create the key before creating the threads */\n  if (thrd_success != tss_create(&key, destructor)) {\n    /* Handle error */\n  }\n\n  /* Create threads that would store specific storage */\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {\n      /* Handle error */\n    }\n  }\n\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_join(thread_id[i], NULL)) {\n      /* Handle error */\n    }\n  }\n\n  tss_delete(key);\n  return 0;\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to free thread-specific objects results in memory leaks and could result in a denial-of-service attack .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ERR06-C",
    "title": "Understand the termination behavior of assert() and abort()",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152296",
    "description": "The C Standard, subclause 7.2.1.1 [ ISO/IEC 9899:2011 ], defines assert() to have the following behavior:\n\nassert()\n\nThe assert macro puts diagnostic tests into programs; it expands to a void expression. When it is executed, if expression (which shall have a scalar type) is false (that is, compares equal to 0), the assert macro writes information about the particular call that failed (including the text of the argument, the name of the source file, the source line number, and the name of the enclosing function—the latter are respectively the values of the pre-processing macros __ FILE_ _ and __ LINE_ _ and of the identifier __ func_ _) on the standard error stream in an implementation-defined format. It then calls the abort function.\n\nassert\n\nexpression\n\nassert\n\n__\nFILE_\n_\n\n__\nLINE_\n_\n\n__\nfunc_\n_)\n\nabort\n\nBecause assert() calls abort() , cleanup functions registered with atexit() are not called. If the intention of the programmer is to properly clean up in the case of a failed assertion, then runtime assertions should be replaced with static assertions where possible. (See DCL03-C. Use a static assertion to test the value of a constant expression .) When the assertion is based on runtime data, the assert should be replaced with a runtime check that implements the adopted error strategy (see ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy ).\n\nassert()\n\nabort()\n\natexit()\n\nassert\n\nSee ERR04-C. Choose an appropriate termination strategy for more information on program termination strategies and MSC11-C. Incorporate diagnostic tests using assertions for more information on using the assert() macro.\n\nassert()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example defines a function that is called before the program exits to clean up:",
          "code": "void cleanup(void) {\n  /* Delete temporary files, restore consistent state, etc. */\n}\n\nint main(void) {\n  if (atexit(cleanup) != 0) {\n    /* Handle error */\n  }\n\n  /* ... */\n\n  assert(/* Something bad didn't happen */);\n\n  /* ... */\n}\n",
          "explanation_after": "However, the code also has an assert , and if the assertion fails, the cleanup() function is not called."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the call to assert() is replaced with an if statement that calls exit() to ensure that the proper termination routines are run:",
          "code": "void cleanup(void) {\n  /* Delete temporary files, restore consistent state, etc. */\n}\n\nint main(void) {\n  if (atexit(cleanup) != 0) {\n    /* Handle error */\n  }\n\n  /* ... */\n\n  if (/* Something bad happened */) {\n    exit(EXIT_FAILURE);\n  }\n\n  /* ... */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Unsafe use of abort() may leave files written in an inconsistent state. It may also leave sensitive temporary files on the file system.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "CON01-C",
    "title": "Acquire and release synchronization primitives in the same module, at the same level of abstraction",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152303",
    "description": "All locking and unlocking of mutexes should be performed in the same module and at the same level of abstraction. Failure to follow this recommendation can lead to some lock or unlock operations not being executed by the multithreaded program as designed, eventually resulting in deadlock, race conditions, or other security vulnerabilities , depending on the mutex type.\n\nA common consequence of improper locking is for a mutex to be unlocked twice, via two calls to mtx_unlock() . This can cause the unlock operation to return errors. In the case of recursive mutexes, an error is returned only if the lock count is 0 (making the mutex available to other threads) and a call to mtx_unlock() is made.\n\n mtx_unlock()\n\nmtx_unlock()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example for a simplified multithreaded banking system, imagine an account with a required minimum balance. The code would need to verify that all debit transactions are allowable. Suppose a call is made to debit() asking to withdraw funds that would bring account_balance below MIN_BALANCE , which would result in two calls to mtx_unlock() . In this example, because the mutex is defined statically, the mutex type is implementation-defined .",
          "code": "#include <threads.h>\n\nenum { MIN_BALANCE = 50 };\n\nint account_balance;\nmtx_t mp;\n\n/* Initialize mp */\n\nint verify_balance(int amount) {\n  if (account_balance - amount < MIN_BALANCE) {\n    /* Handle error condition */\n    if (mtx_unlock(&mp) ==  thrd_error) {\n      /* Handle error */\n    }\n    return -1;\n  }\n  return 0;\n}\n\nvoid debit(int amount) {\n  if (mtx_lock(&mp) == thrd_error) {\n    /* Handle error */\n  }\n  if (verify_balance(amount) == -1) {\n    if (mtx_unlock(&mp) == thrd_error) {\n      /* Handle error */\n    }\n    return;\n  }\n  account_balance -= amount;\n  if (mtx_unlock(&mp) == thrd_error) {\n    /* Handle error */\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution unlocks the mutex only in the same module and at the same level of abstraction at which it is locked. This technique ensures that the code will not attempt to unlock the mutex twice.",
          "code": "#include <threads.h>\n\nenum { MIN_BALANCE = 50 };\n\nstatic int account_balance;\nstatic mtx_t mp;\n\n/* Initialize mp */\n\nstatic int verify_balance(int amount) {\n  if (account_balance - amount < MIN_BALANCE) {\n    return -1;   /* Indicate error to caller */\n  }\n\n  return 0;  /* Indicate success to caller */\n}\n\nint debit(int amount) {\n  if (mtx_lock(&mp) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n\n  if (verify_balance(amount)) {\n    mtx_unlock(&mp);\n    return -1;   /* Indicate error to caller */\n  }\n\n  account_balance -= amount;\n\n  if (mtx_unlock(&mp) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n\n  return 0;   /* Indicate success */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Improper use of mutexes can result in denial-of-service attacks or the unexpected termination of a multithreaded program.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FLP00-C",
    "title": "Understand the limitations of floating-point numbers",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152310",
    "description": "The C programming language provides the ability to use floating-point numbers for calculations. The C Standard specifies requirements on a conforming implementation for floating-point numbers but makes few guarantees about the specific underlying floating-point representation because of the existence of competing floating-point systems.\n\nBy definition, a floating-point number is of finite precision and, regardless of the underlying implementation, is prone to errors associated with rounding. (See FLP01-C. Take care in rearranging floating-point expressions and FLP02-C. Avoid using floating-point numbers when precise computation is needed .)\n\nThe most common floating-point system is specified by the IEEE 754 standard. An older floating-point system is the IBM floating-point representation (sometimes called IBM/370). Each of these systems has different precisions and ranges of representable values. As a result, they do not represent all of the same values, are not binary compatible, and have different associated error rates.\n\nBecause of a lack of guarantees on the specifics of the underlying floating-point system, no assumptions can be made about either precision or range. Even if code is not intended to be portable, the chosen compiler's behavior must be well understood at all compiler optimization levels.\n\nHere is a simple illustration of precision limitations. The following code prints the decimal representation of 1/3 to 50 decimal places. Ideally, it would print 50 numeral 3s:\n\n#include <stdio.h>\n\nint main(void) {\n  float f = 1.0f / 3.0f;\n  printf(\"Float is %.50f\\n\", f);\n  return 0;\n}\n\n#include <stdio.h>\n\nint main(void) {\n  float f = 1.0f / 3.0f;\n  printf(\"Float is %.50f\\n\", f);\n  return 0;\n}\n\nOn 64-bit Linux, with GCC 4.1, it produces\n\nFloat is 0.33333334326744079589843750000000000000000000000000\n\nFloat is 0.33333334326744079589843750000000000000000000000000\n\nOn 64-bit Windows, with Microsoft Visual Studio 2012, it produces\n\nFloat is 0.33333334326744080000000000000000000000000000000000\n\nFloat is 0.33333334326744080000000000000000000000000000000000\n\nAdditionally, compilers may treat floating-point variables differently under different levels of optimization [ Gough 2005 ]:\n\ndouble a = 3.0;\ndouble b = 7.0;\ndouble c = a / b;\n\nif (c == a / b) {\n  printf(\"Comparison succeeds\\n\");\n} else {\n  printf(\"Unexpected result\\n\");\n}\n\ndouble a = 3.0;\ndouble b = 7.0;\ndouble c = a / b;\n\nif (c == a / b) {\n  printf(\"Comparison succeeds\\n\");\n} else {\n  printf(\"Unexpected result\\n\");\n}\n\nWhen compiled on an IA-32 Linux machine with GCC 3.4.4 at optimization level 1 or higher, or on an IA-64 Windows machine with Microsoft Visual Studio 2012 in Debug or Release mode, this code prints\n\nComparison succeeds\n\nComparison succeeds\n\nOn an IA-32 Linux machine with GCC 3.4.4 with optimization turned off, this code prints\n\nUnexpected result\n\nUnexpected result\n\nThe reason for this behavior is that Linux uses the internal extended precision mode of the x87 floating-point unit (FPU) on IA-32 machines for increased accuracy during computation. When the result is stored into memory by the assignment to c , the FPU automatically rounds the result to fit into a double . The value read back from memory now compares unequally to the internal representation, which has extended precision. Windows does not use the extended precision mode, so all computation is done with double precision, and there are no differences in precision between values stored in memory and those internal to the FPU. For GCC, compiling at optimization level 1 or higher eliminates the unnecessary store into memory, so all computation happens within the FPU with extended precision [ Gough 2005 ].\n\nc\n\ndouble\n\nThe standard constant __FLT_EPSILON__ can be used to evaluate if two floating-point values are close enough to be considered equivalent given the granularity of floating-point operations for a given implementation. __FLT_EPSILON__ represents the difference between 1 and the least value greater than 1 that is representable as a float. The granularity of a floating-point operation is determined by multiplying the operand with the larger absolute value by __FLT_EPSILON__ .\n\n__FLT_EPSILON__\n\n__FLT_EPSILON__\n\n__FLT_EPSILON__\n\n#include <math.h>\nfloat RelDif(float a, float b) {\n  float c = fabsf(a);\n  float d = fabsf(b);\n\n  d = fmaxf(c, d);\n\n  return d == 0.0f ? 0.0f : fabsf(a - b) / d;\n}\n\n/* ... */\n\nfloat a = 3.0f;\nfloat b = 7.0f;\nfloat c = a / b;\n\nif (RelDif(c, a / b) <= __FLT_EPSILON__) {\n  puts(\"Comparison succeeds\");\n} else {\n  puts(\"Unexpected result\");\n}\n\n#include <math.h>\nfloat RelDif(float a, float b) {\n  float c = fabsf(a);\n  float d = fabsf(b);\n\n  d = fmaxf(c, d);\n\n  return d == 0.0f ? 0.0f : fabsf(a - b) / d;\n}\n\n/* ... */\n\nfloat a = 3.0f;\nfloat b = 7.0f;\nfloat c = a / b;\n\nif (RelDif(c, a / b) <= __FLT_EPSILON__) {\n  puts(\"Comparison succeeds\");\n} else {\n  puts(\"Unexpected result\");\n}\n\nOn all tested platforms, this code prints\n\nComparison succeeds\n\nComparison succeeds\n\nFor double precision and long double precision floating-point values, use a similar approach using the __DBL_EPSILON__ and __LDBL_EPSILON__ constants, respectively.\n\ndouble\n\nlong double\n\n__DBL_EPSILON__\n\n__LDBL_EPSILON__\n\nConsider using numerical analysis to properly understand the numerical properties of the problem.",
    "examples": null,
    "risk_assessment": {
      "explanation": "Failing to understand the limitations of floating-point numbers can result in unexpected computational results and exceptional conditions, possibly resulting in a violation of data integrity.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ARR30-C",
    "title": "Do not form or use out-of-bounds pointers or array subscripts",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152322",
    "description": "The C Standard identifies the following distinct situations in which undefined behavior (UB) can arise as a result of invalid pointer operations:\n\nUB Description Example Code 43 Addition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that does not point into, or just beyond, the same array object. Forming Out-of-Bounds Pointer , Null Pointer Arithmetic 44 Addition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that points just beyond the array object and is used as the operand of a unary * operator that is evaluated. Dereferencing Past the End Pointer , Using Past the End Index 46 An array subscript is out of range, even if an object is apparently accessible with the given subscript, for example, in the lvalue expression a[1][7] given the declaration int a[4][5] ). Apparently Accessible Out-of-Range Index 59 An attempt is made to access, or generate a pointer to just past, a flexible array member of a structure when the referenced object provides no elements for that array. Pointer Past Flexible Array Member\n\n*\n\na[1][7]\n\nint a[4][5]",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Forming Out-of-Bounds Pointer)",
          "pre_code_commentary": "In this noncompliant code example, the function f() attempts to validate the index before using it as an offset to the statically allocated table of integers. However, the function fails to reject negative index values. When index is less than zero, the behavior of the addition expression in the return statement of the function is undefined behavior 43 . On some implementations, the addition alone can trigger a hardware trap. On other implementations, the addition may produce a result that when dereferenced triggers a hardware trap. Other implementations still may produce a dereferenceable pointer that points to an object distinct from table . Using such a pointer to access the object may lead to information exposure or cause the wrong object to be modified.",
          "code": "enum { TABLESIZE = 100 };\n\nstatic int table[TABLESIZE];\n\nint *f(int index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "One compliant solution is to detect and reject invalid values of index if using them in pointer arithmetic would result in an invalid pointer:",
          "code": "enum { TABLESIZE = 100 };\n\nstatic int table[TABLESIZE];\n\nint *f(int index) {\n  if (index >= 0 && index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Forming Out-of-Bounds Pointer)",
          "pre_code_commentary": "In this noncompliant code example, the function f() attempts to validate the index before using it as an offset to the statically allocated table of integers. However, the function fails to reject negative index values. When index is less than zero, the behavior of the addition expression in the return statement of the function is undefined behavior 43 . On some implementations, the addition alone can trigger a hardware trap. On other implementations, the addition may produce a result that when dereferenced triggers a hardware trap. Other implementations still may produce a dereferenceable pointer that points to an object distinct from table . Using such a pointer to access the object may lead to information exposure or cause the wrong object to be modified.",
          "code": "enum { TABLESIZE = 100 };\n\nstatic int table[TABLESIZE];\n\nint *f(int index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Another slightly simpler and potentially more efficient compliant solution is to use an unsigned type to avoid having to check for negative values while still rejecting out-of-bounds positive values of index :",
          "code": "#include <stddef.h>\n \nenum { TABLESIZE = 100 };\n\nstatic int table[TABLESIZE];\n\nint *f(size_t index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Dereferencing Past-the-End Pointer)",
          "pre_code_commentary": "This noncompliant code example shows the flawed logic in the Windows Distributed Component Object Model (DCOM) Remote Procedure Call (RPC) interface that was exploited by the W32.Blaster.Worm. The error is that the while loop in the GetMachineName() function (used to extract the host name from a longer string) is not sufficiently bounded. When the character array pointed to by pwszTemp does not contain the backslash character among the first MAX_COMPUTERNAME_LENGTH_FQDN + 1 elements, the final valid iteration of the loop will dereference past the end pointer, resulting in exploitable undefined behavior 44 . In this case, the actual exploit allowed the attacker to inject executable code into a running program. Economic damage from the Blaster worm has been estimated to be at least $525 million [ Pethia 2003 ].\n\nFor a discussion of this programming error in the Common Weakness Enumeration database, see CWE-119 , \"Improper Restriction of Operations within the Bounds of a Memory Buffer,\" and CWE-121 , \"Stack-based Buffer Overflow\" [ MITRE 2013 ].",
          "code": "error_status_t _RemoteActivation(\n      /* ... */, WCHAR *pwszObjectName, ... ) {\n   *phr = GetServerPath(\n              pwszObjectName, &pwszObjectName);\n    /* ... */\n}\n\nHRESULT GetServerPath(\n  WCHAR *pwszPath, WCHAR **pwszServerPath ){\n  WCHAR *pwszFinalPath = pwszPath;\n  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1];\n  hr = GetMachineName(pwszPath, wszMachineName);\n  *pwszServerPath = pwszFinalPath;\n}\n\nHRESULT GetMachineName(\n  WCHAR *pwszPath,\n  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])\n{\n  pwszServerName = wszMachineName;\n  LPWSTR pwszTemp = pwszPath + 2;\n  while (*pwszTemp != L'\\\\')\n    *pwszServerName++ = *pwszTemp++;\n  /* ... */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the while loop in the GetMachineName() function is bounded so that the loop terminates when a backslash character is found, the null-termination character ( L'\\0' ) is discovered, or the end of the buffer is reached. Or, as coded, the while loop continues as long as each character is neither a backslash nor a null character and is not at the end of the buffer. This code does not result in a buffer overflow even if no backslash character is found in wszMachineName .",
          "code": "HRESULT GetMachineName(\n  wchar_t *pwszPath,\n  wchar_t wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])\n{\n  wchar_t *pwszServerName = wszMachineName;\n  wchar_t *pwszTemp = pwszPath + 2;\n  wchar_t *end_addr\n    = pwszServerName + MAX_COMPUTERNAME_LENGTH_FQDN;\n  while ((*pwszTemp != L'\\\\') &&\n         (*pwszTemp != L'\\0') &&\n         (pwszServerName < end_addr))\n  {\n    *pwszServerName++ = *pwszTemp++;\n  }\n\n  /* ... */\n}\n",
          "explanation_after": "This compliant solution is for illustrative purposes and is not necessarily the solution implemented by Microsoft. This particular solution may not be correct because there is no guarantee that a backslash is found."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Using Past-the-End Index)",
          "pre_code_commentary": "Similar to the dereferencing-past-the-end-pointer error, the function insert_in_table() in this noncompliant code example uses an otherwise valid index to attempt to store a value in an element just past the end of an array.\n\nFirst, the function incorrectly validates the index pos against the size of the buffer. When pos is initially equal to size , the function attempts to store value in a memory location just past the end of the buffer.\n\nSecond, when the index is greater than size , the function modifies size before growing the size of the buffer. If the call to realloc() fails to increase the size of the buffer, the next call to the function with a value of pos equal to or greater than the original value of size will again attempt to store value in a memory location just past the end of the buffer or beyond.\n\nThird, the function violates INT30-C. Ensure that unsigned integer operations do not wrap , which could lead to wrapping when 1 is added to pos or when size is multiplied by the size of int .\n\nFor a discussion of this programming error in the Common Weakness Enumeration database, see CWE-122 , \"Heap-based Buffer Overflow,\" and CWE-129 , \"Improper Validation of Array Index\" [ MITRE 2013 ].",
          "code": "#include <stdlib.h>\n \nstatic int *table = NULL;\nstatic size_t size = 0;\n\nint insert_in_table(size_t pos, int value) {\n  if (size < pos) {\n    int *tmp;\n    size = pos + 1;\n    tmp = (int *)realloc(table, sizeof(*table) * size);\n    if (tmp == NULL) {\n      return -1;   /* Failure */\n    }\n    table = tmp;\n  }\n\n  table[pos] = value;\n  return 0;\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution correctly validates the index pos by using the <= relational operator, ensures the multiplication will not overflow, and avoids modifying size until it has verified that the call to realloc() was successful:",
          "code": "#include <stdint.h>\n#include <stdlib.h>\n \nstatic int *table = NULL;\nstatic size_t size = 0;\n\nint insert_in_table(size_t pos, int value) {\n  if (size <= pos) {\n    if ((SIZE_MAX - 1 < pos) ||\n        ((pos + 1) > SIZE_MAX / sizeof(*table))) {\n      return -1;\n    }\n \n    int *tmp = (int *)realloc(table, sizeof(*table) * (pos + 1));\n    if (tmp == NULL) {\n      return -1;\n    }\n    /* Modify size only after realloc() succeeds */\n    size  = pos + 1;\n    table = tmp;\n  }\n\n  table[pos] = value;\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Apparently Accessible Out-of-Range Index)",
          "pre_code_commentary": "This noncompliant code example declares matrix to consist of 7 rows and 5 columns in row-major order. The function init_matrix iterates over all 35 elements in an attempt to initialize each to the value given by the function argument x . However, because multidimensional arrays are declared in C in row-major order, the function iterates over the elements in column-major order, and when the value of j reaches the value COLS during the first iteration of the outer loop, the function attempts to access element matrix[0][5] . Because the type of matrix is int[7][5] , the j subscript is out of range, and the access has undefined behavior 46 .",
          "code": "#include <stddef.h>\n#define COLS 5\n#define ROWS 7\nstatic int matrix[ROWS][COLS];\n\nvoid init_matrix(int x) {\n  for (size_t i = 0; i < COLS; i++) {\n    for (size_t j = 0; j < ROWS; j++) {\n      matrix[i][j] = x;\n    }\n  }\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution avoids using out-of-range indices by initializing matrix elements in the same row-major order as multidimensional objects are declared in C:",
          "code": "#include <stddef.h>\n#define COLS 5\n#define ROWS 7\nstatic int matrix[ROWS][COLS];\n\nvoid init_matrix(int x) {\n  for (size_t i = 0; i < ROWS; i++) {\n    for (size_t j = 0; j < COLS; j++) {\n      matrix[i][j] = x;\n    }\n  }\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Pointer Past Flexible Array Member)",
          "pre_code_commentary": "In this noncompliant code example, the function find() attempts to iterate over the elements of the flexible array member buf , starting with the second element. However, because function g() does not allocate any storage for the member, the expression first++ in find() attempts to form a pointer just past the end of buf when there are no elements. This attempt is undefined behavior 59 . (See MSC21-C. Use robust loop termination conditions for more information.)",
          "code": "#include <stdlib.h>\n \nstruct S {\n  size_t len;\n  char buf[];  /* Flexible array member */\n};\n\nconst char *find(const struct S *s, int c) {\n  const char *first = s->buf;\n  const char *last  = s->buf + s->len;\n\n  while (first++ != last) { /* Undefined behavior */\n    if (*first == c) {\n      return first;\n    }\n  }\n  return NULL;\n}\n \nvoid g(void) {\n  struct S *s = (struct S *)malloc(sizeof(struct S));\n  if (s == NULL) {\n    /* Handle error */\n  }\n  s->len = 0;\n  find(s, 'a');\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution avoids incrementing the pointer unless a value past the pointer's current value is known to exist:",
          "code": "#include <stdlib.h>\n \nstruct S {\n  size_t len;\n  char buf[];  /* Flexible array member */\n};\n\nconst char *find(const struct S *s, int c) {\n  const char *first = s->buf;\n  const char *last  = s->buf + s->len;\n\n  while (first != last) { /* Avoid incrementing here */\n    if (*++first == c) {\n      return first;\n    }\n  }\n  return NULL;\n}\n \nvoid g(void) {\n  struct S *s = (struct S *)malloc(sizeof(struct S));\n  if (s == NULL) {\n    /* Handle error */\n  }\n  s->len = 0;\n  find(s, 'a');\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Null Pointer Arithmetic)",
          "pre_code_commentary": "This noncompliant code example is similar to an Adobe Flash Player vulnerability that was first exploited in 2008. This code allocates a block of memory and initializes it with some data. The data does not belong at the beginning of the block, which is left uninitialized. Instead, it is placed offset bytes within the block. The function ensures that the data fits within the allocated block.",
          "code": "#include <string.h>\n#include <stdlib.h>\n\nchar *init_block(size_t block_size, size_t offset,\n                 char *data, size_t data_size) {\n  char *buffer = malloc(block_size);\n  if (data_size > block_size || block_size - data_size < offset) {\n    /* Data won't fit in buffer, handle error */\n  }\n  memcpy(buffer + offset, data, data_size);\n  return buffer;\n}",
          "explanation_after": "This function fails to check if the allocation succeeds, which is a violation of ERR33-C. Detect and handle standard library errors . If the allocation fails, then malloc() returns a null pointer. The null pointer is added to offset and passed as the destination argument to memcpy() . Because a null pointer does not point to a valid object, the result of the pointer arithmetic is undefined behavior 43 .\n\nAn attacker who can supply the arguments to this function can exploit it to execute arbitrary code. This can be accomplished by providing an overly large value for block_size , which causes malloc() to fail and return a null pointer. The offset argument will then serve as the destination address to the call to memcpy() . The attacker can specify the data and data_size arguments to provide the address and length of the address, respectively, that the attacker wishes to write into the memory referenced by offset . The overall result is that the call to memcpy() can be exploited by an attacker to overwrite an arbitrary memory location with an attacker-supplied address, typically resulting in arbitrary code execution."
        },
        "compliant": {
          "heading": "Compliant Solution  (Null Pointer Arithmetic)",
          "pre_code_commentary": "This compliant solution ensures that the call to malloc() succeeds:",
          "code": "#include <string.h>\n#include <stdlib.h>\n\nchar *init_block(size_t block_size, size_t offset,\n                 char *data, size_t data_size) {\n  char *buffer = malloc(block_size);\n  if (NULL == buffer) {\n    /* Handle error */\n  }\n  if (data_size > block_size || block_size - data_size < offset) {\n    /* Data won't fit in buffer, handle error */\n  }\n  memcpy(buffer + offset, data, data_size);\n  return buffer;\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Writing to out-of-range pointers or array subscripts can result in a buffer overflow and the execution of arbitrary code with the permissions of the vulnerable process. Reading from out-of-range pointers or array subscripts can result in unintended information disclosure.",
      "metrics": {
        "severity": "High",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P9",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "ERR00-C",
    "title": "Adopt and implement a consistent and comprehensive error-handling policy",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152349",
    "description": "A secure system is invariably subject to stresses, such as those caused by attack, erroneous or malicious inputs, hardware or software faults, unanticipated user behavior, and unexpected environmental changes that are outside the bounds of \"normal operation.\" Yet the system must continue to deliver essential services in a timely manner, safely and securely. To accomplish this, the system must exhibit qualities such as robustness , reliability , error tolerance , fault tolerance , performance, and security. All of these system-quality attributes depend on consistent and comprehensive error handling that supports the goals of the overall system.\n\nISO/IEC TR 24772, section 6.39.1 [ ISO/IEC TR 24772 ], says:\n\nExpectations that a system will be dependable are based on the confidence that the system will operate as expected and not fail in normal use. The dependability of a system and its fault tolerance can be measured through the component part's reliability, availability, safety and security. Reliability is the ability of a system or component to perform its required functions under stated conditions for a specified period of time [ IEEE 1990 glossary ]. Availability is how timely and reliable the system is to its intended users. Both of these factors matter highly in systems used for safety and security. In spite of the best intentions, systems may encounter a failure, either from internally poorly written software or external forces such as power outages/variations, floods, or other natural disasters. The reaction to a fault can affect the performance of a system and in particular, the safety and security of the system and its users.\n\nEffective error handling (which includes error reporting, report aggregation, analysis, response, and recovery) is a central aspect of the design, implementation, maintenance, and operation of systems that exhibit survivability under stress. Survivability is the capability of a system to fulfill its mission, in a timely manner, despite an attack, accident, or other stress that is outside the bounds of normal operation [ Lipson 2000 ]. If full services cannot be maintained under a given stress, survivable systems degrade gracefully, continue to deliver essential services, and recover full services as conditions permit.\n\nError reporting and error handling play a central role in the engineering and operation of survivable systems. Survivability is an emergent property of a system as a whole [ Fisher 1999 ] and depends on the behavior of all of the system's components and the interactions among them. From the viewpoint of error handling, every system component, down to the smallest routine, can be considered to be a sensor capable of reporting on some aspect of the health of the system. Any error or anomaly, ignored or improperly handled, can threaten delivery of essential system services and, as a result, put at risk the organizational or business mission that the system supports.\n\nThe key characteristics of survivability include the 3 Rs: resistance, recognition, and recovery. Resistance refers to measures that harden a system against particular stresses, recognition refers to situational awareness with respect to instances of stress and their impact on the system, and recovery is the ability of a system to restore services after (and possibly during) an attack, accident, or other event that has disrupted those services.\n\nRecognition of the full nature of adverse events and the determination of appropriate measures for recovery and response are often not possible in the context of the component or routine in which a related error first manifests. Aggregation of multiple error reports and the interpretation of those reports in a higher context may be required both to understand what is happening and to decide on the appropriate action to take. Of course, the domain-specific context in which the system operates plays a huge role in determining proper recovery strategies and tactics. For safety-critical systems, simply halting the system (or even just terminating an offending process) in response to an error is rarely the best course of action and may lead to disaster. From a system perspective, error-handling strategies should map directly into survivability strategies, which may include recovery by activating fully redundant backup services or by providing alternative sets of roughly equivalent services that fulfill the mission with sufficient diversity to greatly improve the odds of survival against common mode failures.\n\nAn error-handling policy must specify a comprehensive approach to error reporting and response. Components and routines should always generate status indicators, and all called routines should have their error returns checked. All input should be checked for compliance with the formal requirements for such input rather than be blindly trusted. Moreover, never assume, on the basis of specific knowledge about the system or its domain, that the success of a called routine is guaranteed. The failure to report or properly respond to errors or other anomalies from a system perspective can threaten the survivability of the system as a whole.\n\nISO/IEC TR 24772:2013, section 6.39.5 [ ISO/IEC TR 24772:2013 ], describes the following mitigation strategies:\n\nSoftware developers can avoid the vulnerability or mitigate its ill effects in the following ways: A strategy for fault handling should be decided. Consistency in fault handling should be the same with respect to critically similar parts. A multi-tiered approach of fault prevention, fault detection, and fault reaction should be used. System-defined components that assist in uniformity of fault handling should be used when available. For one example, designing a \"runtime constraint handler\" permits the application to intercept various erroneous situations and perform one consistent response, such as flushing a previous transaction and restarting at the next one. When there are multiple tasks, a fault-handling policy should be specified whereby a task may halt, and keep its resources available for other tasks (perhaps permitting restarting of the faulting task) halt, and remove its resources (perhaps to allow other tasks to use the resources so freed, or to allow a recreation of the task) halt, and signal the rest of the program to likewise halt",
    "examples": null,
    "risk_assessment": {
      "explanation": "Failure to adopt and implement a consistent and comprehensive error-handling policy is detrimental to system survivability and can result in a broad range of vulnerabilities depending on the operational characteristics of the system.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "ERR30-C",
    "title": "Take care when reading errno",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152351",
    "description": "The value of errno is initialized to zero at program startup, but it is never subsequently set to zero by any C standard library function. The value of errno may be set to nonzero by a C standard library function call whether or not there is an error, provided the use of errno is not documented in the description of the function. It is meaningful for a program to inspect the contents of errno only after an error might have occurred. More precisely, errno is meaningful only after a library function that sets errno on error has returned an error code.\n\nerrno\n\nerrno\n\nerrno\n\nerrno\n\nerrno\n\nerrno\n\nAccording to Question 20.4 of C-FAQ [ Summit 2005 ],\n\nIn general, you should detect errors by checking return values, and use errno only to distinguish among the various causes of an error, such as \"File not found\" or \"Permission denied.\" (Typically, you use perror or strerror to print these discriminating error messages.) It's only necessary to detect errors with errno when a function does not have a unique, unambiguous, out-of-band error return (that is, because all of its possible return values are valid; one example is atoi [ sic ] ). In these cases (and in these cases only; check the documentation to be sure whether a function allows this), you can detect errors by setting errno to 0, calling the function, and then testing errno . (Setting errno to 0 first is important, as no library function ever does that for you.)\n\nerrno\n\nperror\n\nstrerror\n\nerrno\n\natoi [\nsic\n]\n\nerrno\n\nerrno\n\nerrno\n\nNote that atoi() is not required to set the value of errno .\n\natoi()\n\nerrno\n\nLibrary functions fall into the following categories:\n\nThose that set errno and return an out-of-band error indicator Those that set errno and return an in-band error indicator Those that do not promise to set errno Those with differing standards documentation\n\nerrno\n\nerrno\n\nerrno",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( strtoul() )",
          "pre_code_commentary": "This noncompliant code example fails to set errno to 0 before invoking strtoul() . If an error occurs, strtoul() returns a valid value ( ULONG_MAX ), so errno is the only means of determining if strtoul() ran successfully.",
          "code": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n \nvoid func(const char *c_str) {\n  unsigned long number;\n  char *endptr;\n  \n  number = strtoul(c_str, &endptr, 0);\n  if (endptr == c_str || (number == ULONG_MAX \n                         && errno == ERANGE)) {\n    /* Handle error */\n  } else {\n    /* Computation succeeded */\n  }\n}",
          "explanation_after": "Any error detected in this manner may have occurred earlier in the program or may not represent an actual error."
        },
        "compliant": {
          "heading": "Compliant Solution ( strtoul() )",
          "pre_code_commentary": "This compliant solution sets errno to 0 before the call to strtoul() and inspects errno after the call:",
          "code": "#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n \nvoid func(const char *c_str) {\n  unsigned long number;\n  char *endptr;\n \n  errno = 0;\n  number = strtoul(c_str, &endptr, 0);\n  if (endptr == c_str || (number == ULONG_MAX \n                         && errno == ERANGE)) {\n    /* Handle error */\n  } else {\n    /* Computation succeeded */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( ftell() )",
          "pre_code_commentary": "This noncompliant code example, after calling ftell() , examines errno without first checking whether the out-of-band indicator returned by ftell() indicates an error.",
          "code": "#include <errno.h>\n#include <stdio.h>\n\nvoid func(FILE* fp) { \n  errno=0;\n  ftell(fp);\n  if (errno) {\n    perror(\"ftell\");\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( ftell() )",
          "pre_code_commentary": "This compliant solution first detects that ftell() failed using its out-of-band error indicator. Once an error has been confirmed, reading errno (implicitly by using the perror() function) is permitted.",
          "code": "#include <errno.h>\n#include <stdio.h>\n\nvoid func(FILE* fp) { \n  if (ftell(fp) == -1) {\n    perror(\"ftell\");\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "This noncompliant code example may fail to diagnose errors because fopen() might not set errno even if an error occurs:",
          "code": "#include <errno.h>\n#include <stdio.h>\n \nvoid func(const char *filename) {\n  FILE *fileptr;\n\n  errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (errno != 0) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( fopen() , C)",
          "pre_code_commentary": "The C Standard makes no mention of errno when describing fopen() . In this compliant solution, the results of the call to fopen() are used to determine failure and errno is not checked:",
          "code": "#include <stdio.h>\n \nvoid func(const char *filename) {\n  FILE *fileptr = fopen(filename, \"rb\");\n  if (fileptr == NULL)  {\n    /* An error occurred in fopen() */\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example ( fopen() )",
          "pre_code_commentary": "This noncompliant code example may fail to diagnose errors because fopen() might not set errno even if an error occurs:",
          "code": "#include <errno.h>\n#include <stdio.h>\n \nvoid func(const char *filename) {\n  FILE *fileptr;\n\n  errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (errno != 0) {\n    /* Handle error */\n  }\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution ( fopen() , POSIX)",
          "pre_code_commentary": "In this compliant solution, errno is checked only after an error has already been detected by another means:",
          "code": "#include <errno.h>\n#include <stdio.h>\n \nvoid func(const char *filename) {\n  FILE *fileptr;\n\n  errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (fileptr == NULL)  {\n    /*\n     * An error occurred in fopen(); now it's valid \n     * to examine errno.\n     */\n    perror(filename);\n  }\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The improper use of errno may result in failing to detect an error condition or in incorrectly identifying an error condition when none exists.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "POS01-C",
    "title": "Check for the existence of links when dealing with files",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152372",
    "description": "Many common operating systems such as Windows and UNIX support file links, including hard links, symbolic (soft) links, and virtual drives. Hard links can be created in UNIX with the ln command or in Windows operating systems by calling the CreateHardLink() function. Symbolic links can be created in UNIX using the ln -s command or in Windows by using directory junctions in NTFS or the Linkd.exe (Win 2K resource kit) or \"junction\" freeware. Virtual drives can also be created in Windows using the subst command.\n\nln\n\nCreateHardLink()\n\nln -s\n\nsubst\n\nFile links can create security issues for programs that fail to consider the possibility that the file being opened may actually be a link to a different file. This is especially dangerous when the vulnerable program is running with elevated privileges.\n\nFrequently, there is no need to check for the existence of symbolic links because this problem can be solved using other techniques. When opening an existing file, for example, the simplest solution is often to drop privileges to the privileges of the user. This solution permits the use of links while preventing access to files for which the user of the application is not privileged.\n\nWhen creating new files, it may be possible to use functions that create a new file only where a file does not already exist. This prevents the application from overwriting an existing file during file creation. (See FIO03-C. Do not make assumptions about fopen() and file creation .)\n\nIn rare cases, it is necessary to check for the existence of symbolic or hard links to ensure that a program is reading from an intended file and not a different file in another directory. In these cases, avoid creating a race condition when checking for the existence of symbolic links. (See POS35-C. Avoid race conditions while checking for the existence of a symbolic link .)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example opens the file specified by the string file_name for read/write access and then writes user-supplied data to the file:",
          "code": "char *file_name = /* something */;\nchar *userbuf = /* something */;\nunsigned int userlen = /* length of userbuf string */;\n\nint fd = open(file_name, O_RDWR);\nif (fd == -1) {\n   /* handle error */\n}\nwrite(fd, userbuf, userlen);\n",
          "explanation_after": "If the process is running with elevated privileges, an attacker can exploit this code, for example, by replacing the file with a symbolic link to the /etc/passwd authentication file. The attacker can then overwrite data stored in the password file to create a new root account with no password. As a result, this attack can be used to gain root privileges on a vulnerable system."
        },
        "compliant": {
          "heading": "Compliant Solution (Linux 2.1.126+, FreeBSD, Solaris 10, POSIX.1-2008 O_NOFOLLOW )",
          "pre_code_commentary": "Some systems provide the O_NOFOLLOW flag to help mitigate this problem. The flag is required by the POSIX.1-2008 standard and so will become more portable over time [ Open Group 2008 ]. If the flag is set and the supplied file_name is a symbolic link, then the open will fail.",
          "code": "char *file_name = /* something */;\nchar *userbuf = /* something */;\nunsigned int userlen = /* length of userbuf string */;\n\nint fd = open(file_name, O_RDWR | O_NOFOLLOW);\nif (fd == -1) {\n  /* handle error */\n}\nwrite(fd, userbuf, userlen);\n",
          "explanation_after": "Note that this compliant solution does not check for hard links."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example opens the file specified by the string file_name for read/write access and then writes user-supplied data to the file:",
          "code": "char *file_name = /* something */;\nchar *userbuf = /* something */;\nunsigned int userlen = /* length of userbuf string */;\n\nint fd = open(file_name, O_RDWR);\nif (fd == -1) {\n   /* handle error */\n}\nwrite(fd, userbuf, userlen);\n",
          "explanation_after": "If the process is running with elevated privileges, an attacker can exploit this code, for example, by replacing the file with a symbolic link to the /etc/passwd authentication file. The attacker can then overwrite data stored in the password file to create a new root account with no password. As a result, this attack can be used to gain root privileges on a vulnerable system."
        },
        "compliant": {
          "heading": "Compliant Solution ( lstat - fopen - fstat )",
          "pre_code_commentary": "This compliant solution uses the lstat - fopen - fstat idiom illustrated in FIO05-C. Identify files using multiple file attributes :",
          "code": "char *file_name = /* some value */;\n\nstruct stat orig_st;\nif (lstat( file_name, &orig_st) != 0) {\n  /* handle error */\n}\n\nif (!S_ISREG( orig_st.st_mode)) {\n  /* file is irregular or symlink */\n}\n\nint fd = open(file_name, O_RDWR);\nif (fd == -1) {\n  /* handle error */\n}\n\nstruct stat new_st;\nif (fstat(fd, &new_st) != 0) {\n  /* handle error */\n}\n\nif (orig_st.st_dev != new_st.st_dev ||\n    orig_st.st_ino != new_st.st_ino) {\n  /* file was tampered with during race window */\n}\n\n/* ... file is good, operate on fd ... */\n",
          "explanation_after": "This code is still subject to a time-of-check, time-of-use (TOCTOU) race condition, but before doing any operation on the file, it verifies that the file opened is the same file as was previously checked (by checking the file's device and i-node.) As a result, the code will recognize if an attacker has tampered with the file during the race window and can operate accordingly.\n\nNote that this code does not check for hard links.\n\nHard links are problematic because if a file has multiple hard links, it is impossible to distinguish the original link from one that might have been created by a malicious attacker.\n\nOne way to deal with hard links is simply to disallow opening of any file with two or more hard links. The following code snippet, when inserted into the previous example, will identify if a file has multiple hard links:\n\nBecause a hard link may not be created if the link and the linked-to file are on different devices, many platforms place system-critical files on a different device from the one where user-editable files are kept. For instance, the / directory, which contains critical system files like /etc/passwd , would live on one hard drive, while the /home directory, which contains user-editable files, would reside on a separate hard drive. This prevents users, for example, from creating hard links to /etc/passwd ."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to check for the existence of links can result in a critical system file being overwritten, leading to data integrity violations.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  },
  {
    "rule_id": "FIO01-C",
    "title": "Be careful using functions that use file names for identification",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152403",
    "description": "Many file-related security vulnerabilities result from a program accessing an unintended file object because file names are only loosely bound to underlying file objects. File names provide no information regarding the nature of the file object itself. Furthermore, the binding of a file name to a file object is reasserted every time the file name is used in an operation. File descriptors and FILE pointers are bound to underlying file objects by the operating system. (See FIO03-C. Do not make assumptions about fopen() and file creation .)\n\nFILE\n\nAccessing files via file descriptors or FILE pointers rather than file names provides a greater degree of certainty as to which object is actually acted upon. It is recommended that files be accessed through file descriptors or FILE pointers where possible.\n\nFILE\n\nFILE\n\nThe following C functions rely solely on file names for file identification:\n\nremove() rename() fopen() freopen()\n\nremove()\n\nrename()\n\nfopen()\n\nfreopen()\n\nUse these functions with caution. See FIO10-C. Take care when using the rename() function , and FIO08-C. Take care when calling remove() on an open file .",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the file identified by file_name is opened, processed, closed, and removed. However, it is possible that the file object identified by file_name in the call to remove() is not the same file object identified by file_name in the call to fopen() .",
          "code": "char *file_name;\nFILE *f_ptr;\n\n/* Initialize file_name */\n\nf_ptr = fopen(file_name, \"w\");\nif (f_ptr == NULL) {\n  /* Handle error */\n}\n\n/*... Process file ...*/\n\nif (fclose(f_ptr) != 0) {\n  /* Handle error */\n}\n\nif (remove(file_name) != 0) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "Not much can be done programmatically to ensure the file removed is the same file that was opened, processed, and closed except to make sure that the file is opened in a secure directory with privileges that would prevent the file from being manipulated by an untrusted user. (See FIO15-C. Ensure that file operations are performed in a secure directory .)",
          "code": null,
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (POSIX)",
          "pre_code_commentary": "In this noncompliant code example, the function chmod() is called to set the permissions of a file. However, it is not clear whether the file object referred to by file_name refers to the same object in the call to fopen() and in the call to chmod() .",
          "code": "char *file_name;\nFILE *f_ptr;\n\n/* Initialize file_name */\n\nf_ptr = fopen(file_name, \"w\");\nif (f_ptr == NULL)  {\n  /* Handle error */\n}\n\n/* ... */\n\nif (chmod(file_name, S_IRUSR) == -1) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution uses the POSIX fchmod() and open() functions [ IEEE Std 1003.1:2013 ]. Using these functions guarantees that the file opened is the same file that is operated on.",
          "code": "char *file_name;\nint fd;\n\n/* Initialize file_name */\n\nfd = open(\n  file_name,\n  O_WRONLY | O_CREAT | O_EXCL,\n  S_IRWXU\n);\nif (fd == -1) {\n  /* Handle error */\n}\n\n/* ... */\n\nif (fchmod(fd, S_IRUSR) == -1) {\n  /* Handle error */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Many file-related vulnerabilities, such as time-of-check, time-of-use (TOCTOU) race conditions, can be exploited to cause a program to access an unintended file. Using FILE pointers or file descriptors to identify files instead of file names reduces the chance of accessing an unintended file. Remediation costs are medium because, although insecure functions can be easily identified, simple drop-in replacements are not always available.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "POS30-C",
    "title": "Use the readlink() function properly",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152404",
    "description": "The readlink() function reads where a link points to. It makes no effort to null-terminate its second argument, buffer . Instead, it just returns the number of characters it has written.\n\nreadlink()\n\nbuffer",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "If len is equal to sizeof(buf) , the null terminator is written 1 byte past the end of buf :",
          "code": "char buf[1024];\nssize_t len = readlink(\"/usr/bin/perl\", buf, sizeof(buf));\nbuf[len] = '\\0';\n",
          "explanation_after": "An incorrect solution to this problem is to try to make buf large enough that it can always hold the result:\n\nThis modification incorrectly assumes that the symbolic link cannot be longer than the value of SYMLINK_MAX returned by pathconf() . However, the value returned by pathconf() is out of date by the time readlink() is called, so the off-by-one buffer-overflow risk is still present because, between the two calls, the location of /usr/bin/perl can change to a file system with a larger SYMLINK_MAX value. Also, if SYMLINK_MAX is indeterminate (that is, if pathconf() returned -1 without setting errno ), the code uses an arbitrary large buffer size (10,000) that it hopes will be sufficient, but there is a small chance that readlink() can return exactly this size.\n\nAn additional issue is that readlink() can return -1 if it fails, causing an off-by-one underflow."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution ensures there is no overflow by reading in only sizeof(buf)-1 characters. It also properly checks to see if an error has occurred:",
          "code": "enum { BUFFERSIZE = 1024 };\nchar buf[BUFFERSIZE];\nssize_t len = readlink(\"/usr/bin/perl\", buf, sizeof(buf)-1);\n\nif (len != -1) {\n  buf[len] = '\\0';\n}\nelse {\n  /* handle error condition */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to properly null-terminate the result of readlink() can result in abnormal program termination and buffer-overflow vulnerabilities.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P18",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "PRE00-C",
    "title": "Prefer inline or static functions to function-like macros",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152416",
    "description": "Macros are dangerous because their use resembles that of real functions, but they have different semantics. The inline function-specifier was introduced to the C programming language in the C99 standard. Inline functions should be preferred over macros when they can be used interchangeably. Making a function an inline function suggests that calls to the function be as fast as possible by using, for example, an alternative to the usual function call mechanism, such as inline substitution . (See also PRE31-C. Avoid side effects in arguments to unsafe macros , PRE01-C. Use parentheses within macros around parameter names , and PRE02-C. Macro replacement lists should be parenthesized .)\n\nInline substitution is not textual substitution, nor does it create a new function. For example, the expansion of a macro used within the body of the function uses the definition it had at the point the function body appeared, not where the function is called; and identifiers refer to the declarations in scope where the body occurs.\n\nArguably, a decision to inline a function is a low-level optimization detail that the compiler should make without programmer input. The use of inline functions should be evaluated on the basis of (a) how well they are supported by targeted compilers, (b) what (if any) impact they have on the performance characteristics of your system, and (c) portability concerns. Static functions are often as good as inline functions and are supported in C.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the macro CUBE() has undefined behavior when passed an expression that contains side effects:",
          "code": "#define CUBE(X) ((X) * (X) * (X))\n \nvoid func(void) {\n  int i = 2;\n  int a = 81 / CUBE(++i);\n  /* ... */\n}",
          "explanation_after": "For this example, the initialization for a expands to\n\nwhich is undefined (see EXP30-C. Do not depend on the order of evaluation for side effects )."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "When the macro definition is replaced by an inline function, the side effect is executed only once before the function is called:",
          "code": "inline int cube(int i) {\n  return i * i * i;\n}\n \nvoid func(void) {\n  int i = 2;\n  int a = 81 / cube(++i);\n  /* ... */ \n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code example, the programmer has written a macro called EXEC_BUMP() to call a specified function and increment a global counter [ Dewhurst 2002 ]. When the expansion of a macro is used within the body of a function, as in this example, identifiers refer to the declarations in scope where the body occurs. As a result, when the macro is called in the aFunc() function, it inadvertently increments a local counter with the same name as the global variable. Note that this example also violates DCL01-C. Do not reuse variable names in subscopes .",
          "code": "size_t count = 0;\n\n#define EXEC_BUMP(func) (func(), ++count)\n\nvoid g(void) {\n  printf(\"Called g, count = %zu.\\n\", count);\n}\n\nvoid aFunc(void) {\n  size_t count = 0;\n  while (count++ < 10) {\n    EXEC_BUMP(g);\n  }\n}\n",
          "explanation_after": "The result is that invoking aFunc() (incorrectly) prints out the following line five times:"
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, the EXEC_BUMP() macro is replaced by the inline function exec_bump() . Invoking aFunc() now (correctly) prints the value of count ranging from 0 to 9:",
          "code": "size_t count = 0;\n\nvoid g(void) {\n  printf(\"Called g, count = %zu.\\n\", count);\n}\n\ntypedef void (*exec_func)(void);\ninline void exec_bump(exec_func f) {\n  f();\n  ++count;\n}\n\nvoid aFunc(void) {\n  size_t count = 0;\n  while (count++ < 10) {\n    exec_bump(g);\n  }\n}\n",
          "explanation_after": "The use of the inline function binds the identifier count to the global variable when the function body is compiled. The name cannot be re-bound to a different variable (with the same name) when the function is called."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "Unlike functions, the execution of macros can interleave. Consequently, two macros that are harmless in isolation can cause undefined behavior when combined in the same expression. In this example, F() and G() both increment the global variable operations , which causes problems when the two macros are used together:",
          "code": "int operations = 0, calls_to_F = 0, calls_to_G = 0;\n \n#define F(x) (++operations, ++calls_to_F, 2 * x)\n#define G(x) (++operations, ++calls_to_G, x + 1)\n\nvoid func(int x) {\n  int y = F(x) + G(x);\n\n}",
          "explanation_after": "The variable operations is both read and modified twice in the same expression, so it can receive the wrong value if, for example, the following ordering occurs:\n\nThis noncompliant code example also violates EXP30-C. Do not depend on the order of evaluation for side effects ."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "The execution of functions, including inline functions, cannot be interleaved, so problematic orderings are not possible:",
          "code": "int operations = 0, calls_to_F = 0, calls_to_G = 0;\n \ninline int f(int x) {\n  ++operations;\n  ++calls_to_F;\n  return 2 * x;\n}\n\ninline int g(int x) {\n  ++operations;\n  ++calls_to_G;\n  return x + 1;\n}\n\n \nvoid func(int x) {\n  int y = f(x) + g(x);\n\n}",
          "explanation_after": "GNU C (and some other compilers) supported inline functions before they were added to the C Standard and, as a result, have significantly different semantics. Richard Kettlewell provides a good explanation of differences between the C99 and GNU C rules [ Kettlewell 2003 ]."
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Improper use of macros may result in undefined behavior .",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "INT00-C",
    "title": "Understand the data model used by your implementation(s)",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152417",
    "description": "A data model defines the sizes assigned to standard data types. It is important to understand the data models used by your implementation . However, if your code depends on any assumptions not guaranteed by the standard, you should provide static assertions to ensure that your assumptions are valid. (See DCL03-C. Use a static assertion to test the value of a constant expression .) Assumptions concerning integer sizes may become invalid, for example, when porting from a 32-bit architecture to a 64-bit architecture.\n\nCommon Data Models\n\nData Type iAPX86 IA-32 IA-64 SPARC-64 ARM-32 Alpha 64-bit Linux, FreeBSD, NetBSD, and OpenBSD char 8 8 8 8 8 8 8 short 16 16 16 16 16 16 16 int 16 32 32 32 32 32 32 long 32 32 32 64 32 64 64 long long N/A 64 64 64 64 64 64 Pointer 16/32 32 64 64 32 64 64\n\nchar\n\nshort\n\nint\n\nlong\n\nlong long\n\nCode frequently embeds assumptions about data models. For example, some code bases require pointer and long to have the same size, whereas other large code bases require int and long to be the same size [ van de Voort 2007 ]. These types of assumptions, while common, make the code difficult to port and make the ports error prone. One solution is to avoid any implementation-defined behavior . However, this practice can result in inefficient code. Another solution is to include either static or runtime assertions near any platform-specific assumptions, so they can be easily detected and corrected during porting.\n\nlong\n\nint\n\nlong\n\n<limits.h>\n\n<limits.h>\n\nPossibly more important than knowing the number of bits for a given type is knowing that limits.h defines macros that can be used to determine the integral ranges of the standard integer types for any conforming implementation. For example, UINT_MAX is the largest possible value of an unsigned int , and LONG_MIN is the smallest possible value of a long int .\n\nlimits.h\n\nUINT_MAX\n\nunsigned int\n\nLONG_MIN\n\nlong int\n\n<stdint.h>\n\n<stdint.h>\n\nThe stdint.h header introduces types with specific size restrictions that can be used to avoid dependence on a particular data model. For example, int_least32_t is the smallest signed integer type supported by the implementation that contains at least 32 bits. The type uint_fast16_t is the fastest unsigned integer type supported by the implementation that contains at least 16 bits. The type intmax_t is the largest signed integer, and uintmax_t is the largest unsigned type, supported by the implementation. The following types are required to be available on all implementations:\n\nstdint.h\n\nint_least32_t\n\nuint_fast16_t\n\nintmax_t\n\nuintmax_t\n\nSmallest Types Signed Unsigned 8 bits int_least8_t uint_least8_t 16 bits int_least16_t uint_least16_t 32 bits int_least32_t uint_least32_t 64 bits int_least64_t uint_least64_t Fastest Types Signed Unsigned 8 bits int_fast8_t uint_fast8_t 16 bits int_fast16_t uint_fast16_t 32 bits int_fast32_t uint_fast32_t 64 bits int_fast64_t uint_fast64_t Largest Types Signed Unsigned Maximum intmax_t uintmax_t\n\nint_least8_t\n\nuint_least8_t\n\nint_least16_t\n\nuint_least16_t\n\nint_least32_t\n\nuint_least32_t\n\nint_least64_t\n\nuint_least64_t\n\nint_fast8_t\n\nuint_fast8_t\n\nint_fast16_t\n\nuint_fast16_t\n\nint_fast32_t\n\nuint_fast32_t\n\nint_fast64_t\n\nuint_fast64_t\n\nintmax_t\n\nuintmax_t\n\nAdditional types may be supported by an implementation, such as int8_t , a type of exactly 8 bits, and uintptr_t , a type large enough to hold a converted void * if such an integer exists in the implementation.\n\nint8_t\n\nuintptr_t\n\nvoid *\n\n<inttypes.h>\n\n<inttypes.h>\n\nThe inttypes.h header declares functions for manipulating greatest-width integers and converting numeric character strings to greatest-width integers.\n\ninttypes.h",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant example attempts to read a long into an int . This code works for models in which sizeof(int) == sizeof(long) . For others, it causes an unexpected memory write similar to a buffer overflow.",
          "code": "int f(void) {\n  FILE *fp;\n  int x;\n/* ... */\n  if (fscanf(fp, \"%ld\", &x) < 1) {\n    return -1; /* Indicate failure */\n  }\n\n/* ... */\n  return 0;\n}",
          "explanation_after": "Some compilers can generate warnings if a constant format string does not match the argument types."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses the correct format for the type being used:",
          "code": "int f(void) {\n  FILE *fp;\n  int x;\n/* Initialize fp */\n  if (fscanf(fp, \"%d\", &x) < 1) {\n    return -1; /* Indicate failure */\n  }\n\n/* ... */\n  return 0;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code attempts to guarantee that all bits of a multiplication of two unsigned int values are retained by performing arithmetic in the type unsigned long . This practice works for some platforms, such as 64-bit Linux, but fails for others, such as 64-bit Microsoft Windows.",
          "code": "unsigned int a, b;\nunsigned long c;\n/* Initialize a and b */\nc = (unsigned long)a * b; /* Not guaranteed to fit */\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses the largest unsigned integer type available if it is guaranteed to hold the result. If it is not, another solution must be found, as discussed in INT32-C. Ensure that operations on signed integers do not result in overflow .",
          "code": "#if UINT_MAX > UINTMAX_MAX/UINT_MAX\n#error No safe type is available.\n#endif\n/* ... */\nunsigned int a, b;\nuintmax_t c;\n/* Initialize a and b */\nc = (uintmax_t)a * b; /* Guaranteed to fit, verified above */\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Understanding the data model used by your implementation is necessary to avoid making errors about the sizes of integer types and the range of values they can represent. Making assumptions about the sizes of data types may lead to buffer-overflow-style attacks.",
      "metrics": {
        "severity": "High",
        "likelihood": "Unlikely",
        "detectable": "No",
        "repairable": "No",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "FIO20-C",
    "title": "Avoid unintentional truncation when using fgets() or fgetws()",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152445",
    "description": "The fgets() and fgetws() functions are typically used to read a newline-terminated line of input from a stream. Both functions read at most one less than the number of narrow or wide characters specified by an argument n from a stream to a string. Truncation errors can occur if n - 1 is less than the number of characters appearing in the input string prior to the new-line narrow or wide character (which is retained) or after end-of-file.  This can result in the accidental truncation of user input.\n\nfgets()\n\nfgetws()\n\nn\n\nn - 1",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example copies the input string into a buffer, and assumes it captured all of the user's input.",
          "code": "#include <stdbool.h>\n#include <stdio.h>\n \nbool get_data(char *buffer, int size) {\n  if (fgets(buffer, size, stdin)) {\n    return true;\n  }\n  return false;\n}\n \nvoid func(void) {\n  char buf[8];\n  if (get_data(buf, sizeof(buf))) {\n    printf(\"The user input %s\\n\", buf);\n  } else {\n    printf(\"Error getting data from the user\\n\");\n  }\n}",
          "explanation_after": "However, if the last character in buf is not a newline and the stream is not at the end-of-file marker, the buffer was too small to contain all of the data from the user.  For example, because the buffer is only 8 characters in length, if the user input \"Hello World\\n\" , the buffer would contain \"Hello W\" terminated by a null character."
        },
        "compliant": {
          "heading": "Compliant Solution (Fail on Truncation)",
          "pre_code_commentary": "This compliant solution examines the end-of-file marker for the stream and the last character in the buffer to determine whether it is a newline or not.  If it is the end of file, or the last character is a newline, then the buffer contains all of the user's input.  However, if the last character is not at the end-of-file and not a newline then the user's input has been truncated.",
          "code": "#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n \nbool get_data(char *buffer, int size) {\n  if (fgets(buffer, size, stdin)) {\n    size_t len = strlen(buffer);\n    return feof(stdin) || (len != 0 && buffer[len-1] == '\\n');\n  }\n  return false;\n}\n \nvoid func(void) {\n  char buf[8];\n  if (get_data(buf, sizeof(buf))) {\n    printf(\"The user input %s\\n\", buf);\n  } else {\n    printf(\"Error getting data from the user\\n\");\n  }\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example copies the input string into a buffer, and assumes it captured all of the user's input.",
          "code": "#include <stdbool.h>\n#include <stdio.h>\n \nbool get_data(char *buffer, int size) {\n  if (fgets(buffer, size, stdin)) {\n    return true;\n  }\n  return false;\n}\n \nvoid func(void) {\n  char buf[8];\n  if (get_data(buf, sizeof(buf))) {\n    printf(\"The user input %s\\n\", buf);\n  } else {\n    printf(\"Error getting data from the user\\n\");\n  }\n}",
          "explanation_after": "However, if the last character in buf is not a newline and the stream is not at the end-of-file marker, the buffer was too small to contain all of the data from the user.  For example, because the buffer is only 8 characters in length, if the user input \"Hello World\\n\" , the buffer would contain \"Hello W\" terminated by a null character."
        },
        "compliant": {
          "heading": "Compliant Solution (Expanding Buffer)",
          "pre_code_commentary": "This compliant solution solves the problem by expanding the buffer to read the entire contents from stdin instead of failing if the caller did not allocate enough space.  If the allocation fails, it will return NULL , but otherwise, it returns a buffer of the received data, which the caller must free.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *get_filled_buffer(void) {\n  char temp[32];\n  char *ret = NULL;\n  size_t full_length = 0;\n   \n  while (fgets(temp, sizeof(temp), stdin)) {\n    size_t len = strlen(temp);\n    if (SIZE_MAX - len - 1 < full_length) {\n      break;\n    }\n    char *r_temp = realloc(ret, full_length + len + 1);\n    if (r_temp == NULL) {\n      break;\n    }\n    ret = r_temp;\n    strcpy(ret + full_length, temp); /* concatenate */\n    full_length += len;\n   \n    if (feof(stdin) || temp[len-1] == '\\n') {\n      return ret;\n    }\n  }\n\n  free(ret);\n  return NULL;\n}",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This noncompliant code example copies the input string into a buffer, and assumes it captured all of the user's input.",
          "code": "#include <stdbool.h>\n#include <stdio.h>\n \nbool get_data(char *buffer, int size) {\n  if (fgets(buffer, size, stdin)) {\n    return true;\n  }\n  return false;\n}\n \nvoid func(void) {\n  char buf[8];\n  if (get_data(buf, sizeof(buf))) {\n    printf(\"The user input %s\\n\", buf);\n  } else {\n    printf(\"Error getting data from the user\\n\");\n  }\n}",
          "explanation_after": "However, if the last character in buf is not a newline and the stream is not at the end-of-file marker, the buffer was too small to contain all of the data from the user.  For example, because the buffer is only 8 characters in length, if the user input \"Hello World\\n\" , the buffer would contain \"Hello W\" terminated by a null character."
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX getline() )",
          "pre_code_commentary": "The getline() function was originally a GNU extension, but is now standard in POSIX.1-2008. It also fills a string with characters from an input stream. In this case, the program passes it a NULL pointer for a string, indicating that getline() should allocate sufficient space for the string and the caller frees it later.",
          "code": "#include <stdio.h>\n\nvoid func(void) {\n  char* buf = NULL;\n  size_t dummy = 0;\n  if (getline(&buf, &dummy, stdin) == -1) {\n\t/* handle error */\n  }\n  printf(\"The user input %s\\n\", buf);\n  free(buf);\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Incorrectly assuming a newline character is read by fgets() or fgetws() can result in data truncation.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Likely",
        "detectable": "No",
        "repairable": "Yes",
        "priority": "P12",
        "level": "L1"
      }
    }
  },
  {
    "rule_id": "DCL00-C",
    "title": "Const-qualify immutable objects",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152463",
    "description": "Immutable objects should be const -qualified. Enforcing object immutability using const qualification helps ensure the correctness and security of applications. ISO/IEC TR 24772, for example, recommends labeling parameters as constant to avoid the unintentional modification of function arguments [ ISO/IEC TR 24772 ]. STR05-C. Use pointers to const when referring to string literals describes a specialized case of this recommendation.\n\nconst\n\nconst\n\nAdding const qualification may propagate through a program; as you add const , qualifiers become still more necessary. This phenomenon is sometimes called const poisoning , which can frequently lead to violations of EXP05-C. Do not cast away a const qualification . Although const qualification is a good idea, the costs may outweigh the value in the remediation of existing code.\n\nconst\n\nconst\n\nconst\n\nconst\n\nA macro or an enumeration constant may also be used instead of a const -qualified object. DCL06-C. Use meaningful symbolic constants to represent literal values describes the relative merits of using const -qualified objects, enumeration constants, and object-like macros. However, adding a const qualifier to an existing variable is a better first step than replacing the variable with an enumeration constant or macro because the compiler will issue warnings on any code that changes your const -qualified variable. Once you have verified that a const -qualified variable is not changed by any code, you may consider changing it to an enumeration constant or macro, as best fits your design.\n\nconst\n\nconst\n\nconst\n\nconst\n\nconst",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "In this noncompliant code, pi is declared as a float . Although pi is a mathematical constant, its value is not protected from accidental modification.",
          "code": "float pi = 3.14159f;\nfloat degrees;\nfloat radians;\n/* ... */\nradians = degrees * pi / 180;\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "In this compliant solution, pi is declared as a const -qualified object:",
          "code": "const float pi = 3.14159f;\nfloat degrees;\nfloat radians;\n/* ... */\nradians = degrees * pi / 180;\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Failing to const -qualify immutable objects can result in a constant being modified at runtime.",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "Yes",
        "priority": "P3",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "MSC30-C",
    "title": "Do not use the rand() function for generating pseudorandom numbers",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152464",
    "description": "Pseudorandom number generators use mathematical algorithms to produce a sequence of numbers with good statistical properties, but the numbers produced are not genuinely random.\n\nThe C Standard rand() function makes no guarantees as to the quality of the random sequence produced. The numbers generated by some implementations of rand() have a comparatively short cycle and the numbers can be predictable. Applications that have strong pseudorandom number requirements must use a generator that is known to be sufficient for their needs.\n\nrand()\n\nrand()",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The following noncompliant code generates an ID with a numeric part produced by calling the rand() function. The IDs produced are predictable and have limited randomness.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nenum { len = 12 };\n \nvoid func(void) {\n  /*\n   * id will hold the ID, starting with the characters\n   *  \"ID\" followed by a random integer.\n   */\n  char id[len];  \n  int r;\n  int num;\n  /* ... */\n  r = rand();  /* Generate a random integer */\n  num = snprintf(id, len, \"ID%-d\", r);  /* Generate the ID */\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (POSIX)",
          "pre_code_commentary": "This compliant solution replaces the rand() function with the POSIX random() function:",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nenum { len = 12 }; \n\nvoid func(void) {\n  /*\n   * id will hold the ID, starting with the characters\n   *  \"ID\" followed by a random integer.\n   */\n  char id[len];  \n  int r;\n  int num;\n  /* ... */\n  struct timespec ts;\n  if (timespec_get(&ts, TIME_UTC) == 0) {\n    /* Handle error */\n  }\n  srandom(ts.tv_nsec ^ ts.tv_sec);  /* Seed the PRNG */\n  /* ... */\n  r = random();  /* Generate a random integer */\n  num = snprintf(id, len, \"ID%-d\", r);  /* Generate the ID */\n  /* ... */\n}",
          "explanation_after": "The POSIX random() function is a better pseudorandom number generator. Although on some platforms the low dozen bits generated by rand() go through a cyclic pattern, all the bits generated by random() are usable. The rand48 family of functions provides another alternative for pseudorandom numbers.\n\nAlthough not specified by POSIX, arc4random() is another possibility for systems that support it. The arc4random(3) manual page [ OpenBSD ] states\n\n... provides higher quality of data than those described in rand(3), random(3), and drand48(3).\n\nTo achieve the best random numbers possible, an implementation -specific function must be used. When unpredictability is crucial and speed is not an issue, as in the creation of strong cryptographic keys, use a true entropy source, such as /dev/random , or a hardware device capable of generating random numbers. The /dev/random device can block for a long time if there are not enough events going on to generate sufficient entropy."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "The following noncompliant code generates an ID with a numeric part produced by calling the rand() function. The IDs produced are predictable and have limited randomness.",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n \nenum { len = 12 };\n \nvoid func(void) {\n  /*\n   * id will hold the ID, starting with the characters\n   *  \"ID\" followed by a random integer.\n   */\n  char id[len];  \n  int r;\n  int num;\n  /* ... */\n  r = rand();  /* Generate a random integer */\n  num = snprintf(id, len, \"ID%-d\", r);  /* Generate the ID */\n  /* ... */\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Windows)",
          "pre_code_commentary": "On Windows platforms, the BCryptGenRandom() function can be used to generate cryptographically strong random numbers. The Microsoft Developer Network BCryptGenRandom() reference [ MSDN ] states:\n\nThe default random number provider implements an algorithm for generating random numbers that complies with the NIST SP800-90 standard, specifically the CTR_DRBG portion of that standard.",
          "code": "#include <Windows.h>\n#include <bcrypt.h>\n#include <stdio.h>\n\n#pragma comment(lib, \"Bcrypt\")\n\nvoid func(void) {\n  BCRYPT_ALG_HANDLE Prov;\n  int Buffer;\n  if (!BCRYPT_SUCCESS(\n          BCryptOpenAlgorithmProvider(&Prov, BCRYPT_RNG_ALGORITHM,\n                                      NULL, 0))) {\n    /* handle error */\n  }\n  if (!BCRYPT_SUCCESS(BCryptGenRandom(Prov, (PUCHAR) (&Buffer),\n                                      sizeof(Buffer), 0))) {\n    /* handle error */\n  }\n  printf(\"Random number: %d\\n\", Buffer);\n  BCryptCloseAlgorithmProvider(Prov, 0);\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "The use of the rand() function can result in predictable random numbers.",
      "metrics": {
        "severity": "Medium",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P4",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "PRE30-C",
    "title": "Do not create a universal character name through concatenation",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152465",
    "description": "The C Standard supports universal character names that may be used in identifiers, character constants, and string literals to designate characters that are not in the basic character set. The universal character name \\U nnnnnnnn designates the character whose 8-digit short identifier (as specified by ISO/IEC 10646) is nnnnnnnn . Similarly, the universal character name \\u nnnn designates the character whose 4-digit short identifier is nnnn (and whose 8-digit short identifier is 0000 nnnn ).\n\n\\U\n\n\\u\n\n0000\n\nThe C Standard, 5.1.1.2, paragraph 4 [ ISO/IEC 9899:2024 ], says\n\nIf a character sequence that matches the syntax of a universal character name is produced by token concatenation (6.10.5.3), the behavior is undefined.\n\nSee also undefined behavior 3 .\n\nIn general, avoid universal character names in identifiers unless absolutely necessary.",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example",
          "pre_code_commentary": "This code example is noncompliant because it produces a universal character name by token concatenation:",
          "code": "#define assign(uc1, uc2, val) uc1##uc2 = val\n\nvoid func(void) {\n  int \\u0401;\n  /* ... */\n  assign(\\u04, 01, 4);\n  /* ... */\n}",
          "explanation_after": "This code compiles and runs with Microsoft Visual Studio 2013, assigning 4 to the variable as expected.\n\nGCC 4.8.1 on Linux refuses to compile this code; it emits a diagnostic reading, \"stray '\\' in program,\" referring to the universal character fragment in the invocation of the assign macro."
        },
        "compliant": {
          "heading": "Compliant Solution",
          "pre_code_commentary": "This compliant solution uses a universal character name but does not create it by using token concatenation:",
          "code": "#define assign(ucn, val) ucn = val\n \nvoid func(void) {\n  int \\u0401;\n  /* ... */\n  assign(\\u0401, 4);\n  /* ... */\n}",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Creating a universal character name through token concatenation results in undefined behavior. See undefined behavior 3 .",
      "metrics": {
        "severity": "Low",
        "likelihood": "Unlikely",
        "detectable": "Yes",
        "repairable": "No",
        "priority": "P2",
        "level": "L3"
      }
    }
  },
  {
    "rule_id": "DCL30-C",
    "title": "Declare objects with appropriate storage durations",
    "url": "https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152466",
    "description": "Every object has a storage duration that determines its lifetime: static , thread , automatic , or allocated .\n\nAccording to the C Standard, 6.2.4, paragraph 2 [ ISO/IEC 9899:2024 ],\n\nThe lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address, and retains its last-stored value throughout its lifetime. If an object is referred to outside of its lifetime, the behavior is undefined. If a pointer value is used in an evaluation after the object the pointer points to (or just past) reaches the end of its lifetime, the behavior is undefined.\n\nDo not attempt to access an object outside of its lifetime. Attempting to do so is undefined behavior and can lead to an exploitable vulnerability . (See also undefined behavior 9 in the C Standard, Annex J.)",
    "examples": [
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Differing Storage Durations)",
          "pre_code_commentary": "In this noncompliant code example, the address of the variable c_str with automatic storage duration is assigned to the variable p , which has static storage duration. The assignment itself is valid, but it is invalid for c_str to go out of scope while p holds its address, as happens at the end of dont_do_this () .",
          "code": "#include <stdio.h>\n \nconst char *p;\nvoid dont_do_this(void) {\n  const char c_str[] = \"This will change\";\n  p = c_str; /* Dangerous */\n}\n\nvoid innocuous(void) {\n  printf(\"%s\\n\", p);\n}\n\nint main(void) {\n  dont_do_this();\n  innocuous();\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Same Storage Durations)",
          "pre_code_commentary": "In this compliant solution, p is declared with the same storage duration as c_str , preventing p from taking on an indeterminate value outside of this_is_OK() :",
          "code": "void this_is_OK(void) {\n  const char c_str[] = \"Everything OK\";\n  const char *p = c_str;\n  /* ... */\n}\n/* p is inaccessible outside the scope of string c_str */\n",
          "explanation_after": "Alternatively, both p and c_str could be declared with static storage duration."
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Differing Storage Durations)",
          "pre_code_commentary": "In this noncompliant code example, the address of the variable c_str with automatic storage duration is assigned to the variable p , which has static storage duration. The assignment itself is valid, but it is invalid for c_str to go out of scope while p holds its address, as happens at the end of dont_do_this () .",
          "code": "#include <stdio.h>\n \nconst char *p;\nvoid dont_do_this(void) {\n  const char c_str[] = \"This will change\";\n  p = c_str; /* Dangerous */\n}\n\nvoid innocuous(void) {\n  printf(\"%s\\n\", p);\n}\n\nint main(void) {\n  dont_do_this();\n  innocuous();\n  return 0;\n}",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Differing Storage Durations)",
          "pre_code_commentary": "If it is necessary for p to be defined with static storage duration but c_str with a more limited duration, then p can be set to NULL before c_str is destroyed. This practice prevents p from taking on an indeterminate value , although any references to p must check for NULL .",
          "code": "const char *p;\nvoid is_this_OK(void) {\n  const char c_str[] = \"Everything OK?\";\n  p = c_str;\n  /* ... */\n  p = NULL;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Return Values)",
          "pre_code_commentary": "In this noncompliant code sample, the function init_array () returns a pointer to a character array with automatic storage duration, which is accessible to the caller:",
          "code": "char *init_array(void) {\n  char array[10];\n  /* Initialize array */\n  return array;\n}\n",
          "explanation_after": "Some compilers generate a diagnostic message when a pointer to an object with automatic storage duration is returned from a function, as in this example. Programmers should compile code at high warning levels and resolve any diagnostic messages. (See MSC00-C. Compile cleanly at high warning levels .)"
        },
        "compliant": {
          "heading": "Compliant Solution (Return Values)",
          "pre_code_commentary": "The solution, in this case, depends on the intent of the programmer. If the intent is to modify the value of array and have that modification persist outside the scope of init_array() , the desired behavior can be achieved by declaring array elsewhere and passing it as an argument to init_array() :",
          "code": "#include <stddef.h>\nvoid init_array(char *array, size_t len) {\n  /* Initialize array */\n  return;\n}\n\nint main(void) {\n  char array[10];\n  init_array(array, sizeof(array) / sizeof(array[0]));\n  /* ... */\n  return 0;\n}\n",
          "explanation_after": null
        }
      },
      {
        "noncompliant": {
          "heading": "Noncompliant Code Example (Output Parameter)",
          "pre_code_commentary": "In this noncompliant code example, the function squirrel_away() stores a pointer to local variable local into a location pointed to by function parameter ptr_param . Upon the return of squirrel_away() , the pointer ptr_param points to a variable that has an expired lifetime.",
          "code": "void squirrel_away(char **ptr_param) {\n  char local[10];\n  /* Initialize array */\n  *ptr_param = local;\n}\n\nvoid rodent(void) {\n  char *ptr;\n  squirrel_away(&ptr);\n  /* ptr is live but invalid here */\n}\n",
          "explanation_after": null
        },
        "compliant": {
          "heading": "Compliant Solution (Output Parameter)",
          "pre_code_commentary": "In this compliant solution, the variable local has static storage duration; consequently, ptr can be used to reference the local array within the rodent() function:",
          "code": "char local[10];\n \nvoid squirrel_away(char **ptr_param) {\n  /* Initialize array */\n  *ptr_param = local;\n}\n\nvoid rodent(void) {\n  char *ptr;\n  squirrel_away(&ptr);\n  /* ptr is valid in this scope */\n}\n",
          "explanation_after": null
        }
      }
    ],
    "risk_assessment": {
      "explanation": "Referencing an object outside of its lifetime can result in an attacker being able to execute arbitrary code.",
      "metrics": {
        "severity": "High",
        "likelihood": "Probable",
        "detectable": "No",
        "repairable": "No",
        "priority": "P6",
        "level": "L2"
      }
    }
  }
]